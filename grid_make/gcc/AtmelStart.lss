
AtmelStart.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00012970  00004000  00004000  00004000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000005b0  20000000  00016970  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  000205b0  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  000205b0  2**0
                  CONTENTS
  4 .bss          0001ca34  200005b0  00016f20  000205b0  2**4
                  ALLOC
  5 .stack        00010004  2001cfe4  00033954  000205b0  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  000205b0  2**0
                  CONTENTS, READONLY
  7 .comment      0000004c  00000000  00000000  000205de  2**0
                  CONTENTS, READONLY
  8 .debug_info   000b01b4  00000000  00000000  0002062a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 00010f98  00000000  00000000  000d07de  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_loc    00031a0c  00000000  00000000  000e1776  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 00002bd8  00000000  00000000  00113182  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_ranges 00008568  00000000  00000000  00115d5a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_macro  00050024  00000000  00000000  0011e2c2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   0005f800  00000000  00000000  0016e2e6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    00128900  00000000  00000000  001cdae6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_frame  00008930  00000000  00000000  002f63e8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00004000 <exception_table>:
    4000:	e8 cf 02 20 3d 30 01 00 39 30 01 00 39 30 01 00     ... =0..90..90..
    4010:	39 30 01 00 39 30 01 00 39 30 01 00 00 00 00 00     90..90..90......
	...
    402c:	31 b2 00 00 39 30 01 00 00 00 00 00 c1 b2 00 00     1...90..........
    403c:	25 b3 00 00 39 30 01 00 39 30 01 00 39 30 01 00     %...90..90..90..
    404c:	39 30 01 00 39 30 01 00 39 30 01 00 39 30 01 00     90..90..90..90..
    405c:	39 30 01 00 39 30 01 00 39 30 01 00 39 30 01 00     90..90..90..90..
    406c:	19 fa 00 00 39 30 01 00 39 30 01 00 39 30 01 00     ....90..90..90..
    407c:	39 30 01 00 39 30 01 00 39 30 01 00 39 30 01 00     90..90..90..90..
    408c:	39 30 01 00 39 30 01 00 39 30 01 00 39 30 01 00     90..90..90..90..
    409c:	39 30 01 00 39 30 01 00 39 30 01 00 39 30 01 00     90..90..90..90..
    40ac:	39 30 01 00 39 30 01 00 e5 c0 00 00 11 c1 00 00     90..90..........
    40bc:	95 e2 00 00 9d e2 00 00 a5 e2 00 00 ad e2 00 00     ................
    40cc:	b5 e2 00 00 39 30 01 00 39 30 01 00 39 30 01 00     ....90..90..90..
    40dc:	39 30 01 00 39 30 01 00 39 30 01 00 00 00 00 00     90..90..90......
	...
    40f4:	0d de 00 00 89 12 01 00 99 12 01 00 a1 12 01 00     ................
    4104:	a9 12 01 00 b1 12 01 00 c1 12 01 00 c9 12 01 00     ................
    4114:	d1 12 01 00 39 30 01 00 39 30 01 00 39 30 01 00     ....90..90..90..
    4124:	39 30 01 00 d9 12 01 00 1d 13 01 00 25 13 01 00     90..........%...
    4134:	2d 13 01 00 35 13 01 00 45 13 01 00 4d 13 01 00     -...5...E...M...
    4144:	55 13 01 00 5d 13 01 00 ed 13 01 00 f5 13 01 00     U...]...........
    4154:	fd 13 01 00 05 14 01 00 15 14 01 00 1d 14 01 00     ................
    4164:	25 14 01 00 39 30 01 00 39 30 01 00 39 30 01 00     %...90..90..90..
    4174:	39 30 01 00 00 00 00 00 00 00 00 00 a9 d9 00 00     90..............
    4184:	b1 d9 00 00 b9 d9 00 00 c1 d9 00 00 00 00 00 00     ................
    4194:	39 30 01 00 39 30 01 00 39 30 01 00 39 30 01 00     90..90..90..90..
    41a4:	39 30 01 00 39 30 01 00 39 30 01 00 39 30 01 00     90..90..90..90..
    41b4:	39 30 01 00 39 30 01 00 39 30 01 00 39 30 01 00     90..90..90..90..
    41c4:	39 30 01 00 39 30 01 00 39 30 01 00 39 30 01 00     90..90..90..90..
    41d4:	39 30 01 00 39 30 01 00 39 30 01 00 39 30 01 00     90..90..90..90..
    41e4:	39 30 01 00 39 30 01 00 0d 3a 01 00 1d 3a 01 00     90..90...:...:..
    41f4:	2d 3a 01 00 3d 3a 01 00 39 30 01 00 39 30 01 00     -:..=:..90..90..
    4204:	39 30 01 00 39 30 01 00 39 30 01 00 39 30 01 00     90..90..90..90..
    4214:	39 30 01 00 09 30 01 00 19 30 01 00 21 30 01 00     90...0...0..!0..
    4224:	31 30 01 00 39 30 01 00 39 30 01 00 39 30 01 00     10..90..90..90..
    4234:	39 30 01 00 39 30 01 00 39 30 01 00 39 30 01 00     90..90..90..90..
    4244:	39 30 01 00 39 30 01 00 39 30 01 00 39 30 01 00     90..90..90..90..
    4254:	39 30 01 00 39 30 01 00 39 30 01 00 39 30 01 00     90..90..90..90..

00004264 <__do_global_dtors_aux>:
    4264:	b510      	push	{r4, lr}
    4266:	4c05      	ldr	r4, [pc, #20]	; (427c <__do_global_dtors_aux+0x18>)
    4268:	7823      	ldrb	r3, [r4, #0]
    426a:	b933      	cbnz	r3, 427a <__do_global_dtors_aux+0x16>
    426c:	4b04      	ldr	r3, [pc, #16]	; (4280 <__do_global_dtors_aux+0x1c>)
    426e:	b113      	cbz	r3, 4276 <__do_global_dtors_aux+0x12>
    4270:	4804      	ldr	r0, [pc, #16]	; (4284 <__do_global_dtors_aux+0x20>)
    4272:	f3af 8000 	nop.w
    4276:	2301      	movs	r3, #1
    4278:	7023      	strb	r3, [r4, #0]
    427a:	bd10      	pop	{r4, pc}
    427c:	200005b0 	.word	0x200005b0
    4280:	00000000 	.word	0x00000000
    4284:	00016970 	.word	0x00016970

00004288 <frame_dummy>:
    4288:	b508      	push	{r3, lr}
    428a:	4b03      	ldr	r3, [pc, #12]	; (4298 <frame_dummy+0x10>)
    428c:	b11b      	cbz	r3, 4296 <frame_dummy+0xe>
    428e:	4903      	ldr	r1, [pc, #12]	; (429c <frame_dummy+0x14>)
    4290:	4803      	ldr	r0, [pc, #12]	; (42a0 <frame_dummy+0x18>)
    4292:	f3af 8000 	nop.w
    4296:	bd08      	pop	{r3, pc}
    4298:	00000000 	.word	0x00000000
    429c:	200005b4 	.word	0x200005b4
    42a0:	00016970 	.word	0x00016970

000042a4 <audio_midi_req>:
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */

static int32_t audio_midi_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    42a4:	b410      	push	{r4}
		
	//return ERR_NOT_FOUND;	
		
	if ((0x81 == req->bmRequestType) && (req->wIndex == _audiodf_midi_funcd.func_iface[0] || req->wIndex == _audiodf_midi_funcd.func_iface[1])) {
    42a6:	780b      	ldrb	r3, [r1, #0]
    42a8:	2b81      	cmp	r3, #129	; 0x81
    42aa:	d110      	bne.n	42ce <audio_midi_req+0x2a>
    42ac:	4b1a      	ldr	r3, [pc, #104]	; (4318 <audio_midi_req+0x74>)
    42ae:	888a      	ldrh	r2, [r1, #4]
    42b0:	7919      	ldrb	r1, [r3, #4]
    42b2:	4291      	cmp	r1, r2
    42b4:	4619      	mov	r1, r3
    42b6:	d002      	beq.n	42be <audio_midi_req+0x1a>
    42b8:	795b      	ldrb	r3, [r3, #5]
    42ba:	4293      	cmp	r3, r2
    42bc:	d128      	bne.n	4310 <audio_midi_req+0x6c>
	return usbdc_xfer(ep, _audiodf_midi_funcd.audio_desc, _audiodf_midi_funcd.audio_desc[0], false);
    42be:	6809      	ldr	r1, [r1, #0]
    42c0:	780a      	ldrb	r2, [r1, #0]
    42c2:	2300      	movs	r3, #0
			switch (req->bRequest) {
				case 0x03: /* Get Protocol */
				return usbdc_xfer(ep, &_audiodf_midi_funcd.protocol, 1, 0);
				case 0x0B: /* Set Protocol */
				_audiodf_midi_funcd.protocol = req->wValue;
				return usbdc_xfer(ep, NULL, 0, 0);
    42c4:	4c15      	ldr	r4, [pc, #84]	; (431c <audio_midi_req+0x78>)
    42c6:	46a4      	mov	ip, r4
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    42c8:	f85d 4b04 	ldr.w	r4, [sp], #4
				return usbdc_xfer(ep, NULL, 0, 0);
    42cc:	4760      	bx	ip
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    42ce:	f3c3 1341 	ubfx	r3, r3, #5, #2
    42d2:	2b01      	cmp	r3, #1
    42d4:	d11c      	bne.n	4310 <audio_midi_req+0x6c>
		if (req->wIndex == _audiodf_midi_funcd.func_iface[0] || req->wIndex == _audiodf_midi_funcd.func_iface[1]) {
    42d6:	4b10      	ldr	r3, [pc, #64]	; (4318 <audio_midi_req+0x74>)
    42d8:	888a      	ldrh	r2, [r1, #4]
    42da:	791c      	ldrb	r4, [r3, #4]
    42dc:	4294      	cmp	r4, r2
    42de:	461c      	mov	r4, r3
    42e0:	d002      	beq.n	42e8 <audio_midi_req+0x44>
    42e2:	795b      	ldrb	r3, [r3, #5]
    42e4:	4293      	cmp	r3, r2
    42e6:	d113      	bne.n	4310 <audio_midi_req+0x6c>
			switch (req->bRequest) {
    42e8:	784b      	ldrb	r3, [r1, #1]
    42ea:	2b03      	cmp	r3, #3
    42ec:	d006      	beq.n	42fc <audio_midi_req+0x58>
    42ee:	2b0b      	cmp	r3, #11
    42f0:	d008      	beq.n	4304 <audio_midi_req+0x60>
    42f2:	f06f 000c 	mvn.w	r0, #12
}
    42f6:	f85d 4b04 	ldr.w	r4, [sp], #4
    42fa:	4770      	bx	lr
				return usbdc_xfer(ep, &_audiodf_midi_funcd.protocol, 1, 0);
    42fc:	4908      	ldr	r1, [pc, #32]	; (4320 <audio_midi_req+0x7c>)
    42fe:	2300      	movs	r3, #0
    4300:	2201      	movs	r2, #1
    4302:	e7df      	b.n	42c4 <audio_midi_req+0x20>
				_audiodf_midi_funcd.protocol = req->wValue;
    4304:	884b      	ldrh	r3, [r1, #2]
    4306:	7223      	strb	r3, [r4, #8]
				return usbdc_xfer(ep, NULL, 0, 0);
    4308:	2300      	movs	r3, #0
    430a:	461a      	mov	r2, r3
    430c:	4619      	mov	r1, r3
    430e:	e7d9      	b.n	42c4 <audio_midi_req+0x20>
			return ERR_NOT_FOUND; // Never hit breakpoint here
    4310:	f06f 0009 	mvn.w	r0, #9
	(void)stage;
    4314:	e7ef      	b.n	42f6 <audio_midi_req+0x52>
    4316:	bf00      	nop
    4318:	200005cc 	.word	0x200005cc
    431c:	0001323d 	.word	0x0001323d
    4320:	200005d4 	.word	0x200005d4

00004324 <audio_midi_ctrl>:
	switch (ctrl) {
    4324:	2901      	cmp	r1, #1
{
    4326:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    432a:	460d      	mov	r5, r1
    432c:	4614      	mov	r4, r2
	switch (ctrl) {
    432e:	d070      	beq.n	4412 <audio_midi_ctrl+0xee>
    4330:	2902      	cmp	r1, #2
    4332:	f000 8092 	beq.w	445a <audio_midi_ctrl+0x136>
    4336:	2900      	cmp	r1, #0
    4338:	f040 8092 	bne.w	4460 <audio_midi_ctrl+0x13c>
		return audio_midi_enable(drv, (struct usbd_descriptors *)param);
    433c:	6886      	ldr	r6, [r0, #8]
	ifc = desc->sod;
    433e:	f8df 8148 	ldr.w	r8, [pc, #328]	; 4488 <audio_midi_ctrl+0x164>
    4342:	6810      	ldr	r0, [r2, #0]
				usb_debug2[4] = ep_desc.wMaxPacketSize;
    4344:	f8df 9144 	ldr.w	r9, [pc, #324]	; 448c <audio_midi_ctrl+0x168>
    4348:	1d37      	adds	r7, r6, #4
		if (NULL == ifc) {
    434a:	b920      	cbnz	r0, 4356 <audio_midi_ctrl+0x32>
			return ERR_NOT_FOUND;
    434c:	f06f 0009 	mvn.w	r0, #9
}
    4350:	b003      	add	sp, #12
    4352:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (AUDIO_AC_SUBCLASS == ifc_desc.bInterfaceClass || AUDIO_MS_SUBCLASS == ifc_desc.bInterfaceClass) {			
    4356:	7943      	ldrb	r3, [r0, #5]
		ifc_desc.bInterfaceNumber = ifc[2];
    4358:	7882      	ldrb	r2, [r0, #2]
		if (AUDIO_AC_SUBCLASS == ifc_desc.bInterfaceClass || AUDIO_MS_SUBCLASS == ifc_desc.bInterfaceClass) {			
    435a:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    435e:	2b01      	cmp	r3, #1
    4360:	d1f4      	bne.n	434c <audio_midi_ctrl+0x28>
			if (func_data->func_iface[i] == ifc_desc.bInterfaceNumber) { // Initialized
    4362:	783b      	ldrb	r3, [r7, #0]
    4364:	429a      	cmp	r2, r3
    4366:	d07e      	beq.n	4466 <audio_midi_ctrl+0x142>
			} else if (func_data->func_iface[i] != 0xFF) { // Occupied
    4368:	2bff      	cmp	r3, #255	; 0xff
    436a:	d17f      	bne.n	446c <audio_midi_ctrl+0x148>
		if (i == 1){ // i==1 because only the second interface has endpoint descriptors
    436c:	2d01      	cmp	r5, #1
				func_data->func_iface[i] = ifc_desc.bInterfaceNumber;
    436e:	f807 2b01 	strb.w	r2, [r7], #1
		if (i == 1){ // i==1 because only the second interface has endpoint descriptors
    4372:	d009      	beq.n	4388 <audio_midi_ctrl+0x64>
		ifc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_INTERFACE);		
    4374:	6823      	ldr	r3, [r4, #0]
    4376:	6861      	ldr	r1, [r4, #4]
 *  \param[in] desc Byte pointer to the descriptor start address
 *  \return Byte pointer to the next descriptor
 */
static inline uint8_t *usb_desc_next(uint8_t *desc)
{
	return (desc + usb_desc_len(desc));
    4378:	7818      	ldrb	r0, [r3, #0]
    437a:	2204      	movs	r2, #4
    437c:	4418      	add	r0, r3
    437e:	47c0      	blx	r8
	for (i=0; i<2; i++){
    4380:	2d01      	cmp	r5, #1
    4382:	d042      	beq.n	440a <audio_midi_ctrl+0xe6>
    4384:	2501      	movs	r5, #1
    4386:	e7e0      	b.n	434a <audio_midi_ctrl+0x26>
			ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    4388:	6861      	ldr	r1, [r4, #4]
    438a:	f8df a104 	ldr.w	sl, [pc, #260]	; 4490 <audio_midi_ctrl+0x16c>
    438e:	2205      	movs	r2, #5
    4390:	47c0      	blx	r8
    4392:	4683      	mov	fp, r0
			while (NULL != ep) {
    4394:	f1bb 0f00 	cmp.w	fp, #0
    4398:	d0ec      	beq.n	4374 <audio_midi_ctrl+0x50>
				ep_desc.bEndpointAddress = ep[2];
    439a:	f89b 2002 	ldrb.w	r2, [fp, #2]
    439e:	f88d 2002 	strb.w	r2, [sp, #2]
				ep_desc.bmAttributes     = ep[3];
    43a2:	f89b 2003 	ldrb.w	r2, [fp, #3]
    43a6:	f88d 2003 	strb.w	r2, [sp, #3]
	return (ptr[0] + (ptr[1] << 8));
    43aa:	f89b 1005 	ldrb.w	r1, [fp, #5]
    43ae:	f89b 2004 	ldrb.w	r2, [fp, #4]
				if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    43b2:	4b31      	ldr	r3, [pc, #196]	; (4478 <audio_midi_ctrl+0x154>)
    43b4:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    43b8:	b292      	uxth	r2, r2
				ep_desc.wMaxPacketSize   = usb_get_u16(ep + 4);
    43ba:	f8ad 2004 	strh.w	r2, [sp, #4]
				usb_debug2[4] = ep_desc.wMaxPacketSize;
    43be:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    43c2:	b2d2      	uxtb	r2, r2
    43c4:	f889 2004 	strb.w	r2, [r9, #4]
				usb_debug2[0] = i;
    43c8:	2201      	movs	r2, #1
    43ca:	f889 2000 	strb.w	r2, [r9]
				if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    43ce:	f89d 0002 	ldrb.w	r0, [sp, #2]
    43d2:	f89d 1003 	ldrb.w	r1, [sp, #3]
    43d6:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    43da:	b292      	uxth	r2, r2
    43dc:	4798      	blx	r3
    43de:	2800      	cmp	r0, #0
    43e0:	d147      	bne.n	4472 <audio_midi_ctrl+0x14e>
				if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    43e2:	f89d 2002 	ldrb.w	r2, [sp, #2]
					func_data->func_ep_in = ep_desc.bEndpointAddress;
    43e6:	f89d 0002 	ldrb.w	r0, [sp, #2]
				if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    43ea:	0613      	lsls	r3, r2, #24
					func_data->func_ep_in = ep_desc.bEndpointAddress;
    43ec:	b2c0      	uxtb	r0, r0
    43ee:	bf4c      	ite	mi
    43f0:	71b0      	strbmi	r0, [r6, #6]
					func_data->func_ep_out = ep_desc.bEndpointAddress;
    43f2:	71f0      	strbpl	r0, [r6, #7]
					usb_d_ep_enable(func_data->func_ep_out);
    43f4:	47d0      	blx	sl
				desc->sod = ep;
    43f6:	f8c4 b000 	str.w	fp, [r4]
	return (desc + usb_desc_len(desc));
    43fa:	f89b 0000 	ldrb.w	r0, [fp]
				ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    43fe:	6861      	ldr	r1, [r4, #4]
    4400:	4b1e      	ldr	r3, [pc, #120]	; (447c <audio_midi_ctrl+0x158>)
    4402:	4458      	add	r0, fp
    4404:	4798      	blx	r3
    4406:	4683      	mov	fp, r0
    4408:	e7c4      	b.n	4394 <audio_midi_ctrl+0x70>
	_audiodf_midi_funcd.enabled = true;
    440a:	4b1d      	ldr	r3, [pc, #116]	; (4480 <audio_midi_ctrl+0x15c>)
	return ERR_NONE;
    440c:	2000      	movs	r0, #0
	_audiodf_midi_funcd.enabled = true;
    440e:	745d      	strb	r5, [r3, #17]
	return ERR_NONE;
    4410:	e79e      	b.n	4350 <audio_midi_ctrl+0x2c>
		return audio_midi_disable(drv, (struct usbd_descriptors *)param);
    4412:	6885      	ldr	r5, [r0, #8]
	if (desc) {
    4414:	b12a      	cbz	r2, 4422 <audio_midi_ctrl+0xfe>
		ifc_desc.bInterfaceClass = desc->sod[5];
    4416:	6813      	ldr	r3, [r2, #0]
		if ((AUDIO_AC_SUBCLASS != ifc_desc.bInterfaceClass) && (AUDIO_MS_SUBCLASS != ifc_desc.bInterfaceClass)) {
    4418:	795b      	ldrb	r3, [r3, #5]
    441a:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    441e:	2b01      	cmp	r3, #1
    4420:	d194      	bne.n	434c <audio_midi_ctrl+0x28>
	if (func_data->func_iface[0] != 0xFF) {
    4422:	792b      	ldrb	r3, [r5, #4]
	if (func_data->func_ep_in != 0xFF) {
    4424:	79a8      	ldrb	r0, [r5, #6]
	if (func_data->func_iface[0] != 0xFF) {
    4426:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface[0] = 0xFF;
    4428:	bf1c      	itt	ne
    442a:	23ff      	movne	r3, #255	; 0xff
    442c:	712b      	strbne	r3, [r5, #4]
	if (func_data->func_iface[1] != 0xFF) {
    442e:	796b      	ldrb	r3, [r5, #5]
    4430:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface[1] = 0xFF;
    4432:	bf1c      	itt	ne
    4434:	23ff      	movne	r3, #255	; 0xff
    4436:	716b      	strbne	r3, [r5, #5]
	if (func_data->func_ep_in != 0xFF) {
    4438:	28ff      	cmp	r0, #255	; 0xff
    443a:	d003      	beq.n	4444 <audio_midi_ctrl+0x120>
		usb_d_ep_deinit(func_data->func_ep_in);
    443c:	4b11      	ldr	r3, [pc, #68]	; (4484 <audio_midi_ctrl+0x160>)
    443e:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    4440:	23ff      	movs	r3, #255	; 0xff
    4442:	71ab      	strb	r3, [r5, #6]
	if (func_data->func_ep_out != 0xFF) {
    4444:	79e8      	ldrb	r0, [r5, #7]
    4446:	28ff      	cmp	r0, #255	; 0xff
    4448:	d003      	beq.n	4452 <audio_midi_ctrl+0x12e>
		usb_d_ep_deinit(func_data->func_ep_out);
    444a:	4b0e      	ldr	r3, [pc, #56]	; (4484 <audio_midi_ctrl+0x160>)
    444c:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    444e:	23ff      	movs	r3, #255	; 0xff
    4450:	71eb      	strb	r3, [r5, #7]
	_audiodf_midi_funcd.enabled = false;
    4452:	4b0b      	ldr	r3, [pc, #44]	; (4480 <audio_midi_ctrl+0x15c>)
    4454:	2000      	movs	r0, #0
    4456:	7458      	strb	r0, [r3, #17]
	return ERR_NONE;
    4458:	e77a      	b.n	4350 <audio_midi_ctrl+0x2c>
		return ERR_UNSUPPORTED_OP;
    445a:	f06f 001a 	mvn.w	r0, #26
    445e:	e777      	b.n	4350 <audio_midi_ctrl+0x2c>
	switch (ctrl) {
    4460:	f06f 000c 	mvn.w	r0, #12
    4464:	e774      	b.n	4350 <audio_midi_ctrl+0x2c>
				return ERR_ALREADY_INITIALIZED;
    4466:	f06f 0011 	mvn.w	r0, #17
    446a:	e771      	b.n	4350 <audio_midi_ctrl+0x2c>
				return ERR_NO_RESOURCE;
    446c:	f06f 001b 	mvn.w	r0, #27
    4470:	e76e      	b.n	4350 <audio_midi_ctrl+0x2c>
					return ERR_NOT_INITIALIZED;
    4472:	f06f 0013 	mvn.w	r0, #19
    4476:	e76b      	b.n	4350 <audio_midi_ctrl+0x2c>
    4478:	0000f521 	.word	0x0000f521
    447c:	0000b807 	.word	0x0000b807
    4480:	200005cc 	.word	0x200005cc
    4484:	0000f585 	.word	0x0000f585
    4488:	0000b7ed 	.word	0x0000b7ed
    448c:	20009140 	.word	0x20009140
    4490:	0000f5b1 	.word	0x0000f5b1

00004494 <audiodf_midi_init>:

/**
 * \brief Initialize the USB Audio Midi Function Driver
 */
int32_t audiodf_midi_init(void)
{
    4494:	b508      	push	{r3, lr}
	
	
	if (usbdc_get_state() > USBD_S_POWER) {
    4496:	4b0a      	ldr	r3, [pc, #40]	; (44c0 <audiodf_midi_init+0x2c>)
    4498:	4798      	blx	r3
    449a:	2801      	cmp	r0, #1
    449c:	d80c      	bhi.n	44b8 <audiodf_midi_init+0x24>
		return ERR_DENIED;
	}
	
	_audiodf_midi.ctrl      = audio_midi_ctrl;
    449e:	4809      	ldr	r0, [pc, #36]	; (44c4 <audiodf_midi_init+0x30>)
    44a0:	4b09      	ldr	r3, [pc, #36]	; (44c8 <audiodf_midi_init+0x34>)
	_audiodf_midi.func_data = &_audiodf_midi_funcd;
    44a2:	e9c0 3006 	strd	r3, r0, [r0, #24]
	
	usbdc_register_function(&_audiodf_midi);
    44a6:	4b09      	ldr	r3, [pc, #36]	; (44cc <audiodf_midi_init+0x38>)
    44a8:	3014      	adds	r0, #20
    44aa:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &audio_midi_req_h);
    44ac:	2001      	movs	r0, #1
    44ae:	4908      	ldr	r1, [pc, #32]	; (44d0 <audiodf_midi_init+0x3c>)
    44b0:	4b08      	ldr	r3, [pc, #32]	; (44d4 <audiodf_midi_init+0x40>)
    44b2:	4798      	blx	r3
	return ERR_NONE;
    44b4:	2000      	movs	r0, #0
}
    44b6:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    44b8:	f06f 0010 	mvn.w	r0, #16
    44bc:	e7fb      	b.n	44b6 <audiodf_midi_init+0x22>
    44be:	bf00      	nop
    44c0:	00013675 	.word	0x00013675
    44c4:	200005cc 	.word	0x200005cc
    44c8:	00004325 	.word	0x00004325
    44cc:	0001361d 	.word	0x0001361d
    44d0:	20000000 	.word	0x20000000
    44d4:	00013595 	.word	0x00013595

000044d8 <audiodf_midi_write>:
}



int32_t audiodf_midi_write(uint8_t byte0, uint8_t byte1, uint8_t byte2, uint8_t byte3)
{
    44d8:	b410      	push	{r4}
		return ERR_DENIED;
	}
	
	// if previous xfer is completed
	
	_audiodf_midi_funcd.midi_report[0] = byte0;
    44da:	4c07      	ldr	r4, [pc, #28]	; (44f8 <audiodf_midi_write+0x20>)
    44dc:	7260      	strb	r0, [r4, #9]
	_audiodf_midi_funcd.midi_report[1] = byte1;
    44de:	72a1      	strb	r1, [r4, #10]
	_audiodf_midi_funcd.midi_report[2] = byte2;
    44e0:	72e2      	strb	r2, [r4, #11]
	_audiodf_midi_funcd.midi_report[3] = byte3;
    44e2:	7323      	strb	r3, [r4, #12]

	return usbdc_xfer(_audiodf_midi_funcd.func_ep_in, _audiodf_midi_funcd.midi_report, 4, false);
    44e4:	79a0      	ldrb	r0, [r4, #6]
    44e6:	f104 0109 	add.w	r1, r4, #9
    44ea:	4c04      	ldr	r4, [pc, #16]	; (44fc <audiodf_midi_write+0x24>)
    44ec:	2300      	movs	r3, #0
    44ee:	46a4      	mov	ip, r4
    44f0:	2204      	movs	r2, #4
	
}
    44f2:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_audiodf_midi_funcd.func_ep_in, _audiodf_midi_funcd.midi_report, 4, false);
    44f6:	4760      	bx	ip
    44f8:	200005cc 	.word	0x200005cc
    44fc:	0001323d 	.word	0x0001323d

00004500 <audiodf_midi_write_status>:

int32_t audiodf_midi_write_status(){
    4500:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	
	struct usb_d_ep_status epstat;
	return usb_d_ep_get_status(_audiodf_midi_funcd.func_ep_in, &epstat);
    4502:	4b04      	ldr	r3, [pc, #16]	; (4514 <audiodf_midi_write_status+0x14>)
    4504:	a901      	add	r1, sp, #4
    4506:	7998      	ldrb	r0, [r3, #6]
    4508:	4b03      	ldr	r3, [pc, #12]	; (4518 <audiodf_midi_write_status+0x18>)
    450a:	4798      	blx	r3
	
}
    450c:	b005      	add	sp, #20
    450e:	f85d fb04 	ldr.w	pc, [sp], #4
    4512:	bf00      	nop
    4514:	200005cc 	.word	0x200005cc
    4518:	0000f6d9 	.word	0x0000f6d9

0000451c <audiodf_midi_read>:



int32_t audiodf_midi_read(uint8_t *buf, uint32_t size)
{
    451c:	b410      	push	{r4}
    451e:	460a      	mov	r2, r1
	if (!audiodf_midi_is_enabled()) {
		return ERR_DENIED;
	}
		
	return usbdc_xfer(_audiodf_midi_funcd.func_ep_out, buf, size, false);
    4520:	4c04      	ldr	r4, [pc, #16]	; (4534 <audiodf_midi_read+0x18>)
    4522:	4601      	mov	r1, r0
    4524:	4804      	ldr	r0, [pc, #16]	; (4538 <audiodf_midi_read+0x1c>)
    4526:	46a4      	mov	ip, r4
    4528:	79c0      	ldrb	r0, [r0, #7]
}
    452a:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_audiodf_midi_funcd.func_ep_out, buf, size, false);
    452e:	2300      	movs	r3, #0
    4530:	4760      	bx	ip
    4532:	bf00      	nop
    4534:	0001323d 	.word	0x0001323d
    4538:	200005cc 	.word	0x200005cc

0000453c <audiodf_midi_register_callback>:


int32_t audiodf_midi_register_callback(enum audiodf_midi_cb_type cb_type, FUNC_PTR func)
{
    453c:	b510      	push	{r4, lr}
    453e:	460a      	mov	r2, r1
	switch (cb_type) {
    4540:	b120      	cbz	r0, 454c <audiodf_midi_register_callback+0x10>
    4542:	2801      	cmp	r0, #1
    4544:	d009      	beq.n	455a <audiodf_midi_register_callback+0x1e>
    4546:	f06f 000c 	mvn.w	r0, #12
		break;
		default:
		return ERR_INVALID_ARG;
	}
	return ERR_NONE;
}
    454a:	bd10      	pop	{r4, pc}
		usb_d_ep_register_callback(_audiodf_midi_funcd.func_ep_out, USB_D_EP_CB_XFER, func);
    454c:	4b05      	ldr	r3, [pc, #20]	; (4564 <audiodf_midi_register_callback+0x28>)
    454e:	79d8      	ldrb	r0, [r3, #7]
    4550:	2102      	movs	r1, #2
		usb_d_ep_register_callback(_audiodf_midi_funcd.func_ep_in, USB_D_EP_CB_XFER, func);
    4552:	4b05      	ldr	r3, [pc, #20]	; (4568 <audiodf_midi_register_callback+0x2c>)
    4554:	4798      	blx	r3
	return ERR_NONE;
    4556:	2000      	movs	r0, #0
		break;
    4558:	e7f7      	b.n	454a <audiodf_midi_register_callback+0xe>
		usb_d_ep_register_callback(_audiodf_midi_funcd.func_ep_in, USB_D_EP_CB_XFER, func);
    455a:	4b02      	ldr	r3, [pc, #8]	; (4564 <audiodf_midi_register_callback+0x28>)
    455c:	2102      	movs	r1, #2
    455e:	7998      	ldrb	r0, [r3, #6]
    4560:	e7f7      	b.n	4552 <audiodf_midi_register_callback+0x16>
    4562:	bf00      	nop
    4564:	200005cc 	.word	0x200005cc
    4568:	0000f799 	.word	0x0000f799

0000456c <grid_ain_channel_init>:

struct AIN_Channel* ain_channel_buffer;



uint8_t grid_ain_channel_init(struct AIN_Channel* instance , uint8_t buffer_depth, uint8_t result_format, uint8_t result_resolution){
    456c:	b570      	push	{r4, r5, r6, lr}
	instance->buffer_depth = buffer_depth;
	
	instance->result_format = result_format;
	instance->result_resolution = result_resolution;
	
	instance->result_average = 0;
    456e:	2500      	movs	r5, #0
	instance->result_format = result_format;
    4570:	7142      	strb	r2, [r0, #5]
	instance->result_resolution = result_resolution;
    4572:	7183      	strb	r3, [r0, #6]
uint8_t grid_ain_channel_init(struct AIN_Channel* instance , uint8_t buffer_depth, uint8_t result_format, uint8_t result_resolution){
    4574:	4604      	mov	r4, r0
	
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    4576:	4b0a      	ldr	r3, [pc, #40]	; (45a0 <grid_ain_channel_init+0x34>)
	instance->buffer_depth = buffer_depth;
    4578:	7101      	strb	r1, [r0, #4]
	instance->result_average = 0;
    457a:	8145      	strh	r5, [r0, #10]
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    457c:	0048      	lsls	r0, r1, #1
uint8_t grid_ain_channel_init(struct AIN_Channel* instance , uint8_t buffer_depth, uint8_t result_format, uint8_t result_resolution){
    457e:	460e      	mov	r6, r1
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    4580:	4798      	blx	r3
	
	// Init the whole buffer with zeros
	for(uint8_t i=0; i<instance->buffer_depth; i++){
    4582:	462b      	mov	r3, r5
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    4584:	6020      	str	r0, [r4, #0]
	for(uint8_t i=0; i<instance->buffer_depth; i++){
    4586:	462a      	mov	r2, r5
    4588:	b2d9      	uxtb	r1, r3
    458a:	428e      	cmp	r6, r1
    458c:	d803      	bhi.n	4596 <grid_ain_channel_init+0x2a>
		instance->buffer[i] = 0;
	}
	
	instance->result_changed = 0;
    458e:	81a2      	strh	r2, [r4, #12]
	instance->result_value = 0;
    4590:	8122      	strh	r2, [r4, #8]
		
	return 0;
}
    4592:	2000      	movs	r0, #0
    4594:	bd70      	pop	{r4, r5, r6, pc}
		instance->buffer[i] = 0;
    4596:	f820 2013 	strh.w	r2, [r0, r3, lsl #1]
	for(uint8_t i=0; i<instance->buffer_depth; i++){
    459a:	3301      	adds	r3, #1
    459c:	e7f4      	b.n	4588 <grid_ain_channel_init+0x1c>
    459e:	bf00      	nop
    45a0:	000142c5 	.word	0x000142c5

000045a4 <grid_ain_init>:
	}
}


/** Initialize ain buffer for a given number of analog channels */
uint8_t grid_ain_init(uint8_t length, uint8_t depth, uint8_t  format, uint8_t resolution){
    45a4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    45a8:	4605      	mov	r5, r0
    45aa:	4699      	mov	r9, r3
	
	// ain_channel_result_resolution = resolution
	
	
	// 2D buffer, example: 16 potentiometers, last 32 samples stored for each
	ain_channel_buffer = (struct AIN_Channel*) malloc(length * sizeof(struct AIN_Channel));
    45ac:	0100      	lsls	r0, r0, #4
    45ae:	4b0b      	ldr	r3, [pc, #44]	; (45dc <grid_ain_init+0x38>)
    45b0:	4e0b      	ldr	r6, [pc, #44]	; (45e0 <grid_ain_init+0x3c>)

	for (uint8_t i=0; i<length; i++){
		grid_ain_channel_init(&ain_channel_buffer[i], depth, format, resolution);
    45b2:	f8df a030 	ldr.w	sl, [pc, #48]	; 45e4 <grid_ain_init+0x40>
uint8_t grid_ain_init(uint8_t length, uint8_t depth, uint8_t  format, uint8_t resolution){
    45b6:	460f      	mov	r7, r1
    45b8:	4690      	mov	r8, r2
	ain_channel_buffer = (struct AIN_Channel*) malloc(length * sizeof(struct AIN_Channel));
    45ba:	4798      	blx	r3
	for (uint8_t i=0; i<length; i++){
    45bc:	2400      	movs	r4, #0
	ain_channel_buffer = (struct AIN_Channel*) malloc(length * sizeof(struct AIN_Channel));
    45be:	6030      	str	r0, [r6, #0]
	for (uint8_t i=0; i<length; i++){
    45c0:	42a5      	cmp	r5, r4
    45c2:	d102      	bne.n	45ca <grid_ain_init+0x26>
	}

	return 0;
}
    45c4:	2000      	movs	r0, #0
    45c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		grid_ain_channel_init(&ain_channel_buffer[i], depth, format, resolution);
    45ca:	6830      	ldr	r0, [r6, #0]
    45cc:	464b      	mov	r3, r9
    45ce:	eb00 1004 	add.w	r0, r0, r4, lsl #4
    45d2:	4642      	mov	r2, r8
    45d4:	4639      	mov	r1, r7
    45d6:	47d0      	blx	sl
	for (uint8_t i=0; i<length; i++){
    45d8:	3401      	adds	r4, #1
    45da:	e7f1      	b.n	45c0 <grid_ain_init+0x1c>
    45dc:	000142c5 	.word	0x000142c5
    45e0:	2000c0a8 	.word	0x2000c0a8
    45e4:	0000456d 	.word	0x0000456d

000045e8 <grid_ain_add_sample>:

uint8_t grid_ain_add_sample(uint8_t channel, uint16_t value){
	
	struct AIN_Channel* instance = &ain_channel_buffer[channel];
    45e8:	4b30      	ldr	r3, [pc, #192]	; (46ac <grid_ain_add_sample+0xc4>)
uint8_t grid_ain_add_sample(uint8_t channel, uint16_t value){
    45ea:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct AIN_Channel* instance = &ain_channel_buffer[channel];
    45ee:	681a      	ldr	r2, [r3, #0]
    45f0:	0104      	lsls	r4, r0, #4
    45f2:	eb02 1300 	add.w	r3, r2, r0, lsl #4
	uint16_t maximum = 0;

	uint8_t minimum_index = 0;
	uint8_t maximum_index = 0;
	
	for (uint8_t i = 0; i<instance->buffer_depth; i++){
    45f6:	5914      	ldr	r4, [r2, r4]
    45f8:	f893 e004 	ldrb.w	lr, [r3, #4]
    45fc:	2200      	movs	r2, #0
	uint8_t maximum_index = 0;
    45fe:	4615      	mov	r5, r2
	uint8_t minimum_index = 0;
    4600:	4616      	mov	r6, r2
	uint16_t maximum = 0;
    4602:	4691      	mov	r9, r2
	uint16_t minimum = -1; // -1 trick to get the largest possible number
    4604:	f64f 78ff 	movw	r8, #65535	; 0xffff
	uint32_t sum = 0;
    4608:	4610      	mov	r0, r2
    460a:	fa5f fc82 	uxtb.w	ip, r2
	for (uint8_t i = 0; i<instance->buffer_depth; i++){
    460e:	45e6      	cmp	lr, ip
    4610:	d83c      	bhi.n	468c <grid_ain_add_sample+0xa4>
	
	}
	
	uint16_t average = sum/instance->buffer_depth;
	
	if (value>average){		
    4612:	180a      	adds	r2, r1, r0
	uint16_t average = sum/instance->buffer_depth;
    4614:	fbb0 f0fe 	udiv	r0, r0, lr
	if (value>average){		
    4618:	b280      	uxth	r0, r0
    461a:	4288      	cmp	r0, r1
		// Replace minimum in the buffer and recalculate sum
		sum = sum - instance->buffer[minimum_index] + value;
    461c:	bf34      	ite	cc
    461e:	b230      	sxthcc	r0, r6
		instance->buffer[minimum_index] = value;		
	}else{
		// Replace maximum in the buffer and recalculate sum
		sum = sum - instance->buffer[maximum_index] + value;
    4620:	b228      	sxthcs	r0, r5
    4622:	f834 5010 	ldrh.w	r5, [r4, r0, lsl #1]
		instance->buffer[maximum_index] = value;
    4626:	f824 1010 	strh.w	r1, [r4, r0, lsl #1]
		sum = sum - instance->buffer[maximum_index] + value;
    462a:	1b52      	subs	r2, r2, r5
	}
	
	// Recalculate average
	average = sum/instance->buffer_depth;
    462c:	7919      	ldrb	r1, [r3, #4]
    462e:	fbb2 f2f1 	udiv	r2, r2, r1
	
	
	uint8_t downscale_factor = (16-instance->result_resolution);
    4632:	7999      	ldrb	r1, [r3, #6]
	uint8_t upscale_factor   = (instance->result_format - instance->result_resolution);
    4634:	795c      	ldrb	r4, [r3, #5]
	
	uint16_t downsampled = average>>downscale_factor;
	uint16_t upscaled    = downsampled<<upscale_factor;
	
	uint8_t criteria_a = instance->result_value != upscaled;
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    4636:	895e      	ldrh	r6, [r3, #10]
	
	uint8_t criteria_c = upscaled==(1<<instance->result_format)-(1<<upscale_factor);
	uint8_t criteria_d = upscaled==0;
	
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    4638:	f8b3 e008 	ldrh.w	lr, [r3, #8]
	uint8_t downscale_factor = (16-instance->result_resolution);
    463c:	f1c1 0710 	rsb	r7, r1, #16
	uint16_t downsampled = average>>downscale_factor;
    4640:	b295      	uxth	r5, r2
    4642:	b2ff      	uxtb	r7, r7
	uint8_t upscale_factor   = (instance->result_format - instance->result_resolution);
    4644:	1a61      	subs	r1, r4, r1
	uint16_t upscaled    = downsampled<<upscale_factor;
    4646:	b2c8      	uxtb	r0, r1
	uint16_t downsampled = average>>downscale_factor;
    4648:	fa45 f107 	asr.w	r1, r5, r7
	uint16_t upscaled    = downsampled<<upscale_factor;
    464c:	b289      	uxth	r1, r1
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    464e:	1b76      	subs	r6, r6, r5
	uint16_t upscaled    = downsampled<<upscale_factor;
    4650:	4081      	lsls	r1, r0
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    4652:	2e00      	cmp	r6, #0
	uint16_t upscaled    = downsampled<<upscale_factor;
    4654:	fa1f fc81 	uxth.w	ip, r1
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    4658:	bfb8      	it	lt
    465a:	4276      	neglt	r6, r6
    465c:	2501      	movs	r5, #1
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    465e:	45e6      	cmp	lr, ip
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    4660:	fa05 f707 	lsl.w	r7, r5, r7
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    4664:	d01f      	beq.n	46a6 <grid_ain_add_sample+0xbe>
    4666:	42be      	cmp	r6, r7
    4668:	dc09      	bgt.n	467e <grid_ain_add_sample+0x96>
	uint8_t criteria_c = upscaled==(1<<instance->result_format)-(1<<upscale_factor);
    466a:	fa05 f404 	lsl.w	r4, r5, r4
    466e:	fa05 f000 	lsl.w	r0, r5, r0
    4672:	1a20      	subs	r0, r4, r0
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    4674:	4560      	cmp	r0, ip
    4676:	d002      	beq.n	467e <grid_ain_add_sample+0x96>
    4678:	f1bc 0f00 	cmp.w	ip, #0
    467c:	d113      	bne.n	46a6 <grid_ain_add_sample+0xbe>
		
		instance->result_average = average;
		instance->result_value = upscaled;
		instance->result_changed = 1;
    467e:	2001      	movs	r0, #1
	average = sum/instance->buffer_depth;
    4680:	815a      	strh	r2, [r3, #10]
		instance->result_value = upscaled;
    4682:	f8a3 c008 	strh.w	ip, [r3, #8]
		instance->result_changed = 1;
    4686:	8198      	strh	r0, [r3, #12]
		return 1;
	}else{		
		return 0;
	}
	
}
    4688:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		uint16_t current = instance->buffer[i];
    468c:	f834 7012 	ldrh.w	r7, [r4, r2, lsl #1]
		if (current > maximum){
    4690:	45b9      	cmp	r9, r7
    4692:	bf3c      	itt	cc
    4694:	4665      	movcc	r5, ip
    4696:	46b9      	movcc	r9, r7
		if (current < minimum){
    4698:	45b8      	cmp	r8, r7
		sum += current;
    469a:	4438      	add	r0, r7
		if (current < minimum){
    469c:	bf84      	itt	hi
    469e:	4666      	movhi	r6, ip
    46a0:	46b8      	movhi	r8, r7
	for (uint8_t i = 0; i<instance->buffer_depth; i++){
    46a2:	3201      	adds	r2, #1
    46a4:	e7b1      	b.n	460a <grid_ain_add_sample+0x22>
		return 0;
    46a6:	2000      	movs	r0, #0
    46a8:	e7ee      	b.n	4688 <grid_ain_add_sample+0xa0>
    46aa:	bf00      	nop
    46ac:	2000c0a8 	.word	0x2000c0a8

000046b0 <grid_ain_get_changed>:

uint8_t grid_ain_get_changed(uint8_t channel){
	
	struct AIN_Channel* instance = &ain_channel_buffer[channel];
	return instance->result_changed;
    46b0:	4b02      	ldr	r3, [pc, #8]	; (46bc <grid_ain_get_changed+0xc>)
    46b2:	681b      	ldr	r3, [r3, #0]
    46b4:	eb03 1000 	add.w	r0, r3, r0, lsl #4
}
    46b8:	7b00      	ldrb	r0, [r0, #12]
    46ba:	4770      	bx	lr
    46bc:	2000c0a8 	.word	0x2000c0a8

000046c0 <grid_ain_get_average>:
	
uint16_t grid_ain_get_average(uint8_t channel, uint8_t resolution){
	
	struct AIN_Channel* instance = &ain_channel_buffer[channel];	
    46c0:	4b08      	ldr	r3, [pc, #32]	; (46e4 <grid_ain_get_average+0x24>)
    46c2:	681a      	ldr	r2, [r3, #0]
	instance->result_changed = 0;
	
	if (resolution>6 && resolution<15){
    46c4:	1fcb      	subs	r3, r1, #7
	struct AIN_Channel* instance = &ain_channel_buffer[channel];	
    46c6:	eb02 1200 	add.w	r2, r2, r0, lsl #4
	if (resolution>6 && resolution<15){
    46ca:	2b07      	cmp	r3, #7
	instance->result_changed = 0;
    46cc:	f04f 0000 	mov.w	r0, #0
    46d0:	8190      	strh	r0, [r2, #12]
	if (resolution>6 && resolution<15){
    46d2:	d805      	bhi.n	46e0 <grid_ain_get_average+0x20>
		

		
		return (instance->result_value)/(1<<(instance->result_format-resolution));
    46d4:	7950      	ldrb	r0, [r2, #5]
    46d6:	8913      	ldrh	r3, [r2, #8]
    46d8:	1a40      	subs	r0, r0, r1
    46da:	fa43 f000 	asr.w	r0, r3, r0
    46de:	b280      	uxth	r0, r0
		
	}
	else{
		return 0;
	}
}
    46e0:	4770      	bx	lr
    46e2:	bf00      	nop
    46e4:	2000c0a8 	.word	0x2000c0a8

000046e8 <grid_port_reset_receiver>:
#include "grid_buf.h"

// PORTS


void grid_port_reset_receiver(struct grid_port* por){
    46e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
	usart_async_disable(por->usart);
    46ea:	4b24      	ldr	r3, [pc, #144]	; (477c <grid_port_reset_receiver+0x94>)
	
	
	por->ping_partner_token = 255;
	por->ping_local_token = 255;
	
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    46ec:	4e24      	ldr	r6, [pc, #144]	; (4780 <grid_port_reset_receiver+0x98>)
void grid_port_reset_receiver(struct grid_port* por){
    46ee:	4604      	mov	r4, r0
	usart_async_disable(por->usart);
    46f0:	6840      	ldr	r0, [r0, #4]
    46f2:	4798      	blx	r3
	por->partner_status = 0;
    46f4:	f642 734b 	movw	r3, #12107	; 0x2f4b
	por->rx_double_buffer_seek_start_index = 0;
    46f8:	2500      	movs	r5, #0
	por->rx_double_buffer_read_start_index = 0;
    46fa:	e9c4 5509 	strd	r5, r5, [r4, #36]	; 0x24
	por->ping_local_token = 255;
    46fe:	f642 7731 	movw	r7, #12081	; 0x2f31
	por->partner_status = 0;
    4702:	54e5      	strb	r5, [r4, r3]
	por->ping_partner_token = 255;
    4704:	f642 7332 	movw	r3, #12082	; 0x2f32
    4708:	22ff      	movs	r2, #255	; 0xff
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    470a:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
	por->ping_partner_token = 255;
    470e:	54e2      	strb	r2, [r4, r3]
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4710:	2102      	movs	r1, #2
	por->ping_local_token = 255;
    4712:	55e2      	strb	r2, [r4, r7]
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4714:	303b      	adds	r0, #59	; 0x3b
    4716:	47b0      	blx	r6
	grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4718:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
    471c:	5de2      	ldrb	r2, [r4, r7]
    471e:	2102      	movs	r1, #2
    4720:	3039      	adds	r0, #57	; 0x39
    4722:	47b0      	blx	r6
	grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4724:	f642 7347 	movw	r3, #12103	; 0x2f47
    4728:	f504 563c 	add.w	r6, r4, #12032	; 0x2f00
    472c:	3633      	adds	r6, #51	; 0x33
    472e:	5ce1      	ldrb	r1, [r4, r3]
    4730:	4b14      	ldr	r3, [pc, #80]	; (4784 <grid_port_reset_receiver+0x9c>)
    4732:	9101      	str	r1, [sp, #4]
    4734:	4630      	mov	r0, r6
    4736:	4798      	blx	r3
    4738:	9901      	ldr	r1, [sp, #4]
    473a:	4b13      	ldr	r3, [pc, #76]	; (4788 <grid_port_reset_receiver+0xa0>)
    473c:	4602      	mov	r2, r0
    473e:	4630      	mov	r0, r6
    4740:	4798      	blx	r3


	
	por->rx_double_buffer_timeout = 0;
	grid_sys_port_reset_dma(por);
    4742:	4b12      	ldr	r3, [pc, #72]	; (478c <grid_port_reset_receiver+0xa4>)
	por->rx_double_buffer_timeout = 0;
    4744:	61e5      	str	r5, [r4, #28]
	grid_sys_port_reset_dma(por);
    4746:	4620      	mov	r0, r4
    4748:	4798      	blx	r3
	
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    474a:	f504 539d 	add.w	r3, r4, #5024	; 0x13a0
    474e:	3314      	adds	r3, #20
    4750:	f504 521c 	add.w	r2, r4, #9984	; 0x2700
    4754:	323c      	adds	r2, #60	; 0x3c
    4756:	4619      	mov	r1, r3
		por->rx_double_buffer[i] = 0;
    4758:	f803 5b01 	strb.w	r5, [r3], #1
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    475c:	4293      	cmp	r3, r2
    475e:	d1fb      	bne.n	4758 <grid_port_reset_receiver+0x70>
    4760:	f104 032c 	add.w	r3, r4, #44	; 0x2c
	}
	
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
		por->tx_double_buffer[i] = 0;
    4764:	2200      	movs	r2, #0
    4766:	f803 2b01 	strb.w	r2, [r3], #1
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    476a:	428b      	cmp	r3, r1
    476c:	d1fb      	bne.n	4766 <grid_port_reset_receiver+0x7e>
	}
	
	usart_async_enable(por->usart);
    476e:	6860      	ldr	r0, [r4, #4]
    4770:	4b07      	ldr	r3, [pc, #28]	; (4790 <grid_port_reset_receiver+0xa8>)
	
}
    4772:	b003      	add	sp, #12
    4774:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	usart_async_enable(por->usart);
    4778:	4718      	bx	r3
    477a:	bf00      	nop
    477c:	000107e1 	.word	0x000107e1
    4780:	00009841 	.word	0x00009841
    4784:	00009989 	.word	0x00009989
    4788:	000099bd 	.word	0x000099bd
    478c:	000093cd 	.word	0x000093cd
    4790:	000107b5 	.word	0x000107b5

00004794 <grid_buffer_init>:



uint8_t grid_buffer_init(struct grid_buffer* buf, uint16_t length){
	
	grid_buffer_error_count = 0;
    4794:	4a0f      	ldr	r2, [pc, #60]	; (47d4 <grid_buffer_init+0x40>)
    4796:	2300      	movs	r3, #0
uint8_t grid_buffer_init(struct grid_buffer* buf, uint16_t length){
    4798:	b510      	push	{r4, lr}
    479a:	3002      	adds	r0, #2
	grid_buffer_error_count = 0;
    479c:	7013      	strb	r3, [r2, #0]
	
	buf->buffer_length = length;
	
	buf->read_length   = 0;
    479e:	f8a0 33ee 	strh.w	r3, [r0, #1006]	; 0x3ee
	buf->buffer_length = length;
    47a2:	f820 1c02 	strh.w	r1, [r0, #-2]
	
	buf->read_start    = 0;
    47a6:	f8a0 33e8 	strh.w	r3, [r0, #1000]	; 0x3e8
	buf->read_stop     = 0;
    47aa:	f8a0 33ea 	strh.w	r3, [r0, #1002]	; 0x3ea
	buf->read_active   = 0;
    47ae:	f8a0 33ec 	strh.w	r3, [r0, #1004]	; 0x3ec
	
	buf->write_start    = 0;
    47b2:	f8a0 33f0 	strh.w	r3, [r0, #1008]	; 0x3f0
	buf->write_stop     = 0;
    47b6:	f8a0 33f2 	strh.w	r3, [r0, #1010]	; 0x3f2
	buf->write_active   = 0;
    47ba:	f8a0 33f4 	strh.w	r3, [r0, #1012]	; 0x3f4
	

	for (uint16_t i=0; i<buf->buffer_length; i++){
		buf->buffer_storage[i] = 0;
    47be:	461c      	mov	r4, r3
	for (uint16_t i=0; i<buf->buffer_length; i++){
    47c0:	b29a      	uxth	r2, r3
    47c2:	4291      	cmp	r1, r2
    47c4:	d801      	bhi.n	47ca <grid_buffer_init+0x36>
	}
	
	return 1;
	
}
    47c6:	2001      	movs	r0, #1
    47c8:	bd10      	pop	{r4, pc}
		buf->buffer_storage[i] = 0;
    47ca:	f800 4b01 	strb.w	r4, [r0], #1
	for (uint16_t i=0; i<buf->buffer_length; i++){
    47ce:	3301      	adds	r3, #1
    47d0:	e7f6      	b.n	47c0 <grid_buffer_init+0x2c>
    47d2:	bf00      	nop
    47d4:	2000c09c 	.word	0x2000c09c

000047d8 <grid_buffer_get_space>:

uint16_t grid_buffer_get_space(struct grid_buffer* buf){
	
	uint16_t space = 0;
		
	if (buf->read_start > buf->write_start){
    47d8:	f8b0 33ea 	ldrh.w	r3, [r0, #1002]	; 0x3ea
    47dc:	f8b0 23f2 	ldrh.w	r2, [r0, #1010]	; 0x3f2
    47e0:	4293      	cmp	r3, r2
		space = buf->read_start - buf->write_start;
	}
	else{
		space = buf->buffer_length - buf->write_start + buf->read_start;
    47e2:	bf9b      	ittet	ls
    47e4:	8800      	ldrhls	r0, [r0, #0]
    47e6:	18c0      	addls	r0, r0, r3
		space = buf->read_start - buf->write_start;
    47e8:	1a98      	subhi	r0, r3, r2
		space = buf->buffer_length - buf->write_start + buf->read_start;
    47ea:	1a80      	subls	r0, r0, r2
    47ec:	b280      	uxth	r0, r0
	}
	
	return space;
}
    47ee:	4770      	bx	lr

000047f0 <grid_buffer_write_init>:





uint16_t grid_buffer_write_init(struct grid_buffer* buf, uint16_t length){
    47f0:	b510      	push	{r4, lr}
	
	
	
	uint16_t space = grid_buffer_get_space(buf);
    47f2:	4b0c      	ldr	r3, [pc, #48]	; (4824 <grid_buffer_write_init+0x34>)
uint16_t grid_buffer_write_init(struct grid_buffer* buf, uint16_t length){
    47f4:	4604      	mov	r4, r0
	uint16_t space = grid_buffer_get_space(buf);
    47f6:	4798      	blx	r3

	
	if (space>length){
    47f8:	4288      	cmp	r0, r1
    47fa:	d90b      	bls.n	4814 <grid_buffer_write_init+0x24>
		
		buf->write_stop = (buf->write_start+length)%buf->buffer_length;
    47fc:	f8b4 33f2 	ldrh.w	r3, [r4, #1010]	; 0x3f2
    4800:	8820      	ldrh	r0, [r4, #0]
    4802:	440b      	add	r3, r1
    4804:	fbb3 f2f0 	udiv	r2, r3, r0
    4808:	fb00 3312 	mls	r3, r0, r2, r3
    480c:	f8a4 33f4 	strh.w	r3, [r4, #1012]	; 0x3f4
	}
	
	
	
	
}
    4810:	4608      	mov	r0, r1
    4812:	bd10      	pop	{r4, pc}
		grid_buffer_error_count++;
    4814:	4a04      	ldr	r2, [pc, #16]	; (4828 <grid_buffer_write_init+0x38>)
    4816:	7813      	ldrb	r3, [r2, #0]
    4818:	3301      	adds	r3, #1
    481a:	b2db      	uxtb	r3, r3
    481c:	7013      	strb	r3, [r2, #0]
		return 0; // failed
    481e:	2100      	movs	r1, #0
    4820:	e7f6      	b.n	4810 <grid_buffer_write_init+0x20>
    4822:	bf00      	nop
    4824:	000047d9 	.word	0x000047d9
    4828:	2000c09c 	.word	0x2000c09c

0000482c <grid_buffer_write_character>:

uint8_t grid_buffer_write_character(struct grid_buffer* buf, uint8_t character){
	

		
	buf->buffer_storage[buf->write_active] = character;
    482c:	f8b0 33f6 	ldrh.w	r3, [r0, #1014]	; 0x3f6
    4830:	18c2      	adds	r2, r0, r3
		
	buf->write_active++;
    4832:	3301      	adds	r3, #1
	buf->buffer_storage[buf->write_active] = character;
    4834:	7091      	strb	r1, [r2, #2]
	buf->write_active %= buf->buffer_length;
    4836:	8801      	ldrh	r1, [r0, #0]
    4838:	b29b      	uxth	r3, r3
    483a:	fbb3 f2f1 	udiv	r2, r3, r1
    483e:	fb01 3312 	mls	r3, r1, r2, r3
    4842:	f8a0 33f6 	strh.w	r3, [r0, #1014]	; 0x3f6
		
	return 1;
		

}
    4846:	2001      	movs	r0, #1
    4848:	4770      	bx	lr
	...

0000484c <grid_buffer_write_acknowledge>:

uint8_t grid_buffer_write_acknowledge(struct grid_buffer* buf){
	
	if (buf->write_active == buf->write_stop){
    484c:	f8b0 33f4 	ldrh.w	r3, [r0, #1012]	; 0x3f4
    4850:	f8b0 23f6 	ldrh.w	r2, [r0, #1014]	; 0x3f6
    4854:	4293      	cmp	r3, r2
		buf->write_start = buf->write_active;
		return 1;
	}
	else{
		
		grid_buffer_error_count++;
    4856:	bf17      	itett	ne
    4858:	4a05      	ldrne	r2, [pc, #20]	; (4870 <grid_buffer_write_acknowledge+0x24>)
		buf->write_start = buf->write_active;
    485a:	f8a0 33f2 	strheq.w	r3, [r0, #1010]	; 0x3f2
		grid_buffer_error_count++;
    485e:	7813      	ldrbne	r3, [r2, #0]
    4860:	3301      	addne	r3, #1
    4862:	bf17      	itett	ne
    4864:	b2db      	uxtbne	r3, r3
		return 1;
    4866:	2001      	moveq	r0, #1
		grid_buffer_error_count++;
    4868:	7013      	strbne	r3, [r2, #0]
    486a:	2000      	movne	r0, #0
		return 0;
	}
	
	
}
    486c:	4770      	bx	lr
    486e:	bf00      	nop
    4870:	2000c09c 	.word	0x2000c09c

00004874 <grid_port_receive_decode>:
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    4874:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4878:	ed2d 8b02 	vpush	{d8}
	uint8_t buffer[length];
    487c:	1dd3      	adds	r3, r2, #7
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    487e:	b08b      	sub	sp, #44	; 0x2c
    4880:	4690      	mov	r8, r2
	uint8_t buffer[length];
    4882:	08db      	lsrs	r3, r3, #3
    4884:	466a      	mov	r2, sp
    4886:	eba2 03c3 	sub.w	r3, r2, r3, lsl #3
	for (uint16_t i = 0; i<length; i++){
    488a:	2200      	movs	r2, #0
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    488c:	af02      	add	r7, sp, #8
	uint8_t buffer[length];
    488e:	469d      	mov	sp, r3
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    4890:	4604      	mov	r4, r0
    4892:	6a83      	ldr	r3, [r0, #40]	; 0x28
	uint8_t buffer[length];
    4894:	f10d 0908 	add.w	r9, sp, #8
		buffer[i] = por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE];
    4898:	f241 3088 	movw	r0, #5000	; 0x1388
    489c:	f241 35b4 	movw	r5, #5044	; 0x13b4
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE]=0;
    48a0:	4694      	mov	ip, r2
	for (uint16_t i = 0; i<length; i++){
    48a2:	b291      	uxth	r1, r2
    48a4:	4588      	cmp	r8, r1
    48a6:	f200 80e3 	bhi.w	4a70 <grid_port_receive_decode+0x1fc>
	for (uint16_t i = 0; i<length; i++){
    48aa:	2200      	movs	r2, #0
	message = &buffer[0];
    48ac:	464d      	mov	r5, r9
	for (uint16_t i = 0; i<length; i++){
    48ae:	f241 3088 	movw	r0, #5000	; 0x1388
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE] = 0;
    48b2:	f241 3cb4 	movw	ip, #5044	; 0x13b4
    48b6:	4696      	mov	lr, r2
	for (uint16_t i = 0; i<length; i++){
    48b8:	b291      	uxth	r1, r2
    48ba:	4588      	cmp	r8, r1
    48bc:	f200 80e5 	bhi.w	4a8a <grid_port_receive_decode+0x216>
	por->rx_double_buffer_read_start_index = (por->rx_double_buffer_read_start_index + length)%GRID_DOUBLE_BUFFER_RX_SIZE;
    48c0:	4443      	add	r3, r8
    48c2:	fbb3 f2f0 	udiv	r2, r3, r0
    48c6:	fb00 3312 	mls	r3, r0, r2, r3
	por->rx_double_buffer_seek_start_index =  por->rx_double_buffer_read_start_index;
    48ca:	e9c4 3309 	strd	r3, r3, [r4, #36]	; 0x24
	por->rx_double_buffer_status = 0;
    48ce:	2300      	movs	r3, #0
    48d0:	6223      	str	r3, [r4, #32]
			GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Frame Start Offset");
    48d2:	f8df a250 	ldr.w	sl, [pc, #592]	; 4b24 <grid_port_receive_decode+0x2b0>
    48d6:	f8df b250 	ldr.w	fp, [pc, #592]	; 4b28 <grid_port_receive_decode+0x2b4>
    48da:	4b88      	ldr	r3, [pc, #544]	; (4afc <grid_port_receive_decode+0x288>)
	for (uint16_t i = 1; i<length; i++){
    48dc:	2601      	movs	r6, #1
    48de:	45b0      	cmp	r8, r6
    48e0:	f200 80dd 	bhi.w	4a9e <grid_port_receive_decode+0x22a>
	if (message[0] == GRID_CONST_SOH && message[length-1] == GRID_CONST_LF){
    48e4:	782b      	ldrb	r3, [r5, #0]
    48e6:	2b01      	cmp	r3, #1
    48e8:	f040 80bc 	bne.w	4a64 <grid_port_receive_decode+0x1f0>
    48ec:	eb05 0308 	add.w	r3, r5, r8
    48f0:	f813 9c01 	ldrb.w	r9, [r3, #-1]
    48f4:	f1b9 0f0a 	cmp.w	r9, #10
    48f8:	f040 80b4 	bne.w	4a64 <grid_port_receive_decode+0x1f0>
		checksum_received = grid_msg_checksum_read(message, length);
    48fc:	4b80      	ldr	r3, [pc, #512]	; (4b00 <grid_port_receive_decode+0x28c>)
		checksum_calculated = grid_msg_calculate_checksum_of_packet_string(message, length);
    48fe:	4e81      	ldr	r6, [pc, #516]	; (4b04 <grid_port_receive_decode+0x290>)
		checksum_received = grid_msg_checksum_read(message, length);
    4900:	4641      	mov	r1, r8
    4902:	4628      	mov	r0, r5
    4904:	4798      	blx	r3
		checksum_calculated = grid_msg_calculate_checksum_of_packet_string(message, length);
    4906:	4641      	mov	r1, r8
		checksum_received = grid_msg_checksum_read(message, length);
    4908:	4682      	mov	sl, r0
		checksum_calculated = grid_msg_calculate_checksum_of_packet_string(message, length);
    490a:	4628      	mov	r0, r5
    490c:	47b0      	blx	r6
		if (checksum_calculated == checksum_received && error_flag == 0){
    490e:	4582      	cmp	sl, r0
    4910:	f040 81fc 	bne.w	4d0c <grid_port_receive_decode+0x498>
			if (message[1] == GRID_CONST_BRC){ // Broadcast message
    4914:	786b      	ldrb	r3, [r5, #1]
    4916:	2b0f      	cmp	r3, #15
    4918:	f040 810c 	bne.w	4b34 <grid_port_receive_decode+0x2c0>
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    491c:	f107 061f 	add.w	r6, r7, #31
				uint8_t error=0;
    4920:	f04f 0300 	mov.w	r3, #0
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    4924:	f8df b204 	ldr.w	fp, [pc, #516]	; 4b2c <grid_port_receive_decode+0x2b8>
				uint8_t error=0;
    4928:	77fb      	strb	r3, [r7, #31]
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    492a:	2202      	movs	r2, #2
    492c:	4633      	mov	r3, r6
    492e:	2104      	movs	r1, #4
    4930:	4628      	mov	r0, r5
    4932:	47d8      	blx	fp
				uint8_t received_age = grid_msg_get_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, &error);
    4934:	4649      	mov	r1, r9
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    4936:	6078      	str	r0, [r7, #4]
				uint8_t received_age = grid_msg_get_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, &error);
    4938:	4633      	mov	r3, r6
    493a:	2202      	movs	r2, #2
    493c:	4628      	mov	r0, r5
    493e:	47d8      	blx	fp
				int8_t received_dx  = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4940:	4633      	mov	r3, r6
				uint8_t received_age = grid_msg_get_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, &error);
    4942:	6038      	str	r0, [r7, #0]
				int8_t received_dx  = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4944:	2202      	movs	r2, #2
    4946:	2106      	movs	r1, #6
    4948:	4628      	mov	r0, r5
    494a:	47d8      	blx	fp
    494c:	b2c3      	uxtb	r3, r0
    494e:	617b      	str	r3, [r7, #20]
    4950:	f1a3 0a7f 	sub.w	sl, r3, #127	; 0x7f
				int8_t received_dy  = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4954:	2202      	movs	r2, #2
    4956:	4633      	mov	r3, r6
    4958:	2108      	movs	r1, #8
    495a:	4628      	mov	r0, r5
    495c:	47d8      	blx	fp
    495e:	b2c3      	uxtb	r3, r0
    4960:	613b      	str	r3, [r7, #16]
    4962:	f1a3 097f 	sub.w	r9, r3, #127	; 0x7f
				uint8_t received_rot = grid_msg_get_parameter(message, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, &error);
    4966:	2202      	movs	r2, #2
    4968:	4633      	mov	r3, r6
    496a:	210c      	movs	r1, #12
    496c:	4628      	mov	r0, r5
    496e:	47d8      	blx	fp
				uint8_t updated_rot = (received_rot + por->partner_fi)%4;
    4970:	f642 7330 	movw	r3, #12080	; 0x2f30
				int8_t received_dx  = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4974:	fa4f fa8a 	sxtb.w	sl, sl
				uint8_t updated_rot = (received_rot + por->partner_fi)%4;
    4978:	5ce3      	ldrb	r3, [r4, r3]
    497a:	4418      	add	r0, r3
    497c:	f000 0203 	and.w	r2, r0, #3
    4980:	ee08 2a10 	vmov	s16, r2
				int8_t received_dy  = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4984:	fa4f f989 	sxtb.w	r9, r9
				if (por->partner_fi == 0){ // 0 deg
    4988:	b143      	cbz	r3, 499c <grid_port_receive_decode+0x128>
				else if(por->partner_fi == 1){ // 90 deg
    498a:	2b01      	cmp	r3, #1
    498c:	f040 8098 	bne.w	4ac0 <grid_port_receive_decode+0x24c>
					rotated_dx  -= received_dy;
    4990:	693b      	ldr	r3, [r7, #16]
    4992:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
					rotated_dy  += received_dx;
    4996:	46d1      	mov	r9, sl
					rotated_dx  -= received_dy;
    4998:	fa4f fa83 	sxtb.w	sl, r3
				uint8_t updated_dx = rotated_dx + GRID_SYS_DEFAULT_POSITION + por->dx;
    499c:	f642 7349 	movw	r3, #12105	; 0x2f49
    49a0:	f897 b000 	ldrb.w	fp, [r7]
    49a4:	5ce3      	ldrb	r3, [r4, r3]
    49a6:	337f      	adds	r3, #127	; 0x7f
    49a8:	449a      	add	sl, r3
    49aa:	fa5f f38a 	uxtb.w	r3, sl
    49ae:	60fb      	str	r3, [r7, #12]
				uint8_t updated_dy = rotated_dy + GRID_SYS_DEFAULT_POSITION + por->dy;
    49b0:	f642 734a 	movw	r3, #12106	; 0x2f4a
    49b4:	f814 a003 	ldrb.w	sl, [r4, r3]
    49b8:	f10a 0a7f 	add.w	sl, sl, #127	; 0x7f
    49bc:	44d1      	add	r9, sl
    49be:	fa5f f389 	uxtb.w	r3, r9
    49c2:	60bb      	str	r3, [r7, #8]
				if (received_dx + GRID_SYS_DEFAULT_POSITION == 0 && received_dy + GRID_SYS_DEFAULT_POSITION == 0)
    49c4:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    49c8:	4313      	orrs	r3, r2
    49ca:	f897 a004 	ldrb.w	sl, [r7, #4]
    49ce:	d020      	beq.n	4a12 <grid_port_receive_decode+0x19e>
					grid_msg_set_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, updated_id, &error);
    49d0:	f8df 915c 	ldr.w	r9, [pc, #348]	; 4b30 <grid_port_receive_decode+0x2bc>
    49d4:	9600      	str	r6, [sp, #0]
    49d6:	4653      	mov	r3, sl
    49d8:	2202      	movs	r2, #2
    49da:	2104      	movs	r1, #4
    49dc:	4628      	mov	r0, r5
    49de:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, updated_dx, &error);
    49e0:	9600      	str	r6, [sp, #0]
    49e2:	68fb      	ldr	r3, [r7, #12]
    49e4:	2202      	movs	r2, #2
    49e6:	2106      	movs	r1, #6
    49e8:	4628      	mov	r0, r5
    49ea:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, updated_dy, &error);
    49ec:	9600      	str	r6, [sp, #0]
    49ee:	68bb      	ldr	r3, [r7, #8]
    49f0:	2202      	movs	r2, #2
    49f2:	2108      	movs	r1, #8
    49f4:	4628      	mov	r0, r5
    49f6:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, updated_age, &error);
    49f8:	465b      	mov	r3, fp
    49fa:	2202      	movs	r2, #2
    49fc:	210a      	movs	r1, #10
    49fe:	9600      	str	r6, [sp, #0]
    4a00:	4628      	mov	r0, r5
    4a02:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, updated_rot, &error);
    4a04:	ee18 3a10 	vmov	r3, s16
    4a08:	9600      	str	r6, [sp, #0]
    4a0a:	2202      	movs	r2, #2
    4a0c:	210c      	movs	r1, #12
    4a0e:	4628      	mov	r0, r5
    4a10:	47c8      	blx	r9
				uint32_t fingerprint = updated_id*256*256*256 + updated_dx*256*256 + updated_dy*256 + updated_age;
    4a12:	68fb      	ldr	r3, [r7, #12]
				if (0 == grid_msg_find_recent(&grid_sys_state, fingerprint)){
    4a14:	483c      	ldr	r0, [pc, #240]	; (4b08 <grid_port_receive_decode+0x294>)
				uint32_t fingerprint = updated_id*256*256*256 + updated_dx*256*256 + updated_dy*256 + updated_age;
    4a16:	eb03 2a0a 	add.w	sl, r3, sl, lsl #8
    4a1a:	68bb      	ldr	r3, [r7, #8]
    4a1c:	eb03 2a0a 	add.w	sl, r3, sl, lsl #8
    4a20:	eb0b 2a0a 	add.w	sl, fp, sl, lsl #8
				if (0 == grid_msg_find_recent(&grid_sys_state, fingerprint)){
    4a24:	4b39      	ldr	r3, [pc, #228]	; (4b0c <grid_port_receive_decode+0x298>)
    4a26:	4651      	mov	r1, sl
    4a28:	4798      	blx	r3
    4a2a:	b9d8      	cbnz	r0, 4a64 <grid_port_receive_decode+0x1f0>
					grid_msg_checksum_write(message, length, grid_msg_calculate_checksum_of_packet_string(message, length));
    4a2c:	4b35      	ldr	r3, [pc, #212]	; (4b04 <grid_port_receive_decode+0x290>)
    4a2e:	4641      	mov	r1, r8
    4a30:	4628      	mov	r0, r5
    4a32:	4798      	blx	r3
					if (grid_buffer_write_init(&por->rx_buffer, length)){
    4a34:	f504 542c 	add.w	r4, r4, #11008	; 0x2b00
					grid_msg_checksum_write(message, length, grid_msg_calculate_checksum_of_packet_string(message, length));
    4a38:	4b35      	ldr	r3, [pc, #212]	; (4b10 <grid_port_receive_decode+0x29c>)
    4a3a:	4602      	mov	r2, r0
    4a3c:	4641      	mov	r1, r8
    4a3e:	4628      	mov	r0, r5
					if (grid_buffer_write_init(&por->rx_buffer, length)){
    4a40:	3434      	adds	r4, #52	; 0x34
					grid_msg_checksum_write(message, length, grid_msg_calculate_checksum_of_packet_string(message, length));
    4a42:	4798      	blx	r3
					if (grid_buffer_write_init(&por->rx_buffer, length)){
    4a44:	4b33      	ldr	r3, [pc, #204]	; (4b14 <grid_port_receive_decode+0x2a0>)
    4a46:	4641      	mov	r1, r8
    4a48:	4620      	mov	r0, r4
    4a4a:	4798      	blx	r3
    4a4c:	b150      	cbz	r0, 4a64 <grid_port_receive_decode+0x1f0>
							grid_buffer_write_character(&por->rx_buffer, message[i]);
    4a4e:	4e32      	ldr	r6, [pc, #200]	; (4b18 <grid_port_receive_decode+0x2a4>)
    4a50:	44a8      	add	r8, r5
						for (uint16_t i=0; i<length; i++){
    4a52:	45a8      	cmp	r8, r5
    4a54:	d14d      	bne.n	4af2 <grid_port_receive_decode+0x27e>
						grid_buffer_write_acknowledge(&por->rx_buffer);
    4a56:	4b31      	ldr	r3, [pc, #196]	; (4b1c <grid_port_receive_decode+0x2a8>)
    4a58:	4620      	mov	r0, r4
    4a5a:	4798      	blx	r3
						grid_msg_push_recent(&grid_sys_state, fingerprint);
    4a5c:	482a      	ldr	r0, [pc, #168]	; (4b08 <grid_port_receive_decode+0x294>)
    4a5e:	4b30      	ldr	r3, [pc, #192]	; (4b20 <grid_port_receive_decode+0x2ac>)
    4a60:	4651      	mov	r1, sl
    4a62:	4798      	blx	r3
}
    4a64:	3724      	adds	r7, #36	; 0x24
    4a66:	46bd      	mov	sp, r7
    4a68:	ecbd 8b02 	vpop	{d8}
    4a6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		buffer[i] = por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE];
    4a70:	18d6      	adds	r6, r2, r3
    4a72:	fbb6 f1f0 	udiv	r1, r6, r0
    4a76:	fb00 6111 	mls	r1, r0, r1, r6
    4a7a:	4421      	add	r1, r4
    4a7c:	5d4e      	ldrb	r6, [r1, r5]
    4a7e:	f809 6002 	strb.w	r6, [r9, r2]
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE]=0;
    4a82:	f801 c005 	strb.w	ip, [r1, r5]
	for (uint16_t i = 0; i<length; i++){
    4a86:	3201      	adds	r2, #1
    4a88:	e70b      	b.n	48a2 <grid_port_receive_decode+0x2e>
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE] = 0;
    4a8a:	18d6      	adds	r6, r2, r3
    4a8c:	fbb6 f1f0 	udiv	r1, r6, r0
    4a90:	fb00 6111 	mls	r1, r0, r1, r6
    4a94:	4421      	add	r1, r4
    4a96:	3201      	adds	r2, #1
    4a98:	f801 e00c 	strb.w	lr, [r1, ip]
	for (uint16_t i = 0; i<length; i++){
    4a9c:	e70c      	b.n	48b8 <grid_port_receive_decode+0x44>
		if (buffer[i] == GRID_CONST_SOH){
    4a9e:	f819 2006 	ldrb.w	r2, [r9, r6]
    4aa2:	2a01      	cmp	r2, #1
    4aa4:	d109      	bne.n	4aba <grid_port_receive_decode+0x246>
			GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Frame Start Offset");
    4aa6:	4651      	mov	r1, sl
    4aa8:	4658      	mov	r0, fp
    4aaa:	4798      	blx	r3
			length -= i;
    4aac:	eba8 0806 	sub.w	r8, r8, r6
			GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Frame Start Offset");
    4ab0:	4b12      	ldr	r3, [pc, #72]	; (4afc <grid_port_receive_decode+0x288>)
			length -= i;
    4ab2:	fa1f f888 	uxth.w	r8, r8
			message = &buffer[i];
    4ab6:	eb09 0506 	add.w	r5, r9, r6
	for (uint16_t i = 1; i<length; i++){
    4aba:	3601      	adds	r6, #1
    4abc:	b2b6      	uxth	r6, r6
    4abe:	e70e      	b.n	48de <grid_port_receive_decode+0x6a>
				else if(por->partner_fi == 2){ // 180 deg
    4ac0:	2b02      	cmp	r3, #2
    4ac2:	d10a      	bne.n	4ada <grid_port_receive_decode+0x266>
					rotated_dx  -= received_dx;
    4ac4:	697b      	ldr	r3, [r7, #20]
    4ac6:	f1c3 0a7f 	rsb	sl, r3, #127	; 0x7f
					rotated_dy  -= received_dy;
    4aca:	693b      	ldr	r3, [r7, #16]
					rotated_dx  -= received_dx;
    4acc:	fa4f fa8a 	sxtb.w	sl, sl
					rotated_dy  -= received_dy;
    4ad0:	f1c3 097f 	rsb	r9, r3, #127	; 0x7f
					rotated_dy  -= received_dx;
    4ad4:	fa4f f989 	sxtb.w	r9, r9
    4ad8:	e760      	b.n	499c <grid_port_receive_decode+0x128>
				else if(por->partner_fi == 3){ // 270 deg
    4ada:	2b03      	cmp	r3, #3
    4adc:	d105      	bne.n	4aea <grid_port_receive_decode+0x276>
					rotated_dy  -= received_dx;
    4ade:	697b      	ldr	r3, [r7, #20]
    4ae0:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
					rotated_dx  += received_dy;
    4ae4:	46ca      	mov	sl, r9
					rotated_dy  -= received_dx;
    4ae6:	4699      	mov	r9, r3
    4ae8:	e7f4      	b.n	4ad4 <grid_port_receive_decode+0x260>
				int8_t rotated_dy = 0;
    4aea:	f04f 0900 	mov.w	r9, #0
				int8_t rotated_dx = 0;
    4aee:	46ca      	mov	sl, r9
    4af0:	e754      	b.n	499c <grid_port_receive_decode+0x128>
							grid_buffer_write_character(&por->rx_buffer, message[i]);
    4af2:	f815 1b01 	ldrb.w	r1, [r5], #1
    4af6:	4620      	mov	r0, r4
    4af8:	47b0      	blx	r6
						for (uint16_t i=0; i<length; i++){
    4afa:	e7aa      	b.n	4a52 <grid_port_receive_decode+0x1de>
    4afc:	00014451 	.word	0x00014451
    4b00:	000099a1 	.word	0x000099a1
    4b04:	00009989 	.word	0x00009989
    4b08:	2000f008 	.word	0x2000f008
    4b0c:	000099f9 	.word	0x000099f9
    4b10:	000099bd 	.word	0x000099bd
    4b14:	000047f1 	.word	0x000047f1
    4b18:	0000482d 	.word	0x0000482d
    4b1c:	0000484d 	.word	0x0000484d
    4b20:	00009a13 	.word	0x00009a13
    4b24:	00015914 	.word	0x00015914
    4b28:	00015927 	.word	0x00015927
    4b2c:	000099cd 	.word	0x000099cd
    4b30:	000099e5 	.word	0x000099e5
			else if (message[1] == GRID_CONST_DCT){ // Direct Message
    4b34:	2b0e      	cmp	r3, #14
    4b36:	f040 80e5 	bne.w	4d04 <grid_port_receive_decode+0x490>
				if (message[2] == GRID_CONST_ACK){
    4b3a:	78ab      	ldrb	r3, [r5, #2]
    4b3c:	2b07      	cmp	r3, #7
    4b3e:	d191      	bne.n	4a64 <grid_port_receive_decode+0x1f0>
					uint8_t local_token_received = grid_sys_read_hex_string_value(&message[8], 2, error_flag);
    4b40:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 4d20 <grid_port_receive_decode+0x4ac>
    4b44:	2200      	movs	r2, #0
    4b46:	2102      	movs	r1, #2
    4b48:	f105 0008 	add.w	r0, r5, #8
    4b4c:	47c8      	blx	r9
					uint8_t partner_token_received = grid_sys_read_hex_string_value(&message[6], 2, error_flag);
    4b4e:	2200      	movs	r2, #0
					uint8_t local_token_received = grid_sys_read_hex_string_value(&message[8], 2, error_flag);
    4b50:	fa5f fa80 	uxtb.w	sl, r0
					uint8_t partner_token_received = grid_sys_read_hex_string_value(&message[6], 2, error_flag);
    4b54:	2102      	movs	r1, #2
    4b56:	1da8      	adds	r0, r5, #6
    4b58:	47c8      	blx	r9
					if (por->partner_status == 0){
    4b5a:	f642 724b 	movw	r2, #12107	; 0x2f4b
					uint8_t partner_token_received = grid_sys_read_hex_string_value(&message[6], 2, error_flag);
    4b5e:	fa5f fb80 	uxtb.w	fp, r0
					if (por->partner_status == 0){
    4b62:	5ca2      	ldrb	r2, [r4, r2]
    4b64:	2a00      	cmp	r2, #0
    4b66:	d172      	bne.n	4c4e <grid_port_receive_decode+0x3da>
						if (por->ping_local_token == 255){ // I have no clue
    4b68:	f642 7931 	movw	r9, #12081	; 0x2f31
    4b6c:	f814 2009 	ldrb.w	r2, [r4, r9]
    4b70:	2aff      	cmp	r2, #255	; 0xff
    4b72:	d11b      	bne.n	4bac <grid_port_receive_decode+0x338>
							por->ping_local_token  = grid_sys_rtc_get_time(&grid_sys_state)%128;
    4b74:	4a66      	ldr	r2, [pc, #408]	; (4d10 <grid_port_receive_decode+0x49c>)
    4b76:	4867      	ldr	r0, [pc, #412]	; (4d14 <grid_port_receive_decode+0x4a0>)
    4b78:	4790      	blx	r2
    4b7a:	f000 027f 	and.w	r2, r0, #127	; 0x7f
							grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4b7e:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
							por->ping_local_token  = grid_sys_rtc_get_time(&grid_sys_state)%128;
    4b82:	f804 2009 	strb.w	r2, [r4, r9]
							grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4b86:	4b64      	ldr	r3, [pc, #400]	; (4d18 <grid_port_receive_decode+0x4a4>)
    4b88:	2102      	movs	r1, #2
    4b8a:	3039      	adds	r0, #57	; 0x39
    4b8c:	4798      	blx	r3
							grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4b8e:	f504 593c 	add.w	r9, r4, #12032	; 0x2f00
    4b92:	f642 7247 	movw	r2, #12103	; 0x2f47
    4b96:	f109 0933 	add.w	r9, r9, #51	; 0x33
    4b9a:	5ca1      	ldrb	r1, [r4, r2]
    4b9c:	6179      	str	r1, [r7, #20]
    4b9e:	4648      	mov	r0, r9
    4ba0:	47b0      	blx	r6
    4ba2:	6979      	ldr	r1, [r7, #20]
    4ba4:	4b5d      	ldr	r3, [pc, #372]	; (4d1c <grid_port_receive_decode+0x4a8>)
    4ba6:	4602      	mov	r2, r0
    4ba8:	4648      	mov	r0, r9
    4baa:	4798      	blx	r3
						if (partner_token_received != por->ping_partner_token){
    4bac:	f642 7232 	movw	r2, #12082	; 0x2f32
    4bb0:	5ca1      	ldrb	r1, [r4, r2]
    4bb2:	4559      	cmp	r1, fp
    4bb4:	d017      	beq.n	4be6 <grid_port_receive_decode+0x372>
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, partner_token_received);
    4bb6:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
							por->ping_partner_token = partner_token_received;							
    4bba:	f804 b002 	strb.w	fp, [r4, r2]
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, partner_token_received);
    4bbe:	4b56      	ldr	r3, [pc, #344]	; (4d18 <grid_port_receive_decode+0x4a4>)
    4bc0:	465a      	mov	r2, fp
    4bc2:	2102      	movs	r1, #2
    4bc4:	303b      	adds	r0, #59	; 0x3b
    4bc6:	4798      	blx	r3
							grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4bc8:	f504 593c 	add.w	r9, r4, #12032	; 0x2f00
    4bcc:	f642 7347 	movw	r3, #12103	; 0x2f47
    4bd0:	f109 0933 	add.w	r9, r9, #51	; 0x33
    4bd4:	5ce1      	ldrb	r1, [r4, r3]
    4bd6:	6179      	str	r1, [r7, #20]
    4bd8:	4648      	mov	r0, r9
    4bda:	47b0      	blx	r6
    4bdc:	6979      	ldr	r1, [r7, #20]
    4bde:	4b4f      	ldr	r3, [pc, #316]	; (4d1c <grid_port_receive_decode+0x4a8>)
    4be0:	4602      	mov	r2, r0
    4be2:	4648      	mov	r0, r9
    4be4:	4798      	blx	r3
						if (por->ping_local_token != local_token_received){
    4be6:	f642 7331 	movw	r3, #12081	; 0x2f31
    4bea:	5ce3      	ldrb	r3, [r4, r3]
    4bec:	4553      	cmp	r3, sl
    4bee:	d129      	bne.n	4c44 <grid_port_receive_decode+0x3d0>
							por->partner_fi = (message[3] - por->direction + 6)%4;
    4bf0:	7a62      	ldrb	r2, [r4, #9]
    4bf2:	78eb      	ldrb	r3, [r5, #3]
    4bf4:	1a9b      	subs	r3, r3, r2
    4bf6:	3306      	adds	r3, #6
    4bf8:	425a      	negs	r2, r3
    4bfa:	f002 0203 	and.w	r2, r2, #3
    4bfe:	f003 0303 	and.w	r3, r3, #3
    4c02:	bf58      	it	pl
    4c04:	4253      	negpl	r3, r2
    4c06:	f642 7230 	movw	r2, #12080	; 0x2f30
							por->partner_hwcfg = grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c0a:	f1a8 000a 	sub.w	r0, r8, #10
							por->partner_fi = (message[3] - por->direction + 6)%4;
    4c0e:	54a3      	strb	r3, [r4, r2]
							por->partner_hwcfg = grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c10:	2102      	movs	r1, #2
    4c12:	4b43      	ldr	r3, [pc, #268]	; (4d20 <grid_port_receive_decode+0x4ac>)
    4c14:	2200      	movs	r2, #0
    4c16:	4428      	add	r0, r5
    4c18:	4798      	blx	r3
    4c1a:	f642 732c 	movw	r3, #12076	; 0x2f2c
							por->partner_status = 1;
    4c1e:	2201      	movs	r2, #1
							por->partner_hwcfg = grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c20:	50e0      	str	r0, [r4, r3]
							por->partner_status = 1;
    4c22:	f642 734b 	movw	r3, #12107	; 0x2f4b
							GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Connect");
    4c26:	493f      	ldr	r1, [pc, #252]	; (4d24 <grid_port_receive_decode+0x4b0>)
							por->partner_status = 1;
    4c28:	54e2      	strb	r2, [r4, r3]
							GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Connect");
    4c2a:	483f      	ldr	r0, [pc, #252]	; (4d28 <grid_port_receive_decode+0x4b4>)
    4c2c:	4b3f      	ldr	r3, [pc, #252]	; (4d2c <grid_port_receive_decode+0x4b8>)
							grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 500); // GREEN
    4c2e:	4d40      	ldr	r5, [pc, #256]	; (4d30 <grid_port_receive_decode+0x4bc>)
							GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Connect");
    4c30:	4798      	blx	r3
							grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 500); // GREEN
    4c32:	2300      	movs	r3, #0
    4c34:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    4c38:	e9cd 3200 	strd	r3, r2, [sp]
    4c3c:	4835      	ldr	r0, [pc, #212]	; (4d14 <grid_port_receive_decode+0x4a0>)
    4c3e:	22ff      	movs	r2, #255	; 0xff
    4c40:	4619      	mov	r1, r3
    4c42:	47a8      	blx	r5
						por->ping_flag = 1;
    4c44:	f642 7348 	movw	r3, #12104	; 0x2f48
    4c48:	2201      	movs	r2, #1
    4c4a:	54e2      	strb	r2, [r4, r3]
    4c4c:	e70a      	b.n	4a64 <grid_port_receive_decode+0x1f0>
						validator &= por->partner_fi == (message[3] - por->direction + 6)%4;
    4c4e:	7a61      	ldrb	r1, [r4, #9]
    4c50:	78ea      	ldrb	r2, [r5, #3]
    4c52:	1a52      	subs	r2, r2, r1
    4c54:	3206      	adds	r2, #6
    4c56:	4251      	negs	r1, r2
						validator &= local_token_received == por->ping_local_token;
    4c58:	f642 7031 	movw	r0, #12081	; 0x2f31
						validator &= partner_token_received == por->ping_partner_token;
    4c5c:	f642 7c32 	movw	ip, #12082	; 0x2f32
						validator &= por->partner_fi == (message[3] - por->direction + 6)%4;
    4c60:	f001 0103 	and.w	r1, r1, #3
						validator &= local_token_received == por->ping_local_token;
    4c64:	5c20      	ldrb	r0, [r4, r0]
						validator &= partner_token_received == por->ping_partner_token;
    4c66:	f814 c00c 	ldrb.w	ip, [r4, ip]
						validator &= por->partner_fi == (message[3] - por->direction + 6)%4;
    4c6a:	f002 0203 	and.w	r2, r2, #3
    4c6e:	bf58      	it	pl
    4c70:	424a      	negpl	r2, r1
    4c72:	f642 7130 	movw	r1, #12080	; 0x2f30
    4c76:	4550      	cmp	r0, sl
    4c78:	bf08      	it	eq
    4c7a:	45dc      	cmpeq	ip, fp
    4c7c:	5c61      	ldrb	r1, [r4, r1]
    4c7e:	bf0c      	ite	eq
    4c80:	f04f 0a01 	moveq.w	sl, #1
    4c84:	f04f 0a00 	movne.w	sl, #0
						validator &= por->partner_hwcfg == grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c88:	f642 732c 	movw	r3, #12076	; 0x2f2c
    4c8c:	f1a8 000a 	sub.w	r0, r8, #10
    4c90:	428a      	cmp	r2, r1
    4c92:	bf14      	ite	ne
    4c94:	f04f 0a00 	movne.w	sl, #0
    4c98:	f00a 0a01 	andeq.w	sl, sl, #1
    4c9c:	4428      	add	r0, r5
    4c9e:	2200      	movs	r2, #0
    4ca0:	2102      	movs	r1, #2
    4ca2:	f854 b003 	ldr.w	fp, [r4, r3]
    4ca6:	47c8      	blx	r9
						if (validator == 1){
    4ca8:	4558      	cmp	r0, fp
    4caa:	d103      	bne.n	4cb4 <grid_port_receive_decode+0x440>
    4cac:	f1ba 0f00 	cmp.w	sl, #0
    4cb0:	f47f aed8 	bne.w	4a64 <grid_port_receive_decode+0x1f0>
							por->partner_status = 0;
    4cb4:	f642 734b 	movw	r3, #12107	; 0x2f4b
    4cb8:	2200      	movs	r2, #0
    4cba:	54e2      	strb	r2, [r4, r3]
							por->ping_local_token = 255;
    4cbc:	f642 7831 	movw	r8, #12081	; 0x2f31
							por->ping_partner_token = 255;
    4cc0:	f642 7332 	movw	r3, #12082	; 0x2f32
    4cc4:	22ff      	movs	r2, #255	; 0xff
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4cc6:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
							por->ping_partner_token = 255;
    4cca:	54e2      	strb	r2, [r4, r3]
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4ccc:	4d12      	ldr	r5, [pc, #72]	; (4d18 <grid_port_receive_decode+0x4a4>)
							por->ping_local_token = 255;
    4cce:	f804 2008 	strb.w	r2, [r4, r8]
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4cd2:	2102      	movs	r1, #2
    4cd4:	303b      	adds	r0, #59	; 0x3b
    4cd6:	47a8      	blx	r5
							grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4cd8:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
    4cdc:	f814 2008 	ldrb.w	r2, [r4, r8]
    4ce0:	2102      	movs	r1, #2
    4ce2:	3039      	adds	r0, #57	; 0x39
    4ce4:	47a8      	blx	r5
							grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4ce6:	f642 7347 	movw	r3, #12103	; 0x2f47
    4cea:	f504 553c 	add.w	r5, r4, #12032	; 0x2f00
    4cee:	3533      	adds	r5, #51	; 0x33
    4cf0:	5ce1      	ldrb	r1, [r4, r3]
    4cf2:	6179      	str	r1, [r7, #20]
    4cf4:	4628      	mov	r0, r5
    4cf6:	47b0      	blx	r6
    4cf8:	6979      	ldr	r1, [r7, #20]
    4cfa:	4b08      	ldr	r3, [pc, #32]	; (4d1c <grid_port_receive_decode+0x4a8>)
    4cfc:	4602      	mov	r2, r0
    4cfe:	4628      	mov	r0, r5
    4d00:	4798      	blx	r3
    4d02:	e6af      	b.n	4a64 <grid_port_receive_decode+0x1f0>
				printf("{\"type\": \"WARNING\", \"data\": [\"Unknow Message Type\"]}\r\n");
    4d04:	480b      	ldr	r0, [pc, #44]	; (4d34 <grid_port_receive_decode+0x4c0>)
			printf("{\"type\": \"WARNING\", \"data\": [\"Invalid Checksum\"]}\r\n");
    4d06:	4b0c      	ldr	r3, [pc, #48]	; (4d38 <grid_port_receive_decode+0x4c4>)
    4d08:	4798      	blx	r3
	return;
    4d0a:	e6ab      	b.n	4a64 <grid_port_receive_decode+0x1f0>
			printf("{\"type\": \"WARNING\", \"data\": [\"Invalid Checksum\"]}\r\n");
    4d0c:	480b      	ldr	r0, [pc, #44]	; (4d3c <grid_port_receive_decode+0x4c8>)
    4d0e:	e7fa      	b.n	4d06 <grid_port_receive_decode+0x492>
    4d10:	00009761 	.word	0x00009761
    4d14:	2000f008 	.word	0x2000f008
    4d18:	00009841 	.word	0x00009841
    4d1c:	000099bd 	.word	0x000099bd
    4d20:	00009819 	.word	0x00009819
    4d24:	0001594c 	.word	0x0001594c
    4d28:	00015927 	.word	0x00015927
    4d2c:	00014451 	.word	0x00014451
    4d30:	000097cb 	.word	0x000097cb
    4d34:	00015954 	.word	0x00015954
    4d38:	0001455d 	.word	0x0001455d
    4d3c:	0001598a 	.word	0x0001598a

00004d40 <grid_port_receive_task>:
void grid_port_receive_task(struct grid_port* por){
    4d40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (por->usart_error_flag == 1){
    4d42:	7e03      	ldrb	r3, [r0, #24]
    4d44:	2b01      	cmp	r3, #1
void grid_port_receive_task(struct grid_port* por){
    4d46:	4604      	mov	r4, r0
	if (por->usart_error_flag == 1){
    4d48:	d10d      	bne.n	4d66 <grid_port_receive_task+0x26>
		por->usart_error_flag = 0;
    4d4a:	2500      	movs	r5, #0
    4d4c:	7605      	strb	r5, [r0, #24]
		grid_port_reset_receiver(por);
    4d4e:	4b53      	ldr	r3, [pc, #332]	; (4e9c <grid_port_receive_task+0x15c>)
    4d50:	4798      	blx	r3
		grid_sys_alert_set_alert(&grid_sys_state, 255, 255, 255, 0, 500); // White triangle
    4d52:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    4d56:	e9cd 5300 	strd	r5, r3, [sp]
    4d5a:	23ff      	movs	r3, #255	; 0xff
    4d5c:	4850      	ldr	r0, [pc, #320]	; (4ea0 <grid_port_receive_task+0x160>)
    4d5e:	4d51      	ldr	r5, [pc, #324]	; (4ea4 <grid_port_receive_task+0x164>)
    4d60:	461a      	mov	r2, r3
    4d62:	4619      	mov	r1, r3
    4d64:	47a8      	blx	r5
	if	(por->rx_double_buffer_status == 0){
    4d66:	6a25      	ldr	r5, [r4, #32]
    4d68:	bb7d      	cbnz	r5, 4dca <grid_port_receive_task+0x8a>
		if (por->usart!=NULL){ // His is GRID usart port
    4d6a:	6863      	ldr	r3, [r4, #4]
    4d6c:	b1cb      	cbz	r3, 4da2 <grid_port_receive_task+0x62>
			if (por->rx_double_buffer_timeout > 1000){
    4d6e:	69e3      	ldr	r3, [r4, #28]
    4d70:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    4d74:	d93e      	bls.n	4df4 <grid_port_receive_task+0xb4>
				if (por->partner_status == 1){
    4d76:	f642 734b 	movw	r3, #12107	; 0x2f4b
    4d7a:	5ce3      	ldrb	r3, [r4, r3]
    4d7c:	2b01      	cmp	r3, #1
    4d7e:	d12c      	bne.n	4dda <grid_port_receive_task+0x9a>
					GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Timeout Disconnect & Reset Receiver");
    4d80:	4949      	ldr	r1, [pc, #292]	; (4ea8 <grid_port_receive_task+0x168>)
    4d82:	4b4a      	ldr	r3, [pc, #296]	; (4eac <grid_port_receive_task+0x16c>)
    4d84:	484a      	ldr	r0, [pc, #296]	; (4eb0 <grid_port_receive_task+0x170>)
    4d86:	4798      	blx	r3
					grid_port_reset_receiver(por);
    4d88:	4b44      	ldr	r3, [pc, #272]	; (4e9c <grid_port_receive_task+0x15c>)
    4d8a:	4620      	mov	r0, r4
    4d8c:	4798      	blx	r3
					grid_sys_alert_set_alert(&grid_sys_state, 255, 255, 255, 0, 500);
    4d8e:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    4d92:	e9cd 5300 	strd	r5, r3, [sp]
    4d96:	23ff      	movs	r3, #255	; 0xff
    4d98:	4841      	ldr	r0, [pc, #260]	; (4ea0 <grid_port_receive_task+0x160>)
    4d9a:	4d42      	ldr	r5, [pc, #264]	; (4ea4 <grid_port_receive_task+0x164>)
    4d9c:	461a      	mov	r2, r3
    4d9e:	4619      	mov	r1, r3
    4da0:	47a8      	blx	r5
			if (por->rx_double_buffer_seek_start_index == GRID_DOUBLE_BUFFER_RX_SIZE-1 && por->rx_double_buffer_read_start_index == 0)
    4da2:	f241 3687 	movw	r6, #4999	; 0x1387
void grid_port_receive_task(struct grid_port* por){
    4da6:	f44f 71f5 	mov.w	r1, #490	; 0x1ea
			if (por->rx_double_buffer[por->rx_double_buffer_seek_start_index] == 10){ // \n
    4daa:	f241 30b4 	movw	r0, #5044	; 0x13b4
    4dae:	46b4      	mov	ip, r6
			if (por->rx_double_buffer[(por->rx_double_buffer_read_start_index + GRID_DOUBLE_BUFFER_RX_SIZE -1)%GRID_DOUBLE_BUFFER_RX_SIZE] !=0)
    4db0:	f241 3788 	movw	r7, #5000	; 0x1388
			if (por->rx_double_buffer_seek_start_index < GRID_DOUBLE_BUFFER_RX_SIZE-1){
    4db4:	f241 3e86 	movw	lr, #4998	; 0x1386
			if (por->rx_double_buffer[por->rx_double_buffer_seek_start_index] == 10){ // \n
    4db8:	6a62      	ldr	r2, [r4, #36]	; 0x24
    4dba:	18a3      	adds	r3, r4, r2
    4dbc:	5c1b      	ldrb	r3, [r3, r0]
    4dbe:	2b0a      	cmp	r3, #10
    4dc0:	d11b      	bne.n	4dfa <grid_port_receive_task+0xba>
				por->rx_double_buffer_timeout = 0;
    4dc2:	2300      	movs	r3, #0
    4dc4:	2501      	movs	r5, #1
    4dc6:	e9c4 3507 	strd	r3, r5, [r4, #28]
	if (por->rx_double_buffer_read_start_index < por->rx_double_buffer_seek_start_index){
    4dca:	e9d4 2109 	ldrd	r2, r1, [r4, #36]	; 0x24
    4dce:	4291      	cmp	r1, r2
    4dd0:	d359      	bcc.n	4e86 <grid_port_receive_task+0x146>
		length = GRID_DOUBLE_BUFFER_RX_SIZE + por->rx_double_buffer_seek_start_index - por->rx_double_buffer_read_start_index + 1;
    4dd2:	f502 529c 	add.w	r2, r2, #4992	; 0x1380
    4dd6:	3209      	adds	r2, #9
    4dd8:	e056      	b.n	4e88 <grid_port_receive_task+0x148>
					if (por->rx_double_buffer_read_start_index == 0 && por->rx_double_buffer_seek_start_index == 0){
    4dda:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4ddc:	b913      	cbnz	r3, 4de4 <grid_port_receive_task+0xa4>
    4dde:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4de0:	2b00      	cmp	r3, #0
    4de2:	d0de      	beq.n	4da2 <grid_port_receive_task+0x62>
						GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Timeout & Reset Receiver");
    4de4:	4933      	ldr	r1, [pc, #204]	; (4eb4 <grid_port_receive_task+0x174>)
    4de6:	4b31      	ldr	r3, [pc, #196]	; (4eac <grid_port_receive_task+0x16c>)
    4de8:	4831      	ldr	r0, [pc, #196]	; (4eb0 <grid_port_receive_task+0x170>)
    4dea:	4798      	blx	r3
						grid_port_reset_receiver(por);
    4dec:	4b2b      	ldr	r3, [pc, #172]	; (4e9c <grid_port_receive_task+0x15c>)
    4dee:	4620      	mov	r0, r4
    4df0:	4798      	blx	r3
    4df2:	e7d6      	b.n	4da2 <grid_port_receive_task+0x62>
				por->rx_double_buffer_timeout++;
    4df4:	3301      	adds	r3, #1
    4df6:	61e3      	str	r3, [r4, #28]
    4df8:	e7d3      	b.n	4da2 <grid_port_receive_task+0x62>
			else if (por->rx_double_buffer[por->rx_double_buffer_seek_start_index] == 0){
    4dfa:	b923      	cbnz	r3, 4e06 <grid_port_receive_task+0xc6>
	if (por->rx_double_buffer_status == 0){
    4dfc:	6a23      	ldr	r3, [r4, #32]
    4dfe:	2b00      	cmp	r3, #0
    4e00:	d1e3      	bne.n	4dca <grid_port_receive_task+0x8a>
}
    4e02:	b003      	add	sp, #12
    4e04:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (por->rx_double_buffer_seek_start_index == por->rx_double_buffer_read_start_index-1)
    4e06:	6aa5      	ldr	r5, [r4, #40]	; 0x28
    4e08:	1e6b      	subs	r3, r5, #1
    4e0a:	429a      	cmp	r2, r3
    4e0c:	d10d      	bne.n	4e2a <grid_port_receive_task+0xea>
				grid_port_reset_receiver(por);	
    4e0e:	4b23      	ldr	r3, [pc, #140]	; (4e9c <grid_port_receive_task+0x15c>)
    4e10:	4620      	mov	r0, r4
    4e12:	4798      	blx	r3
				grid_sys_alert_set_alert(&grid_sys_state, 255, 0, 0, 2, 200); // RED
    4e14:	2302      	movs	r3, #2
    4e16:	20c8      	movs	r0, #200	; 0xc8
    4e18:	e9cd 3000 	strd	r3, r0, [sp]
    4e1c:	2300      	movs	r3, #0
    4e1e:	461a      	mov	r2, r3
    4e20:	21ff      	movs	r1, #255	; 0xff
				grid_sys_alert_set_alert(&grid_sys_state, 0, 0, 255, 2, 200); // RED
    4e22:	481f      	ldr	r0, [pc, #124]	; (4ea0 <grid_port_receive_task+0x160>)
    4e24:	4c1f      	ldr	r4, [pc, #124]	; (4ea4 <grid_port_receive_task+0x164>)
    4e26:	47a0      	blx	r4
				return;
    4e28:	e7eb      	b.n	4e02 <grid_port_receive_task+0xc2>
			if (por->rx_double_buffer_seek_start_index == GRID_DOUBLE_BUFFER_RX_SIZE-1 && por->rx_double_buffer_read_start_index == 0)
    4e2a:	42b2      	cmp	r2, r6
    4e2c:	d10b      	bne.n	4e46 <grid_port_receive_task+0x106>
    4e2e:	b955      	cbnz	r5, 4e46 <grid_port_receive_task+0x106>
				grid_port_reset_receiver(por);
    4e30:	4b1a      	ldr	r3, [pc, #104]	; (4e9c <grid_port_receive_task+0x15c>)
    4e32:	4620      	mov	r0, r4
    4e34:	4798      	blx	r3
				grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 2, 200); // RED
    4e36:	2302      	movs	r3, #2
    4e38:	21c8      	movs	r1, #200	; 0xc8
    4e3a:	e9cd 3100 	strd	r3, r1, [sp]
    4e3e:	22ff      	movs	r2, #255	; 0xff
    4e40:	462b      	mov	r3, r5
    4e42:	4629      	mov	r1, r5
    4e44:	e7ed      	b.n	4e22 <grid_port_receive_task+0xe2>
			if (por->rx_double_buffer[(por->rx_double_buffer_read_start_index + GRID_DOUBLE_BUFFER_RX_SIZE -1)%GRID_DOUBLE_BUFFER_RX_SIZE] !=0)
    4e46:	4465      	add	r5, ip
    4e48:	fbb5 f3f7 	udiv	r3, r5, r7
    4e4c:	fb07 5513 	mls	r5, r7, r3, r5
    4e50:	4425      	add	r5, r4
    4e52:	5c2b      	ldrb	r3, [r5, r0]
    4e54:	b153      	cbz	r3, 4e6c <grid_port_receive_task+0x12c>
				grid_port_reset_receiver(por);
    4e56:	4b11      	ldr	r3, [pc, #68]	; (4e9c <grid_port_receive_task+0x15c>)
    4e58:	4620      	mov	r0, r4
    4e5a:	4798      	blx	r3
				grid_sys_alert_set_alert(&grid_sys_state, 0, 0, 255, 2, 200); // RED
    4e5c:	2302      	movs	r3, #2
    4e5e:	22c8      	movs	r2, #200	; 0xc8
    4e60:	e9cd 3200 	strd	r3, r2, [sp]
    4e64:	2200      	movs	r2, #0
    4e66:	23ff      	movs	r3, #255	; 0xff
    4e68:	4611      	mov	r1, r2
    4e6a:	e7da      	b.n	4e22 <grid_port_receive_task+0xe2>
			if (por->rx_double_buffer_seek_start_index < GRID_DOUBLE_BUFFER_RX_SIZE-1){
    4e6c:	4572      	cmp	r2, lr
				por->rx_double_buffer_seek_start_index++;
    4e6e:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
    4e72:	bf98      	it	ls
    4e74:	3201      	addls	r2, #1
    4e76:	b289      	uxth	r1, r1
				por->rx_double_buffer_timeout = 0;
    4e78:	61e3      	str	r3, [r4, #28]
				por->rx_double_buffer_seek_start_index++;
    4e7a:	bf94      	ite	ls
    4e7c:	6262      	strls	r2, [r4, #36]	; 0x24
				por->rx_double_buffer_seek_start_index=0;
    4e7e:	6263      	strhi	r3, [r4, #36]	; 0x24
		for(uint16_t i = 0; i<490; i++){
    4e80:	2900      	cmp	r1, #0
    4e82:	d199      	bne.n	4db8 <grid_port_receive_task+0x78>
    4e84:	e7ba      	b.n	4dfc <grid_port_receive_task+0xbc>
		length = por->rx_double_buffer_seek_start_index - por->rx_double_buffer_read_start_index + 1;
    4e86:	3201      	adds	r2, #1
		length = GRID_DOUBLE_BUFFER_RX_SIZE + por->rx_double_buffer_seek_start_index - por->rx_double_buffer_read_start_index + 1;
    4e88:	1a52      	subs	r2, r2, r1
	grid_port_receive_decode(por, por->rx_double_buffer_read_start_index, length);
    4e8a:	4b0b      	ldr	r3, [pc, #44]	; (4eb8 <grid_port_receive_task+0x178>)
    4e8c:	b292      	uxth	r2, r2
    4e8e:	b289      	uxth	r1, r1
    4e90:	4620      	mov	r0, r4
    4e92:	4798      	blx	r3
	por->rx_double_buffer_status = 0;
    4e94:	2300      	movs	r3, #0
    4e96:	6223      	str	r3, [r4, #32]
    4e98:	e7b3      	b.n	4e02 <grid_port_receive_task+0xc2>
    4e9a:	bf00      	nop
    4e9c:	000046e9 	.word	0x000046e9
    4ea0:	2000f008 	.word	0x2000f008
    4ea4:	000097cb 	.word	0x000097cb
    4ea8:	000159bd 	.word	0x000159bd
    4eac:	00014451 	.word	0x00014451
    4eb0:	00015927 	.word	0x00015927
    4eb4:	000159e1 	.word	0x000159e1
    4eb8:	00004875 	.word	0x00004875

00004ebc <grid_buffer_read_size>:
	return 1;
}

uint16_t grid_buffer_read_size(struct grid_buffer* buf){
	
	if (buf->read_active != buf->read_stop) {
    4ebc:	f8b0 13ec 	ldrh.w	r1, [r0, #1004]	; 0x3ec
    4ec0:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4ec4:	428b      	cmp	r3, r1
uint16_t grid_buffer_read_size(struct grid_buffer* buf){
    4ec6:	b5f0      	push	{r4, r5, r6, r7, lr}
    4ec8:	4602      	mov	r2, r0
	if (buf->read_active != buf->read_stop) {
    4eca:	d000      	beq.n	4ece <grid_buffer_read_size+0x12>
		while(1){
    4ecc:	e7fe      	b.n	4ecc <grid_buffer_read_size+0x10>
			// TRAP: TRANSMISSION WAS NOT OVER YET
		}
	}
	
	
	if (buf->read_start	 != buf->read_stop) {
    4ece:	f8b0 63ea 	ldrh.w	r6, [r0, #1002]	; 0x3ea
    4ed2:	42b3      	cmp	r3, r6
    4ed4:	d000      	beq.n	4ed8 <grid_buffer_read_size+0x1c>
		while(1){
    4ed6:	e7fe      	b.n	4ed6 <grid_buffer_read_size+0x1a>
			// TRAP: TRANSMISSION WAS NOT OVER YET
		}
	}
	
	if (buf->read_start == buf->write_start) {
    4ed8:	f8b0 73f2 	ldrh.w	r7, [r0, #1010]	; 0x3f2
    4edc:	42be      	cmp	r6, r7
    4ede:	d016      	beq.n	4f0e <grid_buffer_read_size+0x52>
	}
	
	
	
	// Seek message end character
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4ee0:	8805      	ldrh	r5, [r0, #0]
		
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4ee2:	2400      	movs	r4, #0
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4ee4:	b2a3      	uxth	r3, r4
    4ee6:	429d      	cmp	r5, r3
    4ee8:	d800      	bhi.n	4eec <grid_buffer_read_size+0x30>
		}
		
		
	}
	
	while(1){
    4eea:	e7fe      	b.n	4eea <grid_buffer_read_size+0x2e>
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4eec:	1930      	adds	r0, r6, r4
    4eee:	fbb0 f1f5 	udiv	r1, r0, r5
    4ef2:	fb05 0111 	mls	r1, r5, r1, r0
		if (index == buf->write_start) return 0;
    4ef6:	b288      	uxth	r0, r1
    4ef8:	4287      	cmp	r7, r0
    4efa:	d008      	beq.n	4f0e <grid_buffer_read_size+0x52>
		if (buf->buffer_storage[index] == '\n'){
    4efc:	4411      	add	r1, r2
    4efe:	3301      	adds	r3, #1
    4f00:	b298      	uxth	r0, r3
    4f02:	788b      	ldrb	r3, [r1, #2]
    4f04:	2b0a      	cmp	r3, #10
    4f06:	f104 0401 	add.w	r4, r4, #1
    4f0a:	d1eb      	bne.n	4ee4 <grid_buffer_read_size+0x28>
		// TRAP: TRANSMISSION WAS NOT OVER YET
	}
	
	
}
    4f0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return 0;
    4f0e:	2000      	movs	r0, #0
    4f10:	e7fc      	b.n	4f0c <grid_buffer_read_size+0x50>

00004f12 <grid_buffer_read_init>:

uint16_t grid_buffer_read_init(struct grid_buffer* buf){
	
	if (buf->read_active != buf->read_stop) {
    4f12:	f8b0 23ec 	ldrh.w	r2, [r0, #1004]	; 0x3ec
    4f16:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4f1a:	4293      	cmp	r3, r2
uint16_t grid_buffer_read_init(struct grid_buffer* buf){
    4f1c:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (buf->read_active != buf->read_stop) {
    4f1e:	d000      	beq.n	4f22 <grid_buffer_read_init+0x10>
		while(1){
    4f20:	e7fe      	b.n	4f20 <grid_buffer_read_init+0xe>
		// TRAP: TRANSMISSION WAS NOT OVER YET
		}	
	}
	
	
	if (buf->read_start	 != buf->read_stop) {
    4f22:	f8b0 53ea 	ldrh.w	r5, [r0, #1002]	; 0x3ea
    4f26:	42ab      	cmp	r3, r5
    4f28:	d000      	beq.n	4f2c <grid_buffer_read_init+0x1a>
		while(1){
    4f2a:	e7fe      	b.n	4f2a <grid_buffer_read_init+0x18>
		// TRAP: TRANSMISSION WAS NOT OVER YET
		}	
	}
	
	if (buf->read_start == buf->write_start) {
    4f2c:	f8b0 63f2 	ldrh.w	r6, [r0, #1010]	; 0x3f2
    4f30:	42b5      	cmp	r5, r6
    4f32:	d020      	beq.n	4f76 <grid_buffer_read_init+0x64>
	}
	
	
	
	// Seek message end character	
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4f34:	8801      	ldrh	r1, [r0, #0]
		
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4f36:	2400      	movs	r4, #0
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4f38:	b2a3      	uxth	r3, r4
    4f3a:	4299      	cmp	r1, r3
    4f3c:	d800      	bhi.n	4f40 <grid_buffer_read_init+0x2e>
		}
		
		
	}
		
	while(1){
    4f3e:	e7fe      	b.n	4f3e <grid_buffer_read_init+0x2c>
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4f40:	192f      	adds	r7, r5, r4
    4f42:	fbb7 f2f1 	udiv	r2, r7, r1
    4f46:	fb01 7212 	mls	r2, r1, r2, r7
		if (index == buf->write_start) return 0;	
    4f4a:	b297      	uxth	r7, r2
    4f4c:	42be      	cmp	r6, r7
    4f4e:	d012      	beq.n	4f76 <grid_buffer_read_init+0x64>
		if (buf->buffer_storage[index] == '\n'){
    4f50:	1887      	adds	r7, r0, r2
    4f52:	3301      	adds	r3, #1
    4f54:	78bf      	ldrb	r7, [r7, #2]
    4f56:	2f0a      	cmp	r7, #10
    4f58:	b29b      	uxth	r3, r3
    4f5a:	f104 0401 	add.w	r4, r4, #1
    4f5e:	d1eb      	bne.n	4f38 <grid_buffer_read_init+0x26>
			buf->read_stop = (index+1)%buf->buffer_length;
    4f60:	3201      	adds	r2, #1
    4f62:	fbb2 f4f1 	udiv	r4, r2, r1
    4f66:	fb01 2214 	mls	r2, r1, r4, r2
    4f6a:	f8a0 23ec 	strh.w	r2, [r0, #1004]	; 0x3ec
			buf->read_length = i+1;
    4f6e:	f8a0 33f0 	strh.w	r3, [r0, #1008]	; 0x3f0
		// TRAP: TRANSMISSION WAS NOT OVER YET
	}
	
	
}
    4f72:	4618      	mov	r0, r3
    4f74:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return 0;
    4f76:	2300      	movs	r3, #0
    4f78:	e7fb      	b.n	4f72 <grid_buffer_read_init+0x60>

00004f7a <grid_buffer_read_character>:

uint8_t grid_buffer_read_character(struct grid_buffer* buf){
	
	// Check if packet is not over
	if (buf->read_active != buf->read_stop){
    4f7a:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4f7e:	f8b0 13ec 	ldrh.w	r1, [r0, #1004]	; 0x3ec
    4f82:	4299      	cmp	r1, r3
uint8_t grid_buffer_read_character(struct grid_buffer* buf){
    4f84:	b510      	push	{r4, lr}
    4f86:	4602      	mov	r2, r0
	if (buf->read_active != buf->read_stop){
    4f88:	d00b      	beq.n	4fa2 <grid_buffer_read_character+0x28>
		
		uint8_t character = buf->buffer_storage[buf->read_active];
		
		buf->read_active++;
		buf->read_active %= buf->buffer_length;
    4f8a:	8814      	ldrh	r4, [r2, #0]
		uint8_t character = buf->buffer_storage[buf->read_active];
    4f8c:	18c1      	adds	r1, r0, r3
		buf->read_active++;
    4f8e:	3301      	adds	r3, #1
		buf->read_active %= buf->buffer_length;
    4f90:	b29b      	uxth	r3, r3
		uint8_t character = buf->buffer_storage[buf->read_active];
    4f92:	7888      	ldrb	r0, [r1, #2]
		buf->read_active %= buf->buffer_length;
    4f94:	fbb3 f1f4 	udiv	r1, r3, r4
    4f98:	fb04 3311 	mls	r3, r4, r1, r3
    4f9c:	f8a2 33ee 	strh.w	r3, [r2, #1006]	; 0x3ee
			// TRAP: TRANSMISSION WAS OVER ALREADY
		}
	}
	

}
    4fa0:	bd10      	pop	{r4, pc}
		while(1){
    4fa2:	e7fe      	b.n	4fa2 <grid_buffer_read_character+0x28>

00004fa4 <grid_buffer_read_acknowledge>:

// TRANSMISSION WAS ACKNOWLEDGED, PACKET CAN BE DELETED
uint8_t grid_buffer_read_acknowledge(struct grid_buffer* buf){
	
	// Check if packet is really over
	if (buf->read_active == buf->read_stop){
    4fa4:	f8b0 23ec 	ldrh.w	r2, [r0, #1004]	; 0x3ec
    4fa8:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4fac:	4293      	cmp	r3, r2
    4fae:	d000      	beq.n	4fb2 <grid_buffer_read_acknowledge+0xe>
		buf->read_start = buf->read_stop;
		return 1;
	}else{
		
		while(1){
    4fb0:	e7fe      	b.n	4fb0 <grid_buffer_read_acknowledge+0xc>
		buf->read_start = buf->read_stop;
    4fb2:	f8a0 33ea 	strh.w	r3, [r0, #1002]	; 0x3ea
			// TRAP: TRANSMISSION WAS NOT OVER YET
		}
	}
	

}
    4fb6:	2001      	movs	r0, #1
    4fb8:	4770      	bx	lr
	...

00004fbc <grid_port_init>:
	buf->read_start  = buf->read_stop;
	
	return 1;
}

void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    4fbc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    4fc0:	4604      	mov	r4, r0
	
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    4fc2:	f500 501c 	add.w	r0, r0, #9984	; 0x2700
void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    4fc6:	b087      	sub	sp, #28
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    4fc8:	f8df 8148 	ldr.w	r8, [pc, #328]	; 5114 <grid_port_init+0x158>
void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    4fcc:	460d      	mov	r5, r1
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    4fce:	303c      	adds	r0, #60	; 0x3c
    4fd0:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    4fd4:	4616      	mov	r6, r2
    4fd6:	461f      	mov	r7, r3
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    4fd8:	47c0      	blx	r8
	grid_buffer_init(&por->rx_buffer, GRID_BUFFER_SIZE);
    4fda:	f504 502c 	add.w	r0, r4, #11008	; 0x2b00
    4fde:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    4fe2:	3034      	adds	r0, #52	; 0x34
    4fe4:	47c0      	blx	r8
	
	
	por->cooldown = 0;
    4fe6:	2000      	movs	r0, #0
	
	por->dma_channel = dma;
    4fe8:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
	por->cooldown = 0;
    4fec:	6020      	str	r0, [r4, #0]
	
	por->tx_double_buffer_status	= 0;
	por->rx_double_buffer_status	= 0;
	
	
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    4fee:	f241 3288 	movw	r2, #5000	; 0x1388
	por->dma_channel = dma;
    4ff2:	72a3      	strb	r3, [r4, #10]
	por->direction = dir;
    4ff4:	7267      	strb	r7, [r4, #9]
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    4ff6:	4603      	mov	r3, r0
	por->usart	= usart;
    4ff8:	6065      	str	r5, [r4, #4]
	por->type		= type;
    4ffa:	7226      	strb	r6, [r4, #8]
	por->tx_double_buffer_status	= 0;
    4ffc:	81a0      	strh	r0, [r4, #12]
	por->rx_double_buffer_status	= 0;
    4ffe:	6220      	str	r0, [r4, #32]
		por->tx_double_buffer[i] = 0;		
    5000:	18e1      	adds	r1, r4, r3
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    5002:	3301      	adds	r3, #1
    5004:	4293      	cmp	r3, r2
		por->tx_double_buffer[i] = 0;		
    5006:	f881 002c 	strb.w	r0, [r1, #44]	; 0x2c
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    500a:	d1f9      	bne.n	5000 <grid_port_init+0x44>
	}
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    500c:	2300      	movs	r3, #0
		por->rx_double_buffer[i] = 0;
    500e:	f241 31b4 	movw	r1, #5044	; 0x13b4
    5012:	461d      	mov	r5, r3
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    5014:	f241 3288 	movw	r2, #5000	; 0x1388
		por->rx_double_buffer[i] = 0;
    5018:	18e0      	adds	r0, r4, r3
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    501a:	3301      	adds	r3, #1
    501c:	4293      	cmp	r3, r2
		por->rx_double_buffer[i] = 0;
    501e:	5445      	strb	r5, [r0, r1]
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    5020:	d1fa      	bne.n	5018 <grid_port_init+0x5c>
	}
	
	por->partner_fi = 0;
	
	por->partner_hwcfg = 0;
    5022:	f642 732c 	movw	r3, #12076	; 0x2f2c
	por->partner_fi = 0;
    5026:	f642 7130 	movw	r1, #12080	; 0x2f30
	por->partner_status = 1;
	
	por->ping_local_token = 255;
    502a:	f642 7031 	movw	r0, #12081	; 0x2f31
	por->partner_fi = 0;
    502e:	5465      	strb	r5, [r4, r1]
	por->partner_hwcfg = 0;
    5030:	50e5      	str	r5, [r4, r3]
	por->partner_status = 1;
    5032:	f642 734b 	movw	r3, #12107	; 0x2f4b
    5036:	2201      	movs	r2, #1
	por->ping_local_token = 255;
    5038:	27ff      	movs	r7, #255	; 0xff
	por->partner_status = 1;
    503a:	54e2      	strb	r2, [r4, r3]
	por->ping_local_token = 255;
    503c:	5427      	strb	r7, [r4, r0]
	por->ping_partner_token = 255;
    503e:	f642 7032 	movw	r0, #12082	; 0x2f32
	
	por->ping_flag = 0;
	
	if (type == GRID_PORT_TYPE_USART){	
    5042:	4296      	cmp	r6, r2
	por->ping_partner_token = 255;
    5044:	5427      	strb	r7, [r4, r0]
	por->ping_flag = 0;
    5046:	f642 7048 	movw	r0, #12104	; 0x2f48
    504a:	5425      	strb	r5, [r4, r0]
	if (type == GRID_PORT_TYPE_USART){	
    504c:	d156      	bne.n	50fc <grid_port_init+0x140>
		
		por->partner_status = 0;
    504e:	54e5      	strb	r5, [r4, r3]
		por->partner_fi = 0;
    5050:	5465      	strb	r5, [r4, r1]
		
		
		sprintf(por->ping_packet, "%c%c%c%c%02x%02x%02x%c00\n", GRID_CONST_SOH, GRID_CONST_DCT, GRID_CONST_BELL, por->direction, grid_sys_get_hwcfg(), 255, 255, GRID_CONST_EOT);
    5052:	4b2b      	ldr	r3, [pc, #172]	; (5100 <grid_port_init+0x144>)
    5054:	f894 9009 	ldrb.w	r9, [r4, #9]
    5058:	4798      	blx	r3
    505a:	f504 583c 	add.w	r8, r4, #12032	; 0x2f00
    505e:	2304      	movs	r3, #4
    5060:	f108 0833 	add.w	r8, r8, #51	; 0x33
    5064:	e9cd 7304 	strd	r7, r3, [sp, #16]
    5068:	fa5f f989 	uxtb.w	r9, r9
    506c:	2307      	movs	r3, #7
    506e:	4632      	mov	r2, r6
    5070:	4924      	ldr	r1, [pc, #144]	; (5104 <grid_port_init+0x148>)
    5072:	f8cd 9004 	str.w	r9, [sp, #4]
    5076:	e9cd 0702 	strd	r0, r7, [sp, #8]
    507a:	f8df 909c 	ldr.w	r9, [pc, #156]	; 5118 <grid_port_init+0x15c>
    507e:	9300      	str	r3, [sp, #0]
    5080:	4640      	mov	r0, r8
    5082:	230e      	movs	r3, #14
    5084:	47c8      	blx	r9
		
		por->ping_packet_length = strlen(por->ping_packet);	
    5086:	4b20      	ldr	r3, [pc, #128]	; (5108 <grid_port_init+0x14c>)
    5088:	4640      	mov	r0, r8
    508a:	4798      	blx	r3
    508c:	f642 7347 	movw	r3, #12103	; 0x2f47
    5090:	b2c0      	uxtb	r0, r0
    5092:	54e0      	strb	r0, [r4, r3]
			
		grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    5094:	4640      	mov	r0, r8
    5096:	f814 9003 	ldrb.w	r9, [r4, r3]
    509a:	5ce1      	ldrb	r1, [r4, r3]
    509c:	4b1b      	ldr	r3, [pc, #108]	; (510c <grid_port_init+0x150>)
    509e:	4798      	blx	r3
    50a0:	fa5f f989 	uxtb.w	r9, r9
    50a4:	4b1a      	ldr	r3, [pc, #104]	; (5110 <grid_port_init+0x154>)
    50a6:	4602      	mov	r2, r0
    50a8:	4649      	mov	r1, r9
    50aa:	4640      	mov	r0, r8
    50ac:	4798      	blx	r3
		

		
		if (por->direction == GRID_CONST_NORTH){
    50ae:	7a63      	ldrb	r3, [r4, #9]
    50b0:	2b11      	cmp	r3, #17
    50b2:	d108      	bne.n	50c6 <grid_port_init+0x10a>
			por->dx = 0;
    50b4:	f642 7349 	movw	r3, #12105	; 0x2f49
    50b8:	54e5      	strb	r5, [r4, r3]
			por->dy = 1;
    50ba:	f642 734a 	movw	r3, #12106	; 0x2f4a
    50be:	54e6      	strb	r6, [r4, r3]
	}
	else{
		por->partner_status = 1; //UI AND USB are considered to be connected by default
	}
	
}
    50c0:	b007      	add	sp, #28
    50c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		else if (por->direction == GRID_CONST_EAST){
    50c6:	7a63      	ldrb	r3, [r4, #9]
    50c8:	2b12      	cmp	r3, #18
    50ca:	d106      	bne.n	50da <grid_port_init+0x11e>
			por->dx = 1;
    50cc:	f642 7349 	movw	r3, #12105	; 0x2f49
    50d0:	54e6      	strb	r6, [r4, r3]
			por->dy = 0;
    50d2:	f642 734a 	movw	r3, #12106	; 0x2f4a
    50d6:	54e5      	strb	r5, [r4, r3]
    50d8:	e7f2      	b.n	50c0 <grid_port_init+0x104>
		else if (por->direction == GRID_CONST_SOUTH){
    50da:	7a63      	ldrb	r3, [r4, #9]
    50dc:	2b13      	cmp	r3, #19
    50de:	d106      	bne.n	50ee <grid_port_init+0x132>
			por->dx = 0;
    50e0:	f642 7349 	movw	r3, #12105	; 0x2f49
    50e4:	54e5      	strb	r5, [r4, r3]
			por->dy = -1;
    50e6:	f642 734a 	movw	r3, #12106	; 0x2f4a
    50ea:	54e7      	strb	r7, [r4, r3]
    50ec:	e7e8      	b.n	50c0 <grid_port_init+0x104>
		else if (por->direction == GRID_CONST_WEST){
    50ee:	7a63      	ldrb	r3, [r4, #9]
    50f0:	2b14      	cmp	r3, #20
    50f2:	d1e5      	bne.n	50c0 <grid_port_init+0x104>
			por->dx = -1;
    50f4:	f642 7349 	movw	r3, #12105	; 0x2f49
    50f8:	54e7      	strb	r7, [r4, r3]
    50fa:	e7ea      	b.n	50d2 <grid_port_init+0x116>
		por->partner_status = 1; //UI AND USB are considered to be connected by default
    50fc:	54e2      	strb	r2, [r4, r3]
}
    50fe:	e7df      	b.n	50c0 <grid_port_init+0x104>
    5100:	000098a5 	.word	0x000098a5
    5104:	000159fa 	.word	0x000159fa
    5108:	0001480f 	.word	0x0001480f
    510c:	00009989 	.word	0x00009989
    5110:	000099bd 	.word	0x000099bd
    5114:	00004795 	.word	0x00004795
    5118:	00014791 	.word	0x00014791

0000511c <grid_port_init_all>:

void grid_port_init_all(void){
    511c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	
	grid_port_init(&GRID_PORT_N, &USART_NORTH, GRID_PORT_TYPE_USART, GRID_CONST_NORTH ,0);
    5120:	2600      	movs	r6, #0
    5122:	4d1c      	ldr	r5, [pc, #112]	; (5194 <grid_port_init_all+0x78>)
    5124:	491c      	ldr	r1, [pc, #112]	; (5198 <grid_port_init_all+0x7c>)
    5126:	481d      	ldr	r0, [pc, #116]	; (519c <grid_port_init_all+0x80>)
    5128:	9600      	str	r6, [sp, #0]
	grid_port_init(&GRID_PORT_E, &USART_EAST,  GRID_PORT_TYPE_USART, GRID_CONST_EAST  ,1);
    512a:	2401      	movs	r4, #1
	grid_port_init(&GRID_PORT_N, &USART_NORTH, GRID_PORT_TYPE_USART, GRID_CONST_NORTH ,0);
    512c:	2311      	movs	r3, #17
    512e:	2201      	movs	r2, #1
    5130:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_S, &USART_SOUTH, GRID_PORT_TYPE_USART, GRID_CONST_SOUTH ,2);
    5132:	f04f 0902 	mov.w	r9, #2
	grid_port_init(&GRID_PORT_E, &USART_EAST,  GRID_PORT_TYPE_USART, GRID_CONST_EAST  ,1);
    5136:	4622      	mov	r2, r4
    5138:	4919      	ldr	r1, [pc, #100]	; (51a0 <grid_port_init_all+0x84>)
    513a:	481a      	ldr	r0, [pc, #104]	; (51a4 <grid_port_init_all+0x88>)
    513c:	9400      	str	r4, [sp, #0]
    513e:	2312      	movs	r3, #18
    5140:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_W, &USART_WEST,  GRID_PORT_TYPE_USART, GRID_CONST_WEST  ,3);
    5142:	2703      	movs	r7, #3
	grid_port_init(&GRID_PORT_S, &USART_SOUTH, GRID_PORT_TYPE_USART, GRID_CONST_SOUTH ,2);
    5144:	4622      	mov	r2, r4
    5146:	4918      	ldr	r1, [pc, #96]	; (51a8 <grid_port_init_all+0x8c>)
    5148:	4818      	ldr	r0, [pc, #96]	; (51ac <grid_port_init_all+0x90>)
    514a:	f8cd 9000 	str.w	r9, [sp]
    514e:	2313      	movs	r3, #19
    5150:	47a8      	blx	r5
	
	grid_port_init(&GRID_PORT_U, NULL, GRID_PORT_TYPE_UI, 0, -1);
    5152:	f8df 8068 	ldr.w	r8, [pc, #104]	; 51bc <grid_port_init_all+0xa0>
	grid_port_init(&GRID_PORT_W, &USART_WEST,  GRID_PORT_TYPE_USART, GRID_CONST_WEST  ,3);
    5156:	9700      	str	r7, [sp, #0]
    5158:	4622      	mov	r2, r4
    515a:	4915      	ldr	r1, [pc, #84]	; (51b0 <grid_port_init_all+0x94>)
    515c:	4815      	ldr	r0, [pc, #84]	; (51b4 <grid_port_init_all+0x98>)
    515e:	2314      	movs	r3, #20
    5160:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_U, NULL, GRID_PORT_TYPE_UI, 0, -1);
    5162:	f04f 0aff 	mov.w	sl, #255	; 0xff
    5166:	463a      	mov	r2, r7
	grid_port_init(&GRID_PORT_H, NULL, GRID_PORT_TYPE_USB, 0, -1);	
    5168:	4f13      	ldr	r7, [pc, #76]	; (51b8 <grid_port_init_all+0x9c>)
	grid_port_init(&GRID_PORT_U, NULL, GRID_PORT_TYPE_UI, 0, -1);
    516a:	f8cd a000 	str.w	sl, [sp]
    516e:	4633      	mov	r3, r6
    5170:	4631      	mov	r1, r6
    5172:	4640      	mov	r0, r8
    5174:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_H, NULL, GRID_PORT_TYPE_USB, 0, -1);	
    5176:	4633      	mov	r3, r6
    5178:	f8cd a000 	str.w	sl, [sp]
    517c:	464a      	mov	r2, r9
    517e:	4631      	mov	r1, r6
    5180:	4638      	mov	r0, r7
    5182:	47a8      	blx	r5
	
	GRID_PORT_U.partner_status = 1; // UI IS ALWAYS CONNECTED
    5184:	f642 734b 	movw	r3, #12107	; 0x2f4b
    5188:	f808 4003 	strb.w	r4, [r8, r3]
	GRID_PORT_H.partner_status = 1; // HOST IS ALWAYS CONNECTED (Not really!)
    518c:	54fc      	strb	r4, [r7, r3]
	
	
}
    518e:	b002      	add	sp, #8
    5190:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5194:	00004fbd 	.word	0x00004fbd
    5198:	2001ce04 	.word	0x2001ce04
    519c:	20009150 	.word	0x20009150
    51a0:	2001cdb0 	.word	0x2001cdb0
    51a4:	20019870 	.word	0x20019870
    51a8:	2001cf08 	.word	0x2001cf08
    51ac:	200138d4 	.word	0x200138d4
    51b0:	2001ceb8 	.word	0x2001ceb8
    51b4:	200102d4 	.word	0x200102d4
    51b8:	20016824 	.word	0x20016824
    51bc:	2000c0b0 	.word	0x2000c0b0

000051c0 <grid_port_process_inbound>:


//=============================== PROCESS INBOUND ==============================//


uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    51c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    51c4:	f500 582c 	add.w	r8, r0, #11008	; 0x2b00
uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    51c8:	b091      	sub	sp, #68	; 0x44
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    51ca:	f108 0834 	add.w	r8, r8, #52	; 0x34
uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    51ce:	af02      	add	r7, sp, #8
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    51d0:	4b5c      	ldr	r3, [pc, #368]	; (5344 <grid_port_process_inbound+0x184>)
uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    51d2:	6079      	str	r1, [r7, #4]
    51d4:	4606      	mov	r6, r0
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    51d6:	4640      	mov	r0, r8
    51d8:	4798      	blx	r3
	
	if (!packet_size){
    51da:	4605      	mov	r5, r0
    51dc:	2800      	cmp	r0, #0
    51de:	f000 80af 	beq.w	5340 <grid_port_process_inbound+0x180>
		uint8_t port_count = 6;
		struct grid_port* port_array_default[port_count];
		struct grid_port* port_array[port_count];
		
		
		port_array_default[0] = &GRID_PORT_N;
    51e2:	4b59      	ldr	r3, [pc, #356]	; (5348 <grid_port_process_inbound+0x188>)
    51e4:	60bb      	str	r3, [r7, #8]
		port_array_default[1] = &GRID_PORT_E;
    51e6:	4b59      	ldr	r3, [pc, #356]	; (534c <grid_port_process_inbound+0x18c>)
    51e8:	60fb      	str	r3, [r7, #12]
		port_array_default[2] = &GRID_PORT_S;
    51ea:	4b59      	ldr	r3, [pc, #356]	; (5350 <grid_port_process_inbound+0x190>)
    51ec:	613b      	str	r3, [r7, #16]
		port_array_default[3] = &GRID_PORT_W;
    51ee:	4b59      	ldr	r3, [pc, #356]	; (5354 <grid_port_process_inbound+0x194>)
    51f0:	617b      	str	r3, [r7, #20]
		
		port_array_default[4] = &GRID_PORT_U;
    51f2:	4b59      	ldr	r3, [pc, #356]	; (5358 <grid_port_process_inbound+0x198>)
    51f4:	61bb      	str	r3, [r7, #24]
		port_array_default[5] = &GRID_PORT_H;
    51f6:	4b59      	ldr	r3, [pc, #356]	; (535c <grid_port_process_inbound+0x19c>)
    51f8:	61fb      	str	r3, [r7, #28]
	}else{
    51fa:	46eb      	mov	fp, sp
		
		uint8_t j=0;
		
		for(uint8_t i=0; i<port_count; i++){
    51fc:	f107 0308 	add.w	r3, r7, #8
		port_array_default[5] = &GRID_PORT_H;
    5200:	f04f 0906 	mov.w	r9, #6
		uint8_t j=0;
    5204:	2400      	movs	r4, #0
			if (port_array_default[i]->partner_status != 0){
    5206:	f642 714b 	movw	r1, #12107	; 0x2f4b
    520a:	f853 2b04 	ldr.w	r2, [r3], #4
    520e:	5c50      	ldrb	r0, [r2, r1]
    5210:	b138      	cbz	r0, 5222 <grid_port_process_inbound+0x62>
				port_array[j] = port_array_default[i];
    5212:	f107 0038 	add.w	r0, r7, #56	; 0x38
    5216:	eb00 0084 	add.w	r0, r0, r4, lsl #2
				j++;
    521a:	3401      	adds	r4, #1
				port_array[j] = port_array_default[i];
    521c:	f840 2c18 	str.w	r2, [r0, #-24]
				j++;
    5220:	b2e4      	uxtb	r4, r4
		for(uint8_t i=0; i<port_count; i++){
    5222:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
    5226:	f019 09ff 	ands.w	r9, r9, #255	; 0xff
    522a:	d1ee      	bne.n	520a <grid_port_process_inbound+0x4a>
		
		for (uint8_t i=0; i<port_count; i++)
		{
			if (port_array[i] != por || loopback){
			
				if (packet_size > grid_buffer_write_size(&port_array[i]->tx_buffer)){
    522c:	4a4c      	ldr	r2, [pc, #304]	; (5360 <grid_port_process_inbound+0x1a0>)
    522e:	4649      	mov	r1, r9
			if (port_array[i] != por || loopback){
    5230:	f107 0a20 	add.w	sl, r7, #32
				if (packet_size > grid_buffer_write_size(&port_array[i]->tx_buffer)){
    5234:	f242 7c3c 	movw	ip, #10044	; 0x273c
		for (uint8_t i=0; i<port_count; i++)
    5238:	b2c8      	uxtb	r0, r1
    523a:	4284      	cmp	r4, r0
    523c:	d805      	bhi.n	524a <grid_port_process_inbound+0x8a>
					return 0;
				}	
			}	
		}
		
		if (packet_size != grid_buffer_read_init(&por->rx_buffer)){
    523e:	4b49      	ldr	r3, [pc, #292]	; (5364 <grid_port_process_inbound+0x1a4>)
    5240:	4640      	mov	r0, r8
    5242:	4798      	blx	r3
    5244:	42a8      	cmp	r0, r5
    5246:	d047      	beq.n	52d8 <grid_port_process_inbound+0x118>
			while(1){			
    5248:	e7fe      	b.n	5248 <grid_port_process_inbound+0x88>
			if (port_array[i] != por || loopback){
    524a:	f85a 0021 	ldr.w	r0, [sl, r1, lsl #2]
    524e:	42b0      	cmp	r0, r6
    5250:	d101      	bne.n	5256 <grid_port_process_inbound+0x96>
    5252:	687b      	ldr	r3, [r7, #4]
    5254:	b1b3      	cbz	r3, 5284 <grid_port_process_inbound+0xc4>
				if (packet_size > grid_buffer_write_size(&port_array[i]->tx_buffer)){
    5256:	4460      	add	r0, ip
    5258:	4790      	blx	r2
    525a:	42a8      	cmp	r0, r5
    525c:	4a40      	ldr	r2, [pc, #256]	; (5360 <grid_port_process_inbound+0x1a0>)
    525e:	f242 7c3c 	movw	ip, #10044	; 0x273c
    5262:	d20f      	bcs.n	5284 <grid_port_process_inbound+0xc4>
					grid_sys_alert_set_alert(&grid_sys_state, 100,100,0,2,200);
    5264:	2302      	movs	r3, #2
    5266:	22c8      	movs	r2, #200	; 0xc8
    5268:	e9cd 3200 	strd	r3, r2, [sp]
    526c:	2264      	movs	r2, #100	; 0x64
    526e:	483e      	ldr	r0, [pc, #248]	; (5368 <grid_port_process_inbound+0x1a8>)
    5270:	4c3e      	ldr	r4, [pc, #248]	; (536c <grid_port_process_inbound+0x1ac>)
    5272:	2300      	movs	r3, #0
    5274:	4611      	mov	r1, r2
    5276:	47a0      	blx	r4
					return 0;
    5278:	46dd      	mov	sp, fp
		}	

		return 1;
	}
		
}
    527a:	4648      	mov	r0, r9
    527c:	373c      	adds	r7, #60	; 0x3c
    527e:	46bd      	mov	sp, r7
    5280:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (uint8_t i=0; i<port_count; i++)
    5284:	3101      	adds	r1, #1
    5286:	e7d7      	b.n	5238 <grid_port_process_inbound+0x78>
			if (port_array[i] != por || loopback){
    5288:	f85a 0029 	ldr.w	r0, [sl, r9, lsl #2]
    528c:	42b0      	cmp	r0, r6
    528e:	d101      	bne.n	5294 <grid_port_process_inbound+0xd4>
    5290:	6879      	ldr	r1, [r7, #4]
    5292:	b129      	cbz	r1, 52a0 <grid_port_process_inbound+0xe0>
				grid_buffer_write_init(&port_array[i]->tx_buffer, packet_size);
    5294:	4418      	add	r0, r3
    5296:	4629      	mov	r1, r5
    5298:	4790      	blx	r2
    529a:	4a35      	ldr	r2, [pc, #212]	; (5370 <grid_port_process_inbound+0x1b0>)
    529c:	f242 733c 	movw	r3, #10044	; 0x273c
		for (uint8_t i=0; i<port_count; i++)
    52a0:	f109 0901 	add.w	r9, r9, #1
    52a4:	fa5f f189 	uxtb.w	r1, r9
    52a8:	428c      	cmp	r4, r1
    52aa:	d8ed      	bhi.n	5288 <grid_port_process_inbound+0xc8>
    52ac:	f04f 0a00 	mov.w	sl, #0
		for (uint16_t j=0; j<packet_size; j++)
    52b0:	fa1f f38a 	uxth.w	r3, sl
    52b4:	429d      	cmp	r5, r3
			uint8_t character = grid_buffer_read_character(&por->rx_buffer);
    52b6:	4640      	mov	r0, r8
		for (uint16_t j=0; j<packet_size; j++)
    52b8:	d816      	bhi.n	52e8 <grid_port_process_inbound+0x128>
		grid_buffer_read_acknowledge(&por->rx_buffer);
    52ba:	4b2e      	ldr	r3, [pc, #184]	; (5374 <grid_port_process_inbound+0x1b4>)
				grid_buffer_write_acknowledge(&port_array[i]->tx_buffer);
    52bc:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 5380 <grid_port_process_inbound+0x1c0>
		grid_buffer_read_acknowledge(&por->rx_buffer);
    52c0:	4798      	blx	r3
			if (port_array[i] != por || loopback){
    52c2:	f107 0520 	add.w	r5, r7, #32
		for (uint8_t i=0; i<port_count; i++)
    52c6:	2100      	movs	r1, #0
				grid_buffer_write_acknowledge(&port_array[i]->tx_buffer);
    52c8:	f242 783c 	movw	r8, #10044	; 0x273c
		for (uint8_t i=0; i<port_count; i++)
    52cc:	b2cb      	uxtb	r3, r1
    52ce:	429c      	cmp	r4, r3
    52d0:	d82c      	bhi.n	532c <grid_port_process_inbound+0x16c>
		return 1;
    52d2:	f04f 0901 	mov.w	r9, #1
    52d6:	e7cf      	b.n	5278 <grid_port_process_inbound+0xb8>
				grid_buffer_write_init(&port_array[i]->tx_buffer, packet_size);
    52d8:	4a25      	ldr	r2, [pc, #148]	; (5370 <grid_port_process_inbound+0x1b0>)
    52da:	f04f 0900 	mov.w	r9, #0
			if (port_array[i] != por || loopback){
    52de:	f107 0a20 	add.w	sl, r7, #32
				grid_buffer_write_init(&port_array[i]->tx_buffer, packet_size);
    52e2:	f242 733c 	movw	r3, #10044	; 0x273c
    52e6:	e7dd      	b.n	52a4 <grid_port_process_inbound+0xe4>
			uint8_t character = grid_buffer_read_character(&por->rx_buffer);
    52e8:	4b23      	ldr	r3, [pc, #140]	; (5378 <grid_port_process_inbound+0x1b8>)
    52ea:	4798      	blx	r3
			for (uint8_t i=0; i<port_count; i++){
    52ec:	f04f 0900 	mov.w	r9, #0
			uint8_t character = grid_buffer_read_character(&por->rx_buffer);
    52f0:	4601      	mov	r1, r0
				if (port_array[i] != por || loopback){
    52f2:	f107 0320 	add.w	r3, r7, #32
					grid_buffer_write_character(&port_array[i]->tx_buffer, character);
    52f6:	f242 7c3c 	movw	ip, #10044	; 0x273c
			for (uint8_t i=0; i<port_count; i++){
    52fa:	fa5f f089 	uxtb.w	r0, r9
    52fe:	4284      	cmp	r4, r0
    5300:	d802      	bhi.n	5308 <grid_port_process_inbound+0x148>
		for (uint16_t j=0; j<packet_size; j++)
    5302:	f10a 0a01 	add.w	sl, sl, #1
    5306:	e7d3      	b.n	52b0 <grid_port_process_inbound+0xf0>
				if (port_array[i] != por || loopback){
    5308:	f853 0029 	ldr.w	r0, [r3, r9, lsl #2]
    530c:	42b0      	cmp	r0, r6
    530e:	d101      	bne.n	5314 <grid_port_process_inbound+0x154>
    5310:	687a      	ldr	r2, [r7, #4]
    5312:	b142      	cbz	r2, 5326 <grid_port_process_inbound+0x166>
					grid_buffer_write_character(&port_array[i]->tx_buffer, character);
    5314:	4b19      	ldr	r3, [pc, #100]	; (537c <grid_port_process_inbound+0x1bc>)
    5316:	6039      	str	r1, [r7, #0]
    5318:	4460      	add	r0, ip
    531a:	4798      	blx	r3
    531c:	6839      	ldr	r1, [r7, #0]
    531e:	f107 0320 	add.w	r3, r7, #32
    5322:	f242 7c3c 	movw	ip, #10044	; 0x273c
			for (uint8_t i=0; i<port_count; i++){
    5326:	f109 0901 	add.w	r9, r9, #1
    532a:	e7e6      	b.n	52fa <grid_port_process_inbound+0x13a>
			if (port_array[i] != por || loopback){
    532c:	f855 0021 	ldr.w	r0, [r5, r1, lsl #2]
    5330:	42b0      	cmp	r0, r6
    5332:	d101      	bne.n	5338 <grid_port_process_inbound+0x178>
    5334:	687b      	ldr	r3, [r7, #4]
    5336:	b10b      	cbz	r3, 533c <grid_port_process_inbound+0x17c>
				grid_buffer_write_acknowledge(&port_array[i]->tx_buffer);
    5338:	4440      	add	r0, r8
    533a:	47c8      	blx	r9
		for (uint8_t i=0; i<port_count; i++)
    533c:	3101      	adds	r1, #1
    533e:	e7c5      	b.n	52cc <grid_port_process_inbound+0x10c>
		return 0;
    5340:	4681      	mov	r9, r0
    5342:	e79a      	b.n	527a <grid_port_process_inbound+0xba>
    5344:	00004ebd 	.word	0x00004ebd
    5348:	20009150 	.word	0x20009150
    534c:	20019870 	.word	0x20019870
    5350:	200138d4 	.word	0x200138d4
    5354:	200102d4 	.word	0x200102d4
    5358:	2000c0b0 	.word	0x2000c0b0
    535c:	20016824 	.word	0x20016824
    5360:	000047d9 	.word	0x000047d9
    5364:	00004f13 	.word	0x00004f13
    5368:	2000f008 	.word	0x2000f008
    536c:	000097cb 	.word	0x000097cb
    5370:	000047f1 	.word	0x000047f1
    5374:	00004fa5 	.word	0x00004fa5
    5378:	00004f7b 	.word	0x00004f7b
    537c:	0000482d 	.word	0x0000482d
    5380:	0000484d 	.word	0x0000484d

00005384 <grid_port_process_outbound_usb>:



//=============================== PROCESS OUTBOUND ==============================//

uint8_t grid_port_process_outbound_usb(struct grid_port* por){
    5384:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			

	// OLD DEBUG IMPLEMENTATION
	
	
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    5388:	f500 551c 	add.w	r5, r0, #9984	; 0x2700
    538c:	353c      	adds	r5, #60	; 0x3c
    538e:	4ba7      	ldr	r3, [pc, #668]	; (562c <grid_port_process_outbound_usb+0x2a8>)
uint8_t grid_port_process_outbound_usb(struct grid_port* por){
    5390:	b0ed      	sub	sp, #436	; 0x1b4
    5392:	4680      	mov	r8, r0
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    5394:	4628      	mov	r0, r5
    5396:	4798      	blx	r3
	
	if (!length){		
    5398:	4604      	mov	r4, r0
    539a:	b910      	cbnz	r0, 53a2 <grid_port_process_outbound_usb+0x1e>
			
	// Let's send the packet through USB
	cdcdf_acm_write(por->tx_double_buffer, packet_length);

	
}
    539c:	b06d      	add	sp, #436	; 0x1b4
    539e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    53a2:	f108 0b2c 	add.w	fp, r8, #44	; 0x2c
    53a6:	f508 539d 	add.w	r3, r8, #5024	; 0x13a0
    53aa:	3314      	adds	r3, #20
	if (!length){		
    53ac:	465a      	mov	r2, fp
		por->tx_double_buffer[i] = 0;
    53ae:	2100      	movs	r1, #0
    53b0:	f802 1b01 	strb.w	r1, [r2], #1
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    53b4:	429a      	cmp	r2, r3
    53b6:	d1fb      	bne.n	53b0 <grid_port_process_outbound_usb+0x2c>
	grid_msg_init(&message);
    53b8:	4b9d      	ldr	r3, [pc, #628]	; (5630 <grid_port_process_outbound_usb+0x2ac>)
		grid_msg_packet_receive_char(&message, nextchar);
    53ba:	f8df 92b8 	ldr.w	r9, [pc, #696]	; 5674 <grid_port_process_outbound_usb+0x2f0>
	grid_msg_init(&message);
    53be:	a805      	add	r0, sp, #20
    53c0:	4798      	blx	r3
	grid_buffer_read_init(&por->tx_buffer);
    53c2:	4b9c      	ldr	r3, [pc, #624]	; (5634 <grid_port_process_outbound_usb+0x2b0>)
    53c4:	4628      	mov	r0, r5
    53c6:	4798      	blx	r3
		uint8_t nextchar = grid_buffer_read_character(&por->tx_buffer);
    53c8:	4b9b      	ldr	r3, [pc, #620]	; (5638 <grid_port_process_outbound_usb+0x2b4>)
	for (uint16_t i = 0; i<length; i++){
    53ca:	46da      	mov	sl, fp
    53cc:	2700      	movs	r7, #0
    53ce:	b2ba      	uxth	r2, r7
    53d0:	4294      	cmp	r4, r2
		uint8_t nextchar = grid_buffer_read_character(&por->tx_buffer);
    53d2:	4628      	mov	r0, r5
	for (uint16_t i = 0; i<length; i++){
    53d4:	d825      	bhi.n	5422 <grid_port_process_outbound_usb+0x9e>
	grid_buffer_read_acknowledge(&por->tx_buffer);
    53d6:	4b99      	ldr	r3, [pc, #612]	; (563c <grid_port_process_outbound_usb+0x2b8>)
			uint8_t msg_class = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_offset, GRID_CLASS_length);
    53d8:	4c99      	ldr	r4, [pc, #612]	; (5640 <grid_port_process_outbound_usb+0x2bc>)
	grid_buffer_read_acknowledge(&por->tx_buffer);
    53da:	4798      	blx	r3
	int8_t dx = grid_msg_header_get_dx(&message) - GRID_SYS_DEFAULT_POSITION;
    53dc:	4b99      	ldr	r3, [pc, #612]	; (5644 <grid_port_process_outbound_usb+0x2c0>)
    53de:	a805      	add	r0, sp, #20
    53e0:	4798      	blx	r3
    53e2:	387f      	subs	r0, #127	; 0x7f
    53e4:	b243      	sxtb	r3, r0
    53e6:	9300      	str	r3, [sp, #0]
	int8_t dy = grid_msg_header_get_dy(&message) - GRID_SYS_DEFAULT_POSITION;	
    53e8:	a805      	add	r0, sp, #20
    53ea:	4b97      	ldr	r3, [pc, #604]	; (5648 <grid_port_process_outbound_usb+0x2c4>)
    53ec:	4798      	blx	r3
    53ee:	387f      	subs	r0, #127	; 0x7f
    53f0:	b243      	sxtb	r3, r0
	for (uint16_t i=0; i<message.body_length; i++){
    53f2:	f04f 0a00 	mov.w	sl, #0
	int8_t dy = grid_msg_header_get_dy(&message) - GRID_SYS_DEFAULT_POSITION;	
    53f6:	9301      	str	r3, [sp, #4]
	uint8_t current_start		= 0;
    53f8:	4656      	mov	r6, sl
	for (uint16_t i=0; i<message.body_length; i++){
    53fa:	9a6a      	ldr	r2, [sp, #424]	; 0x1a8
    53fc:	fa1f f38a 	uxth.w	r3, sl
    5400:	429a      	cmp	r2, r3
    5402:	d818      	bhi.n	5436 <grid_port_process_outbound_usb+0xb2>
	uint32_t packet_length = grid_msg_packet_get_length(&message);
    5404:	4b91      	ldr	r3, [pc, #580]	; (564c <grid_port_process_outbound_usb+0x2c8>)
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    5406:	4e92      	ldr	r6, [pc, #584]	; (5650 <grid_port_process_outbound_usb+0x2cc>)
	uint32_t packet_length = grid_msg_packet_get_length(&message);
    5408:	a805      	add	r0, sp, #20
    540a:	4798      	blx	r3
	for (uint32_t i=0; i<packet_length; i++){
    540c:	2400      	movs	r4, #0
	uint32_t packet_length = grid_msg_packet_get_length(&message);
    540e:	4605      	mov	r5, r0
	for (uint32_t i=0; i<packet_length; i++){
    5410:	42ac      	cmp	r4, r5
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    5412:	4621      	mov	r1, r4
	for (uint32_t i=0; i<packet_length; i++){
    5414:	f040 8104 	bne.w	5620 <grid_port_process_outbound_usb+0x29c>
	cdcdf_acm_write(por->tx_double_buffer, packet_length);
    5418:	4b8e      	ldr	r3, [pc, #568]	; (5654 <grid_port_process_outbound_usb+0x2d0>)
    541a:	f108 002c 	add.w	r0, r8, #44	; 0x2c
    541e:	4798      	blx	r3
}
    5420:	e7bc      	b.n	539c <grid_port_process_outbound_usb+0x18>
		uint8_t nextchar = grid_buffer_read_character(&por->tx_buffer);
    5422:	4798      	blx	r3
    5424:	4606      	mov	r6, r0
		grid_msg_packet_receive_char(&message, nextchar);
    5426:	4601      	mov	r1, r0
    5428:	a805      	add	r0, sp, #20
    542a:	47c8      	blx	r9
		por->tx_double_buffer[i] = nextchar;	
    542c:	3701      	adds	r7, #1
    542e:	f80a 6b01 	strb.w	r6, [sl], #1
	for (uint16_t i = 0; i<length; i++){
    5432:	4b81      	ldr	r3, [pc, #516]	; (5638 <grid_port_process_outbound_usb+0x2b4>)
    5434:	e7cb      	b.n	53ce <grid_port_process_outbound_usb+0x4a>
		if (message.body[i] == GRID_CONST_STX){
    5436:	aa05      	add	r2, sp, #20
    5438:	4413      	add	r3, r2
    543a:	7d1b      	ldrb	r3, [r3, #20]
    543c:	2b02      	cmp	r3, #2
    543e:	d104      	bne.n	544a <grid_port_process_outbound_usb+0xc6>
			current_start = i;
    5440:	fa5f f68a 	uxtb.w	r6, sl
	for (uint16_t i=0; i<message.body_length; i++){
    5444:	f10a 0a01 	add.w	sl, sl, #1
    5448:	e7d7      	b.n	53fa <grid_port_process_outbound_usb+0x76>
		else if (message.body[i] == GRID_CONST_ETX && current_start!=0){
    544a:	2b03      	cmp	r3, #3
    544c:	d1fa      	bne.n	5444 <grid_port_process_outbound_usb+0xc0>
    544e:	b90e      	cbnz	r6, 5454 <grid_port_process_outbound_usb+0xd0>
			current_start = 0;
    5450:	2600      	movs	r6, #0
			else if (msg_class == GRID_CLASS_HIDKEYBOARD_code && msg_instr == GRID_INSTR_EXECUTE_code){
    5452:	e7f7      	b.n	5444 <grid_port_process_outbound_usb+0xc0>
			uint8_t msg_class = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_offset, GRID_CLASS_length);
    5454:	4631      	mov	r1, r6
    5456:	2201      	movs	r2, #1
    5458:	a805      	add	r0, sp, #20
    545a:	47a0      	blx	r4
    545c:	4635      	mov	r5, r6
			uint8_t msg_instr = grid_msg_text_get_parameter(&message, current_start, GRID_INSTR_offset, GRID_INSTR_length);
    545e:	2301      	movs	r3, #1
			uint8_t msg_class = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_offset, GRID_CLASS_length);
    5460:	b2c6      	uxtb	r6, r0
			uint8_t msg_instr = grid_msg_text_get_parameter(&message, current_start, GRID_INSTR_offset, GRID_INSTR_length);
    5462:	2204      	movs	r2, #4
    5464:	4629      	mov	r1, r5
    5466:	a805      	add	r0, sp, #20
    5468:	47a0      	blx	r4
    546a:	b2c0      	uxtb	r0, r0
			if (msg_class == GRID_CLASS_MIDIRELATIVE_code && msg_instr == GRID_INSTR_EXECUTE_code){
    546c:	2e00      	cmp	r6, #0
    546e:	d13f      	bne.n	54f0 <grid_port_process_outbound_usb+0x16c>
    5470:	280e      	cmp	r0, #14
    5472:	d1ed      	bne.n	5450 <grid_port_process_outbound_usb+0xcc>
				uint8_t midi_cablecommand = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_CABLECOMMAND_offset,		GRID_CLASS_MIDIRELATIVE_CABLECOMMAND_length);
    5474:	4629      	mov	r1, r5
    5476:	2302      	movs	r3, #2
    5478:	2205      	movs	r2, #5
    547a:	a805      	add	r0, sp, #20
    547c:	47a0      	blx	r4
				uint8_t midi_commandchannel = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_offset ,		GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_length);
    547e:	4629      	mov	r1, r5
    5480:	2302      	movs	r3, #2
    5482:	2207      	movs	r2, #7
    5484:	a805      	add	r0, sp, #20
    5486:	47a0      	blx	r4
				uint8_t midi_param1  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM1_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM1_length);
    5488:	4629      	mov	r1, r5
				uint8_t midi_commandchannel = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_offset ,		GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_length);
    548a:	4681      	mov	r9, r0
				uint8_t midi_param1  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM1_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM1_length);
    548c:	2302      	movs	r3, #2
    548e:	2209      	movs	r2, #9
    5490:	a805      	add	r0, sp, #20
    5492:	47a0      	blx	r4
				uint8_t midi_param2  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM2_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM2_length);
    5494:	4629      	mov	r1, r5
				uint8_t midi_param1  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM1_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM1_length);
    5496:	4607      	mov	r7, r0
				uint8_t midi_param2  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM2_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM2_length);
    5498:	2302      	movs	r3, #2
    549a:	220b      	movs	r2, #11
    549c:	a805      	add	r0, sp, #20
    549e:	47a0      	blx	r4
				uint8_t midi_channel = ((256-dy*1)%4+grid_sys_state.bank_activebank_number*4)%16;
    54a0:	9901      	ldr	r1, [sp, #4]
    54a2:	4a6d      	ldr	r2, [pc, #436]	; (5658 <grid_port_process_outbound_usb+0x2d4>)
				uint8_t midi_param2  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM2_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM2_length);
    54a4:	f88d 000f 	strb.w	r0, [sp, #15]
				uint8_t midi_command = 	(midi_commandchannel&0xF0)>>4;
    54a8:	f3c9 1303 	ubfx	r3, r9, #4, #4
				uint8_t midi_channel = ((256-dy*1)%4+grid_sys_state.bank_activebank_number*4)%16;
    54ac:	7bd2      	ldrb	r2, [r2, #15]
				midievent.byte0 = 0<<4|midi_command;
    54ae:	f88d 300c 	strb.w	r3, [sp, #12]
				uint8_t midi_channel = ((256-dy*1)%4+grid_sys_state.bank_activebank_number*4)%16;
    54b2:	f1c1 0900 	rsb	r9, r1, #0
    54b6:	f009 0903 	and.w	r9, r9, #3
    54ba:	eb09 0982 	add.w	r9, r9, r2, lsl #2
    54be:	f009 090f 	and.w	r9, r9, #15
				midievent.byte1 = midi_command<<4|midi_channel;
    54c2:	ea49 1903 	orr.w	r9, r9, r3, lsl #4
				midi_param1  = (256-32+midi_param1 + 16*dx)%96; // 96-128 reserved
    54c6:	b2ff      	uxtb	r7, r7
    54c8:	9b00      	ldr	r3, [sp, #0]
				midievent.byte1 = midi_command<<4|midi_channel;
    54ca:	f88d 900d 	strb.w	r9, [sp, #13]
				midi_param1  = (256-32+midi_param1 + 16*dx)%96; // 96-128 reserved
    54ce:	37e0      	adds	r7, #224	; 0xe0
    54d0:	2260      	movs	r2, #96	; 0x60
    54d2:	eb07 1703 	add.w	r7, r7, r3, lsl #4
    54d6:	fb97 f3f2 	sdiv	r3, r7, r2
    54da:	fb02 7713 	mls	r7, r2, r3, r7
    54de:	f88d 700e 	strb.w	r7, [sp, #14]
				grid_midi_tx_push(midievent);
    54e2:	9803      	ldr	r0, [sp, #12]
    54e4:	4b5d      	ldr	r3, [pc, #372]	; (565c <grid_port_process_outbound_usb+0x2d8>)
    54e6:	4798      	blx	r3
				grid_midi_tx_pop(midievent);				
    54e8:	9803      	ldr	r0, [sp, #12]
    54ea:	4b5d      	ldr	r3, [pc, #372]	; (5660 <grid_port_process_outbound_usb+0x2dc>)
    54ec:	4798      	blx	r3
			if (msg_class == GRID_CLASS_MIDIRELATIVE_code && msg_instr == GRID_INSTR_EXECUTE_code){
    54ee:	e7a9      	b.n	5444 <grid_port_process_outbound_usb+0xc0>
			else if (msg_class == GRID_CLASS_MIDIABSOLUTE_code && msg_instr == GRID_INSTR_EXECUTE_code){
    54f0:	2e01      	cmp	r6, #1
    54f2:	d127      	bne.n	5544 <grid_port_process_outbound_usb+0x1c0>
    54f4:	280e      	cmp	r0, #14
    54f6:	d1ab      	bne.n	5450 <grid_port_process_outbound_usb+0xcc>
				uint8_t midi_cablecommand =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_offset,		GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_length);
    54f8:	4629      	mov	r1, r5
    54fa:	2302      	movs	r3, #2
    54fc:	2205      	movs	r2, #5
    54fe:	a805      	add	r0, sp, #20
    5500:	47a0      	blx	r4
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    5502:	4629      	mov	r1, r5
				uint8_t midi_cablecommand =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_offset,		GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_length);
    5504:	4681      	mov	r9, r0
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    5506:	2302      	movs	r3, #2
    5508:	2207      	movs	r2, #7
    550a:	a805      	add	r0, sp, #20
    550c:	47a0      	blx	r4
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    550e:	4629      	mov	r1, r5
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    5510:	4607      	mov	r7, r0
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    5512:	2302      	movs	r3, #2
    5514:	2209      	movs	r2, #9
    5516:	a805      	add	r0, sp, #20
    5518:	47a0      	blx	r4
				uint8_t midi_param2  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM2_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM2_length);
    551a:	220b      	movs	r2, #11
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    551c:	4606      	mov	r6, r0
				uint8_t midi_param2  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM2_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM2_length);
    551e:	4629      	mov	r1, r5
    5520:	2302      	movs	r3, #2
    5522:	a805      	add	r0, sp, #20
    5524:	47a0      	blx	r4
				uint8_t midi_cablecommand =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_offset,		GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_length);
    5526:	f88d 900c 	strb.w	r9, [sp, #12]
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    552a:	f88d 700d 	strb.w	r7, [sp, #13]
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    552e:	f88d 600e 	strb.w	r6, [sp, #14]
				uint8_t midi_param2  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM2_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM2_length);
    5532:	f88d 000f 	strb.w	r0, [sp, #15]
				grid_midi_tx_push(midievent);
    5536:	9803      	ldr	r0, [sp, #12]
    5538:	4b48      	ldr	r3, [pc, #288]	; (565c <grid_port_process_outbound_usb+0x2d8>)
    553a:	4798      	blx	r3
				grid_midi_tx_pop(midievent);	
    553c:	9803      	ldr	r0, [sp, #12]
    553e:	4b48      	ldr	r3, [pc, #288]	; (5660 <grid_port_process_outbound_usb+0x2dc>)
    5540:	4798      	blx	r3
    5542:	e785      	b.n	5450 <grid_port_process_outbound_usb+0xcc>
			else if (msg_class == GRID_CLASS_HIDKEYBOARD_code && msg_instr == GRID_INSTR_EXECUTE_code){
    5544:	2e90      	cmp	r6, #144	; 0x90
    5546:	d11d      	bne.n	5584 <grid_port_process_outbound_usb+0x200>
    5548:	280e      	cmp	r0, #14
    554a:	d181      	bne.n	5450 <grid_port_process_outbound_usb+0xcc>
				uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_offset,		GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_length);
    554c:	4629      	mov	r1, r5
    554e:	2302      	movs	r3, #2
    5550:	2205      	movs	r2, #5
    5552:	a805      	add	r0, sp, #20
    5554:	47a0      	blx	r4
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    5556:	4629      	mov	r1, r5
				uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_offset,		GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_length);
    5558:	4607      	mov	r7, r0
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    555a:	2302      	movs	r3, #2
    555c:	2207      	movs	r2, #7
    555e:	a805      	add	r0, sp, #20
    5560:	47a0      	blx	r4
				uint8_t key_state  =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYSTATE_offset  ,			GRID_CLASS_HIDKEYBOARD_KEYSTATE_length);
    5562:	4629      	mov	r1, r5
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    5564:	4606      	mov	r6, r0
				uint8_t key_state  =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYSTATE_offset  ,			GRID_CLASS_HIDKEYBOARD_KEYSTATE_length);
    5566:	2302      	movs	r3, #2
    5568:	2209      	movs	r2, #9
    556a:	a805      	add	r0, sp, #20
    556c:	47a0      	blx	r4
				grid_keyboard_keychange(&grid_keyboard_state, &key);
    556e:	4b3d      	ldr	r3, [pc, #244]	; (5664 <grid_port_process_outbound_usb+0x2e0>)
				uint8_t key_state  =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYSTATE_offset  ,			GRID_CLASS_HIDKEYBOARD_KEYSTATE_length);
    5570:	f88d 000e 	strb.w	r0, [sp, #14]
				grid_keyboard_keychange(&grid_keyboard_state, &key);
    5574:	a903      	add	r1, sp, #12
    5576:	483c      	ldr	r0, [pc, #240]	; (5668 <grid_port_process_outbound_usb+0x2e4>)
				uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_offset,		GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_length);
    5578:	f88d 700d 	strb.w	r7, [sp, #13]
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    557c:	f88d 600c 	strb.w	r6, [sp, #12]
				grid_keyboard_keychange(&grid_keyboard_state, &key);
    5580:	4798      	blx	r3
    5582:	e765      	b.n	5450 <grid_port_process_outbound_usb+0xcc>
			else if (msg_class == GRID_CLASS_HIDKEYMACRO_code && msg_instr == GRID_INSTR_EXECUTE_code){
    5584:	2e91      	cmp	r6, #145	; 0x91
    5586:	f47f af63 	bne.w	5450 <grid_port_process_outbound_usb+0xcc>
    558a:	280e      	cmp	r0, #14
    558c:	f47f af60 	bne.w	5450 <grid_port_process_outbound_usb+0xcc>
    5590:	2605      	movs	r6, #5
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    5592:	2302      	movs	r3, #2
    5594:	4632      	mov	r2, r6
    5596:	4629      	mov	r1, r5
    5598:	a805      	add	r0, sp, #20
    559a:	47a0      	blx	r4
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    559c:	1cb2      	adds	r2, r6, #2
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    559e:	4607      	mov	r7, r0
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    55a0:	2302      	movs	r3, #2
    55a2:	b2d2      	uxtb	r2, r2
    55a4:	4629      	mov	r1, r5
    55a6:	a805      	add	r0, sp, #20
    55a8:	47a0      	blx	r4
    55aa:	b2c0      	uxtb	r0, r0
                    if (key_code != 255){
    55ac:	28ff      	cmp	r0, #255	; 0xff
    55ae:	d00d      	beq.n	55cc <grid_port_process_outbound_usb+0x248>
                        key.ispressed = 1;
    55b0:	2201      	movs	r2, #1
    55b2:	f88d 200e 	strb.w	r2, [sp, #14]
                        key.delay = 100;
    55b6:	2264      	movs	r2, #100	; 0x64
                        key.ismodifier = key_ismodifier;
    55b8:	ab03      	add	r3, sp, #12
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    55ba:	f88d 700d 	strb.w	r7, [sp, #13]
                        key.keycode = key_code;
    55be:	f88d 000c 	strb.w	r0, [sp, #12]
                        key.delay = 100;
    55c2:	9204      	str	r2, [sp, #16]
                        grid_keyboard_tx_push(key);
    55c4:	e893 0003 	ldmia.w	r3, {r0, r1}
    55c8:	4b28      	ldr	r3, [pc, #160]	; (566c <grid_port_process_outbound_usb+0x2e8>)
    55ca:	4798      	blx	r3
				for (uint8_t k=0; k<6; k++){
    55cc:	3604      	adds	r6, #4
    55ce:	b2f6      	uxtb	r6, r6
    55d0:	2e1d      	cmp	r6, #29
    55d2:	d1de      	bne.n	5592 <grid_port_process_outbound_usb+0x20e>
                delay_ms(5);
    55d4:	4b26      	ldr	r3, [pc, #152]	; (5670 <grid_port_process_outbound_usb+0x2ec>)
    55d6:	2005      	movs	r0, #5
    55d8:	4798      	blx	r3
    55da:	2605      	movs	r6, #5
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    55dc:	2302      	movs	r3, #2
    55de:	4632      	mov	r2, r6
    55e0:	4629      	mov	r1, r5
    55e2:	a805      	add	r0, sp, #20
    55e4:	47a0      	blx	r4
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    55e6:	1cb2      	adds	r2, r6, #2
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    55e8:	4607      	mov	r7, r0
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    55ea:	2302      	movs	r3, #2
    55ec:	b2d2      	uxtb	r2, r2
    55ee:	4629      	mov	r1, r5
    55f0:	a805      	add	r0, sp, #20
    55f2:	47a0      	blx	r4
    55f4:	b2c0      	uxtb	r0, r0
                    if (key_code != 255){
    55f6:	28ff      	cmp	r0, #255	; 0xff
    55f8:	d00d      	beq.n	5616 <grid_port_process_outbound_usb+0x292>
                        key.ispressed = 0;
    55fa:	2200      	movs	r2, #0
    55fc:	f88d 200e 	strb.w	r2, [sp, #14]
                        key.delay = 100;
    5600:	2264      	movs	r2, #100	; 0x64
                        key.ismodifier = key_ismodifier;
    5602:	ab03      	add	r3, sp, #12
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    5604:	f88d 700d 	strb.w	r7, [sp, #13]
                        key.keycode = key_code;
    5608:	f88d 000c 	strb.w	r0, [sp, #12]
                        key.delay = 100;
    560c:	9204      	str	r2, [sp, #16]
                        grid_keyboard_tx_push(key);
    560e:	e893 0003 	ldmia.w	r3, {r0, r1}
    5612:	4b16      	ldr	r3, [pc, #88]	; (566c <grid_port_process_outbound_usb+0x2e8>)
    5614:	4798      	blx	r3
				for (uint8_t k=0; k<6; k++){
    5616:	3604      	adds	r6, #4
    5618:	b2f6      	uxtb	r6, r6
    561a:	2e1d      	cmp	r6, #29
    561c:	d1de      	bne.n	55dc <grid_port_process_outbound_usb+0x258>
    561e:	e717      	b.n	5450 <grid_port_process_outbound_usb+0xcc>
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    5620:	a805      	add	r0, sp, #20
    5622:	47b0      	blx	r6
	for (uint32_t i=0; i<packet_length; i++){
    5624:	3401      	adds	r4, #1
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    5626:	f80b 0b01 	strb.w	r0, [fp], #1
	for (uint32_t i=0; i<packet_length; i++){
    562a:	e6f1      	b.n	5410 <grid_port_process_outbound_usb+0x8c>
    562c:	00004ebd 	.word	0x00004ebd
    5630:	0000857d 	.word	0x0000857d
    5634:	00004f13 	.word	0x00004f13
    5638:	00004f7b 	.word	0x00004f7b
    563c:	00004fa5 	.word	0x00004fa5
    5640:	00008545 	.word	0x00008545
    5644:	00008439 	.word	0x00008439
    5648:	00008479 	.word	0x00008479
    564c:	000084d9 	.word	0x000084d9
    5650:	00008673 	.word	0x00008673
    5654:	0000bd51 	.word	0x0000bd51
    5658:	2000f008 	.word	0x2000f008
    565c:	0000aed9 	.word	0x0000aed9
    5660:	0000af01 	.word	0x0000af01
    5664:	0000ad11 	.word	0x0000ad11
    5668:	20010264 	.word	0x20010264
    566c:	0000afe9 	.word	0x0000afe9
    5670:	0000dd8d 	.word	0x0000dd8d
    5674:	00008625 	.word	0x00008625

00005678 <grid_port_process_outbound_ui>:

uint8_t grid_port_process_outbound_ui(struct grid_port* por){
    5678:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    567c:	ed2d 8b02 	vpush	{d8}
	
	
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    5680:	f500 541c 	add.w	r4, r0, #9984	; 0x2700
    5684:	343c      	adds	r4, #60	; 0x3c
uint8_t grid_port_process_outbound_ui(struct grid_port* por){
    5686:	f5ad 7d7b 	sub.w	sp, sp, #1004	; 0x3ec
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    568a:	4bb5      	ldr	r3, [pc, #724]	; (5960 <grid_port_process_outbound_ui+0x2e8>)
    568c:	4620      	mov	r0, r4
    568e:	4798      	blx	r3
	
	if (!length){
    5690:	2500      	movs	r5, #0
    5692:	9006      	str	r0, [sp, #24]
    5694:	b928      	cbnz	r0, 56a2 <grid_port_process_outbound_ui+0x2a>

		
	}
	
	
}
    5696:	f50d 7d7b 	add.w	sp, sp, #1004	; 0x3ec
    569a:	ecbd 8b02 	vpop	{d8}
    569e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint8_t message[GRID_PARAMETER_PACKET_maxlength] = {0};
    56a2:	4bb0      	ldr	r3, [pc, #704]	; (5964 <grid_port_process_outbound_ui+0x2ec>)
    56a4:	952f      	str	r5, [sp, #188]	; 0xbc
    56a6:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    56aa:	4629      	mov	r1, r5
    56ac:	a830      	add	r0, sp, #192	; 0xc0
    56ae:	4798      	blx	r3
		grid_buffer_read_init(&por->tx_buffer);
    56b0:	4bad      	ldr	r3, [pc, #692]	; (5968 <grid_port_process_outbound_ui+0x2f0>)
			message[i] = grid_buffer_read_character(&por->tx_buffer);
    56b2:	4fae      	ldr	r7, [pc, #696]	; (596c <grid_port_process_outbound_ui+0x2f4>)
		grid_buffer_read_init(&por->tx_buffer);
    56b4:	4620      	mov	r0, r4
    56b6:	4798      	blx	r3
		uint8_t message[GRID_PARAMETER_PACKET_maxlength] = {0};
    56b8:	ae2f      	add	r6, sp, #188	; 0xbc
		for (uint16_t i = 0; i<length; i++){
    56ba:	9a06      	ldr	r2, [sp, #24]
    56bc:	b2ab      	uxth	r3, r5
    56be:	429a      	cmp	r2, r3
			message[i] = grid_buffer_read_character(&por->tx_buffer);
    56c0:	4620      	mov	r0, r4
		for (uint16_t i = 0; i<length; i++){
    56c2:	d839      	bhi.n	5738 <grid_port_process_outbound_ui+0xc0>
		grid_buffer_read_acknowledge(&por->tx_buffer);
    56c4:	4baa      	ldr	r3, [pc, #680]	; (5970 <grid_port_process_outbound_ui+0x2f8>)
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    56c6:	4fab      	ldr	r7, [pc, #684]	; (5974 <grid_port_process_outbound_ui+0x2fc>)
		grid_buffer_read_acknowledge(&por->tx_buffer);
    56c8:	4798      	blx	r3
		uint8_t error=0;
    56ca:	2500      	movs	r5, #0
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    56cc:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    56d0:	2202      	movs	r2, #2
    56d2:	2106      	movs	r1, #6
    56d4:	4630      	mov	r0, r6
		uint8_t error=0;
    56d6:	f88d 5026 	strb.w	r5, [sp, #38]	; 0x26
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    56da:	47b8      	blx	r7
		uint8_t dy = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    56dc:	f10d 0326 	add.w	r3, sp, #38	; 0x26
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    56e0:	fa5f fb80 	uxtb.w	fp, r0
		uint8_t dy = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    56e4:	2202      	movs	r2, #2
    56e6:	2108      	movs	r1, #8
    56e8:	4630      	mov	r0, r6
    56ea:	47b8      	blx	r7
		if (dx == GRID_SYS_DEFAULT_POSITION && dy == GRID_SYS_DEFAULT_POSITION){
    56ec:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
		uint8_t dy = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    56f0:	b2c0      	uxtb	r0, r0
		if (dx == GRID_SYS_DEFAULT_POSITION && dy == GRID_SYS_DEFAULT_POSITION){
    56f2:	d125      	bne.n	5740 <grid_port_process_outbound_ui+0xc8>
			position_is_me = 1;
    56f4:	f1a0 027f 	sub.w	r2, r0, #127	; 0x7f
    56f8:	f1d2 0b00 	rsbs	fp, r2, #0
    56fc:	eb4b 0b02 	adc.w	fp, fp, r2
		uint8_t position_is_local = 0;
    5700:	462c      	mov	r4, r5
		uint8_t position_is_global = 0;
    5702:	9502      	str	r5, [sp, #8]
		uint8_t error_flag = 0;	
    5704:	2300      	movs	r3, #0
				uint8_t msg_class = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_offset], GRID_CLASS_length, &error_flag);
    5706:	4d9c      	ldr	r5, [pc, #624]	; (5978 <grid_port_process_outbound_ui+0x300>)
					grid_ui_event_generate_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    5708:	f8df a298 	ldr.w	sl, [pc, #664]	; 59a4 <grid_port_process_outbound_ui+0x32c>
		uint8_t error_flag = 0;	
    570c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    5710:	9303      	str	r3, [sp, #12]
		uint8_t current_start		= 0;
    5712:	4698      	mov	r8, r3
			if (message[i] == GRID_CONST_STX){
    5714:	9b03      	ldr	r3, [sp, #12]
    5716:	f10d 09bc 	add.w	r9, sp, #188	; 0xbc
    571a:	f813 1009 	ldrb.w	r1, [r3, r9]
    571e:	2902      	cmp	r1, #2
    5720:	d120      	bne.n	5764 <grid_port_process_outbound_ui+0xec>
				current_start = i;
    5722:	f89d 800c 	ldrb.w	r8, [sp, #12]
		for (uint16_t i=0; i<length; i++){
    5726:	9b03      	ldr	r3, [sp, #12]
    5728:	9a06      	ldr	r2, [sp, #24]
    572a:	3301      	adds	r3, #1
    572c:	9303      	str	r3, [sp, #12]
    572e:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    5732:	429a      	cmp	r2, r3
    5734:	d8ee      	bhi.n	5714 <grid_port_process_outbound_ui+0x9c>
    5736:	e7ae      	b.n	5696 <grid_port_process_outbound_ui+0x1e>
			message[i] = grid_buffer_read_character(&por->tx_buffer);
    5738:	47b8      	blx	r7
    573a:	5570      	strb	r0, [r6, r5]
		for (uint16_t i = 0; i<length; i++){
    573c:	3501      	adds	r5, #1
    573e:	e7bc      	b.n	56ba <grid_port_process_outbound_ui+0x42>
		else if (dx == GRID_SYS_GLOBAL_POSITION && dy==GRID_SYS_GLOBAL_POSITION){
    5740:	f1bb 0f00 	cmp.w	fp, #0
    5744:	d105      	bne.n	5752 <grid_port_process_outbound_ui+0xda>
		uint8_t position_is_global = 0;
    5746:	fab0 f380 	clz	r3, r0
    574a:	095b      	lsrs	r3, r3, #5
    574c:	9302      	str	r3, [sp, #8]
		uint8_t position_is_local = 0;
    574e:	465c      	mov	r4, fp
    5750:	e7d8      	b.n	5704 <grid_port_process_outbound_ui+0x8c>
		else if (dx == GRID_SYS_LOCAL_POSITION && dy==GRID_SYS_LOCAL_POSITION){
    5752:	ea0b 0000 	and.w	r0, fp, r0
    5756:	f1a0 03ff 	sub.w	r3, r0, #255	; 0xff
    575a:	425c      	negs	r4, r3
    575c:	415c      	adcs	r4, r3
		uint8_t position_is_global = 0;
    575e:	46ab      	mov	fp, r5
		uint8_t position_is_me = 0;
    5760:	9502      	str	r5, [sp, #8]
    5762:	e7cf      	b.n	5704 <grid_port_process_outbound_ui+0x8c>
			else if (message[i] == GRID_CONST_ETX && current_start!=0){
    5764:	2903      	cmp	r1, #3
    5766:	d1de      	bne.n	5726 <grid_port_process_outbound_ui+0xae>
    5768:	f1b8 0f00 	cmp.w	r8, #0
    576c:	d102      	bne.n	5774 <grid_port_process_outbound_ui+0xfc>
				current_start = 0;
    576e:	f04f 0800 	mov.w	r8, #0
				else if (msg_class == GRID_CLASS_LEDCOLOR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_local || position_is_me)){
    5772:	e7d8      	b.n	5726 <grid_port_process_outbound_ui+0xae>
				uint8_t msg_class = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_offset], GRID_CLASS_length, &error_flag);
    5774:	f108 0001 	add.w	r0, r8, #1
    5778:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    577c:	4448      	add	r0, r9
    577e:	47a8      	blx	r5
    5780:	b2c6      	uxtb	r6, r0
				uint8_t msg_instr = grid_sys_read_hex_string_value(&message[current_start+GRID_INSTR_offset], GRID_INSTR_length, &error_flag);
    5782:	f108 0004 	add.w	r0, r8, #4
    5786:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    578a:	2101      	movs	r1, #1
    578c:	4448      	add	r0, r9
    578e:	47a8      	blx	r5
				if (msg_class == GRID_CLASS_BANKACTIVE_code){
    5790:	2e30      	cmp	r6, #48	; 0x30
				uint8_t msg_instr = grid_sys_read_hex_string_value(&message[current_start+GRID_INSTR_offset], GRID_INSTR_length, &error_flag);
    5792:	b2c7      	uxtb	r7, r0
				if (msg_class == GRID_CLASS_BANKACTIVE_code){
    5794:	d126      	bne.n	57e4 <grid_port_process_outbound_ui+0x16c>
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKACTIVE_BANKNUMBER_offset], GRID_CLASS_BANKACTIVE_BANKNUMBER_length, &error_flag);
    5796:	f108 0005 	add.w	r0, r8, #5
    579a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    579e:	2102      	movs	r1, #2
    57a0:	4448      	add	r0, r9
    57a2:	47a8      	blx	r5
					if (msg_instr == GRID_INSTR_EXECUTE_code){ //SET BANK
    57a4:	2f0e      	cmp	r7, #14
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKACTIVE_BANKNUMBER_offset], GRID_CLASS_BANKACTIVE_BANKNUMBER_length, &error_flag);
    57a6:	4606      	mov	r6, r0
					if (msg_instr == GRID_INSTR_EXECUTE_code){ //SET BANK
    57a8:	d10e      	bne.n	57c8 <grid_port_process_outbound_ui+0x150>
						if (grid_sys_get_bank_valid(&grid_sys_state) == 0){
    57aa:	4874      	ldr	r0, [pc, #464]	; (597c <grid_port_process_outbound_ui+0x304>)
    57ac:	4b74      	ldr	r3, [pc, #464]	; (5980 <grid_port_process_outbound_ui+0x308>)
    57ae:	4798      	blx	r3
    57b0:	4602      	mov	r2, r0
    57b2:	b920      	cbnz	r0, 57be <grid_port_process_outbound_ui+0x146>
							grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_HEARTBEAT);
    57b4:	4601      	mov	r1, r0
    57b6:	4f73      	ldr	r7, [pc, #460]	; (5984 <grid_port_process_outbound_ui+0x30c>)
    57b8:	4873      	ldr	r0, [pc, #460]	; (5988 <grid_port_process_outbound_ui+0x310>)
    57ba:	230c      	movs	r3, #12
    57bc:	47b8      	blx	r7
						grid_sys_set_bank(&grid_sys_state, banknumber);
    57be:	486f      	ldr	r0, [pc, #444]	; (597c <grid_port_process_outbound_ui+0x304>)
    57c0:	b2f1      	uxtb	r1, r6
								grid_sys_set_bank(&grid_sys_state, banknumber);
    57c2:	4b72      	ldr	r3, [pc, #456]	; (598c <grid_port_process_outbound_ui+0x314>)
					grid_sys_recall_configuration(&grid_sys_state, banknumber);
    57c4:	4798      	blx	r3
    57c6:	e7d2      	b.n	576e <grid_port_process_outbound_ui+0xf6>
					else if (msg_instr == GRID_INSTR_FETCH_code){ //GET BANK
    57c8:	2f0f      	cmp	r7, #15
    57ca:	d1d0      	bne.n	576e <grid_port_process_outbound_ui+0xf6>
						if (grid_sys_get_bank_valid(&grid_sys_state) != 0){
    57cc:	486b      	ldr	r0, [pc, #428]	; (597c <grid_port_process_outbound_ui+0x304>)
    57ce:	4b6c      	ldr	r3, [pc, #432]	; (5980 <grid_port_process_outbound_ui+0x308>)
    57d0:	4798      	blx	r3
    57d2:	2800      	cmp	r0, #0
    57d4:	d0cb      	beq.n	576e <grid_port_process_outbound_ui+0xf6>
							grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_RESPONSE);
    57d6:	2200      	movs	r2, #0
    57d8:	486b      	ldr	r0, [pc, #428]	; (5988 <grid_port_process_outbound_ui+0x310>)
    57da:	4e6a      	ldr	r6, [pc, #424]	; (5984 <grid_port_process_outbound_ui+0x30c>)
    57dc:	2309      	movs	r3, #9
    57de:	4611      	mov	r1, r2
    57e0:	47b0      	blx	r6
    57e2:	e7c4      	b.n	576e <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_BANKENABLED_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_global || position_is_me || position_is_local)){
    57e4:	2e31      	cmp	r6, #49	; 0x31
    57e6:	d140      	bne.n	586a <grid_port_process_outbound_ui+0x1f2>
    57e8:	2f0e      	cmp	r7, #14
    57ea:	d1c0      	bne.n	576e <grid_port_process_outbound_ui+0xf6>
    57ec:	9b02      	ldr	r3, [sp, #8]
    57ee:	ea4b 0303 	orr.w	r3, fp, r3
    57f2:	4323      	orrs	r3, r4
    57f4:	d0bb      	beq.n	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKENABLED_BANKNUMBER_offset], GRID_CLASS_BANKENABLED_BANKNUMBER_length, &error_flag);
    57f6:	f108 0005 	add.w	r0, r8, #5
    57fa:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    57fe:	2102      	movs	r1, #2
    5800:	4448      	add	r0, r9
    5802:	47a8      	blx	r5
    5804:	b2c6      	uxtb	r6, r0
					uint8_t isenabled  = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKENABLED_ISENABLED_offset], GRID_CLASS_BANKENABLED_ISENABLED_length, &error_flag);
    5806:	f108 0007 	add.w	r0, r8, #7
    580a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    580e:	2102      	movs	r1, #2
    5810:	4448      	add	r0, r9
    5812:	47a8      	blx	r5
    5814:	fa5f f880 	uxtb.w	r8, r0
					if (isenabled == 1){
    5818:	f1b8 0f01 	cmp.w	r8, #1
    581c:	d110      	bne.n	5840 <grid_port_process_outbound_ui+0x1c8>
						grid_sys_bank_enable(&grid_sys_state, banknumber);
    581e:	4f57      	ldr	r7, [pc, #348]	; (597c <grid_port_process_outbound_ui+0x304>)
    5820:	4b5b      	ldr	r3, [pc, #364]	; (5990 <grid_port_process_outbound_ui+0x318>)
    5822:	4631      	mov	r1, r6
    5824:	4638      	mov	r0, r7
    5826:	4798      	blx	r3
						if (grid_sys_get_bank_num(&grid_sys_state) == banknumber){
    5828:	4b5a      	ldr	r3, [pc, #360]	; (5994 <grid_port_process_outbound_ui+0x31c>)
    582a:	4638      	mov	r0, r7
    582c:	4798      	blx	r3
    582e:	42b0      	cmp	r0, r6
    5830:	d19d      	bne.n	576e <grid_port_process_outbound_ui+0xf6>
							if (grid_sys_state.bank_activebank_valid == 1){
    5832:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    5836:	2b01      	cmp	r3, #1
    5838:	d199      	bne.n	576e <grid_port_process_outbound_ui+0xf6>
								grid_sys_set_bank(&grid_sys_state, banknumber);
    583a:	4631      	mov	r1, r6
    583c:	4638      	mov	r0, r7
    583e:	e7c0      	b.n	57c2 <grid_port_process_outbound_ui+0x14a>
					}else if (isenabled == 0){	
    5840:	f1b8 0f00 	cmp.w	r8, #0
    5844:	d193      	bne.n	576e <grid_port_process_outbound_ui+0xf6>
						if (grid_sys_get_bank_num(&grid_sys_state) == banknumber){
    5846:	484d      	ldr	r0, [pc, #308]	; (597c <grid_port_process_outbound_ui+0x304>)
    5848:	4b52      	ldr	r3, [pc, #328]	; (5994 <grid_port_process_outbound_ui+0x31c>)
    584a:	4798      	blx	r3
    584c:	42b0      	cmp	r0, r6
    584e:	d107      	bne.n	5860 <grid_port_process_outbound_ui+0x1e8>
							if (grid_sys_state.bank_activebank_valid == 1){
    5850:	484a      	ldr	r0, [pc, #296]	; (597c <grid_port_process_outbound_ui+0x304>)
    5852:	f890 3023 	ldrb.w	r3, [r0, #35]	; 0x23
    5856:	2b01      	cmp	r3, #1
    5858:	d102      	bne.n	5860 <grid_port_process_outbound_ui+0x1e8>
								grid_sys_set_bank(&grid_sys_state, 255);
    585a:	4b4c      	ldr	r3, [pc, #304]	; (598c <grid_port_process_outbound_ui+0x314>)
    585c:	21ff      	movs	r1, #255	; 0xff
    585e:	4798      	blx	r3
						grid_sys_bank_disable(&grid_sys_state, banknumber);
    5860:	4b4d      	ldr	r3, [pc, #308]	; (5998 <grid_port_process_outbound_ui+0x320>)
    5862:	4846      	ldr	r0, [pc, #280]	; (597c <grid_port_process_outbound_ui+0x304>)
    5864:	4631      	mov	r1, r6
    5866:	4798      	blx	r3
    5868:	e75d      	b.n	5726 <grid_port_process_outbound_ui+0xae>
				else if (msg_class == GRID_CLASS_BANKCOLOR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_global || position_is_me || position_is_local)){
    586a:	2e32      	cmp	r6, #50	; 0x32
    586c:	d147      	bne.n	58fe <grid_port_process_outbound_ui+0x286>
    586e:	2f0e      	cmp	r7, #14
    5870:	f47f af7d 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5874:	9b02      	ldr	r3, [sp, #8]
    5876:	ea4b 0303 	orr.w	r3, fp, r3
    587a:	4323      	orrs	r3, r4
    587c:	f43f af77 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_NUM_offset], GRID_CLASS_BANKCOLOR_NUM_length, &error_flag);
    5880:	f108 0005 	add.w	r0, r8, #5
    5884:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5888:	2102      	movs	r1, #2
    588a:	4448      	add	r0, r9
    588c:	47a8      	blx	r5
    588e:	b2c3      	uxtb	r3, r0
					uint8_t red		   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_RED_offset], GRID_CLASS_BANKCOLOR_RED_length, &error_flag);
    5890:	f108 0007 	add.w	r0, r8, #7
    5894:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5898:	2102      	movs	r1, #2
    589a:	4448      	add	r0, r9
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_NUM_offset], GRID_CLASS_BANKCOLOR_NUM_length, &error_flag);
    589c:	ee08 3a10 	vmov	s16, r3
					uint8_t red		   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_RED_offset], GRID_CLASS_BANKCOLOR_RED_length, &error_flag);
    58a0:	47a8      	blx	r5
    58a2:	4606      	mov	r6, r0
					uint8_t green	   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_GRE_offset], GRID_CLASS_BANKCOLOR_GRE_length, &error_flag);
    58a4:	f108 0009 	add.w	r0, r8, #9
    58a8:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    58ac:	2102      	movs	r1, #2
    58ae:	4448      	add	r0, r9
    58b0:	47a8      	blx	r5
    58b2:	4607      	mov	r7, r0
					uint8_t blue	   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_BLU_offset], GRID_CLASS_BANKCOLOR_BLU_length, &error_flag);
    58b4:	f108 000b 	add.w	r0, r8, #11
    58b8:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    58bc:	2102      	movs	r1, #2
    58be:	4448      	add	r0, r9
					grid_sys_bank_set_color(&grid_sys_state, banknumber, (red<<16) + (green<<8) + (blue<<0) );
    58c0:	0436      	lsls	r6, r6, #16
    58c2:	023f      	lsls	r7, r7, #8
					uint8_t blue	   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_BLU_offset], GRID_CLASS_BANKCOLOR_BLU_length, &error_flag);
    58c4:	47a8      	blx	r5
					grid_sys_bank_set_color(&grid_sys_state, banknumber, (red<<16) + (green<<8) + (blue<<0) );
    58c6:	b2bf      	uxth	r7, r7
    58c8:	f406 067f 	and.w	r6, r6, #16711680	; 0xff0000
    58cc:	433e      	orrs	r6, r7
    58ce:	4f2b      	ldr	r7, [pc, #172]	; (597c <grid_port_process_outbound_ui+0x304>)
    58d0:	4b32      	ldr	r3, [pc, #200]	; (599c <grid_port_process_outbound_ui+0x324>)
    58d2:	fa56 f280 	uxtab	r2, r6, r0
    58d6:	ee18 1a10 	vmov	r1, s16
    58da:	4638      	mov	r0, r7
    58dc:	4798      	blx	r3
					if (grid_sys_get_bank_num(&grid_sys_state) == banknumber){
    58de:	4b2d      	ldr	r3, [pc, #180]	; (5994 <grid_port_process_outbound_ui+0x31c>)
    58e0:	4638      	mov	r0, r7
    58e2:	4798      	blx	r3
    58e4:	ee18 3a10 	vmov	r3, s16
    58e8:	4298      	cmp	r0, r3
    58ea:	f47f af40 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
						if (grid_sys_state.bank_activebank_valid == 1){
    58ee:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    58f2:	2b01      	cmp	r3, #1
    58f4:	f47f af3b 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
							grid_sys_set_bank(&grid_sys_state, banknumber);
    58f8:	ee18 1a10 	vmov	r1, s16
    58fc:	e79e      	b.n	583c <grid_port_process_outbound_ui+0x1c4>
				else if (msg_class == GRID_CLASS_LEDPHASE_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_local || position_is_me)){
    58fe:	2e40      	cmp	r6, #64	; 0x40
    5900:	d154      	bne.n	59ac <grid_port_process_outbound_ui+0x334>
    5902:	2f0e      	cmp	r7, #14
    5904:	f47f af33 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5908:	ea5b 0304 	orrs.w	r3, fp, r4
    590c:	f43f af2f 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t led_num  = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDPHASE_NUM_offset], GRID_CLASS_LEDPHASE_NUM_length, &error_flag);
    5910:	f108 0005 	add.w	r0, r8, #5
    5914:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5918:	2102      	movs	r1, #2
    591a:	4448      	add	r0, r9
    591c:	47a8      	blx	r5
    591e:	b2c6      	uxtb	r6, r0
					uint8_t led_lay = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDPHASE_LAY_offset], GRID_CLASS_LEDPHASE_LAY_length, &error_flag);
    5920:	f108 0007 	add.w	r0, r8, #7
    5924:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5928:	2102      	movs	r1, #2
    592a:	4448      	add	r0, r9
    592c:	47a8      	blx	r5
    592e:	b2c7      	uxtb	r7, r0
					uint16_t led_pha  = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDPHASE_PHA_offset], GRID_CLASS_LEDPHASE_PHA_length, &error_flag);
    5930:	f108 0009 	add.w	r0, r8, #9
    5934:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5938:	2102      	movs	r1, #2
    593a:	4448      	add	r0, r9
    593c:	47a8      	blx	r5
					if (led_pha*2 > 255){
    593e:	b283      	uxth	r3, r0
    5940:	005b      	lsls	r3, r3, #1
    5942:	2bff      	cmp	r3, #255	; 0xff
						grid_led_set_phase(&grid_led_state, led_num, led_lay, led_pha*2);
    5944:	bfdc      	itt	le
    5946:	0040      	lslle	r0, r0, #1
    5948:	f000 03fe 	andle.w	r3, r0, #254	; 0xfe
    594c:	f8df 8058 	ldr.w	r8, [pc, #88]	; 59a8 <grid_port_process_outbound_ui+0x330>
    5950:	4813      	ldr	r0, [pc, #76]	; (59a0 <grid_port_process_outbound_ui+0x328>)
						grid_led_set_phase(&grid_led_state, led_num, led_lay, 255);
    5952:	bfc8      	it	gt
    5954:	23ff      	movgt	r3, #255	; 0xff
						grid_led_set_phase(&grid_led_state, led_num, led_lay, led_pha*2);
    5956:	463a      	mov	r2, r7
    5958:	4631      	mov	r1, r6
    595a:	47c0      	blx	r8
    595c:	e707      	b.n	576e <grid_port_process_outbound_ui+0xf6>
    595e:	bf00      	nop
    5960:	00004ebd 	.word	0x00004ebd
    5964:	000142f1 	.word	0x000142f1
    5968:	00004f13 	.word	0x00004f13
    596c:	00004f7b 	.word	0x00004f7b
    5970:	00004fa5 	.word	0x00004fa5
    5974:	000099cd 	.word	0x000099cd
    5978:	00009819 	.word	0x00009819
    597c:	2000f008 	.word	0x2000f008
    5980:	000096c3 	.word	0x000096c3
    5984:	0000a149 	.word	0x0000a149
    5988:	2001c7c0 	.word	0x2001c7c0
    598c:	0000971b 	.word	0x0000971b
    5990:	00009691 	.word	0x00009691
    5994:	000096bf 	.word	0x000096bf
    5998:	0000969d 	.word	0x0000969d
    599c:	000096a9 	.word	0x000096a9
    59a0:	2001c838 	.word	0x2001c838
    59a4:	2000effc 	.word	0x2000effc
    59a8:	00006d49 	.word	0x00006d49
				else if (msg_class == GRID_CLASS_LEDCOLOR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_local || position_is_me)){
    59ac:	2e41      	cmp	r6, #65	; 0x41
    59ae:	d13a      	bne.n	5a26 <grid_port_process_outbound_ui+0x3ae>
    59b0:	2f0e      	cmp	r7, #14
    59b2:	f47f aedc 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    59b6:	ea5b 0304 	orrs.w	r3, fp, r4
    59ba:	f43f aed8 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t led_num = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_NUM_offset], GRID_CLASS_LEDCOLOR_NUM_length, &error_flag);
    59be:	f108 0005 	add.w	r0, r8, #5
    59c2:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    59c6:	2102      	movs	r1, #2
    59c8:	4448      	add	r0, r9
    59ca:	47a8      	blx	r5
    59cc:	4607      	mov	r7, r0
					uint8_t led_lay = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_LAY_offset], GRID_CLASS_LEDCOLOR_LAY_length, &error_flag);
    59ce:	f108 0007 	add.w	r0, r8, #7
    59d2:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    59d6:	2102      	movs	r1, #2
    59d8:	4448      	add	r0, r9
    59da:	47a8      	blx	r5
    59dc:	9004      	str	r0, [sp, #16]
					uint8_t led_red	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_RED_offset], GRID_CLASS_LEDCOLOR_RED_length, &error_flag);
    59de:	f108 0009 	add.w	r0, r8, #9
    59e2:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    59e6:	2102      	movs	r1, #2
    59e8:	4448      	add	r0, r9
    59ea:	47a8      	blx	r5
    59ec:	9005      	str	r0, [sp, #20]
					uint8_t led_gre	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_GRE_offset], GRID_CLASS_LEDCOLOR_GRE_length, &error_flag);
    59ee:	f108 000b 	add.w	r0, r8, #11
    59f2:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    59f6:	2102      	movs	r1, #2
    59f8:	4448      	add	r0, r9
    59fa:	47a8      	blx	r5
    59fc:	4606      	mov	r6, r0
					uint8_t led_blu	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_BLU_offset], GRID_CLASS_LEDCOLOR_BLU_length, &error_flag);
    59fe:	f108 000d 	add.w	r0, r8, #13
    5a02:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5a06:	2102      	movs	r1, #2
    5a08:	4448      	add	r0, r9
    5a0a:	47a8      	blx	r5
					grid_led_set_color(&grid_led_state, led_num, led_lay, led_red, led_gre, led_blu);
    5a0c:	9b05      	ldr	r3, [sp, #20]
    5a0e:	f89d 2010 	ldrb.w	r2, [sp, #16]
    5a12:	b2c0      	uxtb	r0, r0
    5a14:	b2f6      	uxtb	r6, r6
    5a16:	9001      	str	r0, [sp, #4]
    5a18:	9600      	str	r6, [sp, #0]
    5a1a:	48a9      	ldr	r0, [pc, #676]	; (5cc0 <grid_port_process_outbound_ui+0x648>)
    5a1c:	4ea9      	ldr	r6, [pc, #676]	; (5cc4 <grid_port_process_outbound_ui+0x64c>)
    5a1e:	b2db      	uxtb	r3, r3
    5a20:	b2f9      	uxtb	r1, r7
    5a22:	47b0      	blx	r6
    5a24:	e6a3      	b.n	576e <grid_port_process_outbound_ui+0xf6>
				else if(msg_class == GRID_CLASS_SERIALNUMBER_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5a26:	2e11      	cmp	r6, #17
    5a28:	d15d      	bne.n	5ae6 <grid_port_process_outbound_ui+0x46e>
    5a2a:	2f0f      	cmp	r7, #15
    5a2c:	f47f ae9f 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5a30:	9b02      	ldr	r3, [sp, #8]
    5a32:	ea5b 0303 	orrs.w	r3, fp, r3
    5a36:	f43f ae9a 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint32_t uniqueid[4] = {0};
    5a3a:	2210      	movs	r2, #16
    5a3c:	2100      	movs	r1, #0
    5a3e:	4fa2      	ldr	r7, [pc, #648]	; (5cc8 <grid_port_process_outbound_ui+0x650>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5a40:	f8df 82ac 	ldr.w	r8, [pc, #684]	; 5cf0 <grid_port_process_outbound_ui+0x678>
					uint32_t uniqueid[4] = {0};
    5a44:	a80a      	add	r0, sp, #40	; 0x28
    5a46:	47b8      	blx	r7
					grid_sys_get_id(uniqueid);					
    5a48:	4ba0      	ldr	r3, [pc, #640]	; (5ccc <grid_port_process_outbound_ui+0x654>)
    5a4a:	a80a      	add	r0, sp, #40	; 0x28
    5a4c:	4798      	blx	r3
					grid_msg_init(&response);
    5a4e:	4ba0      	ldr	r3, [pc, #640]	; (5cd0 <grid_port_process_outbound_ui+0x658>)
    5a50:	a893      	add	r0, sp, #588	; 0x24c
    5a52:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5a54:	227f      	movs	r2, #127	; 0x7f
    5a56:	2300      	movs	r3, #0
    5a58:	4611      	mov	r1, r2
    5a5a:	a893      	add	r0, sp, #588	; 0x24c
    5a5c:	47c0      	blx	r8
					uint8_t response_payload[50] = {0};
    5a5e:	f04f 0800 	mov.w	r8, #0
    5a62:	222e      	movs	r2, #46	; 0x2e
    5a64:	4641      	mov	r1, r8
    5a66:	a80f      	add	r0, sp, #60	; 0x3c
    5a68:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    5a6c:	47b8      	blx	r7
					snprintf(response_payload, 49, GRID_CLASS_SERIALNUMBER_frame);
    5a6e:	2303      	movs	r3, #3
    5a70:	e9cd 6300 	strd	r6, r3, [sp]
    5a74:	4a97      	ldr	r2, [pc, #604]	; (5cd4 <grid_port_process_outbound_ui+0x65c>)
    5a76:	4e98      	ldr	r6, [pc, #608]	; (5cd8 <grid_port_process_outbound_ui+0x660>)
    5a78:	2131      	movs	r1, #49	; 0x31
    5a7a:	2302      	movs	r3, #2
    5a7c:	a80e      	add	r0, sp, #56	; 0x38
    5a7e:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5a80:	4b96      	ldr	r3, [pc, #600]	; (5cdc <grid_port_process_outbound_ui+0x664>)
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);					
    5a82:	4e97      	ldr	r6, [pc, #604]	; (5ce0 <grid_port_process_outbound_ui+0x668>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5a84:	a80e      	add	r0, sp, #56	; 0x38
    5a86:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);					
    5a88:	270d      	movs	r7, #13
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5a8a:	4602      	mov	r2, r0
    5a8c:	4b95      	ldr	r3, [pc, #596]	; (5ce4 <grid_port_process_outbound_ui+0x66c>)
    5a8e:	a90e      	add	r1, sp, #56	; 0x38
    5a90:	a893      	add	r0, sp, #588	; 0x24c
    5a92:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);					
    5a94:	2301      	movs	r3, #1
    5a96:	2204      	movs	r2, #4
    5a98:	4641      	mov	r1, r8
    5a9a:	a893      	add	r0, sp, #588	; 0x24c
    5a9c:	9700      	str	r7, [sp, #0]
    5a9e:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD0_offset, GRID_CLASS_SERIALNUMBER_WORD0_length, uniqueid[0]);
    5aa0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5aa2:	9300      	str	r3, [sp, #0]
    5aa4:	2205      	movs	r2, #5
    5aa6:	2308      	movs	r3, #8
    5aa8:	4641      	mov	r1, r8
    5aaa:	a893      	add	r0, sp, #588	; 0x24c
    5aac:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD1_offset, GRID_CLASS_SERIALNUMBER_WORD1_length, uniqueid[1]);
    5aae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5ab0:	9300      	str	r3, [sp, #0]
    5ab2:	463a      	mov	r2, r7
    5ab4:	2308      	movs	r3, #8
    5ab6:	4641      	mov	r1, r8
    5ab8:	a893      	add	r0, sp, #588	; 0x24c
    5aba:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD2_offset, GRID_CLASS_SERIALNUMBER_WORD2_length, uniqueid[2]);
    5abc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5abe:	9300      	str	r3, [sp, #0]
    5ac0:	2215      	movs	r2, #21
    5ac2:	2308      	movs	r3, #8
    5ac4:	4641      	mov	r1, r8
    5ac6:	a893      	add	r0, sp, #588	; 0x24c
    5ac8:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD3_offset, GRID_CLASS_SERIALNUMBER_WORD3_length, uniqueid[3]);
    5aca:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    5acc:	9300      	str	r3, [sp, #0]
    5ace:	221d      	movs	r2, #29
    5ad0:	2308      	movs	r3, #8
    5ad2:	4641      	mov	r1, r8
    5ad4:	a893      	add	r0, sp, #588	; 0x24c
    5ad6:	47b0      	blx	r6
					grid_msg_packet_close(&response);
    5ad8:	4b83      	ldr	r3, [pc, #524]	; (5ce8 <grid_port_process_outbound_ui+0x670>)
    5ada:	a893      	add	r0, sp, #588	; 0x24c
    5adc:	4798      	blx	r3
					grid_msg_packet_send_everywhere(&response);
    5ade:	4b83      	ldr	r3, [pc, #524]	; (5cec <grid_port_process_outbound_ui+0x674>)
    5ae0:	a893      	add	r0, sp, #588	; 0x24c
    5ae2:	4798      	blx	r3
				else if(msg_class == GRID_CLASS_UPTIME_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5ae4:	e61f      	b.n	5726 <grid_port_process_outbound_ui+0xae>
    5ae6:	2e14      	cmp	r6, #20
    5ae8:	d13f      	bne.n	5b6a <grid_port_process_outbound_ui+0x4f2>
    5aea:	2f0f      	cmp	r7, #15
    5aec:	f47f ae3f 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5af0:	9b02      	ldr	r3, [sp, #8]
    5af2:	ea5b 0303 	orrs.w	r3, fp, r3
    5af6:	f43f ae3a 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_msg_init(&response);
    5afa:	4b75      	ldr	r3, [pc, #468]	; (5cd0 <grid_port_process_outbound_ui+0x658>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5afc:	4f7c      	ldr	r7, [pc, #496]	; (5cf0 <grid_port_process_outbound_ui+0x678>)
					grid_msg_init(&response);
    5afe:	a893      	add	r0, sp, #588	; 0x24c
    5b00:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b02:	227f      	movs	r2, #127	; 0x7f
					uint8_t response_payload[50] = {0};
    5b04:	f04f 0800 	mov.w	r8, #0
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b08:	4611      	mov	r1, r2
    5b0a:	2300      	movs	r3, #0
    5b0c:	a893      	add	r0, sp, #588	; 0x24c
    5b0e:	47b8      	blx	r7
					uint8_t response_payload[50] = {0};
    5b10:	4b6d      	ldr	r3, [pc, #436]	; (5cc8 <grid_port_process_outbound_ui+0x650>)
    5b12:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    5b16:	222e      	movs	r2, #46	; 0x2e
    5b18:	4641      	mov	r1, r8
    5b1a:	a80f      	add	r0, sp, #60	; 0x3c
    5b1c:	4798      	blx	r3
					snprintf(response_payload, 49, GRID_CLASS_UPTIME_frame);
    5b1e:	2303      	movs	r3, #3
    5b20:	e9cd 6300 	strd	r6, r3, [sp]
    5b24:	4a73      	ldr	r2, [pc, #460]	; (5cf4 <grid_port_process_outbound_ui+0x67c>)
    5b26:	4e6c      	ldr	r6, [pc, #432]	; (5cd8 <grid_port_process_outbound_ui+0x660>)
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5b28:	4f6d      	ldr	r7, [pc, #436]	; (5ce0 <grid_port_process_outbound_ui+0x668>)
					snprintf(response_payload, 49, GRID_CLASS_UPTIME_frame);
    5b2a:	2131      	movs	r1, #49	; 0x31
    5b2c:	2302      	movs	r3, #2
    5b2e:	a80e      	add	r0, sp, #56	; 0x38
    5b30:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5b32:	4b6a      	ldr	r3, [pc, #424]	; (5cdc <grid_port_process_outbound_ui+0x664>)
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_UPTIME_UPTIME_offset, GRID_CLASS_UPTIME_UPTIME_length, grid_sys_state.uptime);
    5b34:	4e70      	ldr	r6, [pc, #448]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5b36:	a80e      	add	r0, sp, #56	; 0x38
    5b38:	4798      	blx	r3
    5b3a:	4b6a      	ldr	r3, [pc, #424]	; (5ce4 <grid_port_process_outbound_ui+0x66c>)
    5b3c:	4602      	mov	r2, r0
    5b3e:	a90e      	add	r1, sp, #56	; 0x38
    5b40:	a893      	add	r0, sp, #588	; 0x24c
    5b42:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5b44:	230d      	movs	r3, #13
    5b46:	9300      	str	r3, [sp, #0]
    5b48:	2204      	movs	r2, #4
    5b4a:	2301      	movs	r3, #1
    5b4c:	4641      	mov	r1, r8
    5b4e:	a893      	add	r0, sp, #588	; 0x24c
    5b50:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_UPTIME_UPTIME_offset, GRID_CLASS_UPTIME_UPTIME_length, grid_sys_state.uptime);
    5b52:	6833      	ldr	r3, [r6, #0]
    5b54:	9300      	str	r3, [sp, #0]
    5b56:	2205      	movs	r2, #5
    5b58:	2308      	movs	r3, #8
    5b5a:	4641      	mov	r1, r8
    5b5c:	a893      	add	r0, sp, #588	; 0x24c
    5b5e:	47b8      	blx	r7
					uint32_t milliseconds = grid_sys_state.uptime/RTC1MS%1000;
    5b60:	6833      	ldr	r3, [r6, #0]
					uint32_t seconds =		grid_sys_state.uptime/RTC1MS/1000%60;
    5b62:	6833      	ldr	r3, [r6, #0]
					uint32_t minutes =		grid_sys_state.uptime/RTC1MS/1000/60%60;
    5b64:	6833      	ldr	r3, [r6, #0]
					uint32_t hours =		grid_sys_state.uptime/RTC1MS/1000/60/60%60;
    5b66:	6833      	ldr	r3, [r6, #0]
    5b68:	e7b6      	b.n	5ad8 <grid_port_process_outbound_ui+0x460>
				else if(msg_class == GRID_CLASS_RESETCAUSE_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5b6a:	2e12      	cmp	r6, #18
    5b6c:	d137      	bne.n	5bde <grid_port_process_outbound_ui+0x566>
    5b6e:	2f0f      	cmp	r7, #15
    5b70:	f47f adfd 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5b74:	9b02      	ldr	r3, [sp, #8]
    5b76:	ea5b 0303 	orrs.w	r3, fp, r3
    5b7a:	f43f adf8 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_msg_init(&response);
    5b7e:	4b54      	ldr	r3, [pc, #336]	; (5cd0 <grid_port_process_outbound_ui+0x658>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b80:	4f5b      	ldr	r7, [pc, #364]	; (5cf0 <grid_port_process_outbound_ui+0x678>)
					grid_msg_init(&response);
    5b82:	a893      	add	r0, sp, #588	; 0x24c
    5b84:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b86:	227f      	movs	r2, #127	; 0x7f
    5b88:	4611      	mov	r1, r2
    5b8a:	2300      	movs	r3, #0
    5b8c:	a893      	add	r0, sp, #588	; 0x24c
    5b8e:	47b8      	blx	r7
					uint8_t response_payload[50] = {0};
    5b90:	2700      	movs	r7, #0
    5b92:	4b4d      	ldr	r3, [pc, #308]	; (5cc8 <grid_port_process_outbound_ui+0x650>)
    5b94:	970e      	str	r7, [sp, #56]	; 0x38
    5b96:	222e      	movs	r2, #46	; 0x2e
    5b98:	4639      	mov	r1, r7
    5b9a:	a80f      	add	r0, sp, #60	; 0x3c
    5b9c:	4798      	blx	r3
					snprintf(response_payload, 49, GRID_CLASS_RESETCAUSE_frame);
    5b9e:	2303      	movs	r3, #3
    5ba0:	e9cd 6300 	strd	r6, r3, [sp]
    5ba4:	4a55      	ldr	r2, [pc, #340]	; (5cfc <grid_port_process_outbound_ui+0x684>)
    5ba6:	4e4c      	ldr	r6, [pc, #304]	; (5cd8 <grid_port_process_outbound_ui+0x660>)
    5ba8:	2131      	movs	r1, #49	; 0x31
    5baa:	2302      	movs	r3, #2
    5bac:	a80e      	add	r0, sp, #56	; 0x38
    5bae:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5bb0:	4b4a      	ldr	r3, [pc, #296]	; (5cdc <grid_port_process_outbound_ui+0x664>)
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5bb2:	4e4b      	ldr	r6, [pc, #300]	; (5ce0 <grid_port_process_outbound_ui+0x668>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5bb4:	a80e      	add	r0, sp, #56	; 0x38
    5bb6:	4798      	blx	r3
    5bb8:	4b4a      	ldr	r3, [pc, #296]	; (5ce4 <grid_port_process_outbound_ui+0x66c>)
    5bba:	4602      	mov	r2, r0
    5bbc:	a90e      	add	r1, sp, #56	; 0x38
    5bbe:	a893      	add	r0, sp, #588	; 0x24c
    5bc0:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5bc2:	230d      	movs	r3, #13
    5bc4:	9300      	str	r3, [sp, #0]
    5bc6:	2204      	movs	r2, #4
    5bc8:	2301      	movs	r3, #1
    5bca:	4639      	mov	r1, r7
    5bcc:	a893      	add	r0, sp, #588	; 0x24c
    5bce:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_RESETCAUSE_CAUSE_offset, GRID_CLASS_RESETCAUSE_CAUSE_length,grid_sys_state.reset_cause);
    5bd0:	4b49      	ldr	r3, [pc, #292]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
    5bd2:	791b      	ldrb	r3, [r3, #4]
    5bd4:	9300      	str	r3, [sp, #0]
    5bd6:	2205      	movs	r2, #5
    5bd8:	2302      	movs	r3, #2
                    grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    5bda:	4639      	mov	r1, r7
    5bdc:	e26e      	b.n	60bc <grid_port_process_outbound_ui+0xa44>
				else if(msg_class == GRID_CLASS_RESET_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me)){
    5bde:	2e13      	cmp	r6, #19
    5be0:	d113      	bne.n	5c0a <grid_port_process_outbound_ui+0x592>
    5be2:	2f0e      	cmp	r7, #14
    5be4:	f47f adc3 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5be8:	f1bb 0f00 	cmp.w	fp, #0
    5bec:	f43f adbf 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    5bf0:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    5bf4:	4942      	ldr	r1, [pc, #264]	; (5d00 <grid_port_process_outbound_ui+0x688>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    5bf6:	4b43      	ldr	r3, [pc, #268]	; (5d04 <grid_port_process_outbound_ui+0x68c>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    5bf8:	68ca      	ldr	r2, [r1, #12]
    5bfa:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    5bfe:	4313      	orrs	r3, r2
    5c00:	60cb      	str	r3, [r1, #12]
    5c02:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    5c06:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    5c08:	e7fd      	b.n	5c06 <grid_port_process_outbound_ui+0x58e>
				else if (msg_class == GRID_CLASS_GLOBALLOAD_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c0a:	2e61      	cmp	r6, #97	; 0x61
    5c0c:	d10c      	bne.n	5c28 <grid_port_process_outbound_ui+0x5b0>
    5c0e:	2f0e      	cmp	r7, #14
    5c10:	f47f adad 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5c14:	9b02      	ldr	r3, [sp, #8]
    5c16:	ea5b 0303 	orrs.w	r3, fp, r3
    5c1a:	f43f ada8 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_sys_nvm_load_configuration(&grid_sys_state, &grid_nvm_state);
    5c1e:	493a      	ldr	r1, [pc, #232]	; (5d08 <grid_port_process_outbound_ui+0x690>)
    5c20:	4835      	ldr	r0, [pc, #212]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
    5c22:	4b3a      	ldr	r3, [pc, #232]	; (5d0c <grid_port_process_outbound_ui+0x694>)
					grid_ui_nvm_clear_all_configuration(&grid_ui_state, &grid_nvm_state);
    5c24:	4798      	blx	r3
    5c26:	e5a2      	b.n	576e <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_GLOBALSTORE_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c28:	2e60      	cmp	r6, #96	; 0x60
    5c2a:	d117      	bne.n	5c5c <grid_port_process_outbound_ui+0x5e4>
    5c2c:	2f0e      	cmp	r7, #14
    5c2e:	f47f ad9e 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5c32:	9b02      	ldr	r3, [sp, #8]
    5c34:	ea5b 0303 	orrs.w	r3, fp, r3
    5c38:	f43f ad99 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_sys_nvm_store_configuration(&grid_sys_state, &grid_nvm_state);
    5c3c:	4932      	ldr	r1, [pc, #200]	; (5d08 <grid_port_process_outbound_ui+0x690>)
    5c3e:	482e      	ldr	r0, [pc, #184]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
    5c40:	4b33      	ldr	r3, [pc, #204]	; (5d10 <grid_port_process_outbound_ui+0x698>)
                    grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    5c42:	4e34      	ldr	r6, [pc, #208]	; (5d14 <grid_port_process_outbound_ui+0x69c>)
					grid_sys_nvm_clear_configuration(&grid_ui_state, &grid_nvm_state);
    5c44:	4798      	blx	r3
                    grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    5c46:	2700      	movs	r7, #0
    5c48:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    5c4c:	e9cd 7300 	strd	r7, r3, [sp]
    5c50:	4829      	ldr	r0, [pc, #164]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
    5c52:	463b      	mov	r3, r7
    5c54:	22ff      	movs	r2, #255	; 0xff
    5c56:	4639      	mov	r1, r7
    5c58:	47b0      	blx	r6
    5c5a:	e588      	b.n	576e <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_GLOBALCLEAR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c5c:	2e62      	cmp	r6, #98	; 0x62
    5c5e:	d10b      	bne.n	5c78 <grid_port_process_outbound_ui+0x600>
    5c60:	2f0e      	cmp	r7, #14
    5c62:	f47f ad84 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5c66:	9b02      	ldr	r3, [sp, #8]
    5c68:	ea5b 0303 	orrs.w	r3, fp, r3
    5c6c:	f43f ad7f 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_sys_nvm_clear_configuration(&grid_ui_state, &grid_nvm_state);
    5c70:	4925      	ldr	r1, [pc, #148]	; (5d08 <grid_port_process_outbound_ui+0x690>)
    5c72:	4b29      	ldr	r3, [pc, #164]	; (5d18 <grid_port_process_outbound_ui+0x6a0>)
    5c74:	4650      	mov	r0, sl
    5c76:	e7e4      	b.n	5c42 <grid_port_process_outbound_ui+0x5ca>
				else if (msg_class == GRID_CLASS_GLOBALRECALL_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c78:	2e63      	cmp	r6, #99	; 0x63
    5c7a:	d112      	bne.n	5ca2 <grid_port_process_outbound_ui+0x62a>
    5c7c:	2f0e      	cmp	r7, #14
    5c7e:	f47f ad76 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5c82:	9b02      	ldr	r3, [sp, #8]
    5c84:	ea5b 0303 	orrs.w	r3, fp, r3
    5c88:	f43f ad71 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_GLOBALRECALL_BANKNUMBER_offset], GRID_CLASS_GLOBALRECALL_BANKNUMBER_length	, &error_flag);
    5c8c:	f108 0005 	add.w	r0, r8, #5
    5c90:	2102      	movs	r1, #2
    5c92:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5c96:	4448      	add	r0, r9
    5c98:	47a8      	blx	r5
					grid_sys_recall_configuration(&grid_sys_state, banknumber);
    5c9a:	4b20      	ldr	r3, [pc, #128]	; (5d1c <grid_port_process_outbound_ui+0x6a4>)
    5c9c:	b2c1      	uxtb	r1, r0
    5c9e:	4816      	ldr	r0, [pc, #88]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
    5ca0:	e590      	b.n	57c4 <grid_port_process_outbound_ui+0x14c>
				else if (msg_class == GRID_CLASS_LOCALLOAD_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5ca2:	2e71      	cmp	r6, #113	; 0x71
    5ca4:	d13e      	bne.n	5d24 <grid_port_process_outbound_ui+0x6ac>
    5ca6:	2f0e      	cmp	r7, #14
    5ca8:	f47f ad61 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5cac:	9b02      	ldr	r3, [sp, #8]
    5cae:	ea5b 0303 	orrs.w	r3, fp, r3
    5cb2:	f43f ad5c 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_ui_nvm_load_all_configuration(&grid_ui_state, &grid_nvm_state);						
    5cb6:	4914      	ldr	r1, [pc, #80]	; (5d08 <grid_port_process_outbound_ui+0x690>)
    5cb8:	4b19      	ldr	r3, [pc, #100]	; (5d20 <grid_port_process_outbound_ui+0x6a8>)
    5cba:	4650      	mov	r0, sl
    5cbc:	e7b2      	b.n	5c24 <grid_port_process_outbound_ui+0x5ac>
    5cbe:	bf00      	nop
    5cc0:	2001c838 	.word	0x2001c838
    5cc4:	00006cd9 	.word	0x00006cd9
    5cc8:	000142f1 	.word	0x000142f1
    5ccc:	00009879 	.word	0x00009879
    5cd0:	0000857d 	.word	0x0000857d
    5cd4:	00015a14 	.word	0x00015a14
    5cd8:	00014729 	.word	0x00014729
    5cdc:	0001480f 	.word	0x0001480f
    5ce0:	00008561 	.word	0x00008561
    5ce4:	000084ed 	.word	0x000084ed
    5ce8:	000086a9 	.word	0x000086a9
    5cec:	0000877d 	.word	0x0000877d
    5cf0:	000085b1 	.word	0x000085b1
    5cf4:	00015a3e 	.word	0x00015a3e
    5cf8:	2000f008 	.word	0x2000f008
    5cfc:	00015a50 	.word	0x00015a50
    5d00:	e000ed00 	.word	0xe000ed00
    5d04:	05fa0004 	.word	0x05fa0004
    5d08:	2000fa1c 	.word	0x2000fa1c
    5d0c:	0000909d 	.word	0x0000909d
    5d10:	00008d49 	.word	0x00008d49
    5d14:	000097cb 	.word	0x000097cb
    5d18:	00009195 	.word	0x00009195
    5d1c:	00008f41 	.word	0x00008f41
    5d20:	00009aad 	.word	0x00009aad
				else if (msg_class == GRID_CLASS_LOCALSTORE_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5d24:	2e70      	cmp	r6, #112	; 0x70
    5d26:	d10b      	bne.n	5d40 <grid_port_process_outbound_ui+0x6c8>
    5d28:	2f0e      	cmp	r7, #14
    5d2a:	f47f ad20 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5d2e:	9b02      	ldr	r3, [sp, #8]
    5d30:	ea5b 0303 	orrs.w	r3, fp, r3
    5d34:	f43f ad1b 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_ui_nvm_store_all_configuration(&grid_ui_state, &grid_nvm_state);
    5d38:	49b4      	ldr	r1, [pc, #720]	; (600c <grid_port_process_outbound_ui+0x994>)
    5d3a:	4bb5      	ldr	r3, [pc, #724]	; (6010 <grid_port_process_outbound_ui+0x998>)
    5d3c:	4650      	mov	r0, sl
    5d3e:	e771      	b.n	5c24 <grid_port_process_outbound_ui+0x5ac>
				else if (msg_class == GRID_CLASS_LOCALCLEAR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5d40:	2e72      	cmp	r6, #114	; 0x72
    5d42:	d10b      	bne.n	5d5c <grid_port_process_outbound_ui+0x6e4>
    5d44:	2f0e      	cmp	r7, #14
    5d46:	f47f ad12 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5d4a:	9b02      	ldr	r3, [sp, #8]
    5d4c:	ea5b 0303 	orrs.w	r3, fp, r3
    5d50:	f43f ad0d 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_ui_nvm_clear_all_configuration(&grid_ui_state, &grid_nvm_state);
    5d54:	49ad      	ldr	r1, [pc, #692]	; (600c <grid_port_process_outbound_ui+0x994>)
    5d56:	4baf      	ldr	r3, [pc, #700]	; (6014 <grid_port_process_outbound_ui+0x99c>)
    5d58:	4650      	mov	r0, sl
    5d5a:	e763      	b.n	5c24 <grid_port_process_outbound_ui+0x5ac>
				else if (msg_class == GRID_CLASS_CONFIGURATION_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5d5c:	2e80      	cmp	r6, #128	; 0x80
    5d5e:	f040 81b0 	bne.w	60c2 <grid_port_process_outbound_ui+0xa4a>
    5d62:	2f0f      	cmp	r7, #15
    5d64:	d122      	bne.n	5dac <grid_port_process_outbound_ui+0x734>
    5d66:	9b02      	ldr	r3, [sp, #8]
    5d68:	ea5b 0303 	orrs.w	r3, fp, r3
    5d6c:	f43f acff 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_BANKNUMBER_offset]		, GRID_CLASS_CONFIGURATION_BANKNUMBER_length	, &error_flag);
    5d70:	f108 0005 	add.w	r0, r8, #5
    5d74:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5d78:	2102      	movs	r1, #2
    5d7a:	4448      	add	r0, r9
    5d7c:	47a8      	blx	r5
    5d7e:	4606      	mov	r6, r0
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    5d80:	f108 0007 	add.w	r0, r8, #7
    5d84:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5d88:	2102      	movs	r1, #2
    5d8a:	4448      	add	r0, r9
    5d8c:	47a8      	blx	r5
    5d8e:	4607      	mov	r7, r0
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5d90:	f108 0009 	add.w	r0, r8, #9
    5d94:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5d98:	2102      	movs	r1, #2
    5d9a:	4448      	add	r0, r9
    5d9c:	47a8      	blx	r5
					grid_ui_recall_event_configuration(&grid_ui_state, banknumber, elementnumber, eventtype);
    5d9e:	b2f1      	uxtb	r1, r6
    5da0:	b2c3      	uxtb	r3, r0
    5da2:	4e9d      	ldr	r6, [pc, #628]	; (6018 <grid_port_process_outbound_ui+0x9a0>)
    5da4:	b2fa      	uxtb	r2, r7
    5da6:	4650      	mov	r0, sl
    5da8:	47b0      	blx	r6
    5daa:	e4e0      	b.n	576e <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_CONFIGURATION_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_local)){
    5dac:	2f0e      	cmp	r7, #14
    5dae:	f47f acde 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5db2:	f1bb 0f00 	cmp.w	fp, #0
    5db6:	f040 80e0 	bne.w	5f7a <grid_port_process_outbound_ui+0x902>
    5dba:	2c00      	cmp	r4, #0
    5dbc:	f000 8150 	beq.w	6060 <grid_port_process_outbound_ui+0x9e8>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_BANKNUMBER_offset]		, GRID_CLASS_CONFIGURATION_BANKNUMBER_length	, &error_flag);
    5dc0:	ab2f      	add	r3, sp, #188	; 0xbc
    5dc2:	f108 0005 	add.w	r0, r8, #5
    5dc6:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5dca:	2102      	movs	r1, #2
    5dcc:	4418      	add	r0, r3
    5dce:	47a8      	blx	r5
    5dd0:	b2c3      	uxtb	r3, r0
    5dd2:	9305      	str	r3, [sp, #20]
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    5dd4:	f108 0007 	add.w	r0, r8, #7
    5dd8:	ab2f      	add	r3, sp, #188	; 0xbc
    5dda:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5dde:	2102      	movs	r1, #2
    5de0:	4418      	add	r0, r3
    5de2:	47a8      	blx	r5
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5de4:	ab2f      	add	r3, sp, #188	; 0xbc
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    5de6:	9007      	str	r0, [sp, #28]
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5de8:	f108 0009 	add.w	r0, r8, #9
    5dec:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5df0:	2102      	movs	r1, #2
    5df2:	4418      	add	r0, r3
    5df4:	47a8      	blx	r5
					uint8_t actionstring[GRID_UI_ACTION_STRING_maxlength]	= {0};
    5df6:	2700      	movs	r7, #0
    5df8:	4b88      	ldr	r3, [pc, #544]	; (601c <grid_port_process_outbound_ui+0x9a4>)
    5dfa:	970e      	str	r7, [sp, #56]	; 0x38
    5dfc:	227e      	movs	r2, #126	; 0x7e
    5dfe:	4639      	mov	r1, r7
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5e00:	fa5f f980 	uxtb.w	r9, r0
					uint8_t actionstring[GRID_UI_ACTION_STRING_maxlength]	= {0};
    5e04:	a80f      	add	r0, sp, #60	; 0x3c
    5e06:	4798      	blx	r3
					uint32_t actionstring_length = current_stop-current_start-GRID_CLASS_CONFIGURATION_ACTIONSTRING_offset;
    5e08:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5e0c:	f108 000b 	add.w	r0, r8, #11
    5e10:	eba3 0308 	sub.w	r3, r3, r8
    5e14:	aa2f      	add	r2, sp, #188	; 0xbc
					uint8_t actionstring[GRID_UI_ACTION_STRING_maxlength]	= {0};
    5e16:	ae0e      	add	r6, sp, #56	; 0x38
					uint32_t actionstring_length = current_stop-current_start-GRID_CLASS_CONFIGURATION_ACTIONSTRING_offset;
    5e18:	3b0b      	subs	r3, #11
					for(uint32_t j = 0; j<actionstring_length; j++){
    5e1a:	eb02 0800 	add.w	r8, r2, r0
    5e1e:	4639      	mov	r1, r7
    5e20:	4299      	cmp	r1, r3
    5e22:	f0c0 80ed 	bcc.w	6000 <grid_port_process_outbound_ui+0x988>
					grid_ui_event_register_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype, actionstring, actionstring_length);
    5e26:	9905      	ldr	r1, [sp, #20]
    5e28:	f8da 2004 	ldr.w	r2, [sl, #4]
    5e2c:	f89d 801c 	ldrb.w	r8, [sp, #28]
    5e30:	4f7b      	ldr	r7, [pc, #492]	; (6020 <grid_port_process_outbound_ui+0x9a8>)
    5e32:	0109      	lsls	r1, r1, #4
    5e34:	9104      	str	r1, [sp, #16]
    5e36:	9905      	ldr	r1, [sp, #20]
    5e38:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    5e3c:	2664      	movs	r6, #100	; 0x64
    5e3e:	68d0      	ldr	r0, [r2, #12]
    5e40:	fb06 f608 	mul.w	r6, r6, r8
    5e44:	aa0e      	add	r2, sp, #56	; 0x38
    5e46:	4649      	mov	r1, r9
    5e48:	4430      	add	r0, r6
    5e4a:	47b8      	blx	r7
					if (banknumber == grid_sys_state.bank_activebank_number){
    5e4c:	4b75      	ldr	r3, [pc, #468]	; (6024 <grid_port_process_outbound_ui+0x9ac>)
    5e4e:	9a05      	ldr	r2, [sp, #20]
    5e50:	7bdb      	ldrb	r3, [r3, #15]
    5e52:	4293      	cmp	r3, r2
    5e54:	d105      	bne.n	5e62 <grid_port_process_outbound_ui+0x7ea>
						grid_ui_smart_trigger(&grid_ui_state, banknumber, elementnumber, eventtype);
    5e56:	9905      	ldr	r1, [sp, #20]
    5e58:	4f73      	ldr	r7, [pc, #460]	; (6028 <grid_port_process_outbound_ui+0x9b0>)
    5e5a:	464b      	mov	r3, r9
    5e5c:	4642      	mov	r2, r8
    5e5e:	4650      	mov	r0, sl
    5e60:	47b8      	blx	r7
					uint8_t event_index = grid_ui_event_find(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    5e62:	f8da 3004 	ldr.w	r3, [sl, #4]
    5e66:	9a04      	ldr	r2, [sp, #16]
    5e68:	4413      	add	r3, r2
    5e6a:	4649      	mov	r1, r9
    5e6c:	68d8      	ldr	r0, [r3, #12]
    5e6e:	4b6f      	ldr	r3, [pc, #444]	; (602c <grid_port_process_outbound_ui+0x9b4>)
    5e70:	4430      	add	r0, r6
    5e72:	4798      	blx	r3
					if (event_index != 255){
    5e74:	28ff      	cmp	r0, #255	; 0xff
    5e76:	d03d      	beq.n	5ef4 <grid_port_process_outbound_ui+0x87c>
						if (position_is_local){
    5e78:	b304      	cbz	r4, 5ebc <grid_port_process_outbound_ui+0x844>
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_flashempty_flag=0;
    5e7a:	f8da 2004 	ldr.w	r2, [sl, #4]
    5e7e:	9904      	ldr	r1, [sp, #16]
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 0;
    5e80:	9f04      	ldr	r7, [sp, #16]
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_flashempty_flag=0;
    5e82:	440a      	add	r2, r1
    5e84:	23bc      	movs	r3, #188	; 0xbc
    5e86:	68d2      	ldr	r2, [r2, #12]
    5e88:	4432      	add	r2, r6
    5e8a:	fb10 f303 	smulbb	r3, r0, r3
    5e8e:	6e12      	ldr	r2, [r2, #96]	; 0x60
    5e90:	441a      	add	r2, r3
    5e92:	2100      	movs	r1, #0
    5e94:	f882 10b8 	strb.w	r1, [r2, #184]	; 0xb8
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 0;
    5e98:	f8da 2004 	ldr.w	r2, [sl, #4]
    5e9c:	443a      	add	r2, r7
    5e9e:	68d2      	ldr	r2, [r2, #12]
    5ea0:	4432      	add	r2, r6
    5ea2:	6e12      	ldr	r2, [r2, #96]	; 0x60
    5ea4:	441a      	add	r2, r3
    5ea6:	f882 10b6 	strb.w	r1, [r2, #182]	; 0xb6
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 0;
    5eaa:	f8da 2004 	ldr.w	r2, [sl, #4]
    5eae:	443a      	add	r2, r7
    5eb0:	68d2      	ldr	r2, [r2, #12]
    5eb2:	4432      	add	r2, r6
    5eb4:	6e12      	ldr	r2, [r2, #96]	; 0x60
    5eb6:	4413      	add	r3, r2
    5eb8:	f883 10b7 	strb.w	r1, [r3, #183]	; 0xb7
						if (position_is_me){
    5ebc:	f1bb 0f00 	cmp.w	fp, #0
    5ec0:	d018      	beq.n	5ef4 <grid_port_process_outbound_ui+0x87c>
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 1;
    5ec2:	22bc      	movs	r2, #188	; 0xbc
    5ec4:	fb10 f002 	smulbb	r0, r0, r2
    5ec8:	f8da 3004 	ldr.w	r3, [sl, #4]
    5ecc:	9a04      	ldr	r2, [sp, #16]
    5ece:	4413      	add	r3, r2
    5ed0:	2201      	movs	r2, #1
    5ed2:	68db      	ldr	r3, [r3, #12]
    5ed4:	4433      	add	r3, r6
    5ed6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    5ed8:	4403      	add	r3, r0
    5eda:	f883 20b6 	strb.w	r2, [r3, #182]	; 0xb6
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 0;
    5ede:	f8da 3004 	ldr.w	r3, [sl, #4]
    5ee2:	9a04      	ldr	r2, [sp, #16]
    5ee4:	441a      	add	r2, r3
    5ee6:	68d3      	ldr	r3, [r2, #12]
    5ee8:	441e      	add	r6, r3
    5eea:	6e33      	ldr	r3, [r6, #96]	; 0x60
    5eec:	4418      	add	r0, r3
    5eee:	2300      	movs	r3, #0
    5ef0:	f880 30b7 	strb.w	r3, [r0, #183]	; 0xb7
					grid_msg_init(&response);
    5ef4:	4b4e      	ldr	r3, [pc, #312]	; (6030 <grid_port_process_outbound_ui+0x9b8>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5ef6:	4e4f      	ldr	r6, [pc, #316]	; (6034 <grid_port_process_outbound_ui+0x9bc>)
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5ef8:	4f4f      	ldr	r7, [pc, #316]	; (6038 <grid_port_process_outbound_ui+0x9c0>)
					grid_msg_init(&response);
    5efa:	a893      	add	r0, sp, #588	; 0x24c
    5efc:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5efe:	227f      	movs	r2, #127	; 0x7f
    5f00:	4611      	mov	r1, r2
    5f02:	2300      	movs	r3, #0
    5f04:	a893      	add	r0, sp, #588	; 0x24c
    5f06:	47b0      	blx	r6
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f08:	2303      	movs	r3, #3
					uint8_t response_payload[10] = {0};
    5f0a:	2600      	movs	r6, #0
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f0c:	494b      	ldr	r1, [pc, #300]	; (603c <grid_port_process_outbound_ui+0x9c4>)
    5f0e:	9300      	str	r3, [sp, #0]
    5f10:	2202      	movs	r2, #2
    5f12:	2380      	movs	r3, #128	; 0x80
    5f14:	a80a      	add	r0, sp, #40	; 0x28
					uint8_t response_payload[10] = {0};
    5f16:	e9cd 660a 	strd	r6, r6, [sp, #40]	; 0x28
    5f1a:	f8ad 6030 	strh.w	r6, [sp, #48]	; 0x30
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f1e:	47b8      	blx	r7
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5f20:	4b47      	ldr	r3, [pc, #284]	; (6040 <grid_port_process_outbound_ui+0x9c8>)
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, banknumber);
    5f22:	4f48      	ldr	r7, [pc, #288]	; (6044 <grid_port_process_outbound_ui+0x9cc>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5f24:	a80a      	add	r0, sp, #40	; 0x28
    5f26:	4798      	blx	r3
    5f28:	4b47      	ldr	r3, [pc, #284]	; (6048 <grid_port_process_outbound_ui+0x9d0>)
    5f2a:	4602      	mov	r2, r0
    5f2c:	a90a      	add	r1, sp, #40	; 0x28
    5f2e:	a893      	add	r0, sp, #588	; 0x24c
    5f30:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, banknumber);
    5f32:	9b05      	ldr	r3, [sp, #20]
    5f34:	9300      	str	r3, [sp, #0]
    5f36:	2205      	movs	r2, #5
    5f38:	2302      	movs	r3, #2
    5f3a:	4631      	mov	r1, r6
    5f3c:	a893      	add	r0, sp, #588	; 0x24c
    5f3e:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, elementnumber);
    5f40:	2302      	movs	r3, #2
    5f42:	2207      	movs	r2, #7
    5f44:	4631      	mov	r1, r6
    5f46:	a893      	add	r0, sp, #588	; 0x24c
    5f48:	f8cd 8000 	str.w	r8, [sp]
    5f4c:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eventtype);
    5f4e:	2302      	movs	r3, #2
    5f50:	2209      	movs	r2, #9
    5f52:	4631      	mov	r1, r6
    5f54:	a893      	add	r0, sp, #588	; 0x24c
    5f56:	f8cd 9000 	str.w	r9, [sp]
    5f5a:	47b8      	blx	r7
						grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    5f5c:	230a      	movs	r3, #10
    5f5e:	9300      	str	r3, [sp, #0]
    5f60:	2204      	movs	r2, #4
    5f62:	2301      	movs	r3, #1
    5f64:	4631      	mov	r1, r6
    5f66:	a893      	add	r0, sp, #588	; 0x24c
    5f68:	47b8      	blx	r7
                        grid_msg_packet_close(&response);
    5f6a:	4b38      	ldr	r3, [pc, #224]	; (604c <grid_port_process_outbound_ui+0x9d4>)
    5f6c:	a893      	add	r0, sp, #588	; 0x24c
    5f6e:	4798      	blx	r3
                        grid_msg_packet_send_everywhere(&response);
    5f70:	4b37      	ldr	r3, [pc, #220]	; (6050 <grid_port_process_outbound_ui+0x9d8>)
    5f72:	a893      	add	r0, sp, #588	; 0x24c
    5f74:	4798      	blx	r3
    5f76:	f7ff bbfa 	b.w	576e <grid_port_process_outbound_ui+0xf6>
                    if (!position_is_local){
    5f7a:	2c00      	cmp	r4, #0
    5f7c:	f47f af20 	bne.w	5dc0 <grid_port_process_outbound_ui+0x748>
                        grid_keyboard_state.isenabled = 0;             
    5f80:	4e34      	ldr	r6, [pc, #208]	; (6054 <grid_port_process_outbound_ui+0x9dc>)
                        grid_msg_init(&response);
    5f82:	4b2b      	ldr	r3, [pc, #172]	; (6030 <grid_port_process_outbound_ui+0x9b8>)
                        grid_keyboard_state.isenabled = 0;             
    5f84:	f886 4045 	strb.w	r4, [r6, #69]	; 0x45
                        grid_msg_init(&response);
    5f88:	a893      	add	r0, sp, #588	; 0x24c
    5f8a:	4798      	blx	r3
                        grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5f8c:	227f      	movs	r2, #127	; 0x7f
    5f8e:	4623      	mov	r3, r4
    5f90:	4611      	mov	r1, r2
    5f92:	a893      	add	r0, sp, #588	; 0x24c
    5f94:	4f27      	ldr	r7, [pc, #156]	; (6034 <grid_port_process_outbound_ui+0x9bc>)
    5f96:	47b8      	blx	r7
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    5f98:	2303      	movs	r3, #3
    5f9a:	492f      	ldr	r1, [pc, #188]	; (6058 <grid_port_process_outbound_ui+0x9e0>)
    5f9c:	9300      	str	r3, [sp, #0]
    5f9e:	2202      	movs	r2, #2
    5fa0:	4f25      	ldr	r7, [pc, #148]	; (6038 <grid_port_process_outbound_ui+0x9c0>)
                        uint8_t response_payload[10] = {0};
    5fa2:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    5fa6:	2392      	movs	r3, #146	; 0x92
    5fa8:	a80e      	add	r0, sp, #56	; 0x38
                        uint8_t response_payload[10] = {0};
    5faa:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    5fae:	47b8      	blx	r7
                        grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5fb0:	4b23      	ldr	r3, [pc, #140]	; (6040 <grid_port_process_outbound_ui+0x9c8>)
    5fb2:	a80e      	add	r0, sp, #56	; 0x38
    5fb4:	4798      	blx	r3
    5fb6:	a90e      	add	r1, sp, #56	; 0x38
    5fb8:	4602      	mov	r2, r0
    5fba:	4b23      	ldr	r3, [pc, #140]	; (6048 <grid_port_process_outbound_ui+0x9d0>)
    5fbc:	a893      	add	r0, sp, #588	; 0x24c
    5fbe:	4798      	blx	r3
                        grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    5fc0:	f896 3045 	ldrb.w	r3, [r6, #69]	; 0x45
    5fc4:	9300      	str	r3, [sp, #0]
    5fc6:	4e1f      	ldr	r6, [pc, #124]	; (6044 <grid_port_process_outbound_ui+0x9cc>)
    5fc8:	4621      	mov	r1, r4
    5fca:	a893      	add	r0, sp, #588	; 0x24c
    5fcc:	2302      	movs	r3, #2
    5fce:	2205      	movs	r2, #5
    5fd0:	47b0      	blx	r6
                        grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5fd2:	230d      	movs	r3, #13
    5fd4:	4621      	mov	r1, r4
    5fd6:	2204      	movs	r2, #4
    5fd8:	9300      	str	r3, [sp, #0]
    5fda:	a893      	add	r0, sp, #588	; 0x24c
    5fdc:	2301      	movs	r3, #1
    5fde:	47b0      	blx	r6
                        grid_msg_packet_close(&response);
    5fe0:	4b1a      	ldr	r3, [pc, #104]	; (604c <grid_port_process_outbound_ui+0x9d4>)
                        grid_sys_alert_set_alert(&grid_sys_state, 100, 100, 100, 0, 250);
    5fe2:	4e1e      	ldr	r6, [pc, #120]	; (605c <grid_port_process_outbound_ui+0x9e4>)
                        grid_msg_packet_close(&response);
    5fe4:	a893      	add	r0, sp, #588	; 0x24c
    5fe6:	4798      	blx	r3
                        grid_msg_packet_send_everywhere(&response);
    5fe8:	4b19      	ldr	r3, [pc, #100]	; (6050 <grid_port_process_outbound_ui+0x9d8>)
    5fea:	a893      	add	r0, sp, #588	; 0x24c
    5fec:	4798      	blx	r3
                        grid_sys_alert_set_alert(&grid_sys_state, 100, 100, 100, 0, 250);
    5fee:	23fa      	movs	r3, #250	; 0xfa
    5ff0:	e9cd 4300 	strd	r4, r3, [sp]
    5ff4:	2364      	movs	r3, #100	; 0x64
    5ff6:	480b      	ldr	r0, [pc, #44]	; (6024 <grid_port_process_outbound_ui+0x9ac>)
    5ff8:	461a      	mov	r2, r3
    5ffa:	4619      	mov	r1, r3
    5ffc:	47b0      	blx	r6
    5ffe:	e6df      	b.n	5dc0 <grid_port_process_outbound_ui+0x748>
						actionstring[j] = message[current_start+GRID_CLASS_CONFIGURATION_ACTIONSTRING_offset + j];
    6000:	f818 2b01 	ldrb.w	r2, [r8], #1
    6004:	558a      	strb	r2, [r1, r6]
					for(uint32_t j = 0; j<actionstring_length; j++){
    6006:	3101      	adds	r1, #1
    6008:	e70a      	b.n	5e20 <grid_port_process_outbound_ui+0x7a8>
    600a:	bf00      	nop
    600c:	2000fa1c 	.word	0x2000fa1c
    6010:	00009a9d 	.word	0x00009a9d
    6014:	00009abd 	.word	0x00009abd
    6018:	00009acd 	.word	0x00009acd
    601c:	000142f1 	.word	0x000142f1
    6020:	00009eed 	.word	0x00009eed
    6024:	2000f008 	.word	0x2000f008
    6028:	0000a149 	.word	0x0000a149
    602c:	0000a0fd 	.word	0x0000a0fd
    6030:	0000857d 	.word	0x0000857d
    6034:	000085b1 	.word	0x000085b1
    6038:	00014791 	.word	0x00014791
    603c:	00015a5c 	.word	0x00015a5c
    6040:	0001480f 	.word	0x0001480f
    6044:	00008561 	.word	0x00008561
    6048:	000084ed 	.word	0x000084ed
    604c:	000086a9 	.word	0x000086a9
    6050:	0000877d 	.word	0x0000877d
    6054:	20010264 	.word	0x20010264
    6058:	00015a50 	.word	0x00015a50
    605c:	000097cb 	.word	0x000097cb
                        grid_keyboard_state.isenabled = 0;             
    6060:	4e8b      	ldr	r6, [pc, #556]	; (6290 <grid_port_process_outbound_ui+0xc18>)
                        grid_msg_init(&response);
    6062:	4b8c      	ldr	r3, [pc, #560]	; (6294 <grid_port_process_outbound_ui+0xc1c>)
                        grid_keyboard_state.isenabled = 0;             
    6064:	f886 4045 	strb.w	r4, [r6, #69]	; 0x45
                        grid_msg_init(&response);
    6068:	a893      	add	r0, sp, #588	; 0x24c
    606a:	4798      	blx	r3
                        grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    606c:	227f      	movs	r2, #127	; 0x7f
    606e:	4611      	mov	r1, r2
    6070:	4f89      	ldr	r7, [pc, #548]	; (6298 <grid_port_process_outbound_ui+0xc20>)
    6072:	4623      	mov	r3, r4
    6074:	a893      	add	r0, sp, #588	; 0x24c
    6076:	47b8      	blx	r7
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6078:	2303      	movs	r3, #3
    607a:	4988      	ldr	r1, [pc, #544]	; (629c <grid_port_process_outbound_ui+0xc24>)
    607c:	9300      	str	r3, [sp, #0]
    607e:	2202      	movs	r2, #2
    6080:	2392      	movs	r3, #146	; 0x92
    6082:	4f87      	ldr	r7, [pc, #540]	; (62a0 <grid_port_process_outbound_ui+0xc28>)
                        uint8_t response_payload[10] = {0};
    6084:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6088:	a80e      	add	r0, sp, #56	; 0x38
                        uint8_t response_payload[10] = {0};
    608a:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    608e:	47b8      	blx	r7
                        grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    6090:	4b84      	ldr	r3, [pc, #528]	; (62a4 <grid_port_process_outbound_ui+0xc2c>)
    6092:	a80e      	add	r0, sp, #56	; 0x38
    6094:	4798      	blx	r3
    6096:	4b84      	ldr	r3, [pc, #528]	; (62a8 <grid_port_process_outbound_ui+0xc30>)
    6098:	4602      	mov	r2, r0
    609a:	a90e      	add	r1, sp, #56	; 0x38
    609c:	a893      	add	r0, sp, #588	; 0x24c
    609e:	4798      	blx	r3
                        grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    60a0:	f896 3045 	ldrb.w	r3, [r6, #69]	; 0x45
    60a4:	9300      	str	r3, [sp, #0]
    60a6:	2205      	movs	r2, #5
    60a8:	2302      	movs	r3, #2
    60aa:	4621      	mov	r1, r4
    60ac:	4e7f      	ldr	r6, [pc, #508]	; (62ac <grid_port_process_outbound_ui+0xc34>)
    60ae:	a893      	add	r0, sp, #588	; 0x24c
    60b0:	47b0      	blx	r6
                        grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    60b2:	230d      	movs	r3, #13
    60b4:	9300      	str	r3, [sp, #0]
    60b6:	2204      	movs	r2, #4
    60b8:	2301      	movs	r3, #1
    60ba:	4621      	mov	r1, r4
    60bc:	a893      	add	r0, sp, #588	; 0x24c
    60be:	47b0      	blx	r6
    60c0:	e753      	b.n	5f6a <grid_port_process_outbound_ui+0x8f2>
                else if (msg_class == GRID_CLASS_HIDKEYSTATUS_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    60c2:	2e92      	cmp	r6, #146	; 0x92
    60c4:	d13e      	bne.n	6144 <grid_port_process_outbound_ui+0xacc>
    60c6:	2f0e      	cmp	r7, #14
    60c8:	f47f ab51 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    60cc:	9b02      	ldr	r3, [sp, #8]
    60ce:	ea5b 0303 	orrs.w	r3, fp, r3
    60d2:	f43f ab4c 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
                    uint8_t isenabled =	grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset]		, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length	, &error_flag);
    60d6:	f108 0005 	add.w	r0, r8, #5
    60da:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    60de:	2102      	movs	r1, #2
    60e0:	4448      	add	r0, r9
    60e2:	47a8      	blx	r5
                    grid_keyboard_state.isenabled = isenabled;
    60e4:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 6290 <grid_port_process_outbound_ui+0xc18>
                    grid_msg_init(&response);
    60e8:	4b6a      	ldr	r3, [pc, #424]	; (6294 <grid_port_process_outbound_ui+0xc1c>)
                    uint8_t isenabled =	grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset]		, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length	, &error_flag);
    60ea:	f888 0045 	strb.w	r0, [r8, #69]	; 0x45
                    grid_msg_init(&response);
    60ee:	a893      	add	r0, sp, #588	; 0x24c
    60f0:	4798      	blx	r3
                    grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    60f2:	227f      	movs	r2, #127	; 0x7f
    60f4:	4611      	mov	r1, r2
    60f6:	4f68      	ldr	r7, [pc, #416]	; (6298 <grid_port_process_outbound_ui+0xc20>)
    60f8:	2300      	movs	r3, #0
    60fa:	a893      	add	r0, sp, #588	; 0x24c
    60fc:	47b8      	blx	r7
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    60fe:	2303      	movs	r3, #3
    6100:	4966      	ldr	r1, [pc, #408]	; (629c <grid_port_process_outbound_ui+0xc24>)
    6102:	9300      	str	r3, [sp, #0]
                    uint8_t response_payload[10] = {0};
    6104:	2700      	movs	r7, #0
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6106:	4633      	mov	r3, r6
    6108:	2202      	movs	r2, #2
    610a:	4e65      	ldr	r6, [pc, #404]	; (62a0 <grid_port_process_outbound_ui+0xc28>)
                    uint8_t response_payload[10] = {0};
    610c:	f8ad 7040 	strh.w	r7, [sp, #64]	; 0x40
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6110:	a80e      	add	r0, sp, #56	; 0x38
                    uint8_t response_payload[10] = {0};
    6112:	e9cd 770e 	strd	r7, r7, [sp, #56]	; 0x38
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6116:	47b0      	blx	r6
                    grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    6118:	4b62      	ldr	r3, [pc, #392]	; (62a4 <grid_port_process_outbound_ui+0xc2c>)
                    grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    611a:	4e64      	ldr	r6, [pc, #400]	; (62ac <grid_port_process_outbound_ui+0xc34>)
                    grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    611c:	a80e      	add	r0, sp, #56	; 0x38
    611e:	4798      	blx	r3
    6120:	4b61      	ldr	r3, [pc, #388]	; (62a8 <grid_port_process_outbound_ui+0xc30>)
    6122:	4602      	mov	r2, r0
    6124:	a90e      	add	r1, sp, #56	; 0x38
    6126:	a893      	add	r0, sp, #588	; 0x24c
    6128:	4798      	blx	r3
                    grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    612a:	f898 3045 	ldrb.w	r3, [r8, #69]	; 0x45
    612e:	9300      	str	r3, [sp, #0]
    6130:	2205      	movs	r2, #5
    6132:	2302      	movs	r3, #2
    6134:	4639      	mov	r1, r7
    6136:	a893      	add	r0, sp, #588	; 0x24c
    6138:	47b0      	blx	r6
                    grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    613a:	230a      	movs	r3, #10
    613c:	9300      	str	r3, [sp, #0]
    613e:	2204      	movs	r2, #4
    6140:	2301      	movs	r3, #1
    6142:	e54a      	b.n	5bda <grid_port_process_outbound_ui+0x562>
				else if (msg_class == GRID_CLASS_CONFIGDEFAULT_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_local)){
    6144:	2e81      	cmp	r6, #129	; 0x81
    6146:	f47f ab12 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    614a:	2f0e      	cmp	r7, #14
    614c:	f47f ab0f 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    6150:	ea5b 0304 	orrs.w	r3, fp, r4
    6154:	f43f ab0b 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_BANKNUMBER_offset]		, GRID_CLASS_CONFIGURATION_BANKNUMBER_length	, &error_flag);
    6158:	f108 0005 	add.w	r0, r8, #5
    615c:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    6160:	2102      	movs	r1, #2
    6162:	4448      	add	r0, r9
    6164:	47a8      	blx	r5
    6166:	b2c7      	uxtb	r7, r0
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    6168:	f108 0007 	add.w	r0, r8, #7
    616c:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    6170:	2102      	movs	r1, #2
    6172:	4448      	add	r0, r9
    6174:	47a8      	blx	r5
    6176:	4606      	mov	r6, r0
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    6178:	f108 0009 	add.w	r0, r8, #9
    617c:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    6180:	2102      	movs	r1, #2
    6182:	4448      	add	r0, r9
    6184:	47a8      	blx	r5
					grid_ui_event_generate_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    6186:	f8da 3004 	ldr.w	r3, [sl, #4]
    618a:	eb03 1307 	add.w	r3, r3, r7, lsl #4
    618e:	b2f2      	uxtb	r2, r6
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    6190:	fa5f f880 	uxtb.w	r8, r0
					grid_ui_event_generate_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    6194:	f04f 0964 	mov.w	r9, #100	; 0x64
    6198:	68d8      	ldr	r0, [r3, #12]
    619a:	4b45      	ldr	r3, [pc, #276]	; (62b0 <grid_port_process_outbound_ui+0xc38>)
    619c:	9204      	str	r2, [sp, #16]
    619e:	fb09 f902 	mul.w	r9, r9, r2
    61a2:	4641      	mov	r1, r8
    61a4:	4448      	add	r0, r9
    61a6:	4798      	blx	r3
					if (banknumber == grid_sys_state.bank_activebank_number){
    61a8:	4b42      	ldr	r3, [pc, #264]	; (62b4 <grid_port_process_outbound_ui+0xc3c>)
    61aa:	7bdb      	ldrb	r3, [r3, #15]
    61ac:	42bb      	cmp	r3, r7
    61ae:	d105      	bne.n	61bc <grid_port_process_outbound_ui+0xb44>
						grid_ui_smart_trigger(&grid_ui_state, banknumber, elementnumber, eventtype);
    61b0:	9a04      	ldr	r2, [sp, #16]
    61b2:	4e41      	ldr	r6, [pc, #260]	; (62b8 <grid_port_process_outbound_ui+0xc40>)
    61b4:	4643      	mov	r3, r8
    61b6:	4639      	mov	r1, r7
    61b8:	4650      	mov	r0, sl
    61ba:	47b0      	blx	r6
					uint8_t event_index = grid_ui_event_find(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    61bc:	f8da 3004 	ldr.w	r3, [sl, #4]
    61c0:	013a      	lsls	r2, r7, #4
    61c2:	4413      	add	r3, r2
    61c4:	4641      	mov	r1, r8
    61c6:	68d8      	ldr	r0, [r3, #12]
    61c8:	4b3c      	ldr	r3, [pc, #240]	; (62bc <grid_port_process_outbound_ui+0xc44>)
    61ca:	4448      	add	r0, r9
    61cc:	4798      	blx	r3
					if (event_index != 255){
    61ce:	28ff      	cmp	r0, #255	; 0xff
    61d0:	d018      	beq.n	6204 <grid_port_process_outbound_ui+0xb8c>
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 1;
    61d2:	f8da 3004 	ldr.w	r3, [sl, #4]
    61d6:	22bc      	movs	r2, #188	; 0xbc
    61d8:	fb10 f002 	smulbb	r0, r0, r2
    61dc:	013a      	lsls	r2, r7, #4
    61de:	4413      	add	r3, r2
    61e0:	2201      	movs	r2, #1
    61e2:	68db      	ldr	r3, [r3, #12]
    61e4:	444b      	add	r3, r9
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 1;
    61e6:	0139      	lsls	r1, r7, #4
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 1;
    61e8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    61ea:	4403      	add	r3, r0
    61ec:	f883 20b6 	strb.w	r2, [r3, #182]	; 0xb6
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 1;
    61f0:	f8da 3004 	ldr.w	r3, [sl, #4]
    61f4:	440b      	add	r3, r1
    61f6:	68db      	ldr	r3, [r3, #12]
    61f8:	4499      	add	r9, r3
    61fa:	f8d9 3060 	ldr.w	r3, [r9, #96]	; 0x60
    61fe:	4418      	add	r0, r3
    6200:	f880 20b7 	strb.w	r2, [r0, #183]	; 0xb7
					grid_msg_init(&response);
    6204:	4b23      	ldr	r3, [pc, #140]	; (6294 <grid_port_process_outbound_ui+0xc1c>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    6206:	f8df 9090 	ldr.w	r9, [pc, #144]	; 6298 <grid_port_process_outbound_ui+0xc20>
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    620a:	4e25      	ldr	r6, [pc, #148]	; (62a0 <grid_port_process_outbound_ui+0xc28>)
					grid_msg_init(&response);
    620c:	a893      	add	r0, sp, #588	; 0x24c
    620e:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    6210:	227f      	movs	r2, #127	; 0x7f
    6212:	4611      	mov	r1, r2
    6214:	2300      	movs	r3, #0
    6216:	a893      	add	r0, sp, #588	; 0x24c
    6218:	47c8      	blx	r9
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    621a:	2303      	movs	r3, #3
					uint8_t response_payload[10] = {0};
    621c:	f04f 0900 	mov.w	r9, #0
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    6220:	4927      	ldr	r1, [pc, #156]	; (62c0 <grid_port_process_outbound_ui+0xc48>)
    6222:	9300      	str	r3, [sp, #0]
    6224:	2202      	movs	r2, #2
    6226:	2380      	movs	r3, #128	; 0x80
    6228:	a80e      	add	r0, sp, #56	; 0x38
					uint8_t response_payload[10] = {0};
    622a:	e9cd 990e 	strd	r9, r9, [sp, #56]	; 0x38
    622e:	f8ad 9040 	strh.w	r9, [sp, #64]	; 0x40
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    6232:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    6234:	4b1b      	ldr	r3, [pc, #108]	; (62a4 <grid_port_process_outbound_ui+0xc2c>)
    6236:	a80e      	add	r0, sp, #56	; 0x38
    6238:	4798      	blx	r3
    623a:	4b1b      	ldr	r3, [pc, #108]	; (62a8 <grid_port_process_outbound_ui+0xc30>)
    623c:	4602      	mov	r2, r0
    623e:	a90e      	add	r1, sp, #56	; 0x38
    6240:	a893      	add	r0, sp, #588	; 0x24c
    6242:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, banknumber);
    6244:	9700      	str	r7, [sp, #0]
    6246:	2302      	movs	r3, #2
    6248:	4f18      	ldr	r7, [pc, #96]	; (62ac <grid_port_process_outbound_ui+0xc34>)
    624a:	2205      	movs	r2, #5
    624c:	4649      	mov	r1, r9
    624e:	a893      	add	r0, sp, #588	; 0x24c
    6250:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, elementnumber);
    6252:	9b04      	ldr	r3, [sp, #16]
    6254:	9300      	str	r3, [sp, #0]
    6256:	2207      	movs	r2, #7
    6258:	2302      	movs	r3, #2
    625a:	4649      	mov	r1, r9
    625c:	a893      	add	r0, sp, #588	; 0x24c
    625e:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eventtype);
    6260:	f8cd 8000 	str.w	r8, [sp]
    6264:	2302      	movs	r3, #2
    6266:	2209      	movs	r2, #9
    6268:	4649      	mov	r1, r9
    626a:	a893      	add	r0, sp, #588	; 0x24c
    626c:	47b8      	blx	r7
						grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    626e:	230a      	movs	r3, #10
    6270:	2204      	movs	r2, #4
    6272:	4649      	mov	r1, r9
    6274:	9300      	str	r3, [sp, #0]
    6276:	a893      	add	r0, sp, #588	; 0x24c
    6278:	2301      	movs	r3, #1
    627a:	47b8      	blx	r7
					grid_msg_packet_close(&response);
    627c:	4b11      	ldr	r3, [pc, #68]	; (62c4 <grid_port_process_outbound_ui+0xc4c>)
    627e:	a893      	add	r0, sp, #588	; 0x24c
    6280:	4798      	blx	r3
					grid_msg_packet_send_everywhere(&response);
    6282:	4b11      	ldr	r3, [pc, #68]	; (62c8 <grid_port_process_outbound_ui+0xc50>)
    6284:	a893      	add	r0, sp, #588	; 0x24c
    6286:	4798      	blx	r3
				current_start = 0;
    6288:	46c8      	mov	r8, r9
    628a:	f7ff ba4c 	b.w	5726 <grid_port_process_outbound_ui+0xae>
    628e:	bf00      	nop
    6290:	20010264 	.word	0x20010264
    6294:	0000857d 	.word	0x0000857d
    6298:	000085b1 	.word	0x000085b1
    629c:	00015a50 	.word	0x00015a50
    62a0:	00014791 	.word	0x00014791
    62a4:	0001480f 	.word	0x0001480f
    62a8:	000084ed 	.word	0x000084ed
    62ac:	00008561 	.word	0x00008561
    62b0:	00009f59 	.word	0x00009f59
    62b4:	2000f008 	.word	0x2000f008
    62b8:	0000a149 	.word	0x0000a149
    62bc:	0000a0fd 	.word	0x0000a0fd
    62c0:	00015a5c 	.word	0x00015a5c
    62c4:	000086a9 	.word	0x000086a9
    62c8:	0000877d 	.word	0x0000877d

000062cc <grid_port_process_outbound_usart>:

uint8_t grid_port_process_outbound_usart(struct grid_port* por){
    62cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	if (por->tx_double_buffer_status == 0){ // READY TO SEND MESSAGE, NO TRANSMISSION IS IN PROGRESS
    62d0:	8987      	ldrh	r7, [r0, #12]
uint8_t grid_port_process_outbound_usart(struct grid_port* por){
    62d2:	4605      	mov	r5, r0
	if (por->tx_double_buffer_status == 0){ // READY TO SEND MESSAGE, NO TRANSMISSION IS IN PROGRESS
    62d4:	bb1f      	cbnz	r7, 631e <grid_port_process_outbound_usart+0x52>
		
		uint16_t packet_size = grid_buffer_read_size(&por->tx_buffer);
    62d6:	f500 561c 	add.w	r6, r0, #9984	; 0x2700
    62da:	363c      	adds	r6, #60	; 0x3c
    62dc:	4b11      	ldr	r3, [pc, #68]	; (6324 <grid_port_process_outbound_usart+0x58>)
    62de:	4630      	mov	r0, r6
    62e0:	4798      	blx	r3
		
		if (!packet_size){
    62e2:	4604      	mov	r4, r0
    62e4:	b1a0      	cbz	r0, 6310 <grid_port_process_outbound_usart+0x44>
			// NO PACKET IN RX BUFFER
			return 0;
		}else{
			
			// Let's transfer the packet to local memory
			grid_buffer_read_init(&por->tx_buffer);
    62e6:	4b10      	ldr	r3, [pc, #64]	; (6328 <grid_port_process_outbound_usart+0x5c>)
			
			por->tx_double_buffer_status = packet_size;
			
			for (uint16_t i = 0; i<packet_size; i++){
				
				uint8_t character = grid_buffer_read_character(&por->tx_buffer);
    62e8:	f8df a048 	ldr.w	sl, [pc, #72]	; 6334 <grid_port_process_outbound_usart+0x68>
			grid_buffer_read_init(&por->tx_buffer);
    62ec:	4630      	mov	r0, r6
    62ee:	f105 082c 	add.w	r8, r5, #44	; 0x2c
    62f2:	4798      	blx	r3
			por->tx_double_buffer_status = packet_size;
    62f4:	46c1      	mov	r9, r8
    62f6:	81ac      	strh	r4, [r5, #12]
			for (uint16_t i = 0; i<packet_size; i++){
    62f8:	b2bb      	uxth	r3, r7
    62fa:	429c      	cmp	r4, r3
				uint8_t character = grid_buffer_read_character(&por->tx_buffer);
    62fc:	4630      	mov	r0, r6
			for (uint16_t i = 0; i<packet_size; i++){
    62fe:	d809      	bhi.n	6314 <grid_port_process_outbound_usart+0x48>
				por->tx_double_buffer[i] = character;
				
			}
		
			// Let's acknowledge the transaction
			grid_buffer_read_acknowledge(&por->tx_buffer);
    6300:	4b0a      	ldr	r3, [pc, #40]	; (632c <grid_port_process_outbound_usart+0x60>)
    6302:	4798      	blx	r3
			
			// Let's send the packet through USART
			io_write(&por->usart->io, por->tx_double_buffer, por->tx_double_buffer_status);		
    6304:	89aa      	ldrh	r2, [r5, #12]
    6306:	6868      	ldr	r0, [r5, #4]
    6308:	4b09      	ldr	r3, [pc, #36]	; (6330 <grid_port_process_outbound_usart+0x64>)
    630a:	4649      	mov	r1, r9
    630c:	4798      	blx	r3
			
			return 1;
    630e:	2001      	movs	r0, #1
		}
		
	}
	
	return 0;
}
    6310:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				uint8_t character = grid_buffer_read_character(&por->tx_buffer);
    6314:	47d0      	blx	sl
				por->tx_double_buffer[i] = character;
    6316:	3701      	adds	r7, #1
    6318:	f808 0b01 	strb.w	r0, [r8], #1
			for (uint16_t i = 0; i<packet_size; i++){
    631c:	e7ec      	b.n	62f8 <grid_port_process_outbound_usart+0x2c>
	return 0;
    631e:	2000      	movs	r0, #0
    6320:	e7f6      	b.n	6310 <grid_port_process_outbound_usart+0x44>
    6322:	bf00      	nop
    6324:	00004ebd 	.word	0x00004ebd
    6328:	00004f13 	.word	0x00004f13
    632c:	00004fa5 	.word	0x00004fa5
    6330:	0000b0a5 	.word	0x0000b0a5
    6334:	00004f7b 	.word	0x00004f7b

00006338 <grid_d51_init>:
	
}



void grid_d51_init(){
    6338:	b570      	push	{r4, r5, r6, lr}
	
	uint32_t hwid = grid_sys_get_hwcfg();
    633a:	4b09      	ldr	r3, [pc, #36]	; (6360 <grid_d51_init+0x28>)
	
	#ifdef NDEBUG		
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "USER ROW CHECK!");
	grid_d51_verify_user_row();
	#else
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "NO USER ROW CHECK!");
    633c:	4d09      	ldr	r5, [pc, #36]	; (6364 <grid_d51_init+0x2c>)
	printf("{\"type\":\"HWCFG\", \"data\": \"%d\"}\r\n", hwid);
    633e:	4c0a      	ldr	r4, [pc, #40]	; (6368 <grid_d51_init+0x30>)
	uint32_t hwid = grid_sys_get_hwcfg();
    6340:	4798      	blx	r3
    6342:	4601      	mov	r1, r0
	printf("{\"type\":\"HWCFG\", \"data\": \"%d\"}\r\n", hwid);
    6344:	4809      	ldr	r0, [pc, #36]	; (636c <grid_d51_init+0x34>)
    6346:	47a0      	blx	r4
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "NO USER ROW CHECK!");
    6348:	4909      	ldr	r1, [pc, #36]	; (6370 <grid_d51_init+0x38>)
    634a:	4628      	mov	r0, r5
    634c:	47a0      	blx	r4
	{
	}
	
	#else
	
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "No Unit Test");
    634e:	4909      	ldr	r1, [pc, #36]	; (6374 <grid_d51_init+0x3c>)
    6350:	4628      	mov	r0, r5
    6352:	47a0      	blx	r4
	while (1)
	{
	}
	#else
	
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "No Hardware Test");
    6354:	4628      	mov	r0, r5
    6356:	4623      	mov	r3, r4
    6358:	4907      	ldr	r1, [pc, #28]	; (6378 <grid_d51_init+0x40>)
	#endif
		
}
    635a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "No Hardware Test");
    635e:	4718      	bx	r3
    6360:	000098a5 	.word	0x000098a5
    6364:	00015927 	.word	0x00015927
    6368:	00014451 	.word	0x00014451
    636c:	00015a6c 	.word	0x00015a6c
    6370:	00015a8d 	.word	0x00015a8d
    6374:	00015aa0 	.word	0x00015aa0
    6378:	00015aad 	.word	0x00015aad

0000637c <grid_expr_clear_input>:
}


grid_expr_clear_input(struct grid_expr_model* expr){

    expr->input_string_length = 0;
    637c:	2300      	movs	r3, #0
    637e:	f880 30fe 	strb.w	r3, [r0, #254]	; 0xfe

    for (uint32_t i=0; i<GRID_EXPR_INPUT_STRING_MAXLENGTH; i++){
    6382:	1d02      	adds	r2, r0, #4
    6384:	30fe      	adds	r0, #254	; 0xfe

        expr->input_string[i] = 0;
    6386:	f802 3b01 	strb.w	r3, [r2], #1
    for (uint32_t i=0; i<GRID_EXPR_INPUT_STRING_MAXLENGTH; i++){
    638a:	4282      	cmp	r2, r0
    638c:	d1fb      	bne.n	6386 <grid_expr_clear_input+0xa>

    }

}
    638e:	4770      	bx	lr

00006390 <grid_expr_clear_output>:

grid_expr_clear_output(struct grid_expr_model* expr){


    expr->output_string_length = 0;
    6390:	2300      	movs	r3, #0
    6392:	f880 31fa 	strb.w	r3, [r0, #506]	; 0x1fa

    for (uint32_t i=0; i<GRID_EXPR_OUTPUT_STRING_MAXLENGTH; i++){
    6396:	f100 02ff 	add.w	r2, r0, #255	; 0xff
    639a:	f200 10f9 	addw	r0, r0, #505	; 0x1f9

        expr->output_string[i] = 0;
    639e:	f802 3b01 	strb.w	r3, [r2], #1
    for (uint32_t i=0; i<GRID_EXPR_OUTPUT_STRING_MAXLENGTH; i++){
    63a2:	4282      	cmp	r2, r0
    63a4:	d1fb      	bne.n	639e <grid_expr_clear_output+0xe>

    }

}
    63a6:	4770      	bx	lr

000063a8 <grid_expr_init>:
void grid_expr_init(struct grid_expr_model* expr){
    63a8:	b510      	push	{r4, lr}
    expr->current_event = NULL;
    63aa:	2300      	movs	r3, #0
    63ac:	6003      	str	r3, [r0, #0]
    grid_expr_clear_input(expr);
    63ae:	4b04      	ldr	r3, [pc, #16]	; (63c0 <grid_expr_init+0x18>)
void grid_expr_init(struct grid_expr_model* expr){
    63b0:	4601      	mov	r1, r0
    grid_expr_clear_input(expr);
    63b2:	4798      	blx	r3
}
    63b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    grid_expr_clear_output(expr);
    63b8:	4b02      	ldr	r3, [pc, #8]	; (63c4 <grid_expr_init+0x1c>)
    63ba:	4608      	mov	r0, r1
    63bc:	4718      	bx	r3
    63be:	bf00      	nop
    63c0:	0000637d 	.word	0x0000637d
    63c4:	00006391 	.word	0x00006391

000063c8 <grid_expr_set_current_event>:



grid_expr_set_current_event(struct grid_expr_model* expr, struct grid_ui_event* eve){

    expr->current_event = eve;
    63c8:	6001      	str	r1, [r0, #0]
}
    63ca:	4770      	bx	lr

000063cc <get>:
}


char get(char** e)
{
    char ret = **e;
    63cc:	6802      	ldr	r2, [r0, #0]
{
    63ce:	4603      	mov	r3, r0
    char ret = **e;
    63d0:	f812 0b01 	ldrb.w	r0, [r2], #1
    ++*e;
    63d4:	601a      	str	r2, [r3, #0]
    return ret;
}
    63d6:	4770      	bx	lr

000063d8 <number>:

int number(char** e)
{
    63d8:	b530      	push	{r4, r5, lr}
    char ret = **e;
    63da:	6801      	ldr	r1, [r0, #0]
    63dc:	f811 3b01 	ldrb.w	r3, [r1], #1
    ++*e;
    63e0:	6001      	str	r1, [r0, #0]
{
    63e2:	4602      	mov	r2, r0
    int result = get(e) - '0';
    while (peek(e) >= '0' && peek(e) <= '9') // HEX para
    {
        result = 10*result + get(e) - '0'; // HEX para
    63e4:	250a      	movs	r5, #10
    int result = get(e) - '0';
    63e6:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    return **e;
    63ea:	6811      	ldr	r1, [r2, #0]
    63ec:	780b      	ldrb	r3, [r1, #0]
    while (peek(e) >= '0' && peek(e) <= '9') // HEX para
    63ee:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
    63f2:	2c09      	cmp	r4, #9
    63f4:	d900      	bls.n	63f8 <number+0x20>
    }
    return result;
}
    63f6:	bd30      	pop	{r4, r5, pc}
    ++*e;
    63f8:	3101      	adds	r1, #1
        result = 10*result + get(e) - '0'; // HEX para
    63fa:	fb05 3300 	mla	r3, r5, r0, r3
    ++*e;
    63fe:	6011      	str	r1, [r2, #0]
        result = 10*result + get(e) - '0'; // HEX para
    6400:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    6404:	e7f1      	b.n	63ea <number+0x12>
	...

00006408 <expr_level_0>:
            result -= expr_level_2(e);
    return result;
}

int expr_level_0(char ** e) // equality
{
    6408:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int result = expr_level_1(e);
    640a:	4e2a      	ldr	r6, [pc, #168]	; (64b4 <expr_level_0+0xac>)
        else if (peeked == '=' && peeked2 == '='){
            get(e); // burn the second character
            result = (result == expr_level_1(e));
        }
        else if (peeked == '!' && peeked2 == '='){
            get(e); // burn the second character
    640c:	4f2a      	ldr	r7, [pc, #168]	; (64b8 <expr_level_0+0xb0>)
{
    640e:	4605      	mov	r5, r0
    int result = expr_level_1(e);
    6410:	47b0      	blx	r6
    6412:	4604      	mov	r4, r0
    return **e;
    6414:	682a      	ldr	r2, [r5, #0]
    6416:	7813      	ldrb	r3, [r2, #0]
    while (     (peek(e) == '>' && peek2(e) != '=') || 
    6418:	f003 01fd 	and.w	r1, r3, #253	; 0xfd
    641c:	293c      	cmp	r1, #60	; 0x3c
    641e:	d004      	beq.n	642a <expr_level_0+0x22>
                (peek(e) == '<' && peek2(e) != '=') || 
    6420:	2b3d      	cmp	r3, #61	; 0x3d
    6422:	d143      	bne.n	64ac <expr_level_0+0xa4>
                (peek(e) == '!' && peek2(e) == '=') ||
    6424:	7851      	ldrb	r1, [r2, #1]
    6426:	293d      	cmp	r1, #61	; 0x3d
    6428:	d142      	bne.n	64b0 <expr_level_0+0xa8>
    ++*e;
    642a:	1c51      	adds	r1, r2, #1
    642c:	6029      	str	r1, [r5, #0]
        if ((peeked == '>' && peeked2 != '=')){
    642e:	2b3e      	cmp	r3, #62	; 0x3e
    return **e;
    6430:	7852      	ldrb	r2, [r2, #1]
        if ((peeked == '>' && peeked2 != '=')){
    6432:	d108      	bne.n	6446 <expr_level_0+0x3e>
    6434:	2a3d      	cmp	r2, #61	; 0x3d
            result = (result>expr_level_1(e));
    6436:	4628      	mov	r0, r5
        if ((peeked == '>' && peeked2 != '=')){
    6438:	d028      	beq.n	648c <expr_level_0+0x84>
            result = (result>expr_level_1(e));
    643a:	47b0      	blx	r6
    643c:	42a0      	cmp	r0, r4
    643e:	bfac      	ite	ge
    6440:	2400      	movge	r4, #0
    6442:	2401      	movlt	r4, #1
    6444:	e7e6      	b.n	6414 <expr_level_0+0xc>
        else if (peeked == '<' && peeked2 != '='){
    6446:	2b3c      	cmp	r3, #60	; 0x3c
    6448:	d108      	bne.n	645c <expr_level_0+0x54>
    644a:	2a3d      	cmp	r2, #61	; 0x3d
            result = (result<expr_level_1(e));
    644c:	4628      	mov	r0, r5
        else if (peeked == '<' && peeked2 != '='){
    644e:	d025      	beq.n	649c <expr_level_0+0x94>
            result = (result<expr_level_1(e));
    6450:	47b0      	blx	r6
    6452:	42a0      	cmp	r0, r4
    6454:	bfd4      	ite	le
    6456:	2400      	movle	r4, #0
    6458:	2401      	movgt	r4, #1
    645a:	e7db      	b.n	6414 <expr_level_0+0xc>
        else if (peeked == '=' && peeked2 == '='){
    645c:	2b3d      	cmp	r3, #61	; 0x3d
    645e:	d109      	bne.n	6474 <expr_level_0+0x6c>
    6460:	2a3d      	cmp	r2, #61	; 0x3d
    6462:	d1d7      	bne.n	6414 <expr_level_0+0xc>
            get(e); // burn the second character
    6464:	4628      	mov	r0, r5
    6466:	47b8      	blx	r7
            result = (result == expr_level_1(e));
    6468:	4628      	mov	r0, r5
    646a:	47b0      	blx	r6
    646c:	1b03      	subs	r3, r0, r4
    646e:	425c      	negs	r4, r3
    6470:	415c      	adcs	r4, r3
    6472:	e7cf      	b.n	6414 <expr_level_0+0xc>
        else if (peeked == '!' && peeked2 == '='){
    6474:	2b21      	cmp	r3, #33	; 0x21
    6476:	d1cd      	bne.n	6414 <expr_level_0+0xc>
    6478:	2a3d      	cmp	r2, #61	; 0x3d
    647a:	d1cb      	bne.n	6414 <expr_level_0+0xc>
            get(e); // burn the second character
    647c:	4628      	mov	r0, r5
    647e:	47b8      	blx	r7
            result = (result != expr_level_1(e));
    6480:	4628      	mov	r0, r5
    6482:	47b0      	blx	r6
    6484:	1b04      	subs	r4, r0, r4
    6486:	bf18      	it	ne
    6488:	2401      	movne	r4, #1
    648a:	e7c3      	b.n	6414 <expr_level_0+0xc>
        }
        else if (peeked == '>' && peeked2 == '='){
            get(e); // burn the second character
    648c:	47b8      	blx	r7
            result = (result >= expr_level_1(e));
    648e:	4628      	mov	r0, r5
    6490:	47b0      	blx	r6
    6492:	42a0      	cmp	r0, r4
    6494:	bfcc      	ite	gt
    6496:	2400      	movgt	r4, #0
    6498:	2401      	movle	r4, #1
    649a:	e7bb      	b.n	6414 <expr_level_0+0xc>
        }
        else if (peeked == '<' && peeked2 == '='){
            get(e); // burn the second character
    649c:	47b8      	blx	r7
            result = (result <= expr_level_1(e));
    649e:	4628      	mov	r0, r5
    64a0:	47b0      	blx	r6
    64a2:	42a0      	cmp	r0, r4
    64a4:	bfb4      	ite	lt
    64a6:	2400      	movlt	r4, #0
    64a8:	2401      	movge	r4, #1
    64aa:	e7b3      	b.n	6414 <expr_level_0+0xc>
                (peek(e) == '=' && peek2(e) == '=') ||
    64ac:	2b21      	cmp	r3, #33	; 0x21
    64ae:	d0b9      	beq.n	6424 <expr_level_0+0x1c>
        }
    }
    return result;
}
    64b0:	4620      	mov	r0, r4
    64b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    64b4:	00006575 	.word	0x00006575
    64b8:	000063cd 	.word	0x000063cd

000064bc <expr_level_3>:
        get(e);
    64bc:	4913      	ldr	r1, [pc, #76]	; (650c <expr_level_3+0x50>)
{
    64be:	b570      	push	{r4, r5, r6, lr}
    64c0:	4604      	mov	r4, r0
    64c2:	2501      	movs	r5, #1
    return **e;
    64c4:	6823      	ldr	r3, [r4, #0]
    64c6:	781b      	ldrb	r3, [r3, #0]
    if (peek(e) >= '0' && peek(e) <= '9') // HEX para
    64c8:	2b2f      	cmp	r3, #47	; 0x2f
    64ca:	d908      	bls.n	64de <expr_level_3+0x22>
    64cc:	2b39      	cmp	r3, #57	; 0x39
    64ce:	d818      	bhi.n	6502 <expr_level_3+0x46>
        return number(e);
    64d0:	4b0f      	ldr	r3, [pc, #60]	; (6510 <expr_level_3+0x54>)
    64d2:	4620      	mov	r0, r4
    64d4:	4798      	blx	r3
    64d6:	4601      	mov	r1, r0
}
    64d8:	fb05 f001 	mul.w	r0, r5, r1
    64dc:	bd70      	pop	{r4, r5, r6, pc}
    else if (peek(e) == '(')
    64de:	2b28      	cmp	r3, #40	; 0x28
    64e0:	d109      	bne.n	64f6 <expr_level_3+0x3a>
        get(e); // '('
    64e2:	4e0a      	ldr	r6, [pc, #40]	; (650c <expr_level_3+0x50>)
    64e4:	4620      	mov	r0, r4
    64e6:	47b0      	blx	r6
        int result = expr_level_0(e);
    64e8:	4b0a      	ldr	r3, [pc, #40]	; (6514 <expr_level_3+0x58>)
    64ea:	4620      	mov	r0, r4
    64ec:	4798      	blx	r3
    64ee:	4601      	mov	r1, r0
        get(e); // ')'
    64f0:	4620      	mov	r0, r4
    64f2:	47b0      	blx	r6
        return result;
    64f4:	e7f0      	b.n	64d8 <expr_level_3+0x1c>
    else if (peek(e) == '-')
    64f6:	2b2d      	cmp	r3, #45	; 0x2d
    64f8:	d103      	bne.n	6502 <expr_level_3+0x46>
        get(e);
    64fa:	4620      	mov	r0, r4
    64fc:	4788      	blx	r1
        return -expr_level_3(e);
    64fe:	426d      	negs	r5, r5
    6500:	e7e0      	b.n	64c4 <expr_level_3+0x8>
    printf("ERROR in expr_level_3()\n");
    6502:	4805      	ldr	r0, [pc, #20]	; (6518 <expr_level_3+0x5c>)
    6504:	4b05      	ldr	r3, [pc, #20]	; (651c <expr_level_3+0x60>)
    6506:	4798      	blx	r3
    return 0; // error
    6508:	2100      	movs	r1, #0
    650a:	e7e5      	b.n	64d8 <expr_level_3+0x1c>
    650c:	000063cd 	.word	0x000063cd
    6510:	000063d9 	.word	0x000063d9
    6514:	00006409 	.word	0x00006409
    6518:	00015b35 	.word	0x00015b35
    651c:	0001455d 	.word	0x0001455d

00006520 <expr_level_2>:
{
    6520:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int result = expr_level_3(e);
    6522:	4e13      	ldr	r6, [pc, #76]	; (6570 <expr_level_2+0x50>)
{
    6524:	4605      	mov	r5, r0
    int result = expr_level_3(e);
    6526:	47b0      	blx	r6
    while (peek(e) == '*' || peek(e) == '/' || peek(e) == '%'){
    6528:	f240 4721 	movw	r7, #1057	; 0x421
    int result = expr_level_3(e);
    652c:	4604      	mov	r4, r0
    return **e;
    652e:	682a      	ldr	r2, [r5, #0]
    6530:	7811      	ldrb	r1, [r2, #0]
    while (peek(e) == '*' || peek(e) == '/' || peek(e) == '%'){
    6532:	f1a1 0325 	sub.w	r3, r1, #37	; 0x25
    6536:	b2db      	uxtb	r3, r3
    6538:	2b0a      	cmp	r3, #10
    653a:	d803      	bhi.n	6544 <expr_level_2+0x24>
    653c:	fa27 f303 	lsr.w	r3, r7, r3
    6540:	07db      	lsls	r3, r3, #31
    6542:	d401      	bmi.n	6548 <expr_level_2+0x28>
}
    6544:	4620      	mov	r0, r4
    6546:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ++*e;
    6548:	3201      	adds	r2, #1
        if (peeked == '*'){
    654a:	292a      	cmp	r1, #42	; 0x2a
    ++*e;
    654c:	602a      	str	r2, [r5, #0]
            result *= expr_level_3(e);
    654e:	4628      	mov	r0, r5
        if (peeked == '*'){
    6550:	d102      	bne.n	6558 <expr_level_2+0x38>
            result *= expr_level_3(e);
    6552:	47b0      	blx	r6
    6554:	4344      	muls	r4, r0
    6556:	e7ea      	b.n	652e <expr_level_2+0xe>
        else if (peeked == '%'){
    6558:	2925      	cmp	r1, #37	; 0x25
    655a:	d105      	bne.n	6568 <expr_level_2+0x48>
            result %= expr_level_3(e);
    655c:	47b0      	blx	r6
    655e:	fb94 f3f0 	sdiv	r3, r4, r0
    6562:	fb03 4410 	mls	r4, r3, r0, r4
    6566:	e7e2      	b.n	652e <expr_level_2+0xe>
            result /= expr_level_3(e);
    6568:	47b0      	blx	r6
    656a:	fb94 f4f0 	sdiv	r4, r4, r0
    656e:	e7de      	b.n	652e <expr_level_2+0xe>
    6570:	000064bd 	.word	0x000064bd

00006574 <expr_level_1>:
{
    6574:	b570      	push	{r4, r5, r6, lr}
    int result = expr_level_2(e);
    6576:	4e0b      	ldr	r6, [pc, #44]	; (65a4 <expr_level_1+0x30>)
{
    6578:	4605      	mov	r5, r0
    int result = expr_level_2(e);
    657a:	47b0      	blx	r6
    657c:	4604      	mov	r4, r0
    return **e;
    657e:	682b      	ldr	r3, [r5, #0]
    6580:	781a      	ldrb	r2, [r3, #0]
    while (peek(e) == '+' || peek(e) == '-')
    6582:	2a2b      	cmp	r2, #43	; 0x2b
    6584:	d003      	beq.n	658e <expr_level_1+0x1a>
    6586:	2a2d      	cmp	r2, #45	; 0x2d
    6588:	d001      	beq.n	658e <expr_level_1+0x1a>
}
    658a:	4620      	mov	r0, r4
    658c:	bd70      	pop	{r4, r5, r6, pc}
    ++*e;
    658e:	3301      	adds	r3, #1
        if (get(e) == '+')
    6590:	2a2b      	cmp	r2, #43	; 0x2b
    ++*e;
    6592:	602b      	str	r3, [r5, #0]
            result += expr_level_2(e);
    6594:	4628      	mov	r0, r5
        if (get(e) == '+')
    6596:	d102      	bne.n	659e <expr_level_1+0x2a>
            result += expr_level_2(e);
    6598:	47b0      	blx	r6
    659a:	4404      	add	r4, r0
    659c:	e7ef      	b.n	657e <expr_level_1+0xa>
            result -= expr_level_2(e);
    659e:	47b0      	blx	r6
    65a0:	1a24      	subs	r4, r4, r0
    65a2:	e7ec      	b.n	657e <expr_level_1+0xa>
    65a4:	00006521 	.word	0x00006521

000065a8 <insertTo>:


    return expression_inner(&str);
}

void insertTo(char* start,int length,char* that){
    65a8:	b570      	push	{r4, r5, r6, lr}
    65aa:	b09a      	sub	sp, #104	; 0x68
    65ac:	4604      	mov	r4, r0
    
    char ending[100] = {0};
    65ae:	4b0b      	ldr	r3, [pc, #44]	; (65dc <insertTo+0x34>)
void insertTo(char* start,int length,char* that){
    65b0:	4615      	mov	r5, r2
    65b2:	460e      	mov	r6, r1
    char ending[100] = {0};
    65b4:	2260      	movs	r2, #96	; 0x60
    65b6:	2100      	movs	r1, #0
    65b8:	a802      	add	r0, sp, #8
    65ba:	9101      	str	r1, [sp, #4]
    65bc:	4798      	blx	r3
    
    //printf("insertTo: Hova: %s Milyen hossz helyre: %d Mit: %s\n", start, length, that);
    
    sprintf(ending,"%s",start+length);
    65be:	19a1      	adds	r1, r4, r6
    65c0:	a801      	add	r0, sp, #4
    65c2:	4e07      	ldr	r6, [pc, #28]	; (65e0 <insertTo+0x38>)
    65c4:	47b0      	blx	r6
    sprintf(start,"%s",that);
    65c6:	4629      	mov	r1, r5
    65c8:	4620      	mov	r0, r4
    65ca:	47b0      	blx	r6
    sprintf(start+strlen(that),"%s",ending);
    65cc:	4b05      	ldr	r3, [pc, #20]	; (65e4 <insertTo+0x3c>)
    65ce:	4628      	mov	r0, r5
    65d0:	4798      	blx	r3
    65d2:	a901      	add	r1, sp, #4
    65d4:	4420      	add	r0, r4
    65d6:	47b0      	blx	r6
}
    65d8:	b01a      	add	sp, #104	; 0x68
    65da:	bd70      	pop	{r4, r5, r6, pc}
    65dc:	000142f1 	.word	0x000142f1
    65e0:	000147ff 	.word	0x000147ff
    65e4:	0001480f 	.word	0x0001480f

000065e8 <brack_len>:
        // START: SUKU
    
    int nyitCount = 0;
    int zarCount = 0;
    
    for(int i=0; i<maxLen; i++){
    65e8:	2300      	movs	r3, #0
int brack_len(char* funcDesc,int maxLen){ //pl.: almafa(6*(2+2))*45
    65ea:	b530      	push	{r4, r5, lr}
    int nyitCount = 0;
    65ec:	461a      	mov	r2, r3
    int zarCount = 0;
    65ee:	461c      	mov	r4, r3
    for(int i=0; i<maxLen; i++){
    65f0:	428b      	cmp	r3, r1
    65f2:	da0c      	bge.n	660e <brack_len+0x26>
        
        if (funcDesc[i] == '('){
    65f4:	5cc5      	ldrb	r5, [r0, r3]
    65f6:	2d28      	cmp	r5, #40	; 0x28
    65f8:	f103 0301 	add.w	r3, r3, #1
    65fc:	d101      	bne.n	6602 <brack_len+0x1a>
            
            nyitCount++;
    65fe:	3201      	adds	r2, #1
    6600:	e7f6      	b.n	65f0 <brack_len+0x8>
        }
        else if (funcDesc[i] == ')'){
    6602:	2d29      	cmp	r5, #41	; 0x29
    6604:	d1f4      	bne.n	65f0 <brack_len+0x8>
            zarCount++;
    6606:	3401      	adds	r4, #1
            
            if (zarCount == nyitCount){
    6608:	42a2      	cmp	r2, r4
    660a:	d1f1      	bne.n	65f0 <brack_len+0x8>
                return i+1;
    660c:	4618      	mov	r0, r3
            }
        }
        
    }
}
    660e:	bd30      	pop	{r4, r5, pc}

00006610 <calcSubFnc>:



void calcSubFnc(char* startposition){
    6610:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    uint8_t debug_level = 0; 

    char* fName = startposition;
    char* fNameEnd = strstr(fName,"(");
    6614:	4b82      	ldr	r3, [pc, #520]	; (6820 <calcSubFnc+0x210>)
void calcSubFnc(char* startposition){
    6616:	b0ab      	sub	sp, #172	; 0xac
    char* fNameEnd = strstr(fName,"(");
    6618:	2128      	movs	r1, #40	; 0x28
void calcSubFnc(char* startposition){
    661a:	4680      	mov	r8, r0
    char* fNameEnd = strstr(fName,"(");
    661c:	4798      	blx	r3


    if (debug_level) printf("FNC name: ");
    if (debug_level) delay_ms(1);

    for(uint8_t i=0; i<fNameEnd-fName; i++){
    661e:	eba0 0208 	sub.w	r2, r0, r8
    char* fNameEnd = strstr(fName,"(");
    6622:	4681      	mov	r9, r0
    for(uint8_t i=0; i<fNameEnd-fName; i++){
    6624:	2300      	movs	r3, #0
    6626:	9200      	str	r2, [sp, #0]
    6628:	9900      	ldr	r1, [sp, #0]
    662a:	b2da      	uxtb	r2, r3
    662c:	428a      	cmp	r2, r1
    662e:	f103 0301 	add.w	r3, r3, #1
    6632:	dbf9      	blt.n	6628 <calcSubFnc+0x18>
    }

    if (debug_level) printf("\r\n");
    if (debug_level) delay_ms(1);
    
    int max_offset = brack_len(fNameEnd,strlen(fNameEnd)) -2;
    6634:	4b7b      	ldr	r3, [pc, #492]	; (6824 <calcSubFnc+0x214>)
    
    if (debug_level) printf("calcSubFnc Maxoffset: %d  ## \r\n", max_offset);
    if (debug_level) delay_ms(5);;
    
    int param_expr_results[10] = {0};
    6636:	4f7c      	ldr	r7, [pc, #496]	; (6828 <calcSubFnc+0x218>)
    int max_offset = brack_len(fNameEnd,strlen(fNameEnd)) -2;
    6638:	4648      	mov	r0, r9
    663a:	4798      	blx	r3
    663c:	4b7b      	ldr	r3, [pc, #492]	; (682c <calcSubFnc+0x21c>)
    663e:	4601      	mov	r1, r0
    6640:	4648      	mov	r0, r9
    6642:	4798      	blx	r3
    int param_expr_results[10] = {0};
    6644:	2228      	movs	r2, #40	; 0x28
    int max_offset = brack_len(fNameEnd,strlen(fNameEnd)) -2;
    6646:	1e86      	subs	r6, r0, #2
    int param_expr_results[10] = {0};
    6648:	2100      	movs	r1, #0
    664a:	a807      	add	r0, sp, #28
    664c:	47b8      	blx	r7
    char* comma = strstr(start, ",");
    int commaoffset = -1;
    
    
    
    for (int i=0; i<max_offset; i=i){
    664e:	2500      	movs	r5, #0
    int param_expr_results_count = 0;
    6650:	462c      	mov	r4, r5
    for (int i=0; i<max_offset; i=i){
    6652:	42b5      	cmp	r5, r6
    6654:	da2a      	bge.n	66ac <calcSubFnc+0x9c>
    6656:	eb09 0a05 	add.w	sl, r9, r5
    665a:	4652      	mov	r2, sl
    665c:	46ab      	mov	fp, r5
        
        int commaoffset = -1;
        
        for(int j=i; j<max_offset; j++){
            
            if (start[j] == ','){
    665e:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    6662:	f8cd b004 	str.w	fp, [sp, #4]
    6666:	292c      	cmp	r1, #44	; 0x2c
    6668:	f10b 0b01 	add.w	fp, fp, #1
    666c:	f000 80cc 	beq.w	6808 <calcSubFnc+0x1f8>
        for(int j=i; j<max_offset; j++){
    6670:	455e      	cmp	r6, fp
    6672:	dcf4      	bgt.n	665e <calcSubFnc+0x4e>
 
        if (commaoffset==-1){
            
           // printf("No more commas! \r\n");
            
            char param_expr[20] = {0};
    6674:	f04f 0900 	mov.w	r9, #0
    6678:	4649      	mov	r1, r9
    667a:	2210      	movs	r2, #16
    667c:	a812      	add	r0, sp, #72	; 0x48
    667e:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
            
            for (int j=0; j<(max_offset-i); j++){
    6682:	1b75      	subs	r5, r6, r5
            char param_expr[20] = {0};
    6684:	47b8      	blx	r7
            for (int j=0; j<(max_offset-i); j++){
    6686:	4649      	mov	r1, r9
    6688:	ab11      	add	r3, sp, #68	; 0x44
    668a:	e003      	b.n	6694 <calcSubFnc+0x84>
                param_expr[j] = start[i+j];
    668c:	f81a 2f01 	ldrb.w	r2, [sl, #1]!
    6690:	545a      	strb	r2, [r3, r1]
            for (int j=0; j<(max_offset-i); j++){
    6692:	3101      	adds	r1, #1
    6694:	428d      	cmp	r5, r1
    6696:	dcf9      	bgt.n	668c <calcSubFnc+0x7c>
            }
            
            if (debug_level) printf("Parameter: \"%s\", ", param_expr);
            if (debug_level) delay_ms(2);
            
            param_expr_results[param_expr_results_count] = expression(param_expr);
    6698:	9304      	str	r3, [sp, #16]
    int result = expr_level_0(e);
    669a:	a804      	add	r0, sp, #16
    669c:	4b64      	ldr	r3, [pc, #400]	; (6830 <calcSubFnc+0x220>)
    669e:	4798      	blx	r3
            param_expr_results[param_expr_results_count] = expression(param_expr);
    66a0:	ab2a      	add	r3, sp, #168	; 0xa8
    66a2:	eb03 0384 	add.w	r3, r3, r4, lsl #2
            
            
            if (debug_level) printf("Result: \"%d\" \r\n", param_expr_results[param_expr_results_count]);
            if (debug_level) delay_ms(2);
            
            param_expr_results_count++;
    66a6:	3401      	adds	r4, #1
            param_expr_results[param_expr_results_count] = expression(param_expr);
    66a8:	f843 0c8c 	str.w	r0, [r3, #-140]
    
    
    // START: CALC BUILTIN


    char justName[10] = {0};
    66ac:	2300      	movs	r3, #0
    66ae:	aa04      	add	r2, sp, #16
    66b0:	e9cd 3304 	strd	r3, r3, [sp, #16]
    66b4:	f8ad 3018 	strh.w	r3, [sp, #24]
    
    for (int i=0; i<9; i++){
    66b8:	f108 0008 	add.w	r0, r8, #8
    66bc:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
    66c0:	4693      	mov	fp, r2
        
        if (fName[i] == '('){
    66c2:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    66c6:	2928      	cmp	r1, #40	; 0x28
    66c8:	d127      	bne.n	671a <calcSubFnc+0x10a>
        }
        
    }

    
    if(strcmp(justName,"abs")==0){
    66ca:	495a      	ldr	r1, [pc, #360]	; (6834 <calcSubFnc+0x224>)
    66cc:	4d5a      	ldr	r5, [pc, #360]	; (6838 <calcSubFnc+0x228>)
    66ce:	f8df a19c 	ldr.w	sl, [pc, #412]	; 686c <calcSubFnc+0x25c>
    66d2:	4658      	mov	r0, fp
    66d4:	47a8      	blx	r5
    66d6:	f10d 0944 	add.w	r9, sp, #68	; 0x44
    66da:	b318      	cbz	r0, 6724 <calcSubFnc+0x114>
        resultOfFnc = abs(param_expr_results[0]);
    }
    else if(strcmp(justName,"six")==0){
    66dc:	4957      	ldr	r1, [pc, #348]	; (683c <calcSubFnc+0x22c>)
    66de:	4658      	mov	r0, fp
    66e0:	47a8      	blx	r5
    66e2:	2800      	cmp	r0, #0
    66e4:	f000 808e 	beq.w	6804 <calcSubFnc+0x1f4>
        resultOfFnc = 666666;
    }
    else if(strcmp(justName,"add")==0){
    66e8:	4955      	ldr	r1, [pc, #340]	; (6840 <calcSubFnc+0x230>)
    66ea:	4658      	mov	r0, fp
    66ec:	47a8      	blx	r5
    66ee:	2800      	cmp	r0, #0
    66f0:	d130      	bne.n	6754 <calcSubFnc+0x144>
        resultOfFnc = param_expr_results[0] + param_expr_results[1];
    66f2:	e9dd 5307 	ldrd	r5, r3, [sp, #28]
    66f6:	441d      	add	r5, r3
    66f8:	e018      	b.n	672c <calcSubFnc+0x11c>
                param_expr[j] = start[i+j];
    66fa:	f81a 0f01 	ldrb.w	r0, [sl, #1]!
    66fe:	5488      	strb	r0, [r1, r2]
            for (int j=0; j<commaoffset-i; j++){
    6700:	3201      	adds	r2, #1
    6702:	4295      	cmp	r5, r2
    6704:	dcf9      	bgt.n	66fa <calcSubFnc+0xea>
    int result = expr_level_0(e);
    6706:	4b4a      	ldr	r3, [pc, #296]	; (6830 <calcSubFnc+0x220>)
    6708:	9104      	str	r1, [sp, #16]
    670a:	a804      	add	r0, sp, #16
    670c:	4798      	blx	r3
            param_expr_results[param_expr_results_count] = expression(param_expr);
    670e:	ab07      	add	r3, sp, #28
    6710:	465d      	mov	r5, fp
    6712:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
            param_expr_results_count++;
    6716:	3401      	adds	r4, #1
    for (int i=0; i<max_offset; i=i){
    6718:	e79b      	b.n	6652 <calcSubFnc+0x42>
    for (int i=0; i<9; i++){
    671a:	4283      	cmp	r3, r0
            justName[i] = fName[i];
    671c:	f802 1b01 	strb.w	r1, [r2], #1
    for (int i=0; i<9; i++){
    6720:	d1cf      	bne.n	66c2 <calcSubFnc+0xb2>
    6722:	e7d2      	b.n	66ca <calcSubFnc+0xba>
        resultOfFnc = abs(param_expr_results[0]);
    6724:	9d07      	ldr	r5, [sp, #28]
    6726:	2d00      	cmp	r5, #0
    6728:	bfb8      	it	lt
    672a:	426d      	neglt	r5, r5
    
    //printf("resultOfFnc: %d\n", resultOfFnc);
    

    
    char buff[100] = {0};
    672c:	2100      	movs	r1, #0
    672e:	2260      	movs	r2, #96	; 0x60
    6730:	a812      	add	r0, sp, #72	; 0x48
    6732:	9111      	str	r1, [sp, #68]	; 0x44
    6734:	47b8      	blx	r7
    
    sprintf(buff,"(%d)",resultOfFnc); //HEX para, sign para
    6736:	462a      	mov	r2, r5
    6738:	4942      	ldr	r1, [pc, #264]	; (6844 <calcSubFnc+0x234>)
    673a:	4648      	mov	r0, r9
    673c:	47d0      	blx	sl
    
    // hova, milyen hosszan, mit
    insertTo(startposition,(fNameEnd-fName)+max_offset+2,buff);
    673e:	9b00      	ldr	r3, [sp, #0]
    6740:	4433      	add	r3, r6
    6742:	4619      	mov	r1, r3
    6744:	464a      	mov	r2, r9
    6746:	4b40      	ldr	r3, [pc, #256]	; (6848 <calcSubFnc+0x238>)
    6748:	3102      	adds	r1, #2
    674a:	4640      	mov	r0, r8
    674c:	4798      	blx	r3
    
        
    //printf(" @@ debug: %s @@\n", startposition);
}
    674e:	b02b      	add	sp, #172	; 0xac
    6750:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    else if(strcmp(justName,"print")==0 || strcmp(justName,"p")==0 ){
    6754:	493d      	ldr	r1, [pc, #244]	; (684c <calcSubFnc+0x23c>)
    6756:	4658      	mov	r0, fp
    6758:	47a8      	blx	r5
    675a:	b120      	cbz	r0, 6766 <calcSubFnc+0x156>
    675c:	493c      	ldr	r1, [pc, #240]	; (6850 <calcSubFnc+0x240>)
    675e:	4658      	mov	r0, fp
    6760:	47a8      	blx	r5
    6762:	2800      	cmp	r0, #0
    6764:	d13e      	bne.n	67e4 <calcSubFnc+0x1d4>
        char fmt_str[] = "%02x";
    6766:	4b3b      	ldr	r3, [pc, #236]	; (6854 <calcSubFnc+0x244>)
        if (param_expr_results_count>1){
    6768:	2c01      	cmp	r4, #1
        char fmt_str[] = "%02x";
    676a:	6818      	ldr	r0, [r3, #0]
    676c:	791b      	ldrb	r3, [r3, #4]
    676e:	9002      	str	r0, [sp, #8]
    6770:	f88d 300c 	strb.w	r3, [sp, #12]
        if (param_expr_results_count>1){
    6774:	dd0a      	ble.n	678c <calcSubFnc+0x17c>
            if (param_expr_results[param_expr_results_count-1]<=8){
    6776:	ab2a      	add	r3, sp, #168	; 0xa8
    6778:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    677c:	f853 3c90 	ldr.w	r3, [r3, #-144]
    6780:	2b08      	cmp	r3, #8
                fmt_str[2] = param_expr_results[param_expr_results_count-1]+'0';
    6782:	bfd4      	ite	le
    6784:	3330      	addle	r3, #48	; 0x30
                fmt_str[2] = 8+'0';
    6786:	2338      	movgt	r3, #56	; 0x38
    6788:	f88d 300a 	strb.w	r3, [sp, #10]
        uint8_t temp_array[20] = {0};
    678c:	2100      	movs	r1, #0
    678e:	2210      	movs	r2, #16
    6790:	a812      	add	r0, sp, #72	; 0x48
    6792:	9111      	str	r1, [sp, #68]	; 0x44
    6794:	47b8      	blx	r7
        sprintf(temp_array, fmt_str, param_expr_results[0]);
    6796:	9d07      	ldr	r5, [sp, #28]
    6798:	a902      	add	r1, sp, #8
    679a:	462a      	mov	r2, r5
    679c:	4648      	mov	r0, r9
    679e:	47d0      	blx	sl
        if (param_expr_results_count>1){
    67a0:	2c01      	cmp	r4, #1
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    67a2:	4a2d      	ldr	r2, [pc, #180]	; (6858 <calcSubFnc+0x248>)
            temp_array_length = param_expr_results[param_expr_results_count-1];
    67a4:	bfc4      	itt	gt
    67a6:	ab2a      	addgt	r3, sp, #168	; 0xa8
    67a8:	eb03 0484 	addgt.w	r4, r3, r4, lsl #2
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    67ac:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
            temp_array_length = param_expr_results[param_expr_results_count-1];
    67b0:	bfc8      	it	gt
    67b2:	f814 1c90 	ldrbgt.w	r1, [r4, #-144]
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    67b6:	b2d8      	uxtb	r0, r3
    67b8:	f5c3 73fc 	rsb	r3, r3, #504	; 0x1f8
            temp_array_length = 2; // default print length
    67bc:	bfd8      	it	le
    67be:	2102      	movle	r1, #2
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    67c0:	3301      	adds	r3, #1
    67c2:	1a5b      	subs	r3, r3, r1
    67c4:	4413      	add	r3, r2
        for (uint8_t i=0; i<temp_array_length; i++){
    67c6:	2400      	movs	r4, #0
    67c8:	fa5f fc84 	uxtb.w	ip, r4
    67cc:	458c      	cmp	ip, r1
    67ce:	d303      	bcc.n	67d8 <calcSubFnc+0x1c8>
        expr->output_string_length += temp_array_length;
    67d0:	4401      	add	r1, r0
    67d2:	f882 11fa 	strb.w	r1, [r2, #506]	; 0x1fa
    else if(strcmp(justName,"print")==0 || strcmp(justName,"p")==0 ){
    67d6:	e7a9      	b.n	672c <calcSubFnc+0x11c>
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    67d8:	f819 c004 	ldrb.w	ip, [r9, r4]
    67dc:	f803 cb01 	strb.w	ip, [r3], #1
        for (uint8_t i=0; i<temp_array_length; i++){
    67e0:	3401      	adds	r4, #1
    67e2:	e7f1      	b.n	67c8 <calcSubFnc+0x1b8>
    else if(strcmp(justName,"if")==0){
    67e4:	491d      	ldr	r1, [pc, #116]	; (685c <calcSubFnc+0x24c>)
    67e6:	4658      	mov	r0, fp
    67e8:	47a8      	blx	r5
    67ea:	b928      	cbnz	r0, 67f8 <calcSubFnc+0x1e8>
        if (param_expr_results[0]){
    67ec:	9b07      	ldr	r3, [sp, #28]
    67ee:	b10b      	cbz	r3, 67f4 <calcSubFnc+0x1e4>
            resultOfFnc = param_expr_results[1];
    67f0:	9d08      	ldr	r5, [sp, #32]
    67f2:	e79b      	b.n	672c <calcSubFnc+0x11c>
            resultOfFnc = param_expr_results[2];
    67f4:	9d09      	ldr	r5, [sp, #36]	; 0x24
    67f6:	e799      	b.n	672c <calcSubFnc+0x11c>
        printf("Function \"%s\" not found!\n", justName);
    67f8:	4819      	ldr	r0, [pc, #100]	; (6860 <calcSubFnc+0x250>)
    67fa:	4b1a      	ldr	r3, [pc, #104]	; (6864 <calcSubFnc+0x254>)
    67fc:	4659      	mov	r1, fp
    67fe:	4798      	blx	r3
        resultOfFnc = 0;
    6800:	2500      	movs	r5, #0
    6802:	e793      	b.n	672c <calcSubFnc+0x11c>
        resultOfFnc = 666666;
    6804:	4d18      	ldr	r5, [pc, #96]	; (6868 <calcSubFnc+0x258>)
    6806:	e791      	b.n	672c <calcSubFnc+0x11c>
            char param_expr[20] = {0};
    6808:	2300      	movs	r3, #0
    680a:	4619      	mov	r1, r3
    680c:	9311      	str	r3, [sp, #68]	; 0x44
    680e:	2210      	movs	r2, #16
    6810:	4b05      	ldr	r3, [pc, #20]	; (6828 <calcSubFnc+0x218>)
    6812:	a812      	add	r0, sp, #72	; 0x48
    6814:	4798      	blx	r3
            for (int j=0; j<commaoffset-i; j++){
    6816:	9b01      	ldr	r3, [sp, #4]
    6818:	2200      	movs	r2, #0
    681a:	1b5d      	subs	r5, r3, r5
    681c:	a911      	add	r1, sp, #68	; 0x44
    681e:	e770      	b.n	6702 <calcSubFnc+0xf2>
    6820:	000147d1 	.word	0x000147d1
    6824:	0001480f 	.word	0x0001480f
    6828:	000142f1 	.word	0x000142f1
    682c:	000065e9 	.word	0x000065e9
    6830:	00006409 	.word	0x00006409
    6834:	00015b4d 	.word	0x00015b4d
    6838:	000147eb 	.word	0x000147eb
    683c:	00015b51 	.word	0x00015b51
    6840:	00015b55 	.word	0x00015b55
    6844:	00015b7c 	.word	0x00015b7c
    6848:	000065a9 	.word	0x000065a9
    684c:	00015b59 	.word	0x00015b59
    6850:	00016732 	.word	0x00016732
    6854:	00015b81 	.word	0x00015b81
    6858:	20013220 	.word	0x20013220
    685c:	00015b5f 	.word	0x00015b5f
    6860:	00015b62 	.word	0x00015b62
    6864:	00014451 	.word	0x00014451
    6868:	000a2c2a 	.word	0x000a2c2a
    686c:	00014791 	.word	0x00014791

00006870 <char_is_valid_name>:


uint8_t char_is_valid_name(uint8_t ch){


    if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch == '_')){
    6870:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    6874:	2b09      	cmp	r3, #9
    6876:	d909      	bls.n	688c <char_is_valid_name+0x1c>
    6878:	f020 0320 	bic.w	r3, r0, #32
    687c:	3b41      	subs	r3, #65	; 0x41
    687e:	2b19      	cmp	r3, #25
    6880:	d904      	bls.n	688c <char_is_valid_name+0x1c>

                    return 1;
    6882:	f1a0 035f 	sub.w	r3, r0, #95	; 0x5f
    6886:	4258      	negs	r0, r3
    6888:	4158      	adcs	r0, r3
    688a:	4770      	bx	lr
    688c:	2001      	movs	r0, #1
                }
    
    return 0;


}
    688e:	4770      	bx	lr

00006890 <subst_all_variables_starting_from_the_back>:


void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    6890:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6894:	ed2d 8b02 	vpush	{d8}
    uint8_t variable_name_valid = 0;
    

    int izgi = 0;
    int var_end_pos = -1;
    char var_name[10] = {0};
    6898:	2200      	movs	r2, #0
void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    689a:	b0a1      	sub	sp, #132	; 0x84
    char var_name[10] = {0};
    689c:	e9cd 2201 	strd	r2, r2, [sp, #4]
    68a0:	f8df a23c 	ldr.w	sl, [pc, #572]	; 6ae0 <subst_all_variables_starting_from_the_back+0x250>
    68a4:	f8ad 200c 	strh.w	r2, [sp, #12]
void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    68a8:	460d      	mov	r5, r1
    68aa:	1846      	adds	r6, r0, r1
    int var_end_pos = -1;
    68ac:	f04f 3bff 	mov.w	fp, #4294967295	; 0xffffffff
    uint8_t variable_name_found = 0;
    68b0:	4611      	mov	r1, r2
    uint8_t function_name_found = 0;
    68b2:	4691      	mov	r9, r2
    
    if (debug_level) printf("Subst Vars\r\n");
    
    // i must be signed int
    for(int i = len; i>=0; i--){
    68b4:	2d00      	cmp	r5, #0
    68b6:	da04      	bge.n	68c2 <subst_all_variables_starting_from_the_back+0x32>
    if (debug_level ==2) printf("i%d %d %d %d\r\n",i, function_name_found, variable_name_found, variable_name_valid);
    if (debug_level ==2) delay_ms(5);
        
    }
    
}
    68b8:	b021      	add	sp, #132	; 0x84
    68ba:	ecbd 8b02 	vpop	{d8}
    68be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (function_name_found){
    68c2:	ee08 6a10 	vmov	s16, r6
    68c6:	f816 4901 	ldrb.w	r4, [r6], #-1
    68ca:	4620      	mov	r0, r4
    68cc:	47d0      	blx	sl
    68ce:	f1b9 0f00 	cmp.w	r9, #0
    68d2:	d011      	beq.n	68f8 <subst_all_variables_starting_from_the_back+0x68>
                function_name_found=0;
    68d4:	f1b0 0900 	subs.w	r9, r0, #0
    68d8:	bf18      	it	ne
    68da:	f04f 0901 	movne.w	r9, #1
        if (variable_name_found){
    68de:	2900      	cmp	r1, #0
    68e0:	d144      	bne.n	696c <subst_all_variables_starting_from_the_back+0xdc>
                for (int j = 0; j<10; j++){
    68e2:	2300      	movs	r3, #0
    68e4:	aa01      	add	r2, sp, #4
                var_name[j] = 0;
    68e6:	4619      	mov	r1, r3
            for (int j = 0; j<10; j++){
    68e8:	3301      	adds	r3, #1
    68ea:	2b0a      	cmp	r3, #10
                var_name[j] = 0;
    68ec:	f802 1b01 	strb.w	r1, [r2], #1
            for (int j = 0; j<10; j++){
    68f0:	d1fa      	bne.n	68e8 <subst_all_variables_starting_from_the_back+0x58>
            variable_name_valid = 0;
    68f2:	2200      	movs	r2, #0
            variable_name_found = 0;
    68f4:	4611      	mov	r1, r2
    68f6:	e04c      	b.n	6992 <subst_all_variables_starting_from_the_back+0x102>
        else if (variable_name_found == 0){
    68f8:	2900      	cmp	r1, #0
    68fa:	d137      	bne.n	696c <subst_all_variables_starting_from_the_back+0xdc>
            if  (char_is_valid_name(expr_string[i])){
    68fc:	2800      	cmp	r0, #0
    68fe:	d0f0      	beq.n	68e2 <subst_all_variables_starting_from_the_back+0x52>
                if (expr_string[i+1] == '('){
    6900:	78b3      	ldrb	r3, [r6, #2]
    6902:	2b28      	cmp	r3, #40	; 0x28
    6904:	f000 80cd 	beq.w	6aa2 <subst_all_variables_starting_from_the_back+0x212>
                    if ((expr_string[i] >= '0' && expr_string[i] <= '9')){
    6908:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
                        variable_name_valid = 1; 
    690c:	2b09      	cmp	r3, #9
    690e:	bf88      	it	hi
    6910:	2201      	movhi	r2, #1
void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    6912:	46ab      	mov	fp, r5
                var_name[var_end_pos-i] = expr_string[i];
    6914:	ebab 0305 	sub.w	r3, fp, r5
    6918:	a920      	add	r1, sp, #128	; 0x80
    691a:	440b      	add	r3, r1
    691c:	f803 4c7c 	strb.w	r4, [r3, #-124]
                if ((expr_string[i] >= '0' && expr_string[i] <= '9')){
    6920:	3c30      	subs	r4, #48	; 0x30
    6922:	2c09      	cmp	r4, #9
    6924:	d924      	bls.n	6970 <subst_all_variables_starting_from_the_back+0xe0>
                if (i==0){
    6926:	b125      	cbz	r5, 6932 <subst_all_variables_starting_from_the_back+0xa2>
                    if (!char_is_valid_name(expr_string[i-1])){
    6928:	7830      	ldrb	r0, [r6, #0]
    692a:	47d0      	blx	sl
    692c:	2800      	cmp	r0, #0
    692e:	f040 80b6 	bne.w	6a9e <subst_all_variables_starting_from_the_back+0x20e>
                    int var_name_len = strlen(var_name);
    6932:	4b5e      	ldr	r3, [pc, #376]	; (6aac <subst_all_variables_starting_from_the_back+0x21c>)
    6934:	a801      	add	r0, sp, #4
    6936:	4798      	blx	r3
                    char var_name_good[10] = {0};
    6938:	2300      	movs	r3, #0
    693a:	e9cd 3304 	strd	r3, r3, [sp, #16]
    693e:	aa01      	add	r2, sp, #4
                    int var_name_len = strlen(var_name);
    6940:	4680      	mov	r8, r0
                    char var_name_good[10] = {0};
    6942:	4402      	add	r2, r0
    6944:	f8ad 3018 	strh.w	r3, [sp, #24]
                    for (int j = 0; j<var_name_len; j++){
    6948:	a904      	add	r1, sp, #16
                        var_name_good[j+1] = 0;
    694a:	4618      	mov	r0, r3
                    for (int j = 0; j<var_name_len; j++){
    694c:	4543      	cmp	r3, r8
    694e:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
    6952:	db20      	blt.n	6996 <subst_all_variables_starting_from_the_back+0x106>
                    if (var_name_len == 2 || var_name_len == 3){
    6954:	f1a8 0302 	sub.w	r3, r8, #2
    6958:	2b01      	cmp	r3, #1
    695a:	d864      	bhi.n	6a26 <subst_all_variables_starting_from_the_back+0x196>
                        if (var_name_good[0] == 'T'){
    695c:	f89d 3010 	ldrb.w	r3, [sp, #16]
    6960:	2b54      	cmp	r3, #84	; 0x54
    6962:	d15e      	bne.n	6a22 <subst_all_variables_starting_from_the_back+0x192>
                            for (uint8_t j = 1; j<var_name_len; j++){
    6964:	2301      	movs	r3, #1
                            uint8_t index = 0;
    6966:	2200      	movs	r2, #0
                            uint8_t is_template_var = 1;
    6968:	4618      	mov	r0, r3
    696a:	e02d      	b.n	69c8 <subst_all_variables_starting_from_the_back+0x138>
            if (char_is_valid_name(expr_string[i])){
    696c:	2800      	cmp	r0, #0
    696e:	d1d1      	bne.n	6914 <subst_all_variables_starting_from_the_back+0x84>
            if (variable_name_valid){
    6970:	2a00      	cmp	r2, #0
    6972:	d1d8      	bne.n	6926 <subst_all_variables_starting_from_the_back+0x96>
    6974:	2401      	movs	r4, #1
            if (!char_is_valid_name(expr_string[i])){
    6976:	7870      	ldrb	r0, [r6, #1]
    6978:	47d0      	blx	sl
    697a:	4601      	mov	r1, r0
    697c:	2800      	cmp	r0, #0
    697e:	f040 8093 	bne.w	6aa8 <subst_all_variables_starting_from_the_back+0x218>
    6982:	aa01      	add	r2, sp, #4
                for (int j = 0; j<10; j++){
    6984:	4603      	mov	r3, r0
    6986:	3301      	adds	r3, #1
    6988:	2b0a      	cmp	r3, #10
                    var_name[j] = 0;
    698a:	f802 0b01 	strb.w	r0, [r2], #1
                for (int j = 0; j<10; j++){
    698e:	d1fa      	bne.n	6986 <subst_all_variables_starting_from_the_back+0xf6>
                variable_name_valid = 0;
    6990:	2200      	movs	r2, #0
    for(int i = len; i>=0; i--){
    6992:	3d01      	subs	r5, #1
    6994:	e78e      	b.n	68b4 <subst_all_variables_starting_from_the_back+0x24>
                        var_name_good[j] = var_name[var_name_len-1-j];
    6996:	7814      	ldrb	r4, [r2, #0]
    6998:	700c      	strb	r4, [r1, #0]
                        var_name_good[j+1] = 0;
    699a:	3301      	adds	r3, #1
    699c:	f801 0f01 	strb.w	r0, [r1, #1]!
                    for (int j = 0; j<var_name_len; j++){
    69a0:	e7d4      	b.n	694c <subst_all_variables_starting_from_the_back+0xbc>
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    69a2:	a920      	add	r1, sp, #128	; 0x80
    69a4:	4419      	add	r1, r3
                            for (uint8_t j = 1; j<var_name_len; j++){
    69a6:	3301      	adds	r3, #1
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    69a8:	f811 1c70 	ldrb.w	r1, [r1, #-112]
    69ac:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
    69b0:	2c09      	cmp	r4, #9
                                    index = index*10;
    69b2:	bf9f      	itttt	ls
    69b4:	eb02 0282 	addls.w	r2, r2, r2, lsl #2
    69b8:	eb01 0242 	addls.w	r2, r1, r2, lsl #1
                                    index += var_name_good[j] - '0'; 
    69bc:	3a30      	subls	r2, #48	; 0x30
    69be:	f002 02ff 	andls.w	r2, r2, #255	; 0xff
                                    is_template_var = 0;
    69c2:	bf88      	it	hi
    69c4:	2000      	movhi	r0, #0
                            for (uint8_t j = 1; j<var_name_len; j++){
    69c6:	b2db      	uxtb	r3, r3
    69c8:	4543      	cmp	r3, r8
    69ca:	dbea      	blt.n	69a2 <subst_all_variables_starting_from_the_back+0x112>
                            if (is_template_var){
    69cc:	b358      	cbz	r0, 6a26 <subst_all_variables_starting_from_the_back+0x196>
                                variable_value = grid_expr_state.current_event->parent->template_parameter_list[index];
    69ce:	4b38      	ldr	r3, [pc, #224]	; (6ab0 <subst_all_variables_starting_from_the_back+0x220>)
    69d0:	681b      	ldr	r3, [r3, #0]
    69d2:	685b      	ldr	r3, [r3, #4]
    69d4:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    69d8:	68d4      	ldr	r4, [r2, #12]
                    char buff[100] = {0};
    69da:	4b36      	ldr	r3, [pc, #216]	; (6ab4 <subst_all_variables_starting_from_the_back+0x224>)
    69dc:	2700      	movs	r7, #0
    69de:	2260      	movs	r2, #96	; 0x60
    69e0:	4639      	mov	r1, r7
    69e2:	a808      	add	r0, sp, #32
    69e4:	9707      	str	r7, [sp, #28]
    69e6:	4798      	blx	r3
                    sprintf(buff,"%d",variable_value); // HEX para
    69e8:	4933      	ldr	r1, [pc, #204]	; (6ab8 <subst_all_variables_starting_from_the_back+0x228>)
    69ea:	4b34      	ldr	r3, [pc, #208]	; (6abc <subst_all_variables_starting_from_the_back+0x22c>)
    69ec:	4622      	mov	r2, r4
    69ee:	a807      	add	r0, sp, #28
    69f0:	4798      	blx	r3
                    insertTo(found,var_name_len,buff);
    69f2:	4b33      	ldr	r3, [pc, #204]	; (6ac0 <subst_all_variables_starting_from_the_back+0x230>)
    69f4:	aa07      	add	r2, sp, #28
    69f6:	4641      	mov	r1, r8
    69f8:	ee18 0a10 	vmov	r0, s16
    69fc:	4798      	blx	r3
                    for (int j = 0; j<10; j++){
    69fe:	ab01      	add	r3, sp, #4
                    insertTo(found,var_name_len,buff);
    6a00:	461a      	mov	r2, r3
                        var_name[j] = 0;
    6a02:	4639      	mov	r1, r7
                    for (int j = 0; j<10; j++){
    6a04:	3701      	adds	r7, #1
    6a06:	2f0a      	cmp	r7, #10
                        var_name[j] = 0;
    6a08:	f802 1b01 	strb.w	r1, [r2], #1
                    for (int j = 0; j<10; j++){
    6a0c:	d1fa      	bne.n	6a04 <subst_all_variables_starting_from_the_back+0x174>
                    for (int j = 0; j<10; j++){
    6a0e:	2200      	movs	r2, #0
                        var_name[j] = 0;
    6a10:	4611      	mov	r1, r2
                    for (int j = 0; j<10; j++){
    6a12:	3201      	adds	r2, #1
    6a14:	2a0a      	cmp	r2, #10
                        var_name[j] = 0;
    6a16:	f803 1b01 	strb.w	r1, [r3], #1
                    for (int j = 0; j<10; j++){
    6a1a:	d1fa      	bne.n	6a12 <subst_all_variables_starting_from_the_back+0x182>
                    variable_name_valid = 0;
    6a1c:	2200      	movs	r2, #0
    6a1e:	4614      	mov	r4, r2
    6a20:	e7a9      	b.n	6976 <subst_all_variables_starting_from_the_back+0xe6>
                        else if (var_name_good[0] == 'Z'){
    6a22:	2b5a      	cmp	r3, #90	; 0x5a
    6a24:	d01e      	beq.n	6a64 <subst_all_variables_starting_from_the_back+0x1d4>
                    int32_t variable_value = 1;
    6a26:	2401      	movs	r4, #1
    6a28:	e7d7      	b.n	69da <subst_all_variables_starting_from_the_back+0x14a>
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    6a2a:	a920      	add	r1, sp, #128	; 0x80
    6a2c:	4411      	add	r1, r2
                            for (uint8_t j = 1; j<var_name_len; j++){
    6a2e:	3201      	adds	r2, #1
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    6a30:	f811 1c70 	ldrb.w	r1, [r1, #-112]
    6a34:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
    6a38:	2c09      	cmp	r4, #9
                                    index = index*10;
    6a3a:	bf9f      	itttt	ls
    6a3c:	eb03 0383 	addls.w	r3, r3, r3, lsl #2
    6a40:	eb01 0343 	addls.w	r3, r1, r3, lsl #1
                                    index += var_name_good[j] - '0'; 
    6a44:	3b30      	subls	r3, #48	; 0x30
    6a46:	f003 03ff 	andls.w	r3, r3, #255	; 0xff
                                    is_template_var = 0;
    6a4a:	bf88      	it	hi
    6a4c:	2000      	movhi	r0, #0
                            for (uint8_t j = 1; j<var_name_len; j++){
    6a4e:	b2d2      	uxtb	r2, r2
    6a50:	4542      	cmp	r2, r8
    6a52:	dbea      	blt.n	6a2a <subst_all_variables_starting_from_the_back+0x19a>
                            if (is_template_var){
    6a54:	2800      	cmp	r0, #0
    6a56:	d0e6      	beq.n	6a26 <subst_all_variables_starting_from_the_back+0x196>
                                if (index == 0){
    6a58:	b943      	cbnz	r3, 6a6c <subst_all_variables_starting_from_the_back+0x1dc>
                                    variable_value = grid_sys_get_bank_num(&grid_sys_state);
    6a5a:	481a      	ldr	r0, [pc, #104]	; (6ac4 <subst_all_variables_starting_from_the_back+0x234>)
    6a5c:	4b1a      	ldr	r3, [pc, #104]	; (6ac8 <subst_all_variables_starting_from_the_back+0x238>)
                                    variable_value = grid_sys_get_bank_next(&grid_sys_state);
    6a5e:	4798      	blx	r3
    6a60:	4604      	mov	r4, r0
    6a62:	e7ba      	b.n	69da <subst_all_variables_starting_from_the_back+0x14a>
                            for (uint8_t j = 1; j<var_name_len; j++){
    6a64:	2201      	movs	r2, #1
                            uint8_t index = 0;
    6a66:	2300      	movs	r3, #0
                            uint8_t is_template_var = 1;
    6a68:	4610      	mov	r0, r2
    6a6a:	e7f1      	b.n	6a50 <subst_all_variables_starting_from_the_back+0x1c0>
                                else if (index == 1){
    6a6c:	2b01      	cmp	r3, #1
    6a6e:	d102      	bne.n	6a76 <subst_all_variables_starting_from_the_back+0x1e6>
                                    variable_value = grid_sys_get_bank_red(&grid_sys_state);
    6a70:	4814      	ldr	r0, [pc, #80]	; (6ac4 <subst_all_variables_starting_from_the_back+0x234>)
    6a72:	4b16      	ldr	r3, [pc, #88]	; (6acc <subst_all_variables_starting_from_the_back+0x23c>)
    6a74:	e7f3      	b.n	6a5e <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 2){
    6a76:	2b02      	cmp	r3, #2
    6a78:	d102      	bne.n	6a80 <subst_all_variables_starting_from_the_back+0x1f0>
                                    variable_value = grid_sys_get_bank_gre(&grid_sys_state);
    6a7a:	4812      	ldr	r0, [pc, #72]	; (6ac4 <subst_all_variables_starting_from_the_back+0x234>)
    6a7c:	4b14      	ldr	r3, [pc, #80]	; (6ad0 <subst_all_variables_starting_from_the_back+0x240>)
    6a7e:	e7ee      	b.n	6a5e <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 3){
    6a80:	2b03      	cmp	r3, #3
    6a82:	d102      	bne.n	6a8a <subst_all_variables_starting_from_the_back+0x1fa>
                                    variable_value = grid_sys_get_bank_blu(&grid_sys_state);
    6a84:	480f      	ldr	r0, [pc, #60]	; (6ac4 <subst_all_variables_starting_from_the_back+0x234>)
    6a86:	4b13      	ldr	r3, [pc, #76]	; (6ad4 <subst_all_variables_starting_from_the_back+0x244>)
    6a88:	e7e9      	b.n	6a5e <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 4){
    6a8a:	2b04      	cmp	r3, #4
    6a8c:	d102      	bne.n	6a94 <subst_all_variables_starting_from_the_back+0x204>
                                    variable_value = grid_sys_get_map_state(&grid_sys_state);
    6a8e:	480d      	ldr	r0, [pc, #52]	; (6ac4 <subst_all_variables_starting_from_the_back+0x234>)
    6a90:	4b11      	ldr	r3, [pc, #68]	; (6ad8 <subst_all_variables_starting_from_the_back+0x248>)
    6a92:	e7e4      	b.n	6a5e <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 5){
    6a94:	2b05      	cmp	r3, #5
    6a96:	d1c6      	bne.n	6a26 <subst_all_variables_starting_from_the_back+0x196>
                                    variable_value = grid_sys_get_bank_next(&grid_sys_state);
    6a98:	480a      	ldr	r0, [pc, #40]	; (6ac4 <subst_all_variables_starting_from_the_back+0x234>)
    6a9a:	4b10      	ldr	r3, [pc, #64]	; (6adc <subst_all_variables_starting_from_the_back+0x24c>)
    6a9c:	e7df      	b.n	6a5e <subst_all_variables_starting_from_the_back+0x1ce>
    6a9e:	2201      	movs	r2, #1
    6aa0:	e7bd      	b.n	6a1e <subst_all_variables_starting_from_the_back+0x18e>
                    function_name_found = 1;                    
    6aa2:	f04f 0901 	mov.w	r9, #1
    6aa6:	e71c      	b.n	68e2 <subst_all_variables_starting_from_the_back+0x52>
    6aa8:	4621      	mov	r1, r4
    6aaa:	e772      	b.n	6992 <subst_all_variables_starting_from_the_back+0x102>
    6aac:	0001480f 	.word	0x0001480f
    6ab0:	20013220 	.word	0x20013220
    6ab4:	000142f1 	.word	0x000142f1
    6ab8:	00015d8d 	.word	0x00015d8d
    6abc:	00014791 	.word	0x00014791
    6ac0:	000065a9 	.word	0x000065a9
    6ac4:	2000f008 	.word	0x2000f008
    6ac8:	000096bf 	.word	0x000096bf
    6acc:	000096c9 	.word	0x000096c9
    6ad0:	000096cf 	.word	0x000096cf
    6ad4:	000096d5 	.word	0x000096d5
    6ad8:	000096db 	.word	0x000096db
    6adc:	000096df 	.word	0x000096df
    6ae0:	00006871 	.word	0x00006871

00006ae4 <subst_all_functions_starting_from_the_back>:



void subst_all_functions_starting_from_the_back(char* expr_string, int len){
    6ae4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

    if (debug_level) printf("Subst Fncs in %s\r\n", expr_string);
    if (debug_level) delay_ms(5);
    
    uint8_t function_name_found = 0;
    uint8_t function_name_valid = 0;
    6ae8:	2200      	movs	r2, #0

            
        }
        else if (function_name_found){
            
            if (char_is_valid_name(expr_string[i])){
    6aea:	f8df 8068 	ldr.w	r8, [pc, #104]	; 6b54 <subst_all_functions_starting_from_the_back+0x70>
                //printf("izgi=%d, i=%d\n", izgi, i);  
                
            }
            else if (function_name_valid){
                
                calcSubFnc(&expr_string[i+1]);
    6aee:	4f18      	ldr	r7, [pc, #96]	; (6b50 <subst_all_functions_starting_from_the_back+0x6c>)
    6af0:	1844      	adds	r4, r0, r1
void subst_all_functions_starting_from_the_back(char* expr_string, int len){
    6af2:	4605      	mov	r5, r0
    uint8_t function_name_found = 0;
    6af4:	4611      	mov	r1, r2
    for(int i= len; i>=0; i--){
    6af6:	ebb4 0a05 	subs.w	sl, r4, r5
    6afa:	d501      	bpl.n	6b00 <subst_all_functions_starting_from_the_back+0x1c>

        if (debug_level) printf("i%d %d %d\r\n",i, function_name_found, function_name_valid);
        if (debug_level) delay_ms(1);
    }
    
}
    6afc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if (expr_string[i] == '(' && function_name_valid == 0){
    6b00:	7826      	ldrb	r6, [r4, #0]
    6b02:	2e28      	cmp	r6, #40	; 0x28
    6b04:	d100      	bne.n	6b08 <subst_all_functions_starting_from_the_back+0x24>
    6b06:	b1e2      	cbz	r2, 6b42 <subst_all_functions_starting_from_the_back+0x5e>
        else if (function_name_found){
    6b08:	b1c9      	cbz	r1, 6b3e <subst_all_functions_starting_from_the_back+0x5a>
            if (char_is_valid_name(expr_string[i])){
    6b0a:	4630      	mov	r0, r6
    6b0c:	47c0      	blx	r8
    6b0e:	4681      	mov	r9, r0
    6b10:	b158      	cbz	r0, 6b2a <subst_all_functions_starting_from_the_back+0x46>
                if ((expr_string[i] >= '0' && expr_string[i] <= '9')){
    6b12:	3e30      	subs	r6, #48	; 0x30
    6b14:	2e09      	cmp	r6, #9
    6b16:	d816      	bhi.n	6b46 <subst_all_functions_starting_from_the_back+0x62>
                if (i==0 && function_name_valid){ // start of expr string special case
    6b18:	f1ba 0f00 	cmp.w	sl, #0
    6b1c:	d10f      	bne.n	6b3e <subst_all_functions_starting_from_the_back+0x5a>
    6b1e:	b172      	cbz	r2, 6b3e <subst_all_functions_starting_from_the_back+0x5a>
                    calcSubFnc(&expr_string[i]);
    6b20:	4620      	mov	r0, r4
    6b22:	47b8      	blx	r7
                    function_name_valid = 0;
    6b24:	2200      	movs	r2, #0
                function_name_found = 0;
    6b26:	4611      	mov	r1, r2
    6b28:	e009      	b.n	6b3e <subst_all_functions_starting_from_the_back+0x5a>
            else if (function_name_valid){
    6b2a:	2a00      	cmp	r2, #0
    6b2c:	d0fb      	beq.n	6b26 <subst_all_functions_starting_from_the_back+0x42>
                calcSubFnc(&expr_string[i+1]);
    6b2e:	1c60      	adds	r0, r4, #1
    6b30:	47b8      	blx	r7
                function_name_found = (expr_string[i] == '(');
    6b32:	7821      	ldrb	r1, [r4, #0]
    6b34:	f1a1 0328 	sub.w	r3, r1, #40	; 0x28
    6b38:	4259      	negs	r1, r3
    6b3a:	4159      	adcs	r1, r3
                function_name_valid = 0;
    6b3c:	464a      	mov	r2, r9
    for(int i= len; i>=0; i--){
    6b3e:	3c01      	subs	r4, #1
    6b40:	e7d9      	b.n	6af6 <subst_all_functions_starting_from_the_back+0x12>
            function_name_found = 1;
    6b42:	2101      	movs	r1, #1
    6b44:	e7fb      	b.n	6b3e <subst_all_functions_starting_from_the_back+0x5a>
                if (i==0 && function_name_valid){ // start of expr string special case
    6b46:	f1ba 0f00 	cmp.w	sl, #0
    6b4a:	d0e9      	beq.n	6b20 <subst_all_functions_starting_from_the_back+0x3c>
                    function_name_valid = 1;
    6b4c:	460a      	mov	r2, r1
    6b4e:	e7f6      	b.n	6b3e <subst_all_functions_starting_from_the_back+0x5a>
    6b50:	00006611 	.word	0x00006611
    6b54:	00006871 	.word	0x00006871

00006b58 <grid_expr_evaluate>:
grid_expr_evaluate(struct grid_expr_model* expr, char* input_str, uint8_t input_length){
    6b58:	b573      	push	{r0, r1, r4, r5, r6, lr}
    grid_expr_clear_input(expr);
    6b5a:	4b12      	ldr	r3, [pc, #72]	; (6ba4 <grid_expr_evaluate+0x4c>)
grid_expr_evaluate(struct grid_expr_model* expr, char* input_str, uint8_t input_length){
    6b5c:	4604      	mov	r4, r0
    6b5e:	460e      	mov	r6, r1
    6b60:	4611      	mov	r1, r2
    grid_expr_clear_input(expr);
    6b62:	4798      	blx	r3
    grid_expr_clear_output(expr);
    6b64:	4b10      	ldr	r3, [pc, #64]	; (6ba8 <grid_expr_evaluate+0x50>)
    6b66:	4620      	mov	r0, r4
    6b68:	4798      	blx	r3
    for (uint32_t i=0; i<input_length; i++){
    6b6a:	1d22      	adds	r2, r4, #4
    6b6c:	2300      	movs	r3, #0
    6b6e:	4615      	mov	r5, r2
    6b70:	4299      	cmp	r1, r3
    6b72:	d811      	bhi.n	6b98 <grid_expr_evaluate+0x40>
    expr->input_string_length = input_length;
    6b74:	f884 10fe 	strb.w	r1, [r4, #254]	; 0xfe
    subst_all_variables_starting_from_the_back(expr->input_string, expr->input_string_length);    
    6b78:	4b0c      	ldr	r3, [pc, #48]	; (6bac <grid_expr_evaluate+0x54>)
    6b7a:	4628      	mov	r0, r5
    6b7c:	4798      	blx	r3
    subst_all_functions_starting_from_the_back(expr->input_string, expr->input_string_length);
    6b7e:	f894 10fe 	ldrb.w	r1, [r4, #254]	; 0xfe
    6b82:	4b0b      	ldr	r3, [pc, #44]	; (6bb0 <grid_expr_evaluate+0x58>)
    6b84:	4628      	mov	r0, r5
    6b86:	4798      	blx	r3
    int result = expr_level_0(e);
    6b88:	4b0a      	ldr	r3, [pc, #40]	; (6bb4 <grid_expr_evaluate+0x5c>)
    6b8a:	9501      	str	r5, [sp, #4]
    6b8c:	a801      	add	r0, sp, #4
    6b8e:	4798      	blx	r3
    expr->return_value = result;
    6b90:	f8c4 01fc 	str.w	r0, [r4, #508]	; 0x1fc
}
    6b94:	b002      	add	sp, #8
    6b96:	bd70      	pop	{r4, r5, r6, pc}
        expr->input_string[i] = input_str[i];
    6b98:	5cf0      	ldrb	r0, [r6, r3]
    6b9a:	f802 0b01 	strb.w	r0, [r2], #1
    for (uint32_t i=0; i<input_length; i++){
    6b9e:	3301      	adds	r3, #1
    6ba0:	e7e6      	b.n	6b70 <grid_expr_evaluate+0x18>
    6ba2:	bf00      	nop
    6ba4:	0000637d 	.word	0x0000637d
    6ba8:	00006391 	.word	0x00006391
    6bac:	00006891 	.word	0x00006891
    6bb0:	00006ae5 	.word	0x00006ae5
    6bb4:	00006409 	.word	0x00006409

00006bb8 <grid_led_lowlevel_hardware_transfer_complete_cb>:


void grid_led_lowlevel_hardware_transfer_complete_cb(struct _dma_resource *resource){
	

	grid_led_hardware_transfer_done = 1;
    6bb8:	4b01      	ldr	r3, [pc, #4]	; (6bc0 <grid_led_lowlevel_hardware_transfer_complete_cb+0x8>)
    6bba:	2201      	movs	r2, #1
    6bbc:	701a      	strb	r2, [r3, #0]
	
	
}
    6bbe:	4770      	bx	lr
    6bc0:	2000914c 	.word	0x2000914c

00006bc4 <grid_led_lowlevel_set_color>:
uint8_t grid_led_lowlevel_set_color(struct grid_led_model* mod, uint32_t led_index, uint16_t led_r, uint16_t led_g, uint16_t led_b){
    6bc4:	b510      	push	{r4, lr}
	if (led_index<mod->led_number){
    6bc6:	7844      	ldrb	r4, [r0, #1]
    6bc8:	428c      	cmp	r4, r1
    6bca:	d91c      	bls.n	6c06 <grid_led_lowlevel_set_color+0x42>
		mod->led_frame_buffer_usable[led_index*3 + 0] = grid_led_color_code[led_g];
    6bcc:	2bff      	cmp	r3, #255	; 0xff
    6bce:	f04f 040c 	mov.w	r4, #12
    6bd2:	fb04 f101 	mul.w	r1, r4, r1
    6bd6:	bf28      	it	cs
    6bd8:	23ff      	movcs	r3, #255	; 0xff
    6bda:	4c0c      	ldr	r4, [pc, #48]	; (6c0c <grid_led_lowlevel_set_color+0x48>)
    6bdc:	68c0      	ldr	r0, [r0, #12]
    6bde:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    6be2:	5043      	str	r3, [r0, r1]
		mod->led_frame_buffer_usable[led_index*3 + 1] = grid_led_color_code[led_r];
    6be4:	2aff      	cmp	r2, #255	; 0xff
    6be6:	bf28      	it	cs
    6be8:	22ff      	movcs	r2, #255	; 0xff
    6bea:	4401      	add	r1, r0
    6bec:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
    6bf0:	604b      	str	r3, [r1, #4]
		mod->led_frame_buffer_usable[led_index*3 + 2] = grid_led_color_code[led_b];
    6bf2:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    6bf6:	2bff      	cmp	r3, #255	; 0xff
    6bf8:	bf28      	it	cs
    6bfa:	23ff      	movcs	r3, #255	; 0xff
		return 0;
    6bfc:	2000      	movs	r0, #0
		mod->led_frame_buffer_usable[led_index*3 + 2] = grid_led_color_code[led_b];
    6bfe:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    6c02:	608b      	str	r3, [r1, #8]
}
    6c04:	bd10      	pop	{r4, pc}
		return -1;		
    6c06:	20ff      	movs	r0, #255	; 0xff
    6c08:	e7fc      	b.n	6c04 <grid_led_lowlevel_set_color+0x40>
    6c0a:	bf00      	nop
    6c0c:	2000fe60 	.word	0x2000fe60

00006c10 <grid_led_hardware_init>:


}


void grid_led_hardware_init(struct grid_led_model* mod){
    6c10:	b510      	push	{r4, lr}
	
	spi_m_dma_get_io_descriptor(&GRID_LED, &mod->hardware_io_descriptor);
    6c12:	4c06      	ldr	r4, [pc, #24]	; (6c2c <grid_led_hardware_init+0x1c>)
    6c14:	4b06      	ldr	r3, [pc, #24]	; (6c30 <grid_led_hardware_init+0x20>)
    6c16:	f100 0114 	add.w	r1, r0, #20
    6c1a:	4620      	mov	r0, r4
    6c1c:	4798      	blx	r3
	spi_m_dma_register_callback(&GRID_LED, SPI_M_DMA_CB_TX_DONE, grid_led_lowlevel_hardware_transfer_complete_cb);
    6c1e:	4620      	mov	r0, r4
    6c20:	4a04      	ldr	r2, [pc, #16]	; (6c34 <grid_led_hardware_init+0x24>)
    6c22:	4b05      	ldr	r3, [pc, #20]	; (6c38 <grid_led_hardware_init+0x28>)
	

		
}
    6c24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	spi_m_dma_register_callback(&GRID_LED, SPI_M_DMA_CB_TX_DONE, grid_led_lowlevel_hardware_transfer_complete_cb);
    6c28:	2100      	movs	r1, #0
    6c2a:	4718      	bx	r3
    6c2c:	2001ce54 	.word	0x2001ce54
    6c30:	0000ba01 	.word	0x0000ba01
    6c34:	00006bb9 	.word	0x00006bb9
    6c38:	0000b9cd 	.word	0x0000b9cd

00006c3c <grid_led_get_led_number>:

uint32_t grid_led_get_led_number(struct grid_led_model* mod){

	return mod->led_number;

}
    6c3c:	7840      	ldrb	r0, [r0, #1]
    6c3e:	4770      	bx	lr

00006c40 <grid_led_tick>:

/** ================== ANIMATION ==================  */


void grid_led_tick(struct grid_led_model* mod){
    6c40:	b5f0      	push	{r4, r5, r6, r7, lr}
	

	/** ATOMI - all phase registers must be updated  */
	for (uint8_t j=0; j<mod->led_number; j++){
    6c42:	7846      	ldrb	r6, [r0, #1]
    6c44:	eb06 0246 	add.w	r2, r6, r6, lsl #1
    6c48:	eb06 0282 	add.w	r2, r6, r2, lsl #2
    6c4c:	2400      	movs	r4, #0
    6c4e:	270d      	movs	r7, #13
    6c50:	b2e3      	uxtb	r3, r4
    6c52:	429e      	cmp	r6, r3
    6c54:	d800      	bhi.n	6c58 <grid_led_tick+0x18>
			mod->led_smart_buffer[j+(mod->led_number*layer)].pha += mod->led_smart_buffer[j+(mod->led_number*layer)].fre; //PHASE + = FREQUENCY		
		}	
	}
	/** END */
	
}
    6c56:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6c58:	6903      	ldr	r3, [r0, #16]
			mod->led_smart_buffer[j+(mod->led_number*layer)].pha += mod->led_smart_buffer[j+(mod->led_number*layer)].fre; //PHASE + = FREQUENCY		
    6c5a:	2103      	movs	r1, #3
    6c5c:	fb07 3304 	mla	r3, r7, r4, r3
    6c60:	7add      	ldrb	r5, [r3, #11]
    6c62:	f893 c00c 	ldrb.w	ip, [r3, #12]
    6c66:	3901      	subs	r1, #1
    6c68:	4465      	add	r5, ip
		for(uint8_t i=0; i<GRID_LED_LAYER_NUMBER; i++){
    6c6a:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
			mod->led_smart_buffer[j+(mod->led_number*layer)].pha += mod->led_smart_buffer[j+(mod->led_number*layer)].fre; //PHASE + = FREQUENCY		
    6c6e:	72dd      	strb	r5, [r3, #11]
		for(uint8_t i=0; i<GRID_LED_LAYER_NUMBER; i++){
    6c70:	4413      	add	r3, r2
    6c72:	d1f5      	bne.n	6c60 <grid_led_tick+0x20>
	for (uint8_t j=0; j<mod->led_number; j++){
    6c74:	3401      	adds	r4, #1
    6c76:	e7eb      	b.n	6c50 <grid_led_tick+0x10>

00006c78 <grid_led_set_min>:
	grid_led_set_max(mod, num, layer, r, g, b);

}


void grid_led_set_min(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6c78:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.r = r;
    6c7a:	7844      	ldrb	r4, [r0, #1]
    6c7c:	6900      	ldr	r0, [r0, #16]
    6c7e:	fb04 1202 	mla	r2, r4, r2, r1
    6c82:	240d      	movs	r4, #13
    6c84:	4362      	muls	r2, r4
    6c86:	1881      	adds	r1, r0, r2
    6c88:	5483      	strb	r3, [r0, r2]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.g = g;
    6c8a:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6c8e:	704b      	strb	r3, [r1, #1]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.b = b;	
    6c90:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6c94:	708b      	strb	r3, [r1, #2]
}
    6c96:	bd10      	pop	{r4, pc}

00006c98 <grid_led_set_mid>:

void grid_led_set_mid(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6c98:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_mid.r = r;
    6c9a:	7844      	ldrb	r4, [r0, #1]
    6c9c:	fb04 1102 	mla	r1, r4, r2, r1
    6ca0:	6902      	ldr	r2, [r0, #16]
    6ca2:	200d      	movs	r0, #13
    6ca4:	fb00 2201 	mla	r2, r0, r1, r2
    6ca8:	70d3      	strb	r3, [r2, #3]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_mid.g = g;
    6caa:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6cae:	7113      	strb	r3, [r2, #4]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_mid.b = b;	
    6cb0:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6cb4:	7153      	strb	r3, [r2, #5]
}
    6cb6:	bd10      	pop	{r4, pc}

00006cb8 <grid_led_set_max>:

void grid_led_set_max(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6cb8:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.r = r;
    6cba:	7844      	ldrb	r4, [r0, #1]
    6cbc:	fb04 1102 	mla	r1, r4, r2, r1
    6cc0:	6902      	ldr	r2, [r0, #16]
    6cc2:	200d      	movs	r0, #13
    6cc4:	fb00 2201 	mla	r2, r0, r1, r2
    6cc8:	7193      	strb	r3, [r2, #6]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.g = g;
    6cca:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6cce:	71d3      	strb	r3, [r2, #7]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.b = b;	
    6cd0:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6cd4:	7213      	strb	r3, [r2, #8]
}
    6cd6:	bd10      	pop	{r4, pc}

00006cd8 <grid_led_set_color>:
void grid_led_set_color(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6cd8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    6cdc:	f89d 902c 	ldrb.w	r9, [sp, #44]	; 0x2c
    6ce0:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28
	grid_led_set_min(mod, num, layer, r/20, g/20, b/20);				
    6ce4:	f8df a058 	ldr.w	sl, [pc, #88]	; 6d40 <grid_led_set_color+0x68>
void grid_led_set_color(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6ce8:	461c      	mov	r4, r3
	grid_led_set_min(mod, num, layer, r/20, g/20, b/20);				
    6cea:	2314      	movs	r3, #20
    6cec:	fbb9 fcf3 	udiv	ip, r9, r3
    6cf0:	f8cd c004 	str.w	ip, [sp, #4]
    6cf4:	fbb8 fcf3 	udiv	ip, r8, r3
    6cf8:	fbb4 f3f3 	udiv	r3, r4, r3
    6cfc:	f8cd c000 	str.w	ip, [sp]
void grid_led_set_color(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6d00:	4605      	mov	r5, r0
    6d02:	460e      	mov	r6, r1
    6d04:	4617      	mov	r7, r2
	grid_led_set_min(mod, num, layer, r/20, g/20, b/20);				
    6d06:	47d0      	blx	sl
	grid_led_set_mid(mod, num, layer, r/2, g/2, b/2);
    6d08:	ea4f 0359 	mov.w	r3, r9, lsr #1
    6d0c:	9301      	str	r3, [sp, #4]
    6d0e:	ea4f 0358 	mov.w	r3, r8, lsr #1
    6d12:	9300      	str	r3, [sp, #0]
    6d14:	463a      	mov	r2, r7
    6d16:	0863      	lsrs	r3, r4, #1
    6d18:	4631      	mov	r1, r6
    6d1a:	4628      	mov	r0, r5
    6d1c:	f8df a024 	ldr.w	sl, [pc, #36]	; 6d44 <grid_led_set_color+0x6c>
    6d20:	47d0      	blx	sl
	grid_led_set_max(mod, num, layer, r, g, b);
    6d22:	4623      	mov	r3, r4
    6d24:	4c05      	ldr	r4, [pc, #20]	; (6d3c <grid_led_set_color+0x64>)
    6d26:	463a      	mov	r2, r7
    6d28:	4631      	mov	r1, r6
    6d2a:	4628      	mov	r0, r5
    6d2c:	46a4      	mov	ip, r4
    6d2e:	e9cd 890a 	strd	r8, r9, [sp, #40]	; 0x28
}
    6d32:	b002      	add	sp, #8
    6d34:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_led_set_max(mod, num, layer, r, g, b);
    6d38:	4760      	bx	ip
    6d3a:	bf00      	nop
    6d3c:	00006cb9 	.word	0x00006cb9
    6d40:	00006c79 	.word	0x00006c79
    6d44:	00006c99 	.word	0x00006c99

00006d48 <grid_led_set_phase>:

void grid_led_set_phase(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t val){
    6d48:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].pha = val;
    6d4a:	7844      	ldrb	r4, [r0, #1]
    6d4c:	fb04 1102 	mla	r1, r4, r2, r1
    6d50:	6902      	ldr	r2, [r0, #16]
    6d52:	200d      	movs	r0, #13
    6d54:	fb00 2101 	mla	r1, r0, r1, r2
    6d58:	72cb      	strb	r3, [r1, #11]
}
    6d5a:	bd10      	pop	{r4, pc}

00006d5c <grid_led_set_frequency>:
uint8_t grid_led_get_phase(struct grid_led_model* mod, uint8_t num, uint8_t layer){
	
	return mod->led_smart_buffer[num+(mod->led_number*layer)].pha;
}

void grid_led_set_frequency(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t val){
    6d5c:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].fre = val;
    6d5e:	7844      	ldrb	r4, [r0, #1]
    6d60:	fb04 1102 	mla	r1, r4, r2, r1
    6d64:	6902      	ldr	r2, [r0, #16]
    6d66:	200d      	movs	r0, #13
    6d68:	fb00 2101 	mla	r1, r0, r1, r2
    6d6c:	730b      	strb	r3, [r1, #12]
}
    6d6e:	bd10      	pop	{r4, pc}

00006d70 <grid_led_buffer_init>:
void grid_led_buffer_init(struct grid_led_model* mod, uint32_t length){
    6d70:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6d74:	4604      	mov	r4, r0
	mod->led_number = length;
    6d76:	7041      	strb	r1, [r0, #1]
	mod->led_frame_buffer_size = (GRID_LED_RESET_LENGTH + mod->led_number*3*4);
    6d78:	b2cd      	uxtb	r5, r1
    6d7a:	200c      	movs	r0, #12
    6d7c:	4368      	muls	r0, r5
    6d7e:	3090      	adds	r0, #144	; 0x90
	mod->led_frame_buffer = (uint8_t*) malloc(mod->led_frame_buffer_size * sizeof(uint8_t));
    6d80:	4f4c      	ldr	r7, [pc, #304]	; (6eb4 <grid_led_buffer_init+0x144>)
	mod->led_frame_buffer_size = (GRID_LED_RESET_LENGTH + mod->led_number*3*4);
    6d82:	6060      	str	r0, [r4, #4]
	mod->led_frame_buffer = (uint8_t*) malloc(mod->led_frame_buffer_size * sizeof(uint8_t));
    6d84:	47b8      	blx	r7
	mod->led_frame_buffer_usable = (uint32_t*) &mod->led_frame_buffer[GRID_LED_RESET_LENGTH];
    6d86:	f100 0390 	add.w	r3, r0, #144	; 0x90
	mod->led_frame_buffer = (uint8_t*) malloc(mod->led_frame_buffer_size * sizeof(uint8_t));
    6d8a:	60a0      	str	r0, [r4, #8]
    6d8c:	4606      	mov	r6, r0
	mod->led_smart_buffer = (struct LED_layer*) malloc(mod->led_number * GRID_LED_LAYER_NUMBER * sizeof(struct LED_layer));
    6d8e:	2027      	movs	r0, #39	; 0x27
	mod->led_frame_buffer_usable = (uint32_t*) &mod->led_frame_buffer[GRID_LED_RESET_LENGTH];
    6d90:	60e3      	str	r3, [r4, #12]
	mod->led_smart_buffer = (struct LED_layer*) malloc(mod->led_number * GRID_LED_LAYER_NUMBER * sizeof(struct LED_layer));
    6d92:	4368      	muls	r0, r5
    6d94:	47b8      	blx	r7
    6d96:	6120      	str	r0, [r4, #16]
	if(mod->led_frame_buffer==NULL || mod->led_smart_buffer==NULL){
    6d98:	b106      	cbz	r6, 6d9c <grid_led_buffer_init+0x2c>
    6d9a:	b900      	cbnz	r0, 6d9e <grid_led_buffer_init+0x2e>
		while(1){
    6d9c:	e7fe      	b.n	6d9c <grid_led_buffer_init+0x2c>
    6d9e:	2300      	movs	r3, #0
		mod->led_frame_buffer[i] = LED_CODE_R;
    6da0:	4619      	mov	r1, r3
    6da2:	68a2      	ldr	r2, [r4, #8]
    6da4:	54d1      	strb	r1, [r2, r3]
	for (uint8_t i = 0; i<GRID_LED_RESET_LENGTH; i++){
    6da6:	3301      	adds	r3, #1
    6da8:	2b90      	cmp	r3, #144	; 0x90
    6daa:	d1fa      	bne.n	6da2 <grid_led_buffer_init+0x32>
	for (uint32_t i = 0; i<mod->led_number; i++){
    6dac:	2500      	movs	r5, #0
		grid_led_lowlevel_set_color(mod,i,0,0,0);
    6dae:	4f42      	ldr	r7, [pc, #264]	; (6eb8 <grid_led_buffer_init+0x148>)
    6db0:	462e      	mov	r6, r5
	for (uint32_t i = 0; i<mod->led_number; i++){
    6db2:	7863      	ldrb	r3, [r4, #1]
    6db4:	429d      	cmp	r5, r3
    6db6:	d30c      	bcc.n	6dd2 <grid_led_buffer_init+0x62>
		grid_led_set_min(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x00, 0x00);
    6db8:	4d40      	ldr	r5, [pc, #256]	; (6ebc <grid_led_buffer_init+0x14c>)
		grid_led_set_mid(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x7F, 0x00);
    6dba:	4e41      	ldr	r6, [pc, #260]	; (6ec0 <grid_led_buffer_init+0x150>)
		grid_led_set_max(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0xFF, 0x00);
    6dbc:	4f41      	ldr	r7, [pc, #260]	; (6ec4 <grid_led_buffer_init+0x154>)
    6dbe:	f04f 0b00 	mov.w	fp, #0
	for(uint8_t i = 0; i<mod->led_number; i++){
    6dc2:	7863      	ldrb	r3, [r4, #1]
    6dc4:	fa5f fa8b 	uxtb.w	sl, fp
    6dc8:	4553      	cmp	r3, sl
    6dca:	d80a      	bhi.n	6de2 <grid_led_buffer_init+0x72>
}
    6dcc:	b003      	add	sp, #12
    6dce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		grid_led_lowlevel_set_color(mod,i,0,0,0);
    6dd2:	2300      	movs	r3, #0
    6dd4:	4629      	mov	r1, r5
    6dd6:	9600      	str	r6, [sp, #0]
    6dd8:	461a      	mov	r2, r3
    6dda:	4620      	mov	r0, r4
    6ddc:	47b8      	blx	r7
	for (uint32_t i = 0; i<mod->led_number; i++){
    6dde:	3501      	adds	r5, #1
    6de0:	e7e7      	b.n	6db2 <grid_led_buffer_init+0x42>
		grid_led_set_min(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x00, 0x00);
    6de2:	2300      	movs	r3, #0
    6de4:	e9cd 3300 	strd	r3, r3, [sp]
    6de8:	2201      	movs	r2, #1
    6dea:	4651      	mov	r1, sl
    6dec:	4620      	mov	r0, r4
    6dee:	47a8      	blx	r5
		grid_led_set_mid(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x7F, 0x00);
    6df0:	2300      	movs	r3, #0
    6df2:	227f      	movs	r2, #127	; 0x7f
    6df4:	e9cd 2300 	strd	r2, r3, [sp]
    6df8:	4651      	mov	r1, sl
    6dfa:	2201      	movs	r2, #1
    6dfc:	4620      	mov	r0, r4
    6dfe:	47b0      	blx	r6
		grid_led_set_max(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0xFF, 0x00);
    6e00:	2300      	movs	r3, #0
    6e02:	22ff      	movs	r2, #255	; 0xff
    6e04:	e9cd 2300 	strd	r2, r3, [sp]
    6e08:	4651      	mov	r1, sl
    6e0a:	2201      	movs	r2, #1
    6e0c:	4620      	mov	r0, r4
    6e0e:	47b8      	blx	r7
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_UI_A, 0);
    6e10:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 6ec8 <grid_led_buffer_init+0x158>
		grid_led_set_phase(mod,i, GRID_LED_LAYER_UI_A, 0);
    6e14:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 6ecc <grid_led_buffer_init+0x15c>
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_UI_A, 0);
    6e18:	2300      	movs	r3, #0
    6e1a:	2201      	movs	r2, #1
    6e1c:	4651      	mov	r1, sl
    6e1e:	4620      	mov	r0, r4
    6e20:	47c8      	blx	r9
		grid_led_set_phase(mod,i, GRID_LED_LAYER_UI_A, 0);
    6e22:	2300      	movs	r3, #0
    6e24:	2201      	movs	r2, #1
    6e26:	4651      	mov	r1, sl
    6e28:	4620      	mov	r0, r4
    6e2a:	47c0      	blx	r8
		grid_led_set_min(mod,i, GRID_LED_LAYER_UI_B, 0x00, 0x00, 0x00);
    6e2c:	2300      	movs	r3, #0
    6e2e:	e9cd 3300 	strd	r3, r3, [sp]
    6e32:	2202      	movs	r2, #2
    6e34:	4651      	mov	r1, sl
    6e36:	4620      	mov	r0, r4
    6e38:	47a8      	blx	r5
		grid_led_set_mid(mod,i, GRID_LED_LAYER_UI_B, 0x00, 0x7F, 0x00);
    6e3a:	2300      	movs	r3, #0
    6e3c:	227f      	movs	r2, #127	; 0x7f
    6e3e:	e9cd 2300 	strd	r2, r3, [sp]
    6e42:	4651      	mov	r1, sl
    6e44:	2202      	movs	r2, #2
    6e46:	4620      	mov	r0, r4
    6e48:	47b0      	blx	r6
		grid_led_set_max(mod,i, GRID_LED_LAYER_UI_B, 0x00, 0xFF, 0x00);
    6e4a:	2300      	movs	r3, #0
    6e4c:	22ff      	movs	r2, #255	; 0xff
    6e4e:	e9cd 2300 	strd	r2, r3, [sp]
    6e52:	4651      	mov	r1, sl
    6e54:	2202      	movs	r2, #2
    6e56:	4620      	mov	r0, r4
    6e58:	47b8      	blx	r7
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_UI_B, 0);
    6e5a:	2300      	movs	r3, #0
    6e5c:	2202      	movs	r2, #2
    6e5e:	4651      	mov	r1, sl
    6e60:	4620      	mov	r0, r4
    6e62:	47c8      	blx	r9
		grid_led_set_phase(mod,i, GRID_LED_LAYER_UI_B, 0);
    6e64:	2300      	movs	r3, #0
    6e66:	2202      	movs	r2, #2
    6e68:	4651      	mov	r1, sl
    6e6a:	4620      	mov	r0, r4
    6e6c:	47c0      	blx	r8
		grid_led_set_min(mod,i, GRID_LED_LAYER_ALERT, 0x00, 0x00, 0x00);
    6e6e:	2300      	movs	r3, #0
    6e70:	461a      	mov	r2, r3
    6e72:	e9cd 3300 	strd	r3, r3, [sp]
    6e76:	4651      	mov	r1, sl
    6e78:	4620      	mov	r0, r4
    6e7a:	47a8      	blx	r5
		grid_led_set_mid(mod,i, GRID_LED_LAYER_ALERT, 0x00, 0x00, 0x00);
    6e7c:	2300      	movs	r3, #0
    6e7e:	461a      	mov	r2, r3
    6e80:	e9cd 3300 	strd	r3, r3, [sp]
    6e84:	4651      	mov	r1, sl
    6e86:	4620      	mov	r0, r4
    6e88:	47b0      	blx	r6
		grid_led_set_max(mod,i, GRID_LED_LAYER_ALERT, 0x00, 0x00, 0x00);
    6e8a:	2300      	movs	r3, #0
    6e8c:	461a      	mov	r2, r3
    6e8e:	e9cd 3300 	strd	r3, r3, [sp]
    6e92:	4651      	mov	r1, sl
    6e94:	4620      	mov	r0, r4
    6e96:	47b8      	blx	r7
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_ALERT, 0);
    6e98:	2300      	movs	r3, #0
    6e9a:	461a      	mov	r2, r3
    6e9c:	4651      	mov	r1, sl
    6e9e:	4620      	mov	r0, r4
    6ea0:	47c8      	blx	r9
		grid_led_set_phase(mod, i, GRID_LED_LAYER_ALERT, 0);
    6ea2:	2300      	movs	r3, #0
    6ea4:	461a      	mov	r2, r3
    6ea6:	4651      	mov	r1, sl
    6ea8:	4620      	mov	r0, r4
    6eaa:	47c0      	blx	r8
	for(uint8_t i = 0; i<mod->led_number; i++){
    6eac:	f10b 0b01 	add.w	fp, fp, #1
    6eb0:	e787      	b.n	6dc2 <grid_led_buffer_init+0x52>
    6eb2:	bf00      	nop
    6eb4:	000142c5 	.word	0x000142c5
    6eb8:	00006bc5 	.word	0x00006bc5
    6ebc:	00006c79 	.word	0x00006c79
    6ec0:	00006c99 	.word	0x00006c99
    6ec4:	00006cb9 	.word	0x00006cb9
    6ec8:	00006d5d 	.word	0x00006d5d
    6ecc:	00006d49 	.word	0x00006d49

00006ed0 <grid_led_lowlevel_init>:
uint8_t grid_led_lowlevel_init(struct grid_led_model* mod, uint8_t num){
    6ed0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    6ed2:	4e29      	ldr	r6, [pc, #164]	; (6f78 <grid_led_lowlevel_init+0xa8>)
	for(uint16_t i=0; i<256; i++){
    6ed4:	2300      	movs	r3, #0
		temp |= (i/1%2)   ? (LED_CODE_O<<24) : (LED_CODE_Z<<24);
    6ed6:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
		temp |= (i/2%2)   ? (LED_CODE_O<<28) : (LED_CODE_Z<<28);
    6eda:	f013 0f02 	tst.w	r3, #2
    6ede:	bf0c      	ite	eq
    6ee0:	f04f 4500 	moveq.w	r5, #2147483648	; 0x80000000
    6ee4:	f04f 4560 	movne.w	r5, #3758096384	; 0xe0000000
		temp |= (i/4%2)   ? (LED_CODE_O<<16) : (LED_CODE_Z<<16);
    6ee8:	f013 0f04 	tst.w	r3, #4
    6eec:	bf0c      	ite	eq
    6eee:	f44f 2400 	moveq.w	r4, #524288	; 0x80000
    6ef2:	f44f 2460 	movne.w	r4, #917504	; 0xe0000
		temp |= (i/8%2)   ? (LED_CODE_O<<20) : (LED_CODE_Z<<20);
    6ef6:	f013 0f08 	tst.w	r3, #8
    6efa:	ea45 0504 	orr.w	r5, r5, r4
    6efe:	bf0c      	ite	eq
    6f00:	f44f 0400 	moveq.w	r4, #8388608	; 0x800000
    6f04:	f44f 0460 	movne.w	r4, #14680064	; 0xe00000
		temp |= (i/16%2)  ? (LED_CODE_O<<8)  : (LED_CODE_Z<<8);
    6f08:	f013 0f10 	tst.w	r3, #16
    6f0c:	ea45 0504 	orr.w	r5, r5, r4
    6f10:	bf0c      	ite	eq
    6f12:	f44f 6400 	moveq.w	r4, #2048	; 0x800
    6f16:	f44f 6460 	movne.w	r4, #3584	; 0xe00
		temp |= (i/32%2)  ? (LED_CODE_O<<12) : (LED_CODE_Z<<12);
    6f1a:	f013 0f20 	tst.w	r3, #32
    6f1e:	bf0c      	ite	eq
    6f20:	f44f 4200 	moveq.w	r2, #32768	; 0x8000
    6f24:	f44f 4260 	movne.w	r2, #57344	; 0xe000
    6f28:	432c      	orrs	r4, r5
		temp |= (i/64%2)  ? (LED_CODE_O<<0)  : (LED_CODE_Z<<0);
    6f2a:	f013 0f40 	tst.w	r3, #64	; 0x40
    6f2e:	ea44 0402 	orr.w	r4, r4, r2
    6f32:	bf0c      	ite	eq
    6f34:	2208      	moveq	r2, #8
    6f36:	220e      	movne	r2, #14
    6f38:	4314      	orrs	r4, r2
		temp |= (i/128%2) ? (LED_CODE_O<<4)  : (LED_CODE_Z<<4);
    6f3a:	09da      	lsrs	r2, r3, #7
    6f3c:	bf14      	ite	ne
    6f3e:	22e0      	movne	r2, #224	; 0xe0
    6f40:	2280      	moveq	r2, #128	; 0x80
	for(uint16_t i=0; i<256; i++){
    6f42:	3301      	adds	r3, #1
		temp |= (i/128%2) ? (LED_CODE_O<<4)  : (LED_CODE_Z<<4);
    6f44:	4322      	orrs	r2, r4
	for(uint16_t i=0; i<256; i++){
    6f46:	b29b      	uxth	r3, r3
		temp |= (i/128%2) ? (LED_CODE_O<<4)  : (LED_CODE_Z<<4);
    6f48:	433a      	orrs	r2, r7
	for(uint16_t i=0; i<256; i++){
    6f4a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
		grid_led_color_code[i] = temp;
    6f4e:	f846 2b04 	str.w	r2, [r6], #4
	for(uint16_t i=0; i<256; i++){
    6f52:	d108      	bne.n	6f66 <grid_led_lowlevel_init+0x96>
	grid_led_buffer_init(mod, num);		
    6f54:	4b09      	ldr	r3, [pc, #36]	; (6f7c <grid_led_lowlevel_init+0xac>)
    6f56:	9001      	str	r0, [sp, #4]
    6f58:	4798      	blx	r3
	grid_led_hardware_init(mod);
    6f5a:	9801      	ldr	r0, [sp, #4]
    6f5c:	4b08      	ldr	r3, [pc, #32]	; (6f80 <grid_led_lowlevel_init+0xb0>)
    6f5e:	4798      	blx	r3
}
    6f60:	2000      	movs	r0, #0
    6f62:	b003      	add	sp, #12
    6f64:	bdf0      	pop	{r4, r5, r6, r7, pc}
		temp |= (i/1%2)   ? (LED_CODE_O<<24) : (LED_CODE_Z<<24);
    6f66:	f013 0f01 	tst.w	r3, #1
    6f6a:	bf14      	ite	ne
    6f6c:	f04f 6760 	movne.w	r7, #234881024	; 0xe000000
    6f70:	f04f 6700 	moveq.w	r7, #134217728	; 0x8000000
    6f74:	e7b1      	b.n	6eda <grid_led_lowlevel_init+0xa>
    6f76:	bf00      	nop
    6f78:	2000fe60 	.word	0x2000fe60
    6f7c:	00006d71 	.word	0x00006d71
    6f80:	00006c11 	.word	0x00006c11

00006f84 <grid_led_lowlevel_render>:


void grid_led_lowlevel_render(struct grid_led_model* mod, uint32_t num){
    6f84:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6f88:	7847      	ldrb	r7, [r0, #1]
		uint8_t layer = i;
				
		uint8_t min_r = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.r;
		uint8_t min_g = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.g;
		uint8_t min_b = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.b;
		uint8_t min_a = min_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    6f8a:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 702c <grid_led_lowlevel_render+0xa8>
    6f8e:	eb07 0347 	add.w	r3, r7, r7, lsl #1
    6f92:	eb07 0783 	add.w	r7, r7, r3, lsl #2
    6f96:	6903      	ldr	r3, [r0, #16]
	uint32_t mix_b = 0;
    6f98:	2500      	movs	r5, #0
    6f9a:	240d      	movs	r4, #13
    6f9c:	fb04 3401 	mla	r4, r4, r1, r3
		uint8_t min_r = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.r;
    6fa0:	2603      	movs	r6, #3
	uint32_t mix_g = 0;
    6fa2:	462b      	mov	r3, r5
	uint32_t mix_r = 0;
    6fa4:	462a      	mov	r2, r5
		uint8_t min_a = min_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    6fa6:	f894 900b 	ldrb.w	r9, [r4, #11]
		uint8_t max_r = mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.r;
		uint8_t max_g = mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.g;
		uint8_t max_b = mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.b;
		uint8_t max_a = max_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
				
		mix_r += min_r*min_a + mid_r*mid_a + max_r*max_a;
    6faa:	f894 b003 	ldrb.w	fp, [r4, #3]
		uint8_t min_a = min_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    6fae:	f818 e009 	ldrb.w	lr, [r8, r9]
		uint8_t mid_a = mid_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    6fb2:	44c1      	add	r9, r8
    6fb4:	3e01      	subs	r6, #1
    6fb6:	f899 a100 	ldrb.w	sl, [r9, #256]	; 0x100
		uint8_t max_a = max_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    6fba:	f899 c200 	ldrb.w	ip, [r9, #512]	; 0x200
		mix_r += min_r*min_a + mid_r*mid_a + max_r*max_a;
    6fbe:	f894 9000 	ldrb.w	r9, [r4]
    6fc2:	fb1b fb0a 	smulbb	fp, fp, sl
    6fc6:	fb09 bb0e 	mla	fp, r9, lr, fp
    6fca:	f894 9006 	ldrb.w	r9, [r4, #6]
    6fce:	fb09 b90c 	mla	r9, r9, ip, fp
		mix_g += min_g*min_a + mid_g*mid_a + max_g*max_a;
    6fd2:	f894 b004 	ldrb.w	fp, [r4, #4]
		mix_r += min_r*min_a + mid_r*mid_a + max_r*max_a;
    6fd6:	444a      	add	r2, r9
		mix_g += min_g*min_a + mid_g*mid_a + max_g*max_a;
    6fd8:	f894 9001 	ldrb.w	r9, [r4, #1]
    6fdc:	fb1b fb0a 	smulbb	fp, fp, sl
    6fe0:	fb09 bb0e 	mla	fp, r9, lr, fp
    6fe4:	f894 9007 	ldrb.w	r9, [r4, #7]
    6fe8:	fb09 b90c 	mla	r9, r9, ip, fp
    6fec:	444b      	add	r3, r9
		mix_b += min_b*min_a + mid_b*mid_a + max_b*max_a;
    6fee:	f894 9005 	ldrb.w	r9, [r4, #5]
    6ff2:	f894 b002 	ldrb.w	fp, [r4, #2]
    6ff6:	fb19 f90a 	smulbb	r9, r9, sl
    6ffa:	fb0b 9e0e 	mla	lr, fp, lr, r9
    6ffe:	f894 9008 	ldrb.w	r9, [r4, #8]
	for (uint8_t i = 0; i<GRID_LED_LAYER_NUMBER; i++){
    7002:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
		mix_b += min_b*min_a + mid_b*mid_a + max_b*max_a;
    7006:	fb09 ec0c 	mla	ip, r9, ip, lr
    700a:	4465      	add	r5, ip
	for (uint8_t i = 0; i<GRID_LED_LAYER_NUMBER; i++){
    700c:	443c      	add	r4, r7
    700e:	d1ca      	bne.n	6fa6 <grid_led_lowlevel_render+0x22>

	mix_r = (mix_r)/2/256;
	mix_g = (mix_g)/2/256;
	mix_b = (mix_b)/2/256;
				
	grid_led_lowlevel_set_color(mod, num, mix_r, mix_g, mix_b);
    7010:	f3c5 254f 	ubfx	r5, r5, #9, #16
    7014:	4c04      	ldr	r4, [pc, #16]	; (7028 <grid_led_lowlevel_render+0xa4>)
    7016:	9500      	str	r5, [sp, #0]
    7018:	f3c3 234f 	ubfx	r3, r3, #9, #16
    701c:	f3c2 224f 	ubfx	r2, r2, #9, #16
    7020:	47a0      	blx	r4
	
}
    7022:	b003      	add	sp, #12
    7024:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7028:	00006bc5 	.word	0x00006bc5
    702c:	20000008 	.word	0x20000008

00007030 <grid_led_lowlevel_render_all>:


void grid_led_lowlevel_render_all(struct grid_led_model* mod){
    7030:	b570      	push	{r4, r5, r6, lr}
	
	for (uint32_t i=0; i<mod->led_number; i++){
		
		grid_led_lowlevel_render(mod, i);
    7032:	4e06      	ldr	r6, [pc, #24]	; (704c <grid_led_lowlevel_render_all+0x1c>)
void grid_led_lowlevel_render_all(struct grid_led_model* mod){
    7034:	4605      	mov	r5, r0
	for (uint32_t i=0; i<mod->led_number; i++){
    7036:	2400      	movs	r4, #0
    7038:	786b      	ldrb	r3, [r5, #1]
    703a:	42a3      	cmp	r3, r4
    703c:	d800      	bhi.n	7040 <grid_led_lowlevel_render_all+0x10>
	}
	
}
    703e:	bd70      	pop	{r4, r5, r6, pc}
		grid_led_lowlevel_render(mod, i);
    7040:	4621      	mov	r1, r4
    7042:	4628      	mov	r0, r5
    7044:	47b0      	blx	r6
	for (uint32_t i=0; i<mod->led_number; i++){
    7046:	3401      	adds	r4, #1
    7048:	e7f6      	b.n	7038 <grid_led_lowlevel_render_all+0x8>
    704a:	bf00      	nop
    704c:	00006f85 	.word	0x00006f85

00007050 <grid_led_lowlevel_hardware_start_transfer>:
			
	}
	
}

void grid_led_lowlevel_hardware_start_transfer (struct grid_led_model* mod){
    7050:	b510      	push	{r4, lr}
	
	// SEND DATA TO LEDs
	grid_led_hardware_transfer_done = 0;
    7052:	4b07      	ldr	r3, [pc, #28]	; (7070 <grid_led_lowlevel_hardware_start_transfer+0x20>)
void grid_led_lowlevel_hardware_start_transfer (struct grid_led_model* mod){
    7054:	4604      	mov	r4, r0
	grid_led_hardware_transfer_done = 0;
    7056:	2200      	movs	r2, #0
    7058:	701a      	strb	r2, [r3, #0]
	spi_m_dma_enable(&GRID_LED);
    705a:	4806      	ldr	r0, [pc, #24]	; (7074 <grid_led_lowlevel_hardware_start_transfer+0x24>)
    705c:	4b06      	ldr	r3, [pc, #24]	; (7078 <grid_led_lowlevel_hardware_start_transfer+0x28>)
    705e:	4798      	blx	r3
			
	io_write(mod->hardware_io_descriptor, grid_led_lowlevel_get_frame_buffer_pointer(mod), grid_led_lowlevel_get_frame_buffer_size(mod));
    7060:	88a2      	ldrh	r2, [r4, #4]
    7062:	68a1      	ldr	r1, [r4, #8]
    7064:	6960      	ldr	r0, [r4, #20]
    7066:	4b05      	ldr	r3, [pc, #20]	; (707c <grid_led_lowlevel_hardware_start_transfer+0x2c>)

}
    7068:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	io_write(mod->hardware_io_descriptor, grid_led_lowlevel_get_frame_buffer_pointer(mod), grid_led_lowlevel_get_frame_buffer_size(mod));
    706c:	4718      	bx	r3
    706e:	bf00      	nop
    7070:	2000914c 	.word	0x2000914c
    7074:	2001ce54 	.word	0x2001ce54
    7078:	0000b9a5 	.word	0x0000b9a5
    707c:	0000b0a5 	.word	0x0000b0a5

00007080 <grid_module_common_init>:

	
/* ============================== GRID_MODULE_INIT() ================================ */


void grid_module_common_init(void){
    7080:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	grid_ui_model_init(&grid_core_state, 1);
    7084:	4d70      	ldr	r5, [pc, #448]	; (7248 <grid_module_common_init+0x1c8>)
    7086:	4b71      	ldr	r3, [pc, #452]	; (724c <grid_module_common_init+0x1cc>)
	grid_ui_element_init(&grid_core_state.bank_list[0], 0, GRID_UI_ELEMENT_SYSTEM);
	
		
	if (1){	// INIT CORE_STATE->hearbeat	
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7088:	f8df 9240 	ldr.w	r9, [pc, #576]	; 72cc <grid_module_common_init+0x24c>
		uint8_t payload_length = 0;
	
		sprintf(payload_template, GRID_EVENTSTRING_HEARTBEAT );
		payload_length = strlen(payload_template);
    708c:	f8df 8240 	ldr.w	r8, [pc, #576]	; 72d0 <grid_module_common_init+0x250>
	
		sprintf(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_frame);
    7090:	4f6f      	ldr	r7, [pc, #444]	; (7250 <grid_module_common_init+0x1d0>)
		uint8_t error = 0;
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    7092:	f8df a240 	ldr.w	sl, [pc, #576]	; 72d4 <grid_module_common_init+0x254>
void grid_module_common_init(void){
    7096:	b0a5      	sub	sp, #148	; 0x94
	grid_ui_model_init(&grid_core_state, 1);
    7098:	4628      	mov	r0, r5
    709a:	2101      	movs	r1, #1
    709c:	4798      	blx	r3
	grid_ui_bank_init(&grid_core_state, 0, 1);
    709e:	4628      	mov	r0, r5
    70a0:	4b6c      	ldr	r3, [pc, #432]	; (7254 <grid_module_common_init+0x1d4>)
    70a2:	2201      	movs	r2, #1
    70a4:	2100      	movs	r1, #0
    70a6:	4798      	blx	r3
	grid_ui_element_init(&grid_core_state.bank_list[0], 0, GRID_UI_ELEMENT_SYSTEM);
    70a8:	2200      	movs	r2, #0
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    70aa:	2400      	movs	r4, #0
	grid_ui_element_init(&grid_core_state.bank_list[0], 0, GRID_UI_ELEMENT_SYSTEM);
    70ac:	6868      	ldr	r0, [r5, #4]
    70ae:	4b6a      	ldr	r3, [pc, #424]	; (7258 <grid_module_common_init+0x1d8>)
    70b0:	4611      	mov	r1, r2
    70b2:	4798      	blx	r3
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    70b4:	227e      	movs	r2, #126	; 0x7e
    70b6:	4621      	mov	r1, r4
    70b8:	a804      	add	r0, sp, #16
    70ba:	9403      	str	r4, [sp, #12]
    70bc:	47c8      	blx	r9
		sprintf(payload_template, GRID_EVENTSTRING_HEARTBEAT );
    70be:	4967      	ldr	r1, [pc, #412]	; (725c <grid_module_common_init+0x1dc>)
    70c0:	4b67      	ldr	r3, [pc, #412]	; (7260 <grid_module_common_init+0x1e0>)
    70c2:	a803      	add	r0, sp, #12
    70c4:	4798      	blx	r3
		payload_length = strlen(payload_template);
    70c6:	a803      	add	r0, sp, #12
    70c8:	47c0      	blx	r8
		sprintf(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_frame);
    70ca:	aa03      	add	r2, sp, #12
    70cc:	1816      	adds	r6, r2, r0
    70ce:	2303      	movs	r3, #3
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    70d0:	f10d 0b0b 	add.w	fp, sp, #11
		sprintf(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_frame);
    70d4:	4963      	ldr	r1, [pc, #396]	; (7264 <grid_module_common_init+0x1e4>)
    70d6:	9300      	str	r3, [sp, #0]
    70d8:	2202      	movs	r2, #2
    70da:	2310      	movs	r3, #16
    70dc:	4630      	mov	r0, r6
    70de:	47b8      	blx	r7
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    70e0:	230e      	movs	r3, #14
    70e2:	2201      	movs	r2, #1
    70e4:	2104      	movs	r1, #4
	
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_HWCFG_offset, GRID_CLASS_HEARTBEAT_HWCFG_length, grid_sys_get_hwcfg(), &error);
    70e6:	4f60      	ldr	r7, [pc, #384]	; (7268 <grid_module_common_init+0x1e8>)
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    70e8:	f8cd b000 	str.w	fp, [sp]
    70ec:	4630      	mov	r0, r6
		uint8_t error = 0;
    70ee:	f88d 400b 	strb.w	r4, [sp, #11]
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    70f2:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_HWCFG_offset, GRID_CLASS_HEARTBEAT_HWCFG_length, grid_sys_get_hwcfg(), &error);
    70f4:	47b8      	blx	r7
    70f6:	2202      	movs	r2, #2
    70f8:	4603      	mov	r3, r0
    70fa:	2105      	movs	r1, #5
    70fc:	4630      	mov	r0, r6
    70fe:	f8cd b000 	str.w	fp, [sp]
    7102:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_VMAJOR_offset, GRID_CLASS_HEARTBEAT_VMAJOR_length , GRID_PROTOCOL_VERSION_MAJOR, &error);
    7104:	2301      	movs	r3, #1
    7106:	2202      	movs	r2, #2
    7108:	2107      	movs	r1, #7
    710a:	4630      	mov	r0, r6
    710c:	f8cd b000 	str.w	fp, [sp]
    7110:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_VMINOR_offset, GRID_CLASS_HEARTBEAT_VMINOR_length  , GRID_PROTOCOL_VERSION_MINOR, &error);
    7112:	2301      	movs	r3, #1
    7114:	2202      	movs	r2, #2
    7116:	2109      	movs	r1, #9
    7118:	4630      	mov	r0, r6
    711a:	f8cd b000 	str.w	fp, [sp]
    711e:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_VPATCH_offset, GRID_CLASS_HEARTBEAT_VPATCH_length  , GRID_PROTOCOL_VERSION_PATCH, &error);
    7120:	2309      	movs	r3, #9
    7122:	2202      	movs	r2, #2
    7124:	210b      	movs	r1, #11
    7126:	4630      	mov	r0, r6
    7128:	f8cd b000 	str.w	fp, [sp]
    712c:	47d0      	blx	sl
	
		payload_length = strlen(payload_template);
    712e:	a803      	add	r0, sp, #12
    7130:	47c0      	blx	r8
	
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_HEARTBEAT, payload_template, payload_length);		
    7132:	686e      	ldr	r6, [r5, #4]
		payload_length = strlen(payload_template);
    7134:	4603      	mov	r3, r0
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_HEARTBEAT, payload_template, payload_length);		
    7136:	aa03      	add	r2, sp, #12
    7138:	68f0      	ldr	r0, [r6, #12]
    713a:	4e4c      	ldr	r6, [pc, #304]	; (726c <grid_module_common_init+0x1ec>)
    713c:	210c      	movs	r1, #12
    713e:	47b0      	blx	r6
		
	}

	if (1){	// INIT CORE_STATE->mapmode press
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7140:	227e      	movs	r2, #126	; 0x7e
    7142:	4621      	mov	r1, r4
    7144:	a804      	add	r0, sp, #16
    7146:	9403      	str	r4, [sp, #12]
    7148:	47c8      	blx	r9
		uint8_t payload_length = 0;
	
		sprintf(payload_template, GRID_EVENTSTRING_MAPMODE_PRESS GRID_ACTIONSTRING_MAPMODE_PRESS);
    714a:	4949      	ldr	r1, [pc, #292]	; (7270 <grid_module_common_init+0x1f0>)
    714c:	4b44      	ldr	r3, [pc, #272]	; (7260 <grid_module_common_init+0x1e0>)
    714e:	a803      	add	r0, sp, #12
    7150:	4798      	blx	r3
		payload_length = strlen(payload_template);
    7152:	a803      	add	r0, sp, #12
    7154:	47c0      	blx	r8
    7156:	4603      	mov	r3, r0
	
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_MAPMODE_PRESS, payload_template, payload_length);			
    7158:	6868      	ldr	r0, [r5, #4]
    715a:	aa03      	add	r2, sp, #12
    715c:	68c0      	ldr	r0, [r0, #12]
    715e:	2107      	movs	r1, #7
    7160:	47b0      	blx	r6
		
	}	

	if (1){ // INIT CORE_STATE->mapmode release
			
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7162:	227e      	movs	r2, #126	; 0x7e
    7164:	4621      	mov	r1, r4
    7166:	a804      	add	r0, sp, #16
    7168:	9403      	str	r4, [sp, #12]
    716a:	47c8      	blx	r9
		uint8_t payload_length = 0;
		
		sprintf(payload_template, GRID_EVENTSTRING_MAPMODE_RELEASE GRID_ACTIONSTRING_MAPMODE_RELEASE);
    716c:	4941      	ldr	r1, [pc, #260]	; (7274 <grid_module_common_init+0x1f4>)
    716e:	4b3c      	ldr	r3, [pc, #240]	; (7260 <grid_module_common_init+0x1e0>)
    7170:	a803      	add	r0, sp, #12
    7172:	4798      	blx	r3
		payload_length = strlen(payload_template);
    7174:	a803      	add	r0, sp, #12
    7176:	47c0      	blx	r8
    7178:	4603      	mov	r3, r0
		
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_MAPMODE_RELEASE, payload_template, payload_length);
    717a:	6868      	ldr	r0, [r5, #4]
    717c:	aa03      	add	r2, sp, #12
    717e:	68c0      	ldr	r0, [r0, #12]
    7180:	2108      	movs	r1, #8
    7182:	47b0      	blx	r6
		
	}	
	
	if (1){ // INIT CORE_STATE->cfgresponse
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7184:	227e      	movs	r2, #126	; 0x7e
    7186:	4621      	mov	r1, r4
    7188:	a804      	add	r0, sp, #16
    718a:	9403      	str	r4, [sp, #12]
    718c:	47c8      	blx	r9
		uint8_t payload_length = 0;
		
		sprintf(payload_template, GRID_EVENTSTRING_CFG_RESPONES GRID_ACTIONSTRING_CFG_RESPONSE);
    718e:	493a      	ldr	r1, [pc, #232]	; (7278 <grid_module_common_init+0x1f8>)
    7190:	4b33      	ldr	r3, [pc, #204]	; (7260 <grid_module_common_init+0x1e0>)
    7192:	a803      	add	r0, sp, #12
    7194:	4798      	blx	r3
		payload_length = strlen(payload_template);
    7196:	a803      	add	r0, sp, #12
    7198:	47c0      	blx	r8
    719a:	4603      	mov	r3, r0
		
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_RESPONSE, payload_template, payload_length);
    719c:	6868      	ldr	r0, [r5, #4]
    719e:	aa03      	add	r2, sp, #12
    71a0:	68c0      	ldr	r0, [r0, #12]
    71a2:	2109      	movs	r1, #9
    71a4:	47b0      	blx	r6
		
	}	
	
	if (1){ // INIT CORE_STATE->cfgrequest
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    71a6:	227e      	movs	r2, #126	; 0x7e
    71a8:	4621      	mov	r1, r4
    71aa:	a804      	add	r0, sp, #16
    71ac:	9403      	str	r4, [sp, #12]
    71ae:	47c8      	blx	r9
		uint8_t payload_length = 0;
		
		sprintf(payload_template, GRID_EVENTSTRING_CFG_REQUEST GRID_ACTIONSTRING_CFG_REQUEST);
    71b0:	4932      	ldr	r1, [pc, #200]	; (727c <grid_module_common_init+0x1fc>)
    71b2:	4b2b      	ldr	r3, [pc, #172]	; (7260 <grid_module_common_init+0x1e0>)
    71b4:	a803      	add	r0, sp, #12
    71b6:	4798      	blx	r3
		payload_length = strlen(payload_template);
    71b8:	a803      	add	r0, sp, #12
    71ba:	47c0      	blx	r8
		
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_REQUEST, payload_template, payload_length);
    71bc:	686c      	ldr	r4, [r5, #4]
		payload_length = strlen(payload_template);
    71be:	4603      	mov	r3, r0
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_REQUEST, payload_template, payload_length);
    71c0:	aa03      	add	r2, sp, #12
    71c2:	68e0      	ldr	r0, [r4, #12]
	}	
	
	
	//enable pwr!
	
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "UI Power Enable");
    71c4:	4c2e      	ldr	r4, [pc, #184]	; (7280 <grid_module_common_init+0x200>)
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_REQUEST, payload_template, payload_length);
    71c6:	210a      	movs	r1, #10
    71c8:	47b0      	blx	r6
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "UI Power Enable");
    71ca:	492e      	ldr	r1, [pc, #184]	; (7284 <grid_module_common_init+0x204>)
    71cc:	482e      	ldr	r0, [pc, #184]	; (7288 <grid_module_common_init+0x208>)
    71ce:	47a0      	blx	r4
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = PORT_OUT_OUT(mask);
}

static inline void hri_port_set_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    71d0:	4b2e      	ldr	r3, [pc, #184]	; (728c <grid_module_common_init+0x20c>)
    71d2:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    71d6:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	gpio_set_pin_level(UI_PWR_EN, true);

	// ADC SETUP	
	
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    71da:	47b8      	blx	r7
    71dc:	4625      	mov	r5, r4
    71de:	b970      	cbnz	r0, 71fe <grid_module_common_init+0x17e>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: PO16");
    71e0:	492b      	ldr	r1, [pc, #172]	; (7290 <grid_module_common_init+0x210>)
    71e2:	4829      	ldr	r0, [pc, #164]	; (7288 <grid_module_common_init+0x208>)
    71e4:	47a8      	blx	r5
		grid_module_po16_revb_init();
    71e6:	4b2b      	ldr	r3, [pc, #172]	; (7294 <grid_module_common_init+0x214>)
	}
	else if (grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevC ){
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: BU16");
		grid_module_bu16_revb_init();
    71e8:	4798      	blx	r3
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: Unknown Module");
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "HWCFG Mismatch");
	}


	grid_sys_init(&grid_sys_state);
    71ea:	4b2b      	ldr	r3, [pc, #172]	; (7298 <grid_module_common_init+0x218>)
    71ec:	482b      	ldr	r0, [pc, #172]	; (729c <grid_module_common_init+0x21c>)
    71ee:	4798      	blx	r3


	grid_nvm_init(&grid_nvm_state, &FLASH_0);
    71f0:	492b      	ldr	r1, [pc, #172]	; (72a0 <grid_module_common_init+0x220>)
    71f2:	482c      	ldr	r0, [pc, #176]	; (72a4 <grid_module_common_init+0x224>)
    71f4:	4b2c      	ldr	r3, [pc, #176]	; (72a8 <grid_module_common_init+0x228>)
    71f6:	4798      	blx	r3
	
		
}
    71f8:	b025      	add	sp, #148	; 0x94
    71fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    71fe:	47b8      	blx	r7
    7200:	2808      	cmp	r0, #8
    7202:	d0ed      	beq.n	71e0 <grid_module_common_init+0x160>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevC ){
    7204:	47b8      	blx	r7
    7206:	2880      	cmp	r0, #128	; 0x80
    7208:	d104      	bne.n	7214 <grid_module_common_init+0x194>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: BU16");
    720a:	4928      	ldr	r1, [pc, #160]	; (72ac <grid_module_common_init+0x22c>)
    720c:	481e      	ldr	r0, [pc, #120]	; (7288 <grid_module_common_init+0x208>)
    720e:	47a8      	blx	r5
		grid_module_bu16_revb_init();
    7210:	4b27      	ldr	r3, [pc, #156]	; (72b0 <grid_module_common_init+0x230>)
    7212:	e7e9      	b.n	71e8 <grid_module_common_init+0x168>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevC ){
    7214:	47b8      	blx	r7
    7216:	2888      	cmp	r0, #136	; 0x88
    7218:	d0f7      	beq.n	720a <grid_module_common_init+0x18a>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_PBF4_RevA){
    721a:	47b8      	blx	r7
    721c:	2840      	cmp	r0, #64	; 0x40
    721e:	d104      	bne.n	722a <grid_module_common_init+0x1aa>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: PBF4");					
    7220:	4924      	ldr	r1, [pc, #144]	; (72b4 <grid_module_common_init+0x234>)
    7222:	4819      	ldr	r0, [pc, #100]	; (7288 <grid_module_common_init+0x208>)
    7224:	47a0      	blx	r4
		grid_module_pbf4_reva_init();			
    7226:	4b24      	ldr	r3, [pc, #144]	; (72b8 <grid_module_common_init+0x238>)
    7228:	e7de      	b.n	71e8 <grid_module_common_init+0x168>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_EN16_RevA){
    722a:	47b8      	blx	r7
    722c:	28c0      	cmp	r0, #192	; 0xc0
    722e:	d104      	bne.n	723a <grid_module_common_init+0x1ba>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: EN16");
    7230:	4922      	ldr	r1, [pc, #136]	; (72bc <grid_module_common_init+0x23c>)
    7232:	4815      	ldr	r0, [pc, #84]	; (7288 <grid_module_common_init+0x208>)
    7234:	47a0      	blx	r4
		grid_module_en16_reva_init();	
    7236:	4b22      	ldr	r3, [pc, #136]	; (72c0 <grid_module_common_init+0x240>)
    7238:	e7d6      	b.n	71e8 <grid_module_common_init+0x168>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: Unknown Module");
    723a:	4922      	ldr	r1, [pc, #136]	; (72c4 <grid_module_common_init+0x244>)
    723c:	4812      	ldr	r0, [pc, #72]	; (7288 <grid_module_common_init+0x208>)
    723e:	47a0      	blx	r4
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "HWCFG Mismatch");
    7240:	4921      	ldr	r1, [pc, #132]	; (72c8 <grid_module_common_init+0x248>)
    7242:	4811      	ldr	r0, [pc, #68]	; (7288 <grid_module_common_init+0x208>)
    7244:	47a0      	blx	r4
    7246:	e7d0      	b.n	71ea <grid_module_common_init+0x16a>
    7248:	2001c7c0 	.word	0x2001c7c0
    724c:	00009a29 	.word	0x00009a29
    7250:	00014791 	.word	0x00014791
    7254:	00009a5d 	.word	0x00009a5d
    7258:	0000a389 	.word	0x0000a389
    725c:	00015b86 	.word	0x00015b86
    7260:	000147ff 	.word	0x000147ff
    7264:	00015a3e 	.word	0x00015a3e
    7268:	000098a5 	.word	0x000098a5
    726c:	00009eed 	.word	0x00009eed
    7270:	00015b9a 	.word	0x00015b9a
    7274:	00015bc0 	.word	0x00015bc0
    7278:	00015bd9 	.word	0x00015bd9
    727c:	00015bff 	.word	0x00015bff
    7280:	00014451 	.word	0x00014451
    7284:	00015c25 	.word	0x00015c25
    7288:	00015acf 	.word	0x00015acf
    728c:	41008000 	.word	0x41008000
    7290:	00015c35 	.word	0x00015c35
    7294:	00008359 	.word	0x00008359
    7298:	00009609 	.word	0x00009609
    729c:	2000f008 	.word	0x2000f008
    72a0:	2001ccf8 	.word	0x2001ccf8
    72a4:	2000fa1c 	.word	0x2000fa1c
    72a8:	00008cb1 	.word	0x00008cb1
    72ac:	00015c47 	.word	0x00015c47
    72b0:	00007609 	.word	0x00007609
    72b4:	00015c59 	.word	0x00015c59
    72b8:	00007ffd 	.word	0x00007ffd
    72bc:	00015c6b 	.word	0x00015c6b
    72c0:	00007b21 	.word	0x00007b21
    72c4:	00015c7d 	.word	0x00015c7d
    72c8:	00015c99 	.word	0x00015c99
    72cc:	000142f1 	.word	0x000142f1
    72d0:	0001480f 	.word	0x0001480f
    72d4:	000099e5 	.word	0x000099e5

000072d8 <grid_module_bu16_revb_hardware_start_transfer>:

static uint8_t grid_bu16_helper_template_b_tgl2[GRID_SYS_BANK_MAXNUMBER][16] = {0};
static uint8_t grid_bu16_helper_template_b_tgl3[GRID_SYS_BANK_MAXNUMBER][16] = {0};
	
	
void grid_module_bu16_revb_hardware_start_transfer(void){
    72d8:	b510      	push	{r4, lr}
	
	adc_async_start_conversion(&ADC_0);
    72da:	4c04      	ldr	r4, [pc, #16]	; (72ec <grid_module_bu16_revb_hardware_start_transfer+0x14>)
    72dc:	4804      	ldr	r0, [pc, #16]	; (72f0 <grid_module_bu16_revb_hardware_start_transfer+0x18>)
    72de:	47a0      	blx	r4
	adc_async_start_conversion(&ADC_1);
    72e0:	4623      	mov	r3, r4
    72e2:	4804      	ldr	r0, [pc, #16]	; (72f4 <grid_module_bu16_revb_hardware_start_transfer+0x1c>)

}
    72e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_async_start_conversion(&ADC_1);
    72e8:	4718      	bx	r3
    72ea:	bf00      	nop
    72ec:	0000e5f5 	.word	0x0000e5f5
    72f0:	2001cd84 	.word	0x2001cd84
    72f4:	2001cf58 	.word	0x2001cf58

000072f8 <grid_module_bu16_revb_hardware_transfer_complete_cb>:

static void grid_module_bu16_revb_hardware_transfer_complete_cb(void){
    72f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		
	if (grid_module_bu16_revb_hardware_transfer_complete == 0){
    72fc:	4aa4      	ldr	r2, [pc, #656]	; (7590 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x298>)
    72fe:	7813      	ldrb	r3, [r2, #0]
static void grid_module_bu16_revb_hardware_transfer_complete_cb(void){
    7300:	b08b      	sub	sp, #44	; 0x2c
    7302:	4614      	mov	r4, r2
	if (grid_module_bu16_revb_hardware_transfer_complete == 0){
    7304:	b933      	cbnz	r3, 7314 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x1c>
		grid_module_bu16_revb_hardware_transfer_complete++;
    7306:	7813      	ldrb	r3, [r2, #0]
    7308:	3301      	adds	r3, #1
    730a:	b2db      	uxtb	r3, r3
    730c:	7013      	strb	r3, [r2, #0]
	}
	
	
	grid_module_bu16_revb_hardware_transfer_complete = 0;
	grid_module_bu16_revb_hardware_start_transfer();
}
    730e:	b00b      	add	sp, #44	; 0x2c
    7310:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    7314:	4b9f      	ldr	r3, [pc, #636]	; (7594 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x29c>)
    7316:	48a0      	ldr	r0, [pc, #640]	; (7598 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a0>)
	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    7318:	4d9f      	ldr	r5, [pc, #636]	; (7598 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a0>)
	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    731a:	4798      	blx	r3
	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    731c:	7c6a      	ldrb	r2, [r5, #17]
		bank=0;
    731e:	28ff      	cmp	r0, #255	; 0xff
    7320:	bf14      	ite	ne
    7322:	4603      	movne	r3, r0
    7324:	2300      	moveq	r3, #0
	if (bank_changed){
    7326:	b9fa      	cbnz	r2, 7368 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x70>
	uint16_t adcresult_0 = 0;
    7328:	2300      	movs	r3, #0
    732a:	f8ad 3014 	strh.w	r3, [sp, #20]
	uint16_t adcresult_1 = 0;
    732e:	f8ad 3016 	strh.w	r3, [sp, #22]
	uint8_t adc_index_0 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+8];
    7332:	7863      	ldrb	r3, [r4, #1]
    7334:	4a99      	ldr	r2, [pc, #612]	; (759c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a4>)
    7336:	3308      	adds	r3, #8
    7338:	5cd7      	ldrb	r7, [r2, r3]
	uint8_t adc_index_1 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+0];
    733a:	7863      	ldrb	r3, [r4, #1]
    733c:	b2db      	uxtb	r3, r3
	uint8_t adc_index_0 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+8];
    733e:	b2ff      	uxtb	r7, r7
	uint8_t adc_index_1 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+0];
    7340:	5cd6      	ldrb	r6, [r2, r3]
	grid_module_bu16_revb_mux++;
    7342:	7863      	ldrb	r3, [r4, #1]
    7344:	3301      	adds	r3, #1
    7346:	b2db      	uxtb	r3, r3
    7348:	7063      	strb	r3, [r4, #1]
	grid_module_bu16_revb_mux%=8;
    734a:	7863      	ldrb	r3, [r4, #1]
    734c:	f003 0307 	and.w	r3, r3, #7
    7350:	7063      	strb	r3, [r4, #1]
	gpio_set_pin_level(MUX_A, grid_module_bu16_revb_mux/1%2);
    7352:	7863      	ldrb	r3, [r4, #1]
/**
 * \brief Set output level on port with mask
 */
static inline void _gpio_set_level(const enum gpio_port port, const uint32_t mask, const bool level)
{
	if (level) {
    7354:	f013 0f01 	tst.w	r3, #1
	uint8_t adc_index_1 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+0];
    7358:	b2f6      	uxtb	r6, r6
    735a:	4b91      	ldr	r3, [pc, #580]	; (75a0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a8>)
    735c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    7360:	d141      	bne.n	73e6 <grid_module_bu16_revb_hardware_transfer_complete_cb+0xee>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = ~data;
}

static inline void hri_port_clear_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7362:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
    7366:	e040      	b.n	73ea <grid_module_bu16_revb_hardware_transfer_complete_cb+0xf2>
		grid_sys_state.bank_active_changed = 0;
    7368:	f04f 0900 	mov.w	r9, #0
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    736c:	fa0f fa83 	sxth.w	sl, r3
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7370:	f8df 823c 	ldr.w	r8, [pc, #572]	; 75b0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b8>
		grid_sys_state.bank_active_changed = 0;
    7374:	f885 9011 	strb.w	r9, [r5, #17]
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7378:	ea4f 1a0a 	mov.w	sl, sl, lsl #4
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    737c:	eb04 1703 	add.w	r7, r4, r3, lsl #4
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7380:	f8d8 3004 	ldr.w	r3, [r8, #4]
    7384:	7bea      	ldrb	r2, [r5, #15]
    7386:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    738a:	fa5f f689 	uxtb.w	r6, r9
    738e:	7a5b      	ldrb	r3, [r3, #9]
    7390:	42b3      	cmp	r3, r6
    7392:	d9c9      	bls.n	7328 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x30>
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7394:	f8d8 2004 	ldr.w	r2, [r8, #4]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7398:	f8df b220 	ldr.w	fp, [pc, #544]	; 75bc <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2c4>
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    739c:	4452      	add	r2, sl
    739e:	2364      	movs	r3, #100	; 0x64
    73a0:	68d2      	ldr	r2, [r2, #12]
    73a2:	4373      	muls	r3, r6
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    73a4:	19b9      	adds	r1, r7, r6
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    73a6:	441a      	add	r2, r3
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    73a8:	7888      	ldrb	r0, [r1, #2]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_bu16_helper_template_b_tgl3[bank][i];
    73aa:	f891 1042 	ldrb.w	r1, [r1, #66]	; 0x42
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    73ae:	6190      	str	r0, [r2, #24]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_bu16_helper_template_b_tgl3[bank][i];
    73b0:	61d1      	str	r1, [r2, #28]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    73b2:	f8d8 2004 	ldr.w	r2, [r8, #4]
    73b6:	7be9      	ldrb	r1, [r5, #15]
    73b8:	eb02 1201 	add.w	r2, r2, r1, lsl #4
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    73bc:	4640      	mov	r0, r8
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    73be:	68d2      	ldr	r2, [r2, #12]
    73c0:	4413      	add	r3, r2
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    73c2:	4632      	mov	r2, r6
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    73c4:	60de      	str	r6, [r3, #12]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    73c6:	7be9      	ldrb	r1, [r5, #15]
    73c8:	2300      	movs	r3, #0
    73ca:	47d8      	blx	fp
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    73cc:	7be9      	ldrb	r1, [r5, #15]
    73ce:	2304      	movs	r3, #4
    73d0:	4632      	mov	r2, r6
    73d2:	4640      	mov	r0, r8
    73d4:	47d8      	blx	fp
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    73d6:	7be9      	ldrb	r1, [r5, #15]
    73d8:	2305      	movs	r3, #5
    73da:	4632      	mov	r2, r6
    73dc:	4640      	mov	r0, r8
    73de:	47d8      	blx	fp
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    73e0:	f109 0901 	add.w	r9, r9, #1
    73e4:	e7cc      	b.n	7380 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x88>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    73e6:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	gpio_set_pin_level(MUX_B, grid_module_bu16_revb_mux/2%2);
    73ea:	7863      	ldrb	r3, [r4, #1]
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    73ec:	f8df 81d0 	ldr.w	r8, [pc, #464]	; 75c0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2c8>
    73f0:	486c      	ldr	r0, [pc, #432]	; (75a4 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2ac>)
    73f2:	f013 0f02 	tst.w	r3, #2
    73f6:	4b6a      	ldr	r3, [pc, #424]	; (75a0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a8>)
    73f8:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    73fc:	bf14      	ite	ne
    73fe:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7402:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	gpio_set_pin_level(MUX_C, grid_module_bu16_revb_mux/4%2);
    7406:	7863      	ldrb	r3, [r4, #1]
    7408:	f013 0f04 	tst.w	r3, #4
    740c:	4b64      	ldr	r3, [pc, #400]	; (75a0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a8>)
    740e:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7412:	bf14      	ite	ne
    7414:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7418:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    741c:	2100      	movs	r1, #0
    741e:	2302      	movs	r3, #2
    7420:	aa05      	add	r2, sp, #20
    7422:	47c0      	blx	r8
	adc_async_read_channel(&ADC_1, 0, &adcresult_1, 2);
    7424:	2302      	movs	r3, #2
    7426:	f10d 0216 	add.w	r2, sp, #22
    742a:	485f      	ldr	r0, [pc, #380]	; (75a8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b0>)
    742c:	2100      	movs	r1, #0
    742e:	47c0      	blx	r8
	uint8_t result_value[2] = {0};
    7430:	2300      	movs	r3, #0
    7432:	f8ad 300c 	strh.w	r3, [sp, #12]
	uint8_t result_valid[2] = {0};
    7436:	f8ad 3010 	strh.w	r3, [sp, #16]
	if (adcresult_0>60000){
    743a:	f8bd 3014 	ldrh.w	r3, [sp, #20]
	result_index[0] = adc_index_0;
    743e:	f88d 7008 	strb.w	r7, [sp, #8]
	if (adcresult_0>60000){
    7442:	f64e 2260 	movw	r2, #60000	; 0xea60
    7446:	4293      	cmp	r3, r2
	result_index[1] = adc_index_1;
    7448:	f88d 6009 	strb.w	r6, [sp, #9]
	if (adcresult_0>60000){
    744c:	d978      	bls.n	7540 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x248>
		result_valid[0] = 1;
    744e:	2301      	movs	r3, #1
    7450:	f88d 3010 	strb.w	r3, [sp, #16]
	if (adcresult_1>60000){
    7454:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    7458:	f64e 2260 	movw	r2, #60000	; 0xea60
    745c:	4293      	cmp	r3, r2
    745e:	d975      	bls.n	754c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x254>
		result_value[1] = 0;
    7460:	2300      	movs	r3, #0
		result_value[1] = 127;
    7462:	f88d 300d 	strb.w	r3, [sp, #13]
		result_valid[1] = 1;
    7466:	2301      	movs	r3, #1
    7468:	f88d 3011 	strb.w	r3, [sp, #17]
	uint8_t grid_module_bu16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};	
    746c:	4b4f      	ldr	r3, [pc, #316]	; (75ac <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b4>)
    746e:	ae06      	add	r6, sp, #24
    7470:	f103 0710 	add.w	r7, r3, #16
    7474:	6818      	ldr	r0, [r3, #0]
    7476:	6859      	ldr	r1, [r3, #4]
    7478:	4632      	mov	r2, r6
    747a:	c203      	stmia	r2!, {r0, r1}
    747c:	3308      	adds	r3, #8
    747e:	42bb      	cmp	r3, r7
    7480:	4616      	mov	r6, r2
    7482:	d1f7      	bne.n	7474 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x17c>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    7484:	484a      	ldr	r0, [pc, #296]	; (75b0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b8>)
	uint8_t grid_module_bu16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};	
    7486:	2300      	movs	r3, #0
    7488:	f10d 0908 	add.w	r9, sp, #8
    748c:	f10d 0b0c 	add.w	fp, sp, #12
    7490:	9301      	str	r3, [sp, #4]
    7492:	4682      	mov	sl, r0
		uint8_t res_index = result_index[i];
    7494:	f819 6b01 	ldrb.w	r6, [r9], #1
		uint8_t res_value = result_value[i];
    7498:	f81b 8b01 	ldrb.w	r8, [fp], #1
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    749c:	6843      	ldr	r3, [r0, #4]
    749e:	7bea      	ldrb	r2, [r5, #15]
		if (res_value != grid_bu16_helper_template_b_abs[res_index] && res_valid == 1){
    74a0:	19a1      	adds	r1, r4, r6
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    74a2:	b2d2      	uxtb	r2, r2
		if (res_value != grid_bu16_helper_template_b_abs[res_index] && res_valid == 1){
    74a4:	f891 c082 	ldrb.w	ip, [r1, #130]	; 0x82
    74a8:	45e0      	cmp	r8, ip
    74aa:	d042      	beq.n	7532 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x23a>
    74ac:	9f01      	ldr	r7, [sp, #4]
		uint8_t res_valid = result_valid[i];
    74ae:	a904      	add	r1, sp, #16
		if (res_value != grid_bu16_helper_template_b_abs[res_index] && res_valid == 1){
    74b0:	5c79      	ldrb	r1, [r7, r1]
    74b2:	2901      	cmp	r1, #1
    74b4:	d13d      	bne.n	7532 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x23a>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    74b6:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    74ba:	2164      	movs	r1, #100	; 0x64
    74bc:	68db      	ldr	r3, [r3, #12]
    74be:	fb16 f101 	smulbb	r1, r6, r1
    74c2:	440b      	add	r3, r1
			if (grid_bu16_helper_template_b_abs[res_index] == 0){ // Button Press Event
    74c4:	f1bc 0f00 	cmp.w	ip, #0
    74c8:	d14d      	bne.n	7566 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x26e>
				if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] == 0){
    74ca:	699a      	ldr	r2, [r3, #24]
				if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    74cc:	f8d3 e01c 	ldr.w	lr, [r3, #28]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    74d0:	2a00      	cmp	r2, #0
    74d2:	bf0c      	ite	eq
    74d4:	227f      	moveq	r2, #127	; 0x7f
    74d6:	2200      	movne	r2, #0
    74d8:	619a      	str	r2, [r3, #24]
				if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    74da:	f1be 0f00 	cmp.w	lr, #0
    74de:	d13c      	bne.n	755a <grid_module_bu16_revb_hardware_transfer_complete_cb+0x262>
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 63;
    74e0:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 0;
    74e4:	f8c3 c01c 	str.w	ip, [r3, #28]
				grid_bu16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    74e8:	f895 c00f 	ldrb.w	ip, [r5, #15]
    74ec:	9f01      	ldr	r7, [sp, #4]
				grid_bu16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    74ee:	69db      	ldr	r3, [r3, #28]
				grid_bu16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    74f0:	eb04 1c0c 	add.w	ip, r4, ip, lsl #4
    74f4:	44bc      	add	ip, r7
    74f6:	f88c 2002 	strb.w	r2, [ip, #2]
				grid_bu16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    74fa:	7bea      	ldrb	r2, [r5, #15]
    74fc:	eb04 1202 	add.w	r2, r4, r2, lsl #4
    7500:	443a      	add	r2, r7
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7502:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
				grid_bu16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7506:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
    750a:	2300      	movs	r3, #0
                    template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    750c:	f8da 2004 	ldr.w	r2, [sl, #4]
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7510:	441a      	add	r2, r3
    7512:	3310      	adds	r3, #16
    7514:	68d2      	ldr	r2, [r2, #12]
    7516:	440a      	add	r2, r1
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7518:	2b40      	cmp	r3, #64	; 0x40
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    751a:	f8c2 c014 	str.w	ip, [r2, #20]
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    751e:	d1f5      	bne.n	750c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x214>
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DP);
    7520:	7be9      	ldrb	r1, [r5, #15]
    7522:	2304      	movs	r3, #4
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    7524:	4632      	mov	r2, r6
    7526:	4f23      	ldr	r7, [pc, #140]	; (75b4 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2bc>)
				grid_bu16_helper_template_b_abs[result_index[i]] = res_value;
    7528:	4426      	add	r6, r4
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    752a:	47b8      	blx	r7
				grid_bu16_helper_template_b_abs[result_index[i]] = res_value;
    752c:	4820      	ldr	r0, [pc, #128]	; (75b0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b8>)
    752e:	f886 8082 	strb.w	r8, [r6, #130]	; 0x82
	for (uint8_t i=0; i<2; i++)
    7532:	9b01      	ldr	r3, [sp, #4]
    7534:	b173      	cbz	r3, 7554 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x25c>
	grid_module_bu16_revb_hardware_transfer_complete = 0;
    7536:	2300      	movs	r3, #0
    7538:	7023      	strb	r3, [r4, #0]
	grid_module_bu16_revb_hardware_start_transfer();
    753a:	4b1f      	ldr	r3, [pc, #124]	; (75b8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2c0>)
    753c:	4798      	blx	r3
    753e:	e6e6      	b.n	730e <grid_module_bu16_revb_hardware_transfer_complete_cb+0x16>
	else if (adcresult_0<200){
    7540:	2bc7      	cmp	r3, #199	; 0xc7
    7542:	d887      	bhi.n	7454 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x15c>
		result_value[0] = 127;
    7544:	237f      	movs	r3, #127	; 0x7f
    7546:	f88d 300c 	strb.w	r3, [sp, #12]
    754a:	e780      	b.n	744e <grid_module_bu16_revb_hardware_transfer_complete_cb+0x156>
	else if (adcresult_1<200){
    754c:	2bc7      	cmp	r3, #199	; 0xc7
    754e:	d88d      	bhi.n	746c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x174>
		result_value[1] = 127;
    7550:	237f      	movs	r3, #127	; 0x7f
    7552:	e786      	b.n	7462 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x16a>
    7554:	2301      	movs	r3, #1
    7556:	9301      	str	r3, [sp, #4]
    7558:	e79c      	b.n	7494 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x19c>
				else if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 63){
    755a:	f1be 0f3f 	cmp.w	lr, #63	; 0x3f
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    755e:	bf08      	it	eq
    7560:	f04f 0c7f 	moveq.w	ip, #127	; 0x7f
    7564:	e7be      	b.n	74e4 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x1ec>
				template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_bu16_mux_reversed_lookup[res_index];
    7566:	aa0a      	add	r2, sp, #40	; 0x28
    7568:	4432      	add	r2, r6
				template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    756a:	60de      	str	r6, [r3, #12]
				template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_bu16_mux_reversed_lookup[res_index];
    756c:	f812 2c10 	ldrb.w	r2, [r2, #-16]
    7570:	611a      	str	r2, [r3, #16]
    7572:	2300      	movs	r3, #0
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7574:	469c      	mov	ip, r3
                    template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7576:	f8da 2004 	ldr.w	r2, [sl, #4]
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    757a:	441a      	add	r2, r3
    757c:	3310      	adds	r3, #16
    757e:	68d2      	ldr	r2, [r2, #12]
    7580:	440a      	add	r2, r1
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7582:	2b40      	cmp	r3, #64	; 0x40
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7584:	f8c2 c014 	str.w	ip, [r2, #20]
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7588:	d1f5      	bne.n	7576 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x27e>
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    758a:	7be9      	ldrb	r1, [r5, #15]
    758c:	2305      	movs	r3, #5
    758e:	e7c9      	b.n	7524 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x22c>
    7590:	200005ec 	.word	0x200005ec
    7594:	000096bf 	.word	0x000096bf
    7598:	2000f008 	.word	0x2000f008
    759c:	20000308 	.word	0x20000308
    75a0:	41008000 	.word	0x41008000
    75a4:	2001cd84 	.word	0x2001cd84
    75a8:	2001cf58 	.word	0x2001cf58
    75ac:	00015ca8 	.word	0x00015ca8
    75b0:	2000effc 	.word	0x2000effc
    75b4:	0000a149 	.word	0x0000a149
    75b8:	000072d9 	.word	0x000072d9
    75bc:	0000a49d 	.word	0x0000a49d
    75c0:	0000e539 	.word	0x0000e539

000075c4 <grid_module_bu16_revb_hardware_init>:

void grid_module_bu16_revb_hardware_init(void){
    75c4:	b570      	push	{r4, r5, r6, lr}
	

	
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    75c6:	4c0b      	ldr	r4, [pc, #44]	; (75f4 <grid_module_bu16_revb_hardware_init+0x30>)
    75c8:	4e0b      	ldr	r6, [pc, #44]	; (75f8 <grid_module_bu16_revb_hardware_init+0x34>)
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    75ca:	4d0c      	ldr	r5, [pc, #48]	; (75fc <grid_module_bu16_revb_hardware_init+0x38>)
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    75cc:	4b0c      	ldr	r3, [pc, #48]	; (7600 <grid_module_bu16_revb_hardware_init+0x3c>)
    75ce:	2200      	movs	r2, #0
    75d0:	4611      	mov	r1, r2
    75d2:	4620      	mov	r0, r4
    75d4:	47b0      	blx	r6
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    75d6:	2200      	movs	r2, #0
    75d8:	4b09      	ldr	r3, [pc, #36]	; (7600 <grid_module_bu16_revb_hardware_init+0x3c>)
    75da:	4611      	mov	r1, r2
    75dc:	4628      	mov	r0, r5
    75de:	47b0      	blx	r6
	
	adc_async_enable_channel(&ADC_0, 0);
    75e0:	4620      	mov	r0, r4
    75e2:	4c08      	ldr	r4, [pc, #32]	; (7604 <grid_module_bu16_revb_hardware_init+0x40>)
    75e4:	2100      	movs	r1, #0
    75e6:	47a0      	blx	r4
	adc_async_enable_channel(&ADC_1, 0);
    75e8:	4628      	mov	r0, r5
    75ea:	4623      	mov	r3, r4
    75ec:	2100      	movs	r1, #0

}
    75ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	adc_async_enable_channel(&ADC_1, 0);
    75f2:	4718      	bx	r3
    75f4:	2001cd84 	.word	0x2001cd84
    75f8:	0000e4c1 	.word	0x0000e4c1
    75fc:	2001cf58 	.word	0x2001cf58
    7600:	000072f9 	.word	0x000072f9
    7604:	0000e481 	.word	0x0000e481

00007608 <grid_module_bu16_revb_init>:



void grid_module_bu16_revb_init(){
    7608:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

	grid_led_lowlevel_init(&grid_led_state, 16);
    760c:	4b12      	ldr	r3, [pc, #72]	; (7658 <grid_module_bu16_revb_init+0x50>)
    760e:	4813      	ldr	r0, [pc, #76]	; (765c <grid_module_bu16_revb_init+0x54>)
	
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
	
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
		
		grid_ui_bank_init(&grid_ui_state, i, 16);
    7610:	4e13      	ldr	r6, [pc, #76]	; (7660 <grid_module_bu16_revb_init+0x58>)
    7612:	4f14      	ldr	r7, [pc, #80]	; (7664 <grid_module_bu16_revb_init+0x5c>)
		
		for (uint8_t j=0; j<16; j++){

			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_BUTTON);
    7614:	f8df 805c 	ldr.w	r8, [pc, #92]	; 7674 <grid_module_bu16_revb_init+0x6c>
	grid_led_lowlevel_init(&grid_led_state, 16);
    7618:	2110      	movs	r1, #16
    761a:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
    761c:	4810      	ldr	r0, [pc, #64]	; (7660 <grid_module_bu16_revb_init+0x58>)
    761e:	4b12      	ldr	r3, [pc, #72]	; (7668 <grid_module_bu16_revb_init+0x60>)
    7620:	2104      	movs	r1, #4
    7622:	4798      	blx	r3
    7624:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 16);
    7626:	2210      	movs	r2, #16
    7628:	b2e1      	uxtb	r1, r4
    762a:	4630      	mov	r0, r6
    762c:	47b8      	blx	r7
		for (uint8_t j=0; j<16; j++){
    762e:	ea4f 1904 	mov.w	r9, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 16);
    7632:	2500      	movs	r5, #0
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_BUTTON);
    7634:	6870      	ldr	r0, [r6, #4]
    7636:	b2e9      	uxtb	r1, r5
    7638:	2202      	movs	r2, #2
    763a:	4448      	add	r0, r9
    763c:	3501      	adds	r5, #1
    763e:	47c0      	blx	r8
		for (uint8_t j=0; j<16; j++){
    7640:	2d10      	cmp	r5, #16
    7642:	d1f7      	bne.n	7634 <grid_module_bu16_revb_init+0x2c>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    7644:	3401      	adds	r4, #1
    7646:	2c04      	cmp	r4, #4
    7648:	d1ed      	bne.n	7626 <grid_module_bu16_revb_init+0x1e>

		}		
		
	}
				
	grid_module_bu16_revb_hardware_init();
    764a:	4b08      	ldr	r3, [pc, #32]	; (766c <grid_module_bu16_revb_init+0x64>)
    764c:	4798      	blx	r3
	grid_module_bu16_revb_hardware_start_transfer();

};
    764e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_bu16_revb_hardware_start_transfer();
    7652:	4b07      	ldr	r3, [pc, #28]	; (7670 <grid_module_bu16_revb_init+0x68>)
    7654:	4718      	bx	r3
    7656:	bf00      	nop
    7658:	00006ed1 	.word	0x00006ed1
    765c:	2001c838 	.word	0x2001c838
    7660:	2000effc 	.word	0x2000effc
    7664:	00009a5d 	.word	0x00009a5d
    7668:	00009a29 	.word	0x00009a29
    766c:	000075c5 	.word	0x000075c5
    7670:	000072d9 	.word	0x000072d9
    7674:	0000a389 	.word	0x0000a389

00007678 <grid_module_en16_reva_hardware_start_transfer>:





void grid_module_en16_reva_hardware_start_transfer(void){
    7678:	b510      	push	{r4, lr}
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    767a:	4b08      	ldr	r3, [pc, #32]	; (769c <grid_module_en16_reva_hardware_start_transfer+0x24>)
	

	gpio_set_pin_level(PIN_UI_SPI_CS0, true);

	spi_m_async_enable(&UI_SPI);
    767c:	4808      	ldr	r0, [pc, #32]	; (76a0 <grid_module_en16_reva_hardware_start_transfer+0x28>)

	//io_write(io, UI_SPI_TX_BUFFER, 8);
	spi_m_async_transfer(&UI_SPI, UI_SPI_TX_BUFFER, UI_SPI_RX_BUFFER, 8);
    767e:	4c09      	ldr	r4, [pc, #36]	; (76a4 <grid_module_en16_reva_hardware_start_transfer+0x2c>)
    7680:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    7684:	619a      	str	r2, [r3, #24]
	spi_m_async_enable(&UI_SPI);
    7686:	4b08      	ldr	r3, [pc, #32]	; (76a8 <grid_module_en16_reva_hardware_start_transfer+0x30>)
    7688:	4798      	blx	r3
	spi_m_async_transfer(&UI_SPI, UI_SPI_TX_BUFFER, UI_SPI_RX_BUFFER, 8);
    768a:	4a08      	ldr	r2, [pc, #32]	; (76ac <grid_module_en16_reva_hardware_start_transfer+0x34>)
    768c:	4804      	ldr	r0, [pc, #16]	; (76a0 <grid_module_en16_reva_hardware_start_transfer+0x28>)
    768e:	46a4      	mov	ip, r4
    7690:	2308      	movs	r3, #8

}
    7692:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	spi_m_async_transfer(&UI_SPI, UI_SPI_TX_BUFFER, UI_SPI_RX_BUFFER, 8);
    7696:	f102 010e 	add.w	r1, r2, #14
    769a:	4760      	bx	ip
    769c:	41008000 	.word	0x41008000
    76a0:	2001cc70 	.word	0x2001cc70
    76a4:	0000f1bd 	.word	0x0000f1bd
    76a8:	0000f11d 	.word	0x0000f11d
    76ac:	2000067e 	.word	0x2000067e

000076b0 <grid_module_en16_reva_hardware_transfer_complete_cb>:

void grid_module_en16_reva_hardware_transfer_complete_cb(void){
    76b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    76b4:	4ba8      	ldr	r3, [pc, #672]	; (7958 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2a8>)
	
	// Set the shift registers to continuously load data until new transaction is issued
	gpio_set_pin_level(PIN_UI_SPI_CS0, false);


	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    76b6:	48a9      	ldr	r0, [pc, #676]	; (795c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
	if (bank == 255){
		bank=0;
	}


	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    76b8:	4fa8      	ldr	r7, [pc, #672]	; (795c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    76ba:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    76be:	615a      	str	r2, [r3, #20]
void grid_module_en16_reva_hardware_transfer_complete_cb(void){
    76c0:	b089      	sub	sp, #36	; 0x24
	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    76c2:	4ba7      	ldr	r3, [pc, #668]	; (7960 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2b0>)
    76c4:	4798      	blx	r3
	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    76c6:	7c7b      	ldrb	r3, [r7, #17]
		bank=0;
    76c8:	28ff      	cmp	r0, #255	; 0xff
    76ca:	bf14      	ite	ne
    76cc:	4606      	movne	r6, r0
    76ce:	2600      	moveq	r6, #0
		
	if (bank_changed){
    76d0:	2b00      	cmp	r3, #0
    76d2:	f040 815f 	bne.w	7994 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2e4>
		

		uint8_t i = UI_ENCODER_LOOKUP[j];
		

		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    76d6:	f8df 82b8 	ldr.w	r8, [pc, #696]	; 7990 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2e0>
				uint8_t controlnumber = i;
 
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER] = res_index;
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index]; 

				uint8_t new_abs_no_velocity_value = grid_en16_helper_template_e_abs[bank][i];
    76da:	0133      	lsls	r3, r6, #4
    76dc:	9302      	str	r3, [sp, #8]
    76de:	eb08 1306 	add.w	r3, r8, r6, lsl #4
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    76e2:	f04f 0b00 	mov.w	fp, #0
				uint8_t new_abs_no_velocity_value = grid_en16_helper_template_e_abs[bank][i];
    76e6:	9303      	str	r3, [sp, #12]
		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    76e8:	f3cb 0346 	ubfx	r3, fp, #1, #7
    76ec:	f00b 0201 	and.w	r2, fp, #1
    76f0:	f818 3003 	ldrb.w	r3, [r8, r3]
    76f4:	0092      	lsls	r2, r2, #2
    76f6:	4113      	asrs	r3, r2
		uint8_t old_value = UI_SPI_RX_BUFFER_LAST[j];
    76f8:	eb08 020b 	add.w	r2, r8, fp
		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    76fc:	b2de      	uxtb	r6, r3
		uint8_t old_value = UI_SPI_RX_BUFFER_LAST[j];
    76fe:	f892 015c 	ldrb.w	r0, [r2, #348]	; 0x15c
		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    7702:	f003 030f 	and.w	r3, r3, #15
		if (old_value != new_value){
    7706:	4283      	cmp	r3, r0
    7708:	fa5f f18b 	uxtb.w	r1, fp
    770c:	f000 8115 	beq.w	793a <grid_module_en16_reva_hardware_transfer_complete_cb+0x28a>
		uint8_t i = UI_ENCODER_LOOKUP[j];
    7710:	4894      	ldr	r0, [pc, #592]	; (7964 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2b4>)
            UI_SPI_RX_BUFFER_LAST[j] = new_value;
    7712:	f882 315c 	strb.w	r3, [r2, #348]	; 0x15c
			UI_SPI_DEBUG = j;
    7716:	4a94      	ldr	r2, [pc, #592]	; (7968 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2b8>)
		uint8_t i = UI_ENCODER_LOOKUP[j];
    7718:	f81b 4000 	ldrb.w	r4, [fp, r0]
			UI_SPI_DEBUG = j;
    771c:	7011      	strb	r1, [r2, #0]
			if (button_value != grid_ui_encoder_array[i].button_value){
    771e:	4d93      	ldr	r5, [pc, #588]	; (796c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2bc>)
			uint8_t button_value = (new_value&0b00000100)?1:0;
    7720:	f3c3 0280 	ubfx	r2, r3, #2, #1
    7724:	9201      	str	r2, [sp, #4]
            uint8_t phase_a      = (new_value&0b00000010)?1:0;
    7726:	f3c3 0240 	ubfx	r2, r3, #1, #1
    772a:	9200      	str	r2, [sp, #0]
			if (button_value != grid_ui_encoder_array[i].button_value){
    772c:	eb05 1204 	add.w	r2, r5, r4, lsl #4
    7730:	9801      	ldr	r0, [sp, #4]
    7732:	7851      	ldrb	r1, [r2, #1]
    7734:	4281      	cmp	r1, r0
			uint8_t phase_b      = (new_value&0b00000001)?1:0;
    7736:	f006 0601 	and.w	r6, r6, #1
			if (button_value != grid_ui_encoder_array[i].button_value){
    773a:	ea4f 1704 	mov.w	r7, r4, lsl #4
    773e:	d04d      	beq.n	77dc <grid_module_en16_reva_hardware_transfer_complete_cb+0x12c>
				grid_ui_encoder_array[i].button_changed = 1;
    7740:	2101      	movs	r1, #1
				grid_ui_encoder_array[i].button_value = new_value>>2;
    7742:	089b      	lsrs	r3, r3, #2
				grid_ui_encoder_array[i].button_changed = 1;
    7744:	7091      	strb	r1, [r2, #2]
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    7746:	f8df a214 	ldr.w	sl, [pc, #532]	; 795c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>
				grid_ui_encoder_array[i].button_value = new_value>>2;
    774a:	7053      	strb	r3, [r2, #1]
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    774c:	4a88      	ldr	r2, [pc, #544]	; (7970 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
				uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    774e:	f8df c230 	ldr.w	ip, [pc, #560]	; 7980 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d0>
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    7752:	6852      	ldr	r2, [r2, #4]
    7754:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7758:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    775c:	2164      	movs	r1, #100	; 0x64
    775e:	68d2      	ldr	r2, [r2, #12]
				uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7760:	f10d 0910 	add.w	r9, sp, #16
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    7764:	fb04 2201 	mla	r2, r4, r1, r2
				uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7768:	f8dc 1004 	ldr.w	r1, [ip, #4]
    776c:	f8dc 0000 	ldr.w	r0, [ip]
    7770:	46ce      	mov	lr, r9
    7772:	e8ae 0003 	stmia.w	lr!, {r0, r1}
    7776:	497f      	ldr	r1, [pc, #508]	; (7974 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c4>)
    7778:	f10c 0c08 	add.w	ip, ip, #8
    777c:	458c      	cmp	ip, r1
    777e:	46f1      	mov	r9, lr
    7780:	d1f2      	bne.n	7768 <grid_module_en16_reva_hardware_transfer_complete_cb+0xb8>
				if (grid_ui_encoder_array[i].button_value == 0){ // Button Press Event
    7782:	a908      	add	r1, sp, #32
    7784:	4421      	add	r1, r4
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7786:	60d4      	str	r4, [r2, #12]
				if (grid_ui_encoder_array[i].button_value == 0){ // Button Press Event
    7788:	2b00      	cmp	r3, #0
    778a:	f040 8152 	bne.w	7a32 <grid_module_en16_reva_hardware_transfer_complete_cb+0x382>
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    778e:	f811 1c10 	ldrb.w	r1, [r1, #-16]
    7792:	6111      	str	r1, [r2, #16]
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] == 0){
    7794:	6991      	ldr	r1, [r2, #24]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;
    7796:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    779a:	2900      	cmp	r1, #0
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    779c:	69d1      	ldr	r1, [r2, #28]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;
    779e:	f8c2 c014 	str.w	ip, [r2, #20]
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    77a2:	bf0c      	ite	eq
    77a4:	4660      	moveq	r0, ip
    77a6:	2000      	movne	r0, #0
    77a8:	6190      	str	r0, [r2, #24]
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    77aa:	2900      	cmp	r1, #0
    77ac:	f040 813d 	bne.w	7a2a <grid_module_en16_reva_hardware_transfer_complete_cb+0x37a>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 63;
    77b0:	233f      	movs	r3, #63	; 0x3f
					grid_en16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    77b2:	496a      	ldr	r1, [pc, #424]	; (795c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    77b4:	61d3      	str	r3, [r2, #28]
					grid_en16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    77b6:	7bcb      	ldrb	r3, [r1, #15]
    77b8:	eb08 1303 	add.w	r3, r8, r3, lsl #4
    77bc:	4423      	add	r3, r4
    77be:	7718      	strb	r0, [r3, #28]
					grid_en16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    77c0:	7bcb      	ldrb	r3, [r1, #15]
    77c2:	69d2      	ldr	r2, [r2, #28]
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    77c4:	7bc9      	ldrb	r1, [r1, #15]
					grid_en16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    77c6:	eb08 1303 	add.w	r3, r8, r3, lsl #4
    77ca:	4423      	add	r3, r4
    77cc:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    77d0:	2304      	movs	r3, #4
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    77d2:	4867      	ldr	r0, [pc, #412]	; (7970 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
    77d4:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 7984 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d4>
    77d8:	4622      	mov	r2, r4
    77da:	47c8      	blx	r9
            if (a_now == 1 && b_now == 1){ //detent found
    77dc:	9b00      	ldr	r3, [sp, #0]
    77de:	2b00      	cmp	r3, #0
    77e0:	f000 8155 	beq.w	7a8e <grid_module_en16_reva_hardware_transfer_complete_cb+0x3de>
    77e4:	2e00      	cmp	r6, #0
    77e6:	f000 8155 	beq.w	7a94 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
			uint8_t b_prev = grid_ui_encoder_array[i].phase_b_previous;
    77ea:	19eb      	adds	r3, r5, r7
                if (b_prev == 0 && grid_ui_encoder_array[i].phase_change_lock == 0){
    77ec:	7b9a      	ldrb	r2, [r3, #14]
    77ee:	2a00      	cmp	r2, #0
    77f0:	f040 8128 	bne.w	7a44 <grid_module_en16_reva_hardware_transfer_complete_cb+0x394>
    77f4:	7bd9      	ldrb	r1, [r3, #15]
    77f6:	2900      	cmp	r1, #0
    77f8:	f040 814c 	bne.w	7a94 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
                    grid_ui_encoder_array[i].phase_change_lock = 1;
    77fc:	2201      	movs	r2, #1
    77fe:	73da      	strb	r2, [r3, #15]
                    delta = -1;
    7800:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
			grid_ui_encoder_array[i].phase_a_previous = a_now;
    7804:	442f      	add	r7, r5
    7806:	9b00      	ldr	r3, [sp, #0]
    7808:	737b      	strb	r3, [r7, #13]
			grid_ui_encoder_array[i].phase_b_previous = b_now;
    780a:	73be      	strb	r6, [r7, #14]
			if (delta != 0){
    780c:	f1b9 0f00 	cmp.w	r9, #0
    7810:	f000 8093 	beq.w	793a <grid_module_en16_reva_hardware_transfer_complete_cb+0x28a>
				uint32_t elapsed_time = grid_sys_rtc_get_elapsed_time(&grid_sys_state, grid_ui_encoder_array[i].last_real_time);
    7814:	68b9      	ldr	r1, [r7, #8]
    7816:	4851      	ldr	r0, [pc, #324]	; (795c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    7818:	4b57      	ldr	r3, [pc, #348]	; (7978 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c8>)
    781a:	4798      	blx	r3
				if (elapsed_ms>25){
    781c:	f5b0 7fd0 	cmp.w	r0, #416	; 0x1a0
    7820:	f080 811b 	bcs.w	7a5a <grid_module_en16_reva_hardware_transfer_complete_cb+0x3aa>
                uint32_t elapsed_ms = elapsed_time/RTC1MS;
    7824:	0900      	lsrs	r0, r0, #4
    7826:	2801      	cmp	r0, #1
    7828:	bf38      	it	cc
    782a:	2001      	movcc	r0, #1
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    782c:	4e4b      	ldr	r6, [pc, #300]	; (795c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    782e:	4b53      	ldr	r3, [pc, #332]	; (797c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2cc>)
				uint8_t velocityfactor = (25*25-elapsed_ms*elapsed_ms)/150 + 1;
    7830:	f240 2771 	movw	r7, #625	; 0x271
    7834:	fb00 7010 	mls	r0, r0, r0, r7
    7838:	2796      	movs	r7, #150	; 0x96
    783a:	fbb0 f7f7 	udiv	r7, r0, r7
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    783e:	4630      	mov	r0, r6
    7840:	4798      	blx	r3
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7842:	4a4b      	ldr	r2, [pc, #300]	; (7970 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
    7844:	6852      	ldr	r2, [r2, #4]
    7846:	7bf1      	ldrb	r1, [r6, #15]
                uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7848:	4e4d      	ldr	r6, [pc, #308]	; (7980 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d0>)
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    784a:	eb02 1201 	add.w	r2, r2, r1, lsl #4
				uint8_t velocityfactor = (25*25-elapsed_ms*elapsed_ms)/150 + 1;
    784e:	3701      	adds	r7, #1
    7850:	b2ff      	uxtb	r7, r7
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    7852:	eb05 1504 	add.w	r5, r5, r4, lsl #4
				delta_high = delta * (velocityfactor * 2 - 1);
    7856:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
    785a:	eb0a 0a47 	add.w	sl, sl, r7, lsl #1
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    785e:	68d2      	ldr	r2, [r2, #12]
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    7860:	60a8      	str	r0, [r5, #8]
				delta_high = delta * (velocityfactor * 2 - 1);
    7862:	fb0a fa09 	mul.w	sl, sl, r9
				delta_low =  delta * velocityfactor;			
    7866:	fb07 f509 	mul.w	r5, r7, r9
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    786a:	2164      	movs	r1, #100	; 0x64
				delta_low =  delta * velocityfactor;			
    786c:	b2ab      	uxth	r3, r5
				delta_high = delta * (velocityfactor * 2 - 1);
    786e:	fa1f f78a 	uxth.w	r7, sl
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7872:	fb04 2201 	mla	r2, r4, r1, r2
                uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7876:	f10d 0e10 	add.w	lr, sp, #16
    787a:	6871      	ldr	r1, [r6, #4]
    787c:	6830      	ldr	r0, [r6, #0]
    787e:	46f4      	mov	ip, lr
    7880:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    7884:	493b      	ldr	r1, [pc, #236]	; (7974 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c4>)
    7886:	3608      	adds	r6, #8
    7888:	428e      	cmp	r6, r1
    788a:	46e6      	mov	lr, ip
    788c:	d1f5      	bne.n	787a <grid_module_en16_reva_hardware_transfer_complete_cb+0x1ca>
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index]; 
    788e:	a908      	add	r1, sp, #32
    7890:	4421      	add	r1, r4
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7892:	6214      	str	r4, [r2, #32]
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index]; 
    7894:	f811 1c10 	ldrb.w	r1, [r1, #-16]
    7898:	6251      	str	r1, [r2, #36]	; 0x24
				uint8_t new_abs_no_velocity_value = grid_en16_helper_template_e_abs[bank][i];
    789a:	9903      	ldr	r1, [sp, #12]
    789c:	4421      	add	r1, r4
    789e:	f891 c09c 	ldrb.w	ip, [r1, #156]	; 0x9c
				uint8_t new_abs_low_velocity_value = grid_en16_helper_template_e_abs_low_velocity[bank][i];
    78a2:	f891 60dc 	ldrb.w	r6, [r1, #220]	; 0xdc
				uint8_t new_abs_high_velocity_value = grid_en16_helper_template_e_abs_high_velocity[bank][i];
    78a6:	f891 011c 	ldrb.w	r0, [r1, #284]	; 0x11c
                
				uint8_t new_rel_no_velocity_value =  template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL];
    78aa:	f892 1034 	ldrb.w	r1, [r2, #52]	; 0x34
				
				if (delta != 0){
                    
                    
                    // ABSOLUTE NO VELOCITY						
					if (new_abs_no_velocity_value + delta < 0){
    78ae:	44cc      	add	ip, r9
    78b0:	f1bc 3fff 	cmp.w	ip, #4294967295	; 0xffffffff
    78b4:	f000 80d3 	beq.w	7a5e <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ae>
						new_abs_no_velocity_value = 0;
					}
					else if (new_abs_no_velocity_value + delta > 127){
    78b8:	f1bc 0f7f 	cmp.w	ip, #127	; 0x7f
    78bc:	f300 80d2 	bgt.w	7a64 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3b4>
						new_abs_no_velocity_value = 127;
					}
					else{
						new_abs_no_velocity_value += delta;
    78c0:	fa5f fc8c 	uxtb.w	ip, ip
					}	
                    
                    // ABSOLUTE LOW VELOCITY						
					if (new_abs_low_velocity_value + delta_low < 0){
    78c4:	1975      	adds	r5, r6, r5
    78c6:	b2db      	uxtb	r3, r3
    78c8:	f100 80cf 	bmi.w	7a6a <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ba>
						new_abs_low_velocity_value = 0;
					}
					else if (new_abs_low_velocity_value + delta_low > 127){
    78cc:	2d7f      	cmp	r5, #127	; 0x7f
    78ce:	f300 80ce 	bgt.w	7a6e <grid_module_en16_reva_hardware_transfer_complete_cb+0x3be>
						new_abs_low_velocity_value = 127;
					}
					else{
						new_abs_low_velocity_value += delta_low;
    78d2:	441e      	add	r6, r3
    78d4:	b2f6      	uxtb	r6, r6
					}	
  					
                    // ABSOLUTE HIGH VELOCITY						
					if (new_abs_high_velocity_value + delta_high < 0){
    78d6:	eb10 0a0a 	adds.w	sl, r0, sl
    78da:	b2ff      	uxtb	r7, r7
    78dc:	f100 80c9 	bmi.w	7a72 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3c2>
						new_abs_high_velocity_value = 0;
					}
					else if (new_abs_high_velocity_value + delta_high > 127){
    78e0:	f1ba 0f7f 	cmp.w	sl, #127	; 0x7f
    78e4:	f300 80c7 	bgt.w	7a76 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3c6>
						new_abs_high_velocity_value = 127;
					}
					else{
						new_abs_high_velocity_value += delta_high;
    78e8:	4438      	add	r0, r7
    78ea:	b2c0      	uxtb	r0, r0
					}	



                    // RELATIVE NO VELOCITY
					if (new_rel_no_velocity_value == 255){
    78ec:	29ff      	cmp	r1, #255	; 0xff
    78ee:	f040 80c4 	bne.w	7a7a <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ca>
						if (delta>0){
							new_rel_no_velocity_value = 65;
						}
						else{
							new_rel_no_velocity_value = 63;
    78f2:	f1b9 0f01 	cmp.w	r9, #1
					}
                    
                    // RELATIVE LOW VELOCITY
					if (new_rel_low_velocity_value == 255){
                        
                        new_rel_low_velocity_value = 64 + delta_low;
    78f6:	f103 0340 	add.w	r3, r3, #64	; 0x40
							new_rel_no_velocity_value = 63;
    78fa:	bf0c      	ite	eq
    78fc:	2541      	moveq	r5, #65	; 0x41
    78fe:	253f      	movne	r5, #63	; 0x3f
                        new_rel_low_velocity_value = 64 + delta_low;
    7900:	b2db      	uxtb	r3, r3
					}
                    
                    // RELATIVE HIGH VELOCITY
					if (new_rel_high_velocity_value == 255){
				
                        new_rel_high_velocity_value = 64 + delta_high;
    7902:	3740      	adds	r7, #64	; 0x40
	
                    
                    
					
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL] = new_rel_no_velocity_value;
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_LOW] = new_rel_low_velocity_value;
    7904:	e9c2 530d 	strd	r5, r3, [r2, #52]	; 0x34
                    
                    
                    
                    
                    
                    if (button_value == 1){
    7908:	9b01      	ldr	r3, [sp, #4]
    790a:	4914      	ldr	r1, [pc, #80]	; (795c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    790c:	4d1d      	ldr	r5, [pc, #116]	; (7984 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d4>)
						new_rel_high_velocity_value += delta_high;
    790e:	b2ff      	uxtb	r7, r7
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_HIGH] = new_rel_high_velocity_value;
    7910:	63d7      	str	r7, [r2, #60]	; 0x3c
                    if (button_value == 1){
    7912:	2b00      	cmp	r3, #0
    7914:	f000 80b8 	beq.w	7a88 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3d8>
                        
                        // ABS is only updated if nonpush rotation event happened
                        grid_en16_helper_template_e_abs[bank][i] = new_abs_no_velocity_value;
    7918:	9b02      	ldr	r3, [sp, #8]
                        
                        // ABS high velocity
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = new_abs_high_velocity_value;
                        
                        
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);				
    791a:	7bc9      	ldrb	r1, [r1, #15]
                        grid_en16_helper_template_e_abs[bank][i] = new_abs_no_velocity_value;
    791c:	4443      	add	r3, r8
    791e:	4423      	add	r3, r4
    7920:	f883 c09c 	strb.w	ip, [r3, #156]	; 0x9c
                        grid_en16_helper_template_e_abs_low_velocity[bank][i] = new_abs_low_velocity_value;
    7924:	f883 60dc 	strb.w	r6, [r3, #220]	; 0xdc
                        grid_en16_helper_template_e_abs_high_velocity[bank][i] = new_abs_high_velocity_value;
    7928:	f883 011c 	strb.w	r0, [r3, #284]	; 0x11c
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_LOW] = new_abs_low_velocity_value;
    792c:	e9c2 c60a 	strd	ip, r6, [r2, #40]	; 0x28
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = new_abs_high_velocity_value;
    7930:	6310      	str	r0, [r2, #48]	; 0x30
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);				
    7932:	2301      	movs	r3, #1
                    }
                    else{
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_ENCPUSHROT);
    7934:	480e      	ldr	r0, [pc, #56]	; (7970 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
    7936:	4622      	mov	r2, r4
    7938:	47a8      	blx	r5
	for (uint8_t j=0; j<16; j++){
    793a:	f10b 0b01 	add.w	fp, fp, #1
    793e:	f1bb 0f10 	cmp.w	fp, #16
    7942:	f47f aed1 	bne.w	76e8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x38>

			
	}
		

	grid_module_en16_reva_hardware_transfer_complete = 0;
    7946:	4b10      	ldr	r3, [pc, #64]	; (7988 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d8>)
    7948:	2200      	movs	r2, #0
    794a:	701a      	strb	r2, [r3, #0]
	grid_module_en16_reva_hardware_start_transfer();
    794c:	4b0f      	ldr	r3, [pc, #60]	; (798c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2dc>)
}
    794e:	b009      	add	sp, #36	; 0x24
    7950:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_module_en16_reva_hardware_start_transfer();
    7954:	4718      	bx	r3
    7956:	bf00      	nop
    7958:	41008000 	.word	0x41008000
    795c:	2000f008 	.word	0x2000f008
    7960:	000096bf 	.word	0x000096bf
    7964:	20000318 	.word	0x20000318
    7968:	2000c09d 	.word	0x2000c09d
    796c:	20019770 	.word	0x20019770
    7970:	2000effc 	.word	0x2000effc
    7974:	00015cc8 	.word	0x00015cc8
    7978:	00009765 	.word	0x00009765
    797c:	00009761 	.word	0x00009761
    7980:	00015cb8 	.word	0x00015cb8
    7984:	0000a149 	.word	0x0000a149
    7988:	2001c854 	.word	0x2001c854
    798c:	00007679 	.word	0x00007679
    7990:	2000067e 	.word	0x2000067e
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7994:	b233      	sxth	r3, r6
		grid_sys_state.bank_active_changed = 0;
    7996:	2400      	movs	r4, #0
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7998:	ea4f 1b03 	mov.w	fp, r3, lsl #4
    799c:	f8df 8108 	ldr.w	r8, [pc, #264]	; 7aa8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3f8>
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_en16_helper_template_b_tgl2[bank][i];
    79a0:	f8df a108 	ldr.w	sl, [pc, #264]	; 7aac <grid_module_en16_reva_hardware_transfer_complete_cb+0x3fc>
		grid_sys_state.bank_active_changed = 0;
    79a4:	747c      	strb	r4, [r7, #17]
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    79a6:	465d      	mov	r5, fp
    79a8:	f8d8 3004 	ldr.w	r3, [r8, #4]
			uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    79ac:	f8df c100 	ldr.w	ip, [pc, #256]	; 7ab0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x400>
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    79b0:	445b      	add	r3, fp
    79b2:	2164      	movs	r1, #100	; 0x64
    79b4:	68db      	ldr	r3, [r3, #12]
    79b6:	b2e2      	uxtb	r2, r4
    79b8:	fb01 3304 	mla	r3, r1, r4, r3
			uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    79bc:	f10d 0e10 	add.w	lr, sp, #16
    79c0:	f8dc 1004 	ldr.w	r1, [ip, #4]
    79c4:	f8dc 0000 	ldr.w	r0, [ip]
    79c8:	46f1      	mov	r9, lr
    79ca:	e8a9 0003 	stmia.w	r9!, {r0, r1}
    79ce:	4933      	ldr	r1, [pc, #204]	; (7a9c <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ec>)
    79d0:	f10c 0c08 	add.w	ip, ip, #8
    79d4:	458c      	cmp	ip, r1
    79d6:	46ce      	mov	lr, r9
    79d8:	d1f2      	bne.n	79c0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x310>
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    79da:	a904      	add	r1, sp, #16
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    79dc:	60dc      	str	r4, [r3, #12]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    79de:	5d09      	ldrb	r1, [r1, r4]
    79e0:	6119      	str	r1, [r3, #16]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_en16_helper_template_b_tgl2[bank][i];
    79e2:	f815 000a 	ldrb.w	r0, [r5, sl]
    79e6:	6198      	str	r0, [r3, #24]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_en16_helper_template_b_tgl3[bank][i];
    79e8:	482d      	ldr	r0, [pc, #180]	; (7aa0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3f0>)
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    79ea:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 7ab4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x404>
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_en16_helper_template_b_tgl3[bank][i];
    79ee:	5c28      	ldrb	r0, [r5, r0]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    79f0:	6259      	str	r1, [r3, #36]	; 0x24
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER] = res_index;
    79f2:	e9c3 0407 	strd	r0, r4, [r3, #28]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS] = grid_en16_helper_template_e_abs[bank][i];
    79f6:	492b      	ldr	r1, [pc, #172]	; (7aa4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3f4>)
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    79f8:	9200      	str	r2, [sp, #0]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS] = grid_en16_helper_template_e_abs[bank][i];
    79fa:	5c68      	ldrb	r0, [r5, r1]
    79fc:	6298      	str	r0, [r3, #40]	; 0x28
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_LOW] = grid_en16_helper_template_e_abs_low_velocity[bank][i];
    79fe:	f101 0040 	add.w	r0, r1, #64	; 0x40
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = grid_en16_helper_template_e_abs_high_velocity[bank][i];			
    7a02:	3180      	adds	r1, #128	; 0x80
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_LOW] = grid_en16_helper_template_e_abs_low_velocity[bank][i];
    7a04:	5c28      	ldrb	r0, [r5, r0]
    7a06:	62d8      	str	r0, [r3, #44]	; 0x2c
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = grid_en16_helper_template_e_abs_high_velocity[bank][i];			
    7a08:	5c69      	ldrb	r1, [r5, r1]
    7a0a:	6319      	str	r1, [r3, #48]	; 0x30
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7a0c:	4640      	mov	r0, r8
    7a0e:	7bf9      	ldrb	r1, [r7, #15]
    7a10:	2300      	movs	r3, #0
    7a12:	47c8      	blx	r9
            grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);
    7a14:	3401      	adds	r4, #1
    7a16:	7bf9      	ldrb	r1, [r7, #15]
    7a18:	9a00      	ldr	r2, [sp, #0]
    7a1a:	2301      	movs	r3, #1
    7a1c:	4640      	mov	r0, r8
    7a1e:	47c8      	blx	r9
		for (uint8_t i = 0; i<16; i++)
    7a20:	2c10      	cmp	r4, #16
    7a22:	f105 0501 	add.w	r5, r5, #1
    7a26:	d1bf      	bne.n	79a8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2f8>
    7a28:	e655      	b.n	76d6 <grid_module_en16_reva_hardware_transfer_complete_cb+0x26>
					else if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 63){
    7a2a:	293f      	cmp	r1, #63	; 0x3f
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    7a2c:	bf08      	it	eq
    7a2e:	4663      	moveq	r3, ip
    7a30:	e6bf      	b.n	77b2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x102>
 					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    7a32:	f811 3c10 	ldrb.w	r3, [r1, #-16]
    7a36:	6113      	str	r3, [r2, #16]
 					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;
    7a38:	2300      	movs	r3, #0
    7a3a:	6153      	str	r3, [r2, #20]
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    7a3c:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7a40:	2305      	movs	r3, #5
    7a42:	e6c6      	b.n	77d2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x122>
                if (a_prev == 0 && grid_ui_encoder_array[i].phase_change_lock == 0){
    7a44:	7b5a      	ldrb	r2, [r3, #13]
    7a46:	bb2a      	cbnz	r2, 7a94 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
    7a48:	7bd9      	ldrb	r1, [r3, #15]
    7a4a:	b921      	cbnz	r1, 7a56 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3a6>
                    grid_ui_encoder_array[i].phase_change_lock = 1;
    7a4c:	f04f 0901 	mov.w	r9, #1
    7a50:	f883 900f 	strb.w	r9, [r3, #15]
    7a54:	e6d6      	b.n	7804 <grid_module_en16_reva_hardware_transfer_complete_cb+0x154>
			int16_t delta = 0;
    7a56:	4691      	mov	r9, r2
    7a58:	e6d4      	b.n	7804 <grid_module_en16_reva_hardware_transfer_complete_cb+0x154>
					elapsed_ms = 25;
    7a5a:	2019      	movs	r0, #25
    7a5c:	e6e6      	b.n	782c <grid_module_en16_reva_hardware_transfer_complete_cb+0x17c>
						new_abs_no_velocity_value = 0;
    7a5e:	f04f 0c00 	mov.w	ip, #0
    7a62:	e72f      	b.n	78c4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x214>
						new_abs_no_velocity_value = 127;
    7a64:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
    7a68:	e72c      	b.n	78c4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x214>
						new_abs_low_velocity_value = 0;
    7a6a:	2600      	movs	r6, #0
    7a6c:	e733      	b.n	78d6 <grid_module_en16_reva_hardware_transfer_complete_cb+0x226>
						new_abs_low_velocity_value = 127;
    7a6e:	267f      	movs	r6, #127	; 0x7f
    7a70:	e731      	b.n	78d6 <grid_module_en16_reva_hardware_transfer_complete_cb+0x226>
						new_abs_high_velocity_value = 0;
    7a72:	2000      	movs	r0, #0
    7a74:	e73a      	b.n	78ec <grid_module_en16_reva_hardware_transfer_complete_cb+0x23c>
						new_abs_high_velocity_value = 127;
    7a76:	207f      	movs	r0, #127	; 0x7f
    7a78:	e738      	b.n	78ec <grid_module_en16_reva_hardware_transfer_complete_cb+0x23c>
						new_rel_no_velocity_value += delta;
    7a7a:	4489      	add	r9, r1
						new_rel_low_velocity_value += delta_low;
    7a7c:	440b      	add	r3, r1
						new_rel_no_velocity_value += delta;
    7a7e:	fa5f f589 	uxtb.w	r5, r9
						new_rel_low_velocity_value += delta_low;
    7a82:	b2db      	uxtb	r3, r3
						new_rel_high_velocity_value += delta_high;
    7a84:	440f      	add	r7, r1
    7a86:	e73d      	b.n	7904 <grid_module_en16_reva_hardware_transfer_complete_cb+0x254>
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_ENCPUSHROT);
    7a88:	7bc9      	ldrb	r1, [r1, #15]
    7a8a:	230d      	movs	r3, #13
    7a8c:	e752      	b.n	7934 <grid_module_en16_reva_hardware_transfer_complete_cb+0x284>
            if (a_now == 0 && b_now == 0){
    7a8e:	b90e      	cbnz	r6, 7a94 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
                grid_ui_encoder_array[i].phase_change_lock = 0;
    7a90:	19eb      	adds	r3, r5, r7
    7a92:	73de      	strb	r6, [r3, #15]
			int16_t delta = 0;
    7a94:	f04f 0900 	mov.w	r9, #0
    7a98:	e6b4      	b.n	7804 <grid_module_en16_reva_hardware_transfer_complete_cb+0x154>
    7a9a:	bf00      	nop
    7a9c:	00015cc8 	.word	0x00015cc8
    7aa0:	200006da 	.word	0x200006da
    7aa4:	2000071a 	.word	0x2000071a
    7aa8:	2000effc 	.word	0x2000effc
    7aac:	2000069a 	.word	0x2000069a
    7ab0:	00015cb8 	.word	0x00015cb8
    7ab4:	0000a49d 	.word	0x0000a49d

00007ab8 <grid_module_en16_reva_hardware_init>:
    7ab8:	4b0f      	ldr	r3, [pc, #60]	; (7af8 <grid_module_en16_reva_hardware_init+0x40>)
    7aba:	f44f 1200 	mov.w	r2, #2097152	; 0x200000

void grid_module_en16_reva_hardware_init(void){
    7abe:	b510      	push	{r4, lr}
    7ac0:	615a      	str	r2, [r3, #20]
	
	
	
	
	
	spi_m_async_set_mode(&UI_SPI, SPI_MODE_3);
    7ac2:	4c0e      	ldr	r4, [pc, #56]	; (7afc <grid_module_en16_reva_hardware_init+0x44>)
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    7ac4:	609a      	str	r2, [r3, #8]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    7ac6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    7aca:	629a      	str	r2, [r3, #40]	; 0x28
    7acc:	4a0c      	ldr	r2, [pc, #48]	; (7b00 <grid_module_en16_reva_hardware_init+0x48>)
    7ace:	629a      	str	r2, [r3, #40]	; 0x28
    7ad0:	2103      	movs	r1, #3
    7ad2:	4b0c      	ldr	r3, [pc, #48]	; (7b04 <grid_module_en16_reva_hardware_init+0x4c>)
    7ad4:	4620      	mov	r0, r4
    7ad6:	4798      	blx	r3
	spi_m_async_set_baudrate(&UI_SPI, 1000000); // was 400000 check clock div setting
    7ad8:	490b      	ldr	r1, [pc, #44]	; (7b08 <grid_module_en16_reva_hardware_init+0x50>)
    7ada:	4b0c      	ldr	r3, [pc, #48]	; (7b0c <grid_module_en16_reva_hardware_init+0x54>)
    7adc:	4620      	mov	r0, r4
    7ade:	4798      	blx	r3
	
	spi_m_async_get_io_descriptor(&UI_SPI, &grid_module_en16_reva_hardware_io);
    7ae0:	490b      	ldr	r1, [pc, #44]	; (7b10 <grid_module_en16_reva_hardware_init+0x58>)
    7ae2:	4b0c      	ldr	r3, [pc, #48]	; (7b14 <grid_module_en16_reva_hardware_init+0x5c>)
    7ae4:	4620      	mov	r0, r4
    7ae6:	4798      	blx	r3


	spi_m_async_register_callback(&UI_SPI, SPI_M_ASYNC_CB_XFER, grid_module_en16_reva_hardware_transfer_complete_cb);
    7ae8:	4620      	mov	r0, r4
    7aea:	4a0b      	ldr	r2, [pc, #44]	; (7b18 <grid_module_en16_reva_hardware_init+0x60>)
    7aec:	4b0b      	ldr	r3, [pc, #44]	; (7b1c <grid_module_en16_reva_hardware_init+0x64>)


}
    7aee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	spi_m_async_register_callback(&UI_SPI, SPI_M_ASYNC_CB_XFER, grid_module_en16_reva_hardware_transfer_complete_cb);
    7af2:	2100      	movs	r1, #0
    7af4:	4718      	bx	r3
    7af6:	bf00      	nop
    7af8:	41008000 	.word	0x41008000
    7afc:	2001cc70 	.word	0x2001cc70
    7b00:	c0000020 	.word	0xc0000020
    7b04:	0000f181 	.word	0x0000f181
    7b08:	000f4240 	.word	0x000f4240
    7b0c:	0000f145 	.word	0x0000f145
    7b10:	2000c0a0 	.word	0x2000c0a0
    7b14:	0000f265 	.word	0x0000f265
    7b18:	000076b1 	.word	0x000076b1
    7b1c:	0000f221 	.word	0x0000f221

00007b20 <grid_module_en16_reva_init>:

void grid_module_en16_reva_init(){
    7b20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	
	grid_led_lowlevel_init(&grid_led_state, 16);
    7b24:	4b1d      	ldr	r3, [pc, #116]	; (7b9c <grid_module_en16_reva_init+0x7c>)
    7b26:	481e      	ldr	r0, [pc, #120]	; (7ba0 <grid_module_en16_reva_init+0x80>)

	
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++)
	{
		
		grid_ui_bank_init(&grid_ui_state, i, 16);	
    7b28:	4e1e      	ldr	r6, [pc, #120]	; (7ba4 <grid_module_en16_reva_init+0x84>)
    7b2a:	4f1f      	ldr	r7, [pc, #124]	; (7ba8 <grid_module_en16_reva_init+0x88>)
		
		for(uint8_t j=0; j<16; j++){
		
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_ENCODER);	
    7b2c:	f8df 808c 	ldr.w	r8, [pc, #140]	; 7bbc <grid_module_en16_reva_init+0x9c>
	grid_led_lowlevel_init(&grid_led_state, 16);
    7b30:	2110      	movs	r1, #16
    7b32:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);	
    7b34:	481b      	ldr	r0, [pc, #108]	; (7ba4 <grid_module_en16_reva_init+0x84>)
    7b36:	4b1d      	ldr	r3, [pc, #116]	; (7bac <grid_module_en16_reva_init+0x8c>)
    7b38:	2104      	movs	r1, #4
    7b3a:	4798      	blx	r3
    7b3c:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 16);	
    7b3e:	2210      	movs	r2, #16
    7b40:	b2e1      	uxtb	r1, r4
    7b42:	4630      	mov	r0, r6
    7b44:	47b8      	blx	r7
		for(uint8_t j=0; j<16; j++){
    7b46:	ea4f 1904 	mov.w	r9, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 16);	
    7b4a:	2500      	movs	r5, #0
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_ENCODER);	
    7b4c:	6870      	ldr	r0, [r6, #4]
    7b4e:	b2e9      	uxtb	r1, r5
    7b50:	2203      	movs	r2, #3
    7b52:	4448      	add	r0, r9
    7b54:	3501      	adds	r5, #1
    7b56:	47c0      	blx	r8
		for(uint8_t j=0; j<16; j++){
    7b58:	2d10      	cmp	r5, #16
    7b5a:	d1f7      	bne.n	7b4c <grid_module_en16_reva_init+0x2c>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++)
    7b5c:	3401      	adds	r4, #1
    7b5e:	2c04      	cmp	r4, #4
    7b60:	d1ed      	bne.n	7b3e <grid_module_en16_reva_init+0x1e>
    7b62:	2200      	movs	r2, #0
    7b64:	4b12      	ldr	r3, [pc, #72]	; (7bb0 <grid_module_en16_reva_init+0x90>)
	// initialize local encoder helper struct
	for (uint8_t j = 0; j<16; j++)
	{
		grid_ui_encoder_array[j].controller_number = j;
		
		grid_ui_encoder_array[j].button_value = 1;
    7b66:	2001      	movs	r0, #1
		grid_ui_encoder_array[j].button_changed = 0; 
    7b68:	4611      	mov	r1, r2
		grid_ui_encoder_array[j].rotation_value = 0;
		grid_ui_encoder_array[j].rotation_changed = 1;
		grid_ui_encoder_array[j].rotation_direction = 0;
		grid_ui_encoder_array[j].last_real_time = -1;
    7b6a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		grid_ui_encoder_array[j].controller_number = j;
    7b6e:	701a      	strb	r2, [r3, #0]
		grid_ui_encoder_array[j].button_value = 1;
    7b70:	3201      	adds	r2, #1
	for (uint8_t j = 0; j<16; j++)
    7b72:	2a10      	cmp	r2, #16
		grid_ui_encoder_array[j].button_value = 1;
    7b74:	7058      	strb	r0, [r3, #1]
		grid_ui_encoder_array[j].button_changed = 0; 
    7b76:	7099      	strb	r1, [r3, #2]
		grid_ui_encoder_array[j].rotation_value = 0;
    7b78:	70d9      	strb	r1, [r3, #3]
		grid_ui_encoder_array[j].rotation_changed = 1;
    7b7a:	7118      	strb	r0, [r3, #4]
		grid_ui_encoder_array[j].rotation_direction = 0;
    7b7c:	7159      	strb	r1, [r3, #5]
		grid_ui_encoder_array[j].last_real_time = -1;
    7b7e:	609c      	str	r4, [r3, #8]
		grid_ui_encoder_array[j].velocity = 0;
    7b80:	7319      	strb	r1, [r3, #12]
		grid_ui_encoder_array[j].phase_a_previous = 1;
    7b82:	7358      	strb	r0, [r3, #13]
		grid_ui_encoder_array[j].phase_b_previous = 1;	
    7b84:	7398      	strb	r0, [r3, #14]
        
        grid_ui_encoder_array[j].phase_change_lock = 0;
    7b86:	73d9      	strb	r1, [r3, #15]
	for (uint8_t j = 0; j<16; j++)
    7b88:	f103 0310 	add.w	r3, r3, #16
    7b8c:	d1ef      	bne.n	7b6e <grid_module_en16_reva_init+0x4e>
		
	}
	
	
	grid_module_en16_reva_hardware_init();
    7b8e:	4b09      	ldr	r3, [pc, #36]	; (7bb4 <grid_module_en16_reva_init+0x94>)
    7b90:	4798      	blx	r3
	
	
	grid_module_en16_reva_hardware_start_transfer();
	
}
    7b92:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_en16_reva_hardware_start_transfer();
    7b96:	4b08      	ldr	r3, [pc, #32]	; (7bb8 <grid_module_en16_reva_init+0x98>)
    7b98:	4718      	bx	r3
    7b9a:	bf00      	nop
    7b9c:	00006ed1 	.word	0x00006ed1
    7ba0:	2001c838 	.word	0x2001c838
    7ba4:	2000effc 	.word	0x2000effc
    7ba8:	00009a5d 	.word	0x00009a5d
    7bac:	00009a29 	.word	0x00009a29
    7bb0:	20019770 	.word	0x20019770
    7bb4:	00007ab9 	.word	0x00007ab9
    7bb8:	00007679 	.word	0x00007679
    7bbc:	0000a389 	.word	0x0000a389

00007bc0 <grid_module_pbf4_reva_hardware_start_transfer>:
static uint8_t grid_pbf4_helper_template_b_abs[16] = {0};
	
static uint8_t grid_pbf4_helper_template_b_tgl2[GRID_SYS_BANK_MAXNUMBER][16] = {0};
static uint8_t grid_pbf4_helper_template_b_tgl3[GRID_SYS_BANK_MAXNUMBER][16] = {0};

void grid_module_pbf4_reva_hardware_start_transfer(void){
    7bc0:	b510      	push	{r4, lr}
	
	adc_async_start_conversion(&ADC_0);
    7bc2:	4c04      	ldr	r4, [pc, #16]	; (7bd4 <grid_module_pbf4_reva_hardware_start_transfer+0x14>)
    7bc4:	4804      	ldr	r0, [pc, #16]	; (7bd8 <grid_module_pbf4_reva_hardware_start_transfer+0x18>)
    7bc6:	47a0      	blx	r4
	adc_async_start_conversion(&ADC_1);
    7bc8:	4623      	mov	r3, r4
    7bca:	4804      	ldr	r0, [pc, #16]	; (7bdc <grid_module_pbf4_reva_hardware_start_transfer+0x1c>)
	
}
    7bcc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_async_start_conversion(&ADC_1);
    7bd0:	4718      	bx	r3
    7bd2:	bf00      	nop
    7bd4:	0000e5f5 	.word	0x0000e5f5
    7bd8:	2001cd84 	.word	0x2001cd84
    7bdc:	2001cf58 	.word	0x2001cf58

00007be0 <grid_module_pbf4_reva_hardware_transfer_complete_cb>:

void grid_module_pbf4_reva_hardware_transfer_complete_cb(void){
    7be0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	
	if (grid_module_pbf4_reva_hardware_transfer_complete == 0){
    7be4:	4aa8      	ldr	r2, [pc, #672]	; (7e88 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a8>)
    7be6:	7813      	ldrb	r3, [r2, #0]
void grid_module_pbf4_reva_hardware_transfer_complete_cb(void){
    7be8:	b08b      	sub	sp, #44	; 0x2c
	if (grid_module_pbf4_reva_hardware_transfer_complete == 0){
    7bea:	b933      	cbnz	r3, 7bfa <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1a>
		grid_module_pbf4_reva_hardware_transfer_complete++;
    7bec:	7813      	ldrb	r3, [r2, #0]
    7bee:	3301      	adds	r3, #1
    7bf0:	b2db      	uxtb	r3, r3
    7bf2:	7013      	strb	r3, [r2, #0]
	
	
	
	grid_module_pbf4_reva_hardware_transfer_complete = 0;
	grid_module_pbf4_reva_hardware_start_transfer();
}
    7bf4:	b00b      	add	sp, #44	; 0x2c
    7bf6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (grid_sys_state.bank_active_changed){
    7bfa:	4ba4      	ldr	r3, [pc, #656]	; (7e8c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2ac>)
    7bfc:	7c5a      	ldrb	r2, [r3, #17]
    7bfe:	469a      	mov	sl, r3
    7c00:	bb02      	cbnz	r2, 7c44 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x64>
	uint16_t adcresult_0 = 0;
    7c02:	2300      	movs	r3, #0
    7c04:	f8ad 3014 	strh.w	r3, [sp, #20]
	uint16_t adcresult_1 = 0;
    7c08:	f8ad 3016 	strh.w	r3, [sp, #22]
	uint8_t adc_index_0 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+8];
    7c0c:	4ba0      	ldr	r3, [pc, #640]	; (7e90 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b0>)
    7c0e:	49a1      	ldr	r1, [pc, #644]	; (7e94 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b4>)
    7c10:	781a      	ldrb	r2, [r3, #0]
    7c12:	3208      	adds	r2, #8
    7c14:	5c8d      	ldrb	r5, [r1, r2]
	uint8_t adc_index_1 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+0];
    7c16:	781a      	ldrb	r2, [r3, #0]
    7c18:	b2d2      	uxtb	r2, r2
	uint8_t adc_index_0 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+8];
    7c1a:	b2ed      	uxtb	r5, r5
	uint8_t adc_index_1 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+0];
    7c1c:	5c8c      	ldrb	r4, [r1, r2]
	grid_module_pbf4_reva_mux++;
    7c1e:	781a      	ldrb	r2, [r3, #0]
    7c20:	3201      	adds	r2, #1
    7c22:	b2d2      	uxtb	r2, r2
    7c24:	701a      	strb	r2, [r3, #0]
	grid_module_pbf4_reva_mux%=8;
    7c26:	781a      	ldrb	r2, [r3, #0]
    7c28:	f002 0207 	and.w	r2, r2, #7
    7c2c:	701a      	strb	r2, [r3, #0]
	gpio_set_pin_level(MUX_A, grid_module_pbf4_reva_mux/1%2);
    7c2e:	781a      	ldrb	r2, [r3, #0]
    7c30:	f012 0f01 	tst.w	r2, #1
	uint8_t adc_index_1 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+0];
    7c34:	b2e4      	uxtb	r4, r4
    7c36:	4a98      	ldr	r2, [pc, #608]	; (7e98 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b8>)
    7c38:	f44f 2100 	mov.w	r1, #524288	; 0x80000
    7c3c:	d133      	bne.n	7ca6 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0xc6>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7c3e:	f8c2 1114 	str.w	r1, [r2, #276]	; 0x114
}
    7c42:	e032      	b.n	7caa <grid_module_pbf4_reva_hardware_transfer_complete_cb+0xca>
		grid_sys_state.bank_active_changed = 0;
    7c44:	2500      	movs	r5, #0
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7c46:	4c95      	ldr	r4, [pc, #596]	; (7e9c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2bc>)
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7c48:	4e95      	ldr	r6, [pc, #596]	; (7ea0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2c0>)
		grid_sys_state.bank_active_changed = 0;
    7c4a:	745d      	strb	r5, [r3, #17]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7c4c:	2764      	movs	r7, #100	; 0x64
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7c4e:	6863      	ldr	r3, [r4, #4]
    7c50:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7c54:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    7c58:	b2ea      	uxtb	r2, r5
    7c5a:	7a5b      	ldrb	r3, [r3, #9]
    7c5c:	4293      	cmp	r3, r2
    7c5e:	d9d0      	bls.n	7c02 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x22>
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7c60:	6863      	ldr	r3, [r4, #4]
    7c62:	f89a 100f 	ldrb.w	r1, [sl, #15]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7c66:	9201      	str	r2, [sp, #4]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7c68:	eb03 1301 	add.w	r3, r3, r1, lsl #4
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7c6c:	4620      	mov	r0, r4
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7c6e:	68db      	ldr	r3, [r3, #12]
    7c70:	fb07 3302 	mla	r3, r7, r2, r3
    7c74:	3501      	adds	r5, #1
    7c76:	60da      	str	r2, [r3, #12]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7c78:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7c7c:	2300      	movs	r3, #0
    7c7e:	47b0      	blx	r6
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);
    7c80:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7c84:	9a01      	ldr	r2, [sp, #4]
    7c86:	2301      	movs	r3, #1
    7c88:	4620      	mov	r0, r4
    7c8a:	47b0      	blx	r6
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    7c8c:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7c90:	9a01      	ldr	r2, [sp, #4]
    7c92:	2304      	movs	r3, #4
    7c94:	4620      	mov	r0, r4
    7c96:	47b0      	blx	r6
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    7c98:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7c9c:	9a01      	ldr	r2, [sp, #4]
    7c9e:	2305      	movs	r3, #5
    7ca0:	4620      	mov	r0, r4
    7ca2:	47b0      	blx	r6
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7ca4:	e7d3      	b.n	7c4e <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x6e>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7ca6:	f8c2 1118 	str.w	r1, [r2, #280]	; 0x118
	gpio_set_pin_level(MUX_B, grid_module_pbf4_reva_mux/2%2);
    7caa:	781a      	ldrb	r2, [r3, #0]
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    7cac:	4e7d      	ldr	r6, [pc, #500]	; (7ea4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2c4>)
    7cae:	487e      	ldr	r0, [pc, #504]	; (7ea8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2c8>)
	uint32_t input_0 = adcresult_0*1.03;
    7cb0:	f8df b210 	ldr.w	fp, [pc, #528]	; 7ec4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2e4>
    7cb4:	f8df 9210 	ldr.w	r9, [pc, #528]	; 7ec8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2e8>
    7cb8:	f012 0f02 	tst.w	r2, #2
    7cbc:	4a76      	ldr	r2, [pc, #472]	; (7e98 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b8>)
    7cbe:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
    7cc2:	bf14      	ite	ne
    7cc4:	f8c2 1118 	strne.w	r1, [r2, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7cc8:	f8c2 1114 	streq.w	r1, [r2, #276]	; 0x114
	gpio_set_pin_level(MUX_C, grid_module_pbf4_reva_mux/4%2);
    7ccc:	781b      	ldrb	r3, [r3, #0]
    7cce:	f013 0f04 	tst.w	r3, #4
    7cd2:	4b71      	ldr	r3, [pc, #452]	; (7e98 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b8>)
    7cd4:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7cd8:	bf14      	ite	ne
    7cda:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7cde:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    7ce2:	2100      	movs	r1, #0
    7ce4:	2302      	movs	r3, #2
    7ce6:	aa05      	add	r2, sp, #20
    7ce8:	47b0      	blx	r6
	adc_async_read_channel(&ADC_1, 0, &adcresult_1, 2);
    7cea:	2302      	movs	r3, #2
    7cec:	f10d 0216 	add.w	r2, sp, #22
    7cf0:	2100      	movs	r1, #0
    7cf2:	486e      	ldr	r0, [pc, #440]	; (7eac <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2cc>)
    7cf4:	47b0      	blx	r6
	uint32_t input_0 = adcresult_0*1.03;
    7cf6:	f8bd 0014 	ldrh.w	r0, [sp, #20]
    7cfa:	4e6d      	ldr	r6, [pc, #436]	; (7eb0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d0>)
    7cfc:	47d8      	blx	fp
    7cfe:	a360      	add	r3, pc, #384	; (adr r3, 7e80 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a0>)
    7d00:	e9d3 2300 	ldrd	r2, r3, [r3]
    7d04:	47b0      	blx	r6
    7d06:	47c8      	blx	r9
    7d08:	f64f 77ff 	movw	r7, #65535	; 0xffff
    7d0c:	42b8      	cmp	r0, r7
    7d0e:	4680      	mov	r8, r0
    7d10:	bf28      	it	cs
    7d12:	46b8      	movcs	r8, r7
    7d14:	9001      	str	r0, [sp, #4]
	adcresult_0 = input_0;
    7d16:	f8ad 8014 	strh.w	r8, [sp, #20]
	uint32_t input_1 = adcresult_1*1.03;
    7d1a:	f8bd 0016 	ldrh.w	r0, [sp, #22]
    7d1e:	47d8      	blx	fp
    7d20:	a357      	add	r3, pc, #348	; (adr r3, 7e80 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a0>)
    7d22:	e9d3 2300 	ldrd	r2, r3, [r3]
    7d26:	47b0      	blx	r6
    7d28:	47c8      	blx	r9
	adcresult_1 = input_1;
    7d2a:	42b8      	cmp	r0, r7
    7d2c:	4603      	mov	r3, r0
    7d2e:	bf28      	it	cs
    7d30:	463b      	movcs	r3, r7
    7d32:	f8ad 3016 	strh.w	r3, [sp, #22]
	if (adc_index_1 == 8 || adc_index_1 == 9){
    7d36:	f1a4 0308 	sub.w	r3, r4, #8
    7d3a:	2b01      	cmp	r3, #1
    7d3c:	d972      	bls.n	7e24 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x244>
	else if (adc_index_0 > 13){ // BUTTON
    7d3e:	2d0d      	cmp	r5, #13
    7d40:	f8df 9188 	ldr.w	r9, [pc, #392]	; 7ecc <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2ec>
    7d44:	f240 80c4 	bls.w	7ed0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2f0>
		uint8_t result_value[2] = {0};
    7d48:	2300      	movs	r3, #0
		if (adcresult_0>60000){
    7d4a:	9a01      	ldr	r2, [sp, #4]
		uint8_t result_value[2] = {0};
    7d4c:	f8ad 300c 	strh.w	r3, [sp, #12]
		uint8_t result_valid[2] = {0};
    7d50:	f8ad 3010 	strh.w	r3, [sp, #16]
		if (adcresult_0>60000){
    7d54:	f64e 2360 	movw	r3, #60000	; 0xea60
		result_index[0] = adc_index_0-4;
    7d58:	3d04      	subs	r5, #4
		result_index[1] = adc_index_1-4;
    7d5a:	3c04      	subs	r4, #4
		if (adcresult_0>60000){
    7d5c:	429a      	cmp	r2, r3
		result_index[0] = adc_index_0-4;
    7d5e:	f88d 5008 	strb.w	r5, [sp, #8]
		result_index[1] = adc_index_1-4;
    7d62:	f88d 4009 	strb.w	r4, [sp, #9]
		if (adcresult_0>60000){
    7d66:	d963      	bls.n	7e30 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x250>
			result_valid[0] = 1;
    7d68:	2301      	movs	r3, #1
    7d6a:	f88d 3010 	strb.w	r3, [sp, #16]
		if (adcresult_1>60000){
    7d6e:	f64e 2360 	movw	r3, #60000	; 0xea60
    7d72:	4298      	cmp	r0, r3
    7d74:	d963      	bls.n	7e3e <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x25e>
			result_value[1] = 0;
    7d76:	2300      	movs	r3, #0
			result_value[1] = 127;
    7d78:	f88d 300d 	strb.w	r3, [sp, #13]
			result_valid[1] = 1;
    7d7c:	2301      	movs	r3, #1
    7d7e:	f88d 3011 	strb.w	r3, [sp, #17]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7d82:	4b4c      	ldr	r3, [pc, #304]	; (7eb4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d4>)
    7d84:	ac06      	add	r4, sp, #24
    7d86:	6818      	ldr	r0, [r3, #0]
    7d88:	6859      	ldr	r1, [r3, #4]
    7d8a:	4622      	mov	r2, r4
    7d8c:	c203      	stmia	r2!, {r0, r1}
    7d8e:	3308      	adds	r3, #8
    7d90:	454b      	cmp	r3, r9
    7d92:	4614      	mov	r4, r2
    7d94:	d1f7      	bne.n	7d86 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1a6>
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7d96:	f8df b104 	ldr.w	fp, [pc, #260]	; 7e9c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2bc>
    7d9a:	ab03      	add	r3, sp, #12
    7d9c:	f10d 0808 	add.w	r8, sp, #8
    7da0:	9301      	str	r3, [sp, #4]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7da2:	2400      	movs	r4, #0
    7da4:	46d9      	mov	r9, fp
			uint8_t res_value = result_value[i];
    7da6:	9b01      	ldr	r3, [sp, #4]
			uint8_t res_index = result_index[i];
    7da8:	f818 7b01 	ldrb.w	r7, [r8], #1
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    7dac:	4a42      	ldr	r2, [pc, #264]	; (7eb8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d8>)
			uint8_t res_value = result_value[i];
    7dae:	f813 6b01 	ldrb.w	r6, [r3], #1
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    7db2:	5dd2      	ldrb	r2, [r2, r7]
			uint8_t res_value = result_value[i];
    7db4:	9301      	str	r3, [sp, #4]
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7db6:	f8db 3004 	ldr.w	r3, [fp, #4]
    7dba:	f89a 100f 	ldrb.w	r1, [sl, #15]
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    7dbe:	4296      	cmp	r6, r2
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7dc0:	b2c9      	uxtb	r1, r1
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    7dc2:	d02e      	beq.n	7e22 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x242>
			uint8_t res_valid = result_valid[i];
    7dc4:	a804      	add	r0, sp, #16
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    7dc6:	5c20      	ldrb	r0, [r4, r0]
    7dc8:	2801      	cmp	r0, #1
    7dca:	d12a      	bne.n	7e22 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x242>
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7dcc:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    7dd0:	2064      	movs	r0, #100	; 0x64
    7dd2:	68db      	ldr	r3, [r3, #12]
    7dd4:	fb17 f000 	smulbb	r0, r7, r0
    7dd8:	4403      	add	r3, r0
				if (grid_pbf4_helper_template_b_abs[res_index] == 0){ // Button Press Event
    7dda:	2a00      	cmp	r2, #0
    7ddc:	d13b      	bne.n	7e56 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x276>
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] == 0){
    7dde:	6999      	ldr	r1, [r3, #24]
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    7de0:	2900      	cmp	r1, #0
    7de2:	bf0c      	ite	eq
    7de4:	217f      	moveq	r1, #127	; 0x7f
    7de6:	2100      	movne	r1, #0
    7de8:	6199      	str	r1, [r3, #24]
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    7dea:	69d9      	ldr	r1, [r3, #28]
    7dec:	bb69      	cbnz	r1, 7e4a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x26a>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 63;
    7dee:	213f      	movs	r1, #63	; 0x3f
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    7df0:	61d9      	str	r1, [r3, #28]
					grid_pbf4_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    7df2:	f89a 300f 	ldrb.w	r3, [sl, #15]
					grid_pbf4_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7df6:	f89a 300f 	ldrb.w	r3, [sl, #15]
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7dfa:	227f      	movs	r2, #127	; 0x7f
					grid_pbf4_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7dfc:	2300      	movs	r3, #0
                        template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7dfe:	f8d9 1004 	ldr.w	r1, [r9, #4]
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7e02:	4419      	add	r1, r3
    7e04:	3310      	adds	r3, #16
    7e06:	68c9      	ldr	r1, [r1, #12]
    7e08:	4401      	add	r1, r0
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7e0a:	2b40      	cmp	r3, #64	; 0x40
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7e0c:	614a      	str	r2, [r1, #20]
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7e0e:	d1f6      	bne.n	7dfe <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x21e>
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DP);
    7e10:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7e14:	2304      	movs	r3, #4
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    7e16:	4d29      	ldr	r5, [pc, #164]	; (7ebc <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2dc>)
    7e18:	463a      	mov	r2, r7
    7e1a:	4658      	mov	r0, fp
    7e1c:	47a8      	blx	r5
					grid_pbf4_helper_template_b_abs[result_index[i]] = res_value;
    7e1e:	4b26      	ldr	r3, [pc, #152]	; (7eb8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d8>)
    7e20:	55de      	strb	r6, [r3, r7]
		for (uint8_t i=0; i<2; i++)
    7e22:	b184      	cbz	r4, 7e46 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x266>
	grid_module_pbf4_reva_hardware_transfer_complete = 0;
    7e24:	4a18      	ldr	r2, [pc, #96]	; (7e88 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a8>)
    7e26:	2300      	movs	r3, #0
    7e28:	7013      	strb	r3, [r2, #0]
	grid_module_pbf4_reva_hardware_start_transfer();
    7e2a:	4b25      	ldr	r3, [pc, #148]	; (7ec0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2e0>)
    7e2c:	4798      	blx	r3
    7e2e:	e6e1      	b.n	7bf4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x14>
		else if (adcresult_0<200){
    7e30:	9b01      	ldr	r3, [sp, #4]
    7e32:	2bc7      	cmp	r3, #199	; 0xc7
    7e34:	d89b      	bhi.n	7d6e <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x18e>
			result_value[0] = 127;
    7e36:	237f      	movs	r3, #127	; 0x7f
    7e38:	f88d 300c 	strb.w	r3, [sp, #12]
    7e3c:	e794      	b.n	7d68 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x188>
		else if (adcresult_1<200){
    7e3e:	28c7      	cmp	r0, #199	; 0xc7
    7e40:	d89f      	bhi.n	7d82 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1a2>
			result_value[1] = 127;
    7e42:	237f      	movs	r3, #127	; 0x7f
    7e44:	e798      	b.n	7d78 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x198>
    7e46:	2401      	movs	r4, #1
    7e48:	e7ad      	b.n	7da6 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1c6>
					else if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 63){
    7e4a:	293f      	cmp	r1, #63	; 0x3f
    7e4c:	d101      	bne.n	7e52 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x272>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    7e4e:	217f      	movs	r1, #127	; 0x7f
    7e50:	e7ce      	b.n	7df0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x210>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 0;
    7e52:	61da      	str	r2, [r3, #28]
    7e54:	e7cd      	b.n	7df2 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x212>
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7e56:	aa0a      	add	r2, sp, #40	; 0x28
    7e58:	19d1      	adds	r1, r2, r7
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7e5a:	60df      	str	r7, [r3, #12]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7e5c:	f811 1c10 	ldrb.w	r1, [r1, #-16]
    7e60:	6119      	str	r1, [r3, #16]
    7e62:	2300      	movs	r3, #0
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7e64:	461a      	mov	r2, r3
                        template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7e66:	f8d9 1004 	ldr.w	r1, [r9, #4]
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7e6a:	4419      	add	r1, r3
    7e6c:	3310      	adds	r3, #16
    7e6e:	68c9      	ldr	r1, [r1, #12]
    7e70:	4401      	add	r1, r0
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7e72:	2b40      	cmp	r3, #64	; 0x40
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7e74:	614a      	str	r2, [r1, #20]
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7e76:	d1f6      	bne.n	7e66 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x286>
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    7e78:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7e7c:	2305      	movs	r3, #5
    7e7e:	e7ca      	b.n	7e16 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x236>
    7e80:	47ae147b 	.word	0x47ae147b
    7e84:	3ff07ae1 	.word	0x3ff07ae1
    7e88:	2000c0ac 	.word	0x2000c0ac
    7e8c:	2000f008 	.word	0x2000f008
    7e90:	2001c7c8 	.word	0x2001c7c8
    7e94:	20000329 	.word	0x20000329
    7e98:	41008000 	.word	0x41008000
    7e9c:	2000effc 	.word	0x2000effc
    7ea0:	0000a49d 	.word	0x0000a49d
    7ea4:	0000e539 	.word	0x0000e539
    7ea8:	2001cd84 	.word	0x2001cd84
    7eac:	2001cf58 	.word	0x2001cf58
    7eb0:	00013e19 	.word	0x00013e19
    7eb4:	00015cc8 	.word	0x00015cc8
    7eb8:	200007eb 	.word	0x200007eb
    7ebc:	0000a149 	.word	0x0000a149
    7ec0:	00007bc1 	.word	0x00007bc1
    7ec4:	00013d45 	.word	0x00013d45
    7ec8:	0001423d 	.word	0x0001423d
    7ecc:	00015cd8 	.word	0x00015cd8
		if (adc_index_1 == 0 || adc_index_1 == 1){
    7ed0:	2c01      	cmp	r4, #1
    7ed2:	4e33      	ldr	r6, [pc, #204]	; (7fa0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3c0>)
    7ed4:	d85e      	bhi.n	7f94 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3b4>
			grid_ain_add_sample(adc_index_0, (1<<16)-1-adcresult_0);
    7ed6:	ea88 0107 	eor.w	r1, r8, r7
    7eda:	4628      	mov	r0, r5
    7edc:	47b0      	blx	r6
			grid_ain_add_sample(adc_index_1, (1<<16)-1-adcresult_1);
    7ede:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    7ee2:	1a79      	subs	r1, r7, r1
			grid_ain_add_sample(adc_index_1, adcresult_1);
    7ee4:	4620      	mov	r0, r4
    7ee6:	47b0      	blx	r6
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7ee8:	4a2e      	ldr	r2, [pc, #184]	; (7fa4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3c4>)
		result_index[0] = adc_index_0;
    7eea:	f88d 5010 	strb.w	r5, [sp, #16]
		result_index[1] = adc_index_1;
    7eee:	f88d 4011 	strb.w	r4, [sp, #17]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7ef2:	ab06      	add	r3, sp, #24
    7ef4:	6810      	ldr	r0, [r2, #0]
    7ef6:	6851      	ldr	r1, [r2, #4]
    7ef8:	461c      	mov	r4, r3
    7efa:	c403      	stmia	r4!, {r0, r1}
    7efc:	3208      	adds	r2, #8
    7efe:	454a      	cmp	r2, r9
    7f00:	4623      	mov	r3, r4
    7f02:	d1f7      	bne.n	7ef4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x314>
		for (uint8_t i=0; i<2; i++)
    7f04:	ab04      	add	r3, sp, #16
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f06:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 7fb0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3d0>
    7f0a:	9301      	str	r3, [sp, #4]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7f0c:	f04f 0902 	mov.w	r9, #2
			uint8_t res_index = result_index[i];
    7f10:	9b01      	ldr	r3, [sp, #4]
    7f12:	f813 4b01 	ldrb.w	r4, [r3], #1
    7f16:	9301      	str	r3, [sp, #4]
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f18:	f8d8 3004 	ldr.w	r3, [r8, #4]
    7f1c:	f89a 200f 	ldrb.w	r2, [sl, #15]
    7f20:	eb03 1302 	add.w	r3, r3, r2, lsl #4
			if (grid_ain_get_changed(res_index)){
    7f24:	4620      	mov	r0, r4
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f26:	68dd      	ldr	r5, [r3, #12]
			if (grid_ain_get_changed(res_index)){
    7f28:	4b1f      	ldr	r3, [pc, #124]	; (7fa8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3c8>)
    7f2a:	4798      	blx	r3
    7f2c:	b358      	cbz	r0, 7f86 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3a6>
				uint8_t res_value = grid_ain_get_average(res_index, 7);
    7f2e:	4e1f      	ldr	r6, [pc, #124]	; (7fac <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3cc>)
    7f30:	2107      	movs	r1, #7
    7f32:	4620      	mov	r0, r4
    7f34:	47b0      	blx	r6
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f36:	2764      	movs	r7, #100	; 0x64
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7f38:	ab0a      	add	r3, sp, #40	; 0x28
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f3a:	fb14 f707 	smulbb	r7, r4, r7
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7f3e:	4423      	add	r3, r4
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f40:	443d      	add	r5, r7
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7f42:	f813 3c10 	ldrb.w	r3, [r3, #-16]
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7f46:	60ec      	str	r4, [r5, #12]
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7f48:	612b      	str	r3, [r5, #16]
    7f4a:	2500      	movs	r5, #0
                	template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7f4c:	4b18      	ldr	r3, [pc, #96]	; (7fb0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3d0>)
    7f4e:	685a      	ldr	r2, [r3, #4]
    7f50:	442a      	add	r2, r5
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    7f52:	2107      	movs	r1, #7
                	template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7f54:	68d2      	ldr	r2, [r2, #12]
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    7f56:	4620      	mov	r0, r4
                	template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7f58:	eb02 0b07 	add.w	fp, r2, r7
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    7f5c:	47b0      	blx	r6
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    7f5e:	2107      	movs	r1, #7
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    7f60:	f8cb 0014 	str.w	r0, [fp, #20]
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    7f64:	4620      	mov	r0, r4
    7f66:	47b0      	blx	r6
    7f68:	3510      	adds	r5, #16
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    7f6a:	2300      	movs	r3, #0
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7f6c:	2d40      	cmp	r5, #64	; 0x40
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    7f6e:	f8cb 0018 	str.w	r0, [fp, #24]
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    7f72:	f8cb 301c 	str.w	r3, [fp, #28]
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7f76:	d1e9      	bne.n	7f4c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x36c>
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_AVC7);
    7f78:	4622      	mov	r2, r4
    7f7a:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7f7e:	4c0d      	ldr	r4, [pc, #52]	; (7fb4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3d4>)
    7f80:	2301      	movs	r3, #1
    7f82:	4640      	mov	r0, r8
    7f84:	47a0      	blx	r4
		for (uint8_t i=0; i<2; i++)
    7f86:	f1b9 0f01 	cmp.w	r9, #1
    7f8a:	f43f af4b 	beq.w	7e24 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x244>
    7f8e:	f04f 0901 	mov.w	r9, #1
    7f92:	e7bd      	b.n	7f10 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x330>
			grid_ain_add_sample(adc_index_0, adcresult_0);
    7f94:	4641      	mov	r1, r8
    7f96:	4628      	mov	r0, r5
    7f98:	47b0      	blx	r6
			grid_ain_add_sample(adc_index_1, adcresult_1);
    7f9a:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    7f9e:	e7a1      	b.n	7ee4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x304>
    7fa0:	000045e9 	.word	0x000045e9
    7fa4:	00015cc8 	.word	0x00015cc8
    7fa8:	000046b1 	.word	0x000046b1
    7fac:	000046c1 	.word	0x000046c1
    7fb0:	2000effc 	.word	0x2000effc
    7fb4:	0000a149 	.word	0x0000a149

00007fb8 <grid_module_pbf4_reva_hardware_init>:

void grid_module_pbf4_reva_hardware_init(void){
    7fb8:	b570      	push	{r4, r5, r6, lr}
	
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    7fba:	4c0b      	ldr	r4, [pc, #44]	; (7fe8 <grid_module_pbf4_reva_hardware_init+0x30>)
    7fbc:	4e0b      	ldr	r6, [pc, #44]	; (7fec <grid_module_pbf4_reva_hardware_init+0x34>)
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    7fbe:	4d0c      	ldr	r5, [pc, #48]	; (7ff0 <grid_module_pbf4_reva_hardware_init+0x38>)
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    7fc0:	4b0c      	ldr	r3, [pc, #48]	; (7ff4 <grid_module_pbf4_reva_hardware_init+0x3c>)
    7fc2:	2200      	movs	r2, #0
    7fc4:	4611      	mov	r1, r2
    7fc6:	4620      	mov	r0, r4
    7fc8:	47b0      	blx	r6
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    7fca:	2200      	movs	r2, #0
    7fcc:	4b09      	ldr	r3, [pc, #36]	; (7ff4 <grid_module_pbf4_reva_hardware_init+0x3c>)
    7fce:	4611      	mov	r1, r2
    7fd0:	4628      	mov	r0, r5
    7fd2:	47b0      	blx	r6
	
	adc_async_enable_channel(&ADC_0, 0);
    7fd4:	4620      	mov	r0, r4
    7fd6:	4c08      	ldr	r4, [pc, #32]	; (7ff8 <grid_module_pbf4_reva_hardware_init+0x40>)
    7fd8:	2100      	movs	r1, #0
    7fda:	47a0      	blx	r4
	adc_async_enable_channel(&ADC_1, 0);
    7fdc:	4628      	mov	r0, r5
    7fde:	4623      	mov	r3, r4
    7fe0:	2100      	movs	r1, #0

}
    7fe2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	adc_async_enable_channel(&ADC_1, 0);
    7fe6:	4718      	bx	r3
    7fe8:	2001cd84 	.word	0x2001cd84
    7fec:	0000e4c1 	.word	0x0000e4c1
    7ff0:	2001cf58 	.word	0x2001cf58
    7ff4:	00007be1 	.word	0x00007be1
    7ff8:	0000e481 	.word	0x0000e481

00007ffc <grid_module_pbf4_reva_init>:




void grid_module_pbf4_reva_init(){
    7ffc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	
	// 16 pot, depth of 5, 14bit internal, 7bit result;
	grid_ain_init(16, 5, 14, 7);
    8000:	220e      	movs	r2, #14
    8002:	4c16      	ldr	r4, [pc, #88]	; (805c <grid_module_pbf4_reva_init+0x60>)
	
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);

	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
		
		grid_ui_bank_init(&grid_ui_state, i, 12);
    8004:	4e16      	ldr	r6, [pc, #88]	; (8060 <grid_module_pbf4_reva_init+0x64>)
    8006:	f8df 9074 	ldr.w	r9, [pc, #116]	; 807c <grid_module_pbf4_reva_init+0x80>
    800a:	4f16      	ldr	r7, [pc, #88]	; (8064 <grid_module_pbf4_reva_init+0x68>)
	grid_ain_init(16, 5, 14, 7);
    800c:	2307      	movs	r3, #7
    800e:	2105      	movs	r1, #5
    8010:	2010      	movs	r0, #16
    8012:	47a0      	blx	r4
	grid_led_lowlevel_init(&grid_led_state, 12);	
    8014:	4b14      	ldr	r3, [pc, #80]	; (8068 <grid_module_pbf4_reva_init+0x6c>)
    8016:	4815      	ldr	r0, [pc, #84]	; (806c <grid_module_pbf4_reva_init+0x70>)
    8018:	210c      	movs	r1, #12
    801a:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
    801c:	4810      	ldr	r0, [pc, #64]	; (8060 <grid_module_pbf4_reva_init+0x64>)
    801e:	4b14      	ldr	r3, [pc, #80]	; (8070 <grid_module_pbf4_reva_init+0x74>)
    8020:	2104      	movs	r1, #4
    8022:	4798      	blx	r3
    8024:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 12);
    8026:	220c      	movs	r2, #12
    8028:	b2e1      	uxtb	r1, r4
    802a:	4630      	mov	r0, r6
    802c:	47c8      	blx	r9
		
		for(uint8_t j=0; j<12; j++){
    802e:	ea4f 1804 	mov.w	r8, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 12);
    8032:	2500      	movs	r5, #0
			
				
			if (j<8){ // PORENTIOMETERS & FADERS -> MIDI Control Change
				
				grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    8034:	6870      	ldr	r0, [r6, #4]
			if (j<8){ // PORENTIOMETERS & FADERS -> MIDI Control Change
    8036:	2d07      	cmp	r5, #7
    8038:	b2e9      	uxtb	r1, r5
				grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    803a:	bf94      	ite	ls
    803c:	2201      	movls	r2, #1
			
			}
			else{ // BUTTONS -> MIDI Note On/Off
				
				grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_BUTTON);
    803e:	2202      	movhi	r2, #2
    8040:	4440      	add	r0, r8
    8042:	3501      	adds	r5, #1
    8044:	47b8      	blx	r7
		for(uint8_t j=0; j<12; j++){
    8046:	2d0c      	cmp	r5, #12
    8048:	d1f4      	bne.n	8034 <grid_module_pbf4_reva_init+0x38>
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    804a:	3401      	adds	r4, #1
    804c:	2c04      	cmp	r4, #4
    804e:	d1ea      	bne.n	8026 <grid_module_pbf4_reva_init+0x2a>
			}
			
		}	
	}
			
	grid_module_pbf4_reva_hardware_init();
    8050:	4b08      	ldr	r3, [pc, #32]	; (8074 <grid_module_pbf4_reva_init+0x78>)
    8052:	4798      	blx	r3
	grid_module_pbf4_reva_hardware_start_transfer();
	
    8054:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_pbf4_reva_hardware_start_transfer();
    8058:	4b07      	ldr	r3, [pc, #28]	; (8078 <grid_module_pbf4_reva_init+0x7c>)
    805a:	4718      	bx	r3
    805c:	000045a5 	.word	0x000045a5
    8060:	2000effc 	.word	0x2000effc
    8064:	0000a389 	.word	0x0000a389
    8068:	00006ed1 	.word	0x00006ed1
    806c:	2001c838 	.word	0x2001c838
    8070:	00009a29 	.word	0x00009a29
    8074:	00007fb9 	.word	0x00007fb9
    8078:	00007bc1 	.word	0x00007bc1
    807c:	00009a5d 	.word	0x00009a5d

00008080 <grid_module_po16_revb_hardware_start_transfer>:

volatile uint8_t grid_module_po16_revb_hardware_transfer_complete = 0;
volatile uint8_t grid_module_po16_revb_mux =0;
volatile uint8_t grid_module_po16_revb_mux_lookup[16] = {0, 1, 4, 5, 8, 9, 12, 13, 2, 3, 6, 7, 10, 11, 14, 15};

void grid_module_po16_revb_hardware_start_transfer(void){
    8080:	b510      	push	{r4, lr}
	
	adc_async_start_conversion(&ADC_0);
    8082:	4c04      	ldr	r4, [pc, #16]	; (8094 <grid_module_po16_revb_hardware_start_transfer+0x14>)
    8084:	4804      	ldr	r0, [pc, #16]	; (8098 <grid_module_po16_revb_hardware_start_transfer+0x18>)
    8086:	47a0      	blx	r4
	adc_async_start_conversion(&ADC_1);
    8088:	4623      	mov	r3, r4
    808a:	4804      	ldr	r0, [pc, #16]	; (809c <grid_module_po16_revb_hardware_start_transfer+0x1c>)
	
}
    808c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_async_start_conversion(&ADC_1);
    8090:	4718      	bx	r3
    8092:	bf00      	nop
    8094:	0000e5f5 	.word	0x0000e5f5
    8098:	2001cd84 	.word	0x2001cd84
    809c:	2001cf58 	.word	0x2001cf58

000080a0 <grid_module_po16_revb_hardware_transfer_complete_cb>:

static void grid_module_po16_revb_hardware_transfer_complete_cb(void){
    80a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	
	if (grid_module_po16_revb_hardware_transfer_complete == 0){
    80a4:	4a88      	ldr	r2, [pc, #544]	; (82c8 <grid_module_po16_revb_hardware_transfer_complete_cb+0x228>)
    80a6:	7813      	ldrb	r3, [r2, #0]
static void grid_module_po16_revb_hardware_transfer_complete_cb(void){
    80a8:	b089      	sub	sp, #36	; 0x24
    80aa:	4614      	mov	r4, r2
	if (grid_module_po16_revb_hardware_transfer_complete == 0){
    80ac:	b933      	cbnz	r3, 80bc <grid_module_po16_revb_hardware_transfer_complete_cb+0x1c>
		grid_module_po16_revb_hardware_transfer_complete++;
    80ae:	7813      	ldrb	r3, [r2, #0]
    80b0:	3301      	adds	r3, #1
    80b2:	b2db      	uxtb	r3, r3
    80b4:	7013      	strb	r3, [r2, #0]
	}
	
	
	grid_module_po16_revb_hardware_transfer_complete = 0;
	grid_module_po16_revb_hardware_start_transfer();
}
    80b6:	b009      	add	sp, #36	; 0x24
    80b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (grid_sys_state.bank_active_changed){
    80bc:	4d83      	ldr	r5, [pc, #524]	; (82cc <grid_module_po16_revb_hardware_transfer_complete_cb+0x22c>)
    80be:	7c6b      	ldrb	r3, [r5, #17]
    80c0:	b9fb      	cbnz	r3, 8102 <grid_module_po16_revb_hardware_transfer_complete_cb+0x62>
	uint16_t adcresult_0 = 0;
    80c2:	2300      	movs	r3, #0
    80c4:	f8ad 300c 	strh.w	r3, [sp, #12]
	uint16_t adcresult_1 = 0;
    80c8:	f8ad 300e 	strh.w	r3, [sp, #14]
	uint8_t adc_index_0 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+8];
    80cc:	7863      	ldrb	r3, [r4, #1]
    80ce:	4a80      	ldr	r2, [pc, #512]	; (82d0 <grid_module_po16_revb_hardware_transfer_complete_cb+0x230>)
    80d0:	3308      	adds	r3, #8
    80d2:	5cd7      	ldrb	r7, [r2, r3]
	uint8_t adc_index_1 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+0];
    80d4:	7863      	ldrb	r3, [r4, #1]
    80d6:	b2db      	uxtb	r3, r3
	uint8_t adc_index_0 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+8];
    80d8:	b2ff      	uxtb	r7, r7
	uint8_t adc_index_1 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+0];
    80da:	5cd6      	ldrb	r6, [r2, r3]
	grid_module_po16_revb_mux++;
    80dc:	7863      	ldrb	r3, [r4, #1]
    80de:	3301      	adds	r3, #1
    80e0:	b2db      	uxtb	r3, r3
    80e2:	7063      	strb	r3, [r4, #1]
	grid_module_po16_revb_mux%=8;
    80e4:	7863      	ldrb	r3, [r4, #1]
    80e6:	f003 0307 	and.w	r3, r3, #7
    80ea:	7063      	strb	r3, [r4, #1]
	gpio_set_pin_level(MUX_A, grid_module_po16_revb_mux/1%2);
    80ec:	7863      	ldrb	r3, [r4, #1]
    80ee:	f013 0f01 	tst.w	r3, #1
	uint8_t adc_index_1 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+0];
    80f2:	b2f6      	uxtb	r6, r6
    80f4:	4b77      	ldr	r3, [pc, #476]	; (82d4 <grid_module_po16_revb_hardware_transfer_complete_cb+0x234>)
    80f6:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    80fa:	d128      	bne.n	814e <grid_module_po16_revb_hardware_transfer_complete_cb+0xae>
    80fc:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
    8100:	e027      	b.n	8152 <grid_module_po16_revb_hardware_transfer_complete_cb+0xb2>
		grid_sys_state.bank_active_changed = 0;
    8102:	2600      	movs	r6, #0
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    8104:	f8df 81e4 	ldr.w	r8, [pc, #484]	; 82ec <grid_module_po16_revb_hardware_transfer_complete_cb+0x24c>
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8108:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 82fc <grid_module_po16_revb_hardware_transfer_complete_cb+0x25c>
		grid_sys_state.bank_active_changed = 0;
    810c:	746e      	strb	r6, [r5, #17]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    810e:	f04f 0a64 	mov.w	sl, #100	; 0x64
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    8112:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8116:	7bea      	ldrb	r2, [r5, #15]
    8118:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    811c:	b2f7      	uxtb	r7, r6
    811e:	7a5b      	ldrb	r3, [r3, #9]
    8120:	42bb      	cmp	r3, r7
    8122:	d9ce      	bls.n	80c2 <grid_module_po16_revb_hardware_transfer_complete_cb+0x22>
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8124:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8128:	7bea      	ldrb	r2, [r5, #15]
    812a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    812e:	4640      	mov	r0, r8
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8130:	68db      	ldr	r3, [r3, #12]
    8132:	fb0a 3307 	mla	r3, sl, r7, r3
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8136:	463a      	mov	r2, r7
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8138:	60df      	str	r7, [r3, #12]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    813a:	7be9      	ldrb	r1, [r5, #15]
    813c:	2300      	movs	r3, #0
    813e:	47c8      	blx	r9
            grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);
    8140:	7be9      	ldrb	r1, [r5, #15]
    8142:	2301      	movs	r3, #1
    8144:	463a      	mov	r2, r7
    8146:	4640      	mov	r0, r8
    8148:	47c8      	blx	r9
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    814a:	3601      	adds	r6, #1
    814c:	e7e1      	b.n	8112 <grid_module_po16_revb_hardware_transfer_complete_cb+0x72>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    814e:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	gpio_set_pin_level(MUX_B, grid_module_po16_revb_mux/2%2);
    8152:	7863      	ldrb	r3, [r4, #1]
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    8154:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 8300 <grid_module_po16_revb_hardware_transfer_complete_cb+0x260>
    8158:	485f      	ldr	r0, [pc, #380]	; (82d8 <grid_module_po16_revb_hardware_transfer_complete_cb+0x238>)
	uint32_t input_0 = adcresult_0*1.03;	
    815a:	f8df b1a8 	ldr.w	fp, [pc, #424]	; 8304 <grid_module_po16_revb_hardware_transfer_complete_cb+0x264>
    815e:	f8df a1a8 	ldr.w	sl, [pc, #424]	; 8308 <grid_module_po16_revb_hardware_transfer_complete_cb+0x268>
    8162:	f8df 91a8 	ldr.w	r9, [pc, #424]	; 830c <grid_module_po16_revb_hardware_transfer_complete_cb+0x26c>
    8166:	f013 0f02 	tst.w	r3, #2
    816a:	4b5a      	ldr	r3, [pc, #360]	; (82d4 <grid_module_po16_revb_hardware_transfer_complete_cb+0x234>)
    816c:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    8170:	bf14      	ite	ne
    8172:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    8176:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	gpio_set_pin_level(MUX_C, grid_module_po16_revb_mux/4%2);
    817a:	7863      	ldrb	r3, [r4, #1]
    817c:	f013 0f04 	tst.w	r3, #4
    8180:	4b54      	ldr	r3, [pc, #336]	; (82d4 <grid_module_po16_revb_hardware_transfer_complete_cb+0x234>)
    8182:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    8186:	bf14      	ite	ne
    8188:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    818c:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    8190:	2100      	movs	r1, #0
    8192:	2302      	movs	r3, #2
    8194:	aa03      	add	r2, sp, #12
    8196:	47c0      	blx	r8
	adc_async_read_channel(&ADC_1, 0, &adcresult_1, 2);
    8198:	2302      	movs	r3, #2
    819a:	f10d 020e 	add.w	r2, sp, #14
    819e:	2100      	movs	r1, #0
    81a0:	484e      	ldr	r0, [pc, #312]	; (82dc <grid_module_po16_revb_hardware_transfer_complete_cb+0x23c>)
    81a2:	47c0      	blx	r8
	uint32_t input_0 = adcresult_0*1.03;	
    81a4:	f8bd 000c 	ldrh.w	r0, [sp, #12]
    81a8:	47d8      	blx	fp
    81aa:	a345      	add	r3, pc, #276	; (adr r3, 82c0 <grid_module_po16_revb_hardware_transfer_complete_cb+0x220>)
    81ac:	e9d3 2300 	ldrd	r2, r3, [r3]
    81b0:	47d0      	blx	sl
    81b2:	47c8      	blx	r9
	adcresult_0 = input_0;
    81b4:	f64f 78ff 	movw	r8, #65535	; 0xffff
    81b8:	4540      	cmp	r0, r8
    81ba:	bf28      	it	cs
    81bc:	4640      	movcs	r0, r8
    81be:	f8ad 000c 	strh.w	r0, [sp, #12]
	uint32_t input_1 = adcresult_1*1.03;	
    81c2:	f8bd 000e 	ldrh.w	r0, [sp, #14]
    81c6:	47d8      	blx	fp
    81c8:	a33d      	add	r3, pc, #244	; (adr r3, 82c0 <grid_module_po16_revb_hardware_transfer_complete_cb+0x220>)
    81ca:	e9d3 2300 	ldrd	r2, r3, [r3]
    81ce:	47d0      	blx	sl
    81d0:	47c8      	blx	r9
	adcresult_1 = input_1;
    81d2:	4540      	cmp	r0, r8
    81d4:	bf28      	it	cs
    81d6:	4640      	movcs	r0, r8
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    81d8:	4b41      	ldr	r3, [pc, #260]	; (82e0 <grid_module_po16_revb_hardware_transfer_complete_cb+0x240>)
	adcresult_1 = input_1;
    81da:	f8ad 000e 	strh.w	r0, [sp, #14]
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    81de:	4798      	blx	r3
    81e0:	2808      	cmp	r0, #8
    81e2:	d109      	bne.n	81f8 <grid_module_po16_revb_hardware_transfer_complete_cb+0x158>
		adcresult_0	= 65535 - adcresult_0;
    81e4:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    81e8:	43db      	mvns	r3, r3
    81ea:	f8ad 300c 	strh.w	r3, [sp, #12]
		adcresult_1 = 65535 - adcresult_1;
    81ee:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    81f2:	43db      	mvns	r3, r3
    81f4:	f8ad 300e 	strh.w	r3, [sp, #14]
	grid_ain_add_sample(adc_index_0, adcresult_0);
    81f8:	f8bd 100c 	ldrh.w	r1, [sp, #12]
    81fc:	f8df 8110 	ldr.w	r8, [pc, #272]	; 8310 <grid_module_po16_revb_hardware_transfer_complete_cb+0x270>
    8200:	4638      	mov	r0, r7
    8202:	47c0      	blx	r8
	grid_ain_add_sample(adc_index_1, adcresult_1);
    8204:	4630      	mov	r0, r6
    8206:	f8bd 100e 	ldrh.w	r1, [sp, #14]
    820a:	47c0      	blx	r8
	uint8_t grid_module_po16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    820c:	4b35      	ldr	r3, [pc, #212]	; (82e4 <grid_module_po16_revb_hardware_transfer_complete_cb+0x244>)
	result_index[0] = adc_index_0;
    820e:	f88d 7008 	strb.w	r7, [sp, #8]
	result_index[1] = adc_index_1;
    8212:	f88d 6009 	strb.w	r6, [sp, #9]
	uint8_t grid_module_po16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    8216:	f103 0710 	add.w	r7, r3, #16
    821a:	ae04      	add	r6, sp, #16
    821c:	6818      	ldr	r0, [r3, #0]
    821e:	6859      	ldr	r1, [r3, #4]
    8220:	4632      	mov	r2, r6
    8222:	c203      	stmia	r2!, {r0, r1}
    8224:	3308      	adds	r3, #8
    8226:	42bb      	cmp	r3, r7
    8228:	4616      	mov	r6, r2
    822a:	d1f7      	bne.n	821c <grid_module_po16_revb_hardware_transfer_complete_cb+0x17c>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    822c:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 82ec <grid_module_po16_revb_hardware_transfer_complete_cb+0x24c>
    8230:	f10d 0a08 	add.w	sl, sp, #8
	for (uint8_t i=0; i<2; i++)
    8234:	f04f 0900 	mov.w	r9, #0
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8238:	f8d8 3004 	ldr.w	r3, [r8, #4]
    823c:	7bea      	ldrb	r2, [r5, #15]
		uint8_t res_index = result_index[i];
    823e:	f81a 6b01 	ldrb.w	r6, [sl], #1
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8242:	eb03 1302 	add.w	r3, r3, r2, lsl #4
		if (grid_ain_get_changed(res_index)){
    8246:	4630      	mov	r0, r6
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8248:	68df      	ldr	r7, [r3, #12]
		if (grid_ain_get_changed(res_index)){
    824a:	4b27      	ldr	r3, [pc, #156]	; (82e8 <grid_module_po16_revb_hardware_transfer_complete_cb+0x248>)
    824c:	4798      	blx	r3
    824e:	b350      	cbz	r0, 82a6 <grid_module_po16_revb_hardware_transfer_complete_cb+0x206>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8250:	2264      	movs	r2, #100	; 0x64
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    8252:	a908      	add	r1, sp, #32
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8254:	fb16 f202 	smulbb	r2, r6, r2
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    8258:	4431      	add	r1, r6
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    825a:	18bb      	adds	r3, r7, r2
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    825c:	f811 1c10 	ldrb.w	r1, [r1, #-16]
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = res_index;
    8260:	60de      	str	r6, [r3, #12]
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    8262:	6119      	str	r1, [r3, #16]
    8264:	2700      	movs	r7, #0
                template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    8266:	4b21      	ldr	r3, [pc, #132]	; (82ec <grid_module_po16_revb_hardware_transfer_complete_cb+0x24c>)
    8268:	9201      	str	r2, [sp, #4]
    826a:	685b      	ldr	r3, [r3, #4]
    826c:	443b      	add	r3, r7
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    826e:	2107      	movs	r1, #7
                template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    8270:	68db      	ldr	r3, [r3, #12]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    8272:	4630      	mov	r0, r6
                template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    8274:	eb03 0b02 	add.w	fp, r3, r2
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    8278:	4b1d      	ldr	r3, [pc, #116]	; (82f0 <grid_module_po16_revb_hardware_transfer_complete_cb+0x250>)
    827a:	4798      	blx	r3
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    827c:	4b1c      	ldr	r3, [pc, #112]	; (82f0 <grid_module_po16_revb_hardware_transfer_complete_cb+0x250>)
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    827e:	f8cb 0014 	str.w	r0, [fp, #20]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    8282:	2107      	movs	r1, #7
    8284:	4630      	mov	r0, r6
    8286:	4798      	blx	r3
    8288:	3710      	adds	r7, #16
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    828a:	2300      	movs	r3, #0
            for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    828c:	2f40      	cmp	r7, #64	; 0x40
    828e:	9a01      	ldr	r2, [sp, #4]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    8290:	f8cb 0018 	str.w	r0, [fp, #24]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    8294:	f8cb 301c 	str.w	r3, [fp, #28]
            for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    8298:	d1e5      	bne.n	8266 <grid_module_po16_revb_hardware_transfer_complete_cb+0x1c6>
			grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_AVC7);		
    829a:	4632      	mov	r2, r6
    829c:	7be9      	ldrb	r1, [r5, #15]
    829e:	4e15      	ldr	r6, [pc, #84]	; (82f4 <grid_module_po16_revb_hardware_transfer_complete_cb+0x254>)
    82a0:	2301      	movs	r3, #1
    82a2:	4640      	mov	r0, r8
    82a4:	47b0      	blx	r6
	for (uint8_t i=0; i<2; i++)
    82a6:	f1b9 0f00 	cmp.w	r9, #0
    82aa:	d004      	beq.n	82b6 <grid_module_po16_revb_hardware_transfer_complete_cb+0x216>
	grid_module_po16_revb_hardware_transfer_complete = 0;
    82ac:	2300      	movs	r3, #0
    82ae:	7023      	strb	r3, [r4, #0]
	grid_module_po16_revb_hardware_start_transfer();
    82b0:	4b11      	ldr	r3, [pc, #68]	; (82f8 <grid_module_po16_revb_hardware_transfer_complete_cb+0x258>)
    82b2:	4798      	blx	r3
    82b4:	e6ff      	b.n	80b6 <grid_module_po16_revb_hardware_transfer_complete_cb+0x16>
    82b6:	f04f 0901 	mov.w	r9, #1
    82ba:	e7bd      	b.n	8238 <grid_module_po16_revb_hardware_transfer_complete_cb+0x198>
    82bc:	f3af 8000 	nop.w
    82c0:	47ae147b 	.word	0x47ae147b
    82c4:	3ff07ae1 	.word	0x3ff07ae1
    82c8:	200007fd 	.word	0x200007fd
    82cc:	2000f008 	.word	0x2000f008
    82d0:	20000339 	.word	0x20000339
    82d4:	41008000 	.word	0x41008000
    82d8:	2001cd84 	.word	0x2001cd84
    82dc:	2001cf58 	.word	0x2001cf58
    82e0:	000098a5 	.word	0x000098a5
    82e4:	00015cd8 	.word	0x00015cd8
    82e8:	000046b1 	.word	0x000046b1
    82ec:	2000effc 	.word	0x2000effc
    82f0:	000046c1 	.word	0x000046c1
    82f4:	0000a149 	.word	0x0000a149
    82f8:	00008081 	.word	0x00008081
    82fc:	0000a49d 	.word	0x0000a49d
    8300:	0000e539 	.word	0x0000e539
    8304:	00013d45 	.word	0x00013d45
    8308:	00013e19 	.word	0x00013e19
    830c:	0001423d 	.word	0x0001423d
    8310:	000045e9 	.word	0x000045e9

00008314 <grid_module_po16_revb_hardware_init>:

void grid_module_po16_revb_hardware_init(void){
    8314:	b570      	push	{r4, r5, r6, lr}
	
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    8316:	4c0b      	ldr	r4, [pc, #44]	; (8344 <grid_module_po16_revb_hardware_init+0x30>)
    8318:	4e0b      	ldr	r6, [pc, #44]	; (8348 <grid_module_po16_revb_hardware_init+0x34>)
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    831a:	4d0c      	ldr	r5, [pc, #48]	; (834c <grid_module_po16_revb_hardware_init+0x38>)
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    831c:	4b0c      	ldr	r3, [pc, #48]	; (8350 <grid_module_po16_revb_hardware_init+0x3c>)
    831e:	2200      	movs	r2, #0
    8320:	4611      	mov	r1, r2
    8322:	4620      	mov	r0, r4
    8324:	47b0      	blx	r6
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    8326:	2200      	movs	r2, #0
    8328:	4b09      	ldr	r3, [pc, #36]	; (8350 <grid_module_po16_revb_hardware_init+0x3c>)
    832a:	4611      	mov	r1, r2
    832c:	4628      	mov	r0, r5
    832e:	47b0      	blx	r6
		
	adc_async_enable_channel(&ADC_0, 0);
    8330:	4620      	mov	r0, r4
    8332:	4c08      	ldr	r4, [pc, #32]	; (8354 <grid_module_po16_revb_hardware_init+0x40>)
    8334:	2100      	movs	r1, #0
    8336:	47a0      	blx	r4
	adc_async_enable_channel(&ADC_1, 0);
    8338:	4628      	mov	r0, r5
    833a:	4623      	mov	r3, r4
    833c:	2100      	movs	r1, #0

}
    833e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	adc_async_enable_channel(&ADC_1, 0);
    8342:	4718      	bx	r3
    8344:	2001cd84 	.word	0x2001cd84
    8348:	0000e4c1 	.word	0x0000e4c1
    834c:	2001cf58 	.word	0x2001cf58
    8350:	000080a1 	.word	0x000080a1
    8354:	0000e481 	.word	0x0000e481

00008358 <grid_module_po16_revb_init>:




void grid_module_po16_revb_init(){
    8358:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	// 16 pot, depth of 5, 14bit internal, 7bit result;
	grid_ain_init(16, 5, 14, 7);
    835c:	220e      	movs	r2, #14
    835e:	4c15      	ldr	r4, [pc, #84]	; (83b4 <grid_module_po16_revb_init+0x5c>)
	
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
	
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){	
		
		grid_ui_bank_init(&grid_ui_state, i, 16);
    8360:	4e15      	ldr	r6, [pc, #84]	; (83b8 <grid_module_po16_revb_init+0x60>)
    8362:	4f16      	ldr	r7, [pc, #88]	; (83bc <grid_module_po16_revb_init+0x64>)
		
		for(uint8_t j=0; j<16; j++){
			
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    8364:	f8df 806c 	ldr.w	r8, [pc, #108]	; 83d4 <grid_module_po16_revb_init+0x7c>
	grid_ain_init(16, 5, 14, 7);
    8368:	2307      	movs	r3, #7
    836a:	2105      	movs	r1, #5
    836c:	2010      	movs	r0, #16
    836e:	47a0      	blx	r4
	grid_led_lowlevel_init(&grid_led_state, 16);
    8370:	4b13      	ldr	r3, [pc, #76]	; (83c0 <grid_module_po16_revb_init+0x68>)
    8372:	4814      	ldr	r0, [pc, #80]	; (83c4 <grid_module_po16_revb_init+0x6c>)
    8374:	2110      	movs	r1, #16
    8376:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
    8378:	480f      	ldr	r0, [pc, #60]	; (83b8 <grid_module_po16_revb_init+0x60>)
    837a:	4b13      	ldr	r3, [pc, #76]	; (83c8 <grid_module_po16_revb_init+0x70>)
    837c:	2104      	movs	r1, #4
    837e:	4798      	blx	r3
    8380:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 16);
    8382:	2210      	movs	r2, #16
    8384:	b2e1      	uxtb	r1, r4
    8386:	4630      	mov	r0, r6
    8388:	47b8      	blx	r7
		for(uint8_t j=0; j<16; j++){
    838a:	ea4f 1904 	mov.w	r9, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 16);
    838e:	2500      	movs	r5, #0
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    8390:	6870      	ldr	r0, [r6, #4]
    8392:	b2e9      	uxtb	r1, r5
    8394:	2201      	movs	r2, #1
    8396:	4448      	add	r0, r9
    8398:	3501      	adds	r5, #1
    839a:	47c0      	blx	r8
		for(uint8_t j=0; j<16; j++){
    839c:	2d10      	cmp	r5, #16
    839e:	d1f7      	bne.n	8390 <grid_module_po16_revb_init+0x38>
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){	
    83a0:	3401      	adds	r4, #1
    83a2:	2c04      	cmp	r4, #4
    83a4:	d1ed      	bne.n	8382 <grid_module_po16_revb_init+0x2a>

		}
	}
	
	grid_module_po16_revb_hardware_init();
    83a6:	4b09      	ldr	r3, [pc, #36]	; (83cc <grid_module_po16_revb_init+0x74>)
    83a8:	4798      	blx	r3
	grid_module_po16_revb_hardware_start_transfer();
	
    83aa:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_po16_revb_hardware_start_transfer();
    83ae:	4b08      	ldr	r3, [pc, #32]	; (83d0 <grid_module_po16_revb_init+0x78>)
    83b0:	4718      	bx	r3
    83b2:	bf00      	nop
    83b4:	000045a5 	.word	0x000045a5
    83b8:	2000effc 	.word	0x2000effc
    83bc:	00009a5d 	.word	0x00009a5d
    83c0:	00006ed1 	.word	0x00006ed1
    83c4:	2001c838 	.word	0x2001c838
    83c8:	00009a29 	.word	0x00009a29
    83cc:	00008315 	.word	0x00008315
    83d0:	00008081 	.word	0x00008081
    83d4:	0000a389 	.word	0x0000a389

000083d8 <grid_msg_header_set_len>:

#include "grid_msg.h"


// ======================= GRID MSG LEN ======================//
void	grid_msg_header_set_len(struct grid_msg* msg, uint8_t len){
    83d8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    83da:	2200      	movs	r2, #0
    83dc:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_LEN_offset, GRID_BRC_LEN_length, len, &error);
    83e0:	f10d 020f 	add.w	r2, sp, #15
    83e4:	9200      	str	r2, [sp, #0]
    83e6:	2202      	movs	r2, #2
void	grid_msg_header_set_len(struct grid_msg* msg, uint8_t len){
    83e8:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_LEN_offset, GRID_BRC_LEN_length, len, &error);
    83ea:	4c02      	ldr	r4, [pc, #8]	; (83f4 <grid_msg_header_set_len+0x1c>)
    83ec:	4611      	mov	r1, r2
    83ee:	47a0      	blx	r4
	
}
    83f0:	b004      	add	sp, #16
    83f2:	bd10      	pop	{r4, pc}
    83f4:	000099e5 	.word	0x000099e5

000083f8 <grid_msg_header_set_id>:
	uint8_t error = 0;
	return grid_msg_get_parameter(msg->header, GRID_BRC_LEN_offset, GRID_BRC_LEN_length, &error);
}

// ======================= GRID MSG ID ======================//
void	grid_msg_header_set_id(struct grid_msg* msg, uint8_t id){
    83f8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    83fa:	2200      	movs	r2, #0
    83fc:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_ID_offset, GRID_BRC_ID_length, id, &error);
    8400:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_id(struct grid_msg* msg, uint8_t id){
    8404:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_ID_offset, GRID_BRC_ID_length, id, &error);
    8406:	9200      	str	r2, [sp, #0]
    8408:	4c02      	ldr	r4, [pc, #8]	; (8414 <grid_msg_header_set_id+0x1c>)
    840a:	2202      	movs	r2, #2
    840c:	2104      	movs	r1, #4
    840e:	47a0      	blx	r4
	
}
    8410:	b004      	add	sp, #16
    8412:	bd10      	pop	{r4, pc}
    8414:	000099e5 	.word	0x000099e5

00008418 <grid_msg_header_set_dx>:
	uint8_t error = 0;
	return grid_msg_get_parameter(msg->header, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
}

// ======================= GRID MSG DX ======================//
void	grid_msg_header_set_dx(struct grid_msg* msg, uint8_t dx){
    8418:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    841a:	2200      	movs	r2, #0
    841c:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_DX_offset, GRID_BRC_DX_length, dx, &error);
    8420:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_dx(struct grid_msg* msg, uint8_t dx){
    8424:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_DX_offset, GRID_BRC_DX_length, dx, &error);
    8426:	9200      	str	r2, [sp, #0]
    8428:	4c02      	ldr	r4, [pc, #8]	; (8434 <grid_msg_header_set_dx+0x1c>)
    842a:	2202      	movs	r2, #2
    842c:	2106      	movs	r1, #6
    842e:	47a0      	blx	r4
	
}
    8430:	b004      	add	sp, #16
    8432:	bd10      	pop	{r4, pc}
    8434:	000099e5 	.word	0x000099e5

00008438 <grid_msg_header_get_dx>:


uint8_t grid_msg_header_get_dx(struct grid_msg* msg){
    8438:	b513      	push	{r0, r1, r4, lr}
	
	uint8_t error = 0;
    843a:	2300      	movs	r3, #0
    843c:	f88d 3007 	strb.w	r3, [sp, #7]
	return grid_msg_get_parameter(msg->header, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    8440:	4c04      	ldr	r4, [pc, #16]	; (8454 <grid_msg_header_get_dx+0x1c>)
    8442:	f10d 0307 	add.w	r3, sp, #7
    8446:	2202      	movs	r2, #2
    8448:	2106      	movs	r1, #6
    844a:	47a0      	blx	r4
}
    844c:	b2c0      	uxtb	r0, r0
    844e:	b002      	add	sp, #8
    8450:	bd10      	pop	{r4, pc}
    8452:	bf00      	nop
    8454:	000099cd 	.word	0x000099cd

00008458 <grid_msg_header_set_dy>:

// ======================= GRID MSG DY ======================//
void	grid_msg_header_set_dy(struct grid_msg* msg, uint8_t dy){
    8458:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    845a:	2200      	movs	r2, #0
    845c:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_DY_offset, GRID_BRC_DY_length, dy, &error);
    8460:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_dy(struct grid_msg* msg, uint8_t dy){
    8464:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_DY_offset, GRID_BRC_DY_length, dy, &error);
    8466:	9200      	str	r2, [sp, #0]
    8468:	4c02      	ldr	r4, [pc, #8]	; (8474 <grid_msg_header_set_dy+0x1c>)
    846a:	2202      	movs	r2, #2
    846c:	2108      	movs	r1, #8
    846e:	47a0      	blx	r4
	
}
    8470:	b004      	add	sp, #16
    8472:	bd10      	pop	{r4, pc}
    8474:	000099e5 	.word	0x000099e5

00008478 <grid_msg_header_get_dy>:


uint8_t grid_msg_header_get_dy(struct grid_msg* msg){
    8478:	b513      	push	{r0, r1, r4, lr}
	
	uint8_t error = 0;
    847a:	2300      	movs	r3, #0
    847c:	f88d 3007 	strb.w	r3, [sp, #7]
	return grid_msg_get_parameter(msg->header, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    8480:	4c04      	ldr	r4, [pc, #16]	; (8494 <grid_msg_header_get_dy+0x1c>)
    8482:	f10d 0307 	add.w	r3, sp, #7
    8486:	2202      	movs	r2, #2
    8488:	2108      	movs	r1, #8
    848a:	47a0      	blx	r4
}
    848c:	b2c0      	uxtb	r0, r0
    848e:	b002      	add	sp, #8
    8490:	bd10      	pop	{r4, pc}
    8492:	bf00      	nop
    8494:	000099cd 	.word	0x000099cd

00008498 <grid_msg_header_set_rot>:

// ======================= GRID MSG ROT ======================//
void	grid_msg_header_set_rot(struct grid_msg* msg, uint8_t rot){
    8498:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    849a:	2200      	movs	r2, #0
    849c:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, rot, &error);
    84a0:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_rot(struct grid_msg* msg, uint8_t rot){
    84a4:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, rot, &error);
    84a6:	9200      	str	r2, [sp, #0]
    84a8:	4c02      	ldr	r4, [pc, #8]	; (84b4 <grid_msg_header_set_rot+0x1c>)
    84aa:	2202      	movs	r2, #2
    84ac:	210c      	movs	r1, #12
    84ae:	47a0      	blx	r4
	
}
    84b0:	b004      	add	sp, #16
    84b2:	bd10      	pop	{r4, pc}
    84b4:	000099e5 	.word	0x000099e5

000084b8 <grid_msg_header_set_age>:
	uint8_t error = 0;
	return grid_msg_get_parameter(msg->header, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, &error);
}

// ======================= GRID MSG AGE ======================//
void	grid_msg_header_set_age(struct grid_msg* msg, uint8_t age){
    84b8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    84ba:	2200      	movs	r2, #0
    84bc:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, age, &error);
    84c0:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_age(struct grid_msg* msg, uint8_t age){
    84c4:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, age, &error);
    84c6:	9200      	str	r2, [sp, #0]
    84c8:	4c02      	ldr	r4, [pc, #8]	; (84d4 <grid_msg_header_set_age+0x1c>)
    84ca:	2202      	movs	r2, #2
    84cc:	210a      	movs	r1, #10
    84ce:	47a0      	blx	r4
	
}
    84d0:	b004      	add	sp, #16
    84d2:	bd10      	pop	{r4, pc}
    84d4:	000099e5 	.word	0x000099e5

000084d8 <grid_msg_packet_get_length>:
}

// ======================= MSG GET PACKET LENGTH ======================//
uint32_t grid_msg_packet_get_length(struct grid_msg* msg){
	
	return (msg->header_length + msg->body_length + msg->footer_length);
    84d8:	e9d0 3264 	ldrd	r3, r2, [r0, #400]	; 0x190
    84dc:	f8d0 0198 	ldr.w	r0, [r0, #408]	; 0x198
    84e0:	4413      	add	r3, r2
}
    84e2:	4418      	add	r0, r3
    84e4:	4770      	bx	lr

000084e6 <grid_msg_body_get_length>:

// ======================= MSG GET BODY LENGTH ======================//
uint32_t grid_msg_body_get_length(struct grid_msg* msg){
	
	return (msg->body_length);
}
    84e6:	f8d0 0194 	ldr.w	r0, [r0, #404]	; 0x194
    84ea:	4770      	bx	lr

000084ec <grid_msg_body_append_text>:
	
	return (msg->footer_length);
}


void	grid_msg_body_append_text(struct grid_msg* msg, uint8_t* str, uint32_t len){
    84ec:	b570      	push	{r4, r5, r6, lr}
    84ee:	f8d0 5194 	ldr.w	r5, [r0, #404]	; 0x194

	
	for(uint32_t i=0; i<len; i++){
    84f2:	2300      	movs	r3, #0
    84f4:	4293      	cmp	r3, r2
    84f6:	d103      	bne.n	8500 <grid_msg_body_append_text+0x14>
		
		msg->body[msg->body_length + i] = str[i];
	}
	
	msg->body_length += len;
    84f8:	442b      	add	r3, r5
    84fa:	f8c0 3194 	str.w	r3, [r0, #404]	; 0x194

}
    84fe:	bd70      	pop	{r4, r5, r6, pc}
		msg->body[msg->body_length + i] = str[i];
    8500:	18c4      	adds	r4, r0, r3
    8502:	442c      	add	r4, r5
    8504:	5cce      	ldrb	r6, [r1, r3]
    8506:	7526      	strb	r6, [r4, #20]
	for(uint32_t i=0; i<len; i++){
    8508:	3301      	adds	r3, #1
    850a:	e7f3      	b.n	84f4 <grid_msg_body_append_text+0x8>

0000850c <grid_msg_body_append_text_escaped>:

void	grid_msg_body_append_text_escaped(struct grid_msg* msg, uint8_t* str, uint32_t len){
    850c:	b5f0      	push	{r4, r5, r6, r7, lr}
    850e:	f8d0 6194 	ldr.w	r6, [r0, #404]	; 0x194
	
	for(uint32_t i=0; i<len; i++){
    8512:	2400      	movs	r4, #0
		
		if (str[i] == GRID_CONST_STX){
			msg->body[msg->body_length + i] = GRID_CONST_STX+128;
		}
		else if (str[i] == GRID_CONST_ETX){
			msg->body[msg->body_length + i] = GRID_CONST_ETX+128;
    8514:	2783      	movs	r7, #131	; 0x83
			msg->body[msg->body_length + i] = GRID_CONST_STX+128;
    8516:	f04f 0c82 	mov.w	ip, #130	; 0x82
	for(uint32_t i=0; i<len; i++){
    851a:	4294      	cmp	r4, r2
    851c:	eb04 0306 	add.w	r3, r4, r6
    8520:	d102      	bne.n	8528 <grid_msg_body_append_text_escaped+0x1c>
			msg->body[msg->body_length + i] = str[i];
		}
		
	}
	
	msg->body_length += len;
    8522:	f8c0 3194 	str.w	r3, [r0, #404]	; 0x194

}
    8526:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (str[i] == GRID_CONST_STX){
    8528:	5d0d      	ldrb	r5, [r1, r4]
    852a:	2d02      	cmp	r5, #2
    852c:	4403      	add	r3, r0
    852e:	d103      	bne.n	8538 <grid_msg_body_append_text_escaped+0x2c>
			msg->body[msg->body_length + i] = GRID_CONST_STX+128;
    8530:	f883 c014 	strb.w	ip, [r3, #20]
	for(uint32_t i=0; i<len; i++){
    8534:	3401      	adds	r4, #1
    8536:	e7f0      	b.n	851a <grid_msg_body_append_text_escaped+0xe>
		else if (str[i] == GRID_CONST_ETX){
    8538:	2d03      	cmp	r5, #3
			msg->body[msg->body_length + i] = GRID_CONST_ETX+128;
    853a:	bf0c      	ite	eq
    853c:	751f      	strbeq	r7, [r3, #20]
			msg->body[msg->body_length + i] = str[i];
    853e:	751d      	strbne	r5, [r3, #20]
    8540:	e7f8      	b.n	8534 <grid_msg_body_append_text_escaped+0x28>
	...

00008544 <grid_msg_text_get_parameter>:


uint32_t grid_msg_text_get_parameter(struct grid_msg* msg, uint32_t text_start_offset, uint8_t parameter_offset, uint8_t parameter_length){
    8544:	b420      	push	{r5}
	
	uint8_t error;
	
	return grid_sys_read_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, error);
    8546:	f101 0514 	add.w	r5, r1, #20
    854a:	4415      	add	r5, r2
    854c:	4619      	mov	r1, r3
    854e:	4428      	add	r0, r5
    8550:	4b02      	ldr	r3, [pc, #8]	; (855c <grid_msg_text_get_parameter+0x18>)
	
}
    8552:	f85d 5b04 	ldr.w	r5, [sp], #4
	return grid_sys_read_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, error);
    8556:	2200      	movs	r2, #0
    8558:	4718      	bx	r3
    855a:	bf00      	nop
    855c:	00009819 	.word	0x00009819

00008560 <grid_msg_text_set_parameter>:

void grid_msg_text_set_parameter(struct grid_msg* msg, uint32_t text_start_offset, uint8_t parameter_offset, uint8_t parameter_length, uint32_t value){
    8560:	b420      	push	{r5}
	
	return grid_sys_write_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, value);
    8562:	f101 0514 	add.w	r5, r1, #20
    8566:	4415      	add	r5, r2
    8568:	4619      	mov	r1, r3
    856a:	9a01      	ldr	r2, [sp, #4]
    856c:	4b02      	ldr	r3, [pc, #8]	; (8578 <grid_msg_text_set_parameter+0x18>)
    856e:	4428      	add	r0, r5
	
}
    8570:	f85d 5b04 	ldr.w	r5, [sp], #4
	return grid_sys_write_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, value);
    8574:	4718      	bx	r3
    8576:	bf00      	nop
    8578:	00009841 	.word	0x00009841

0000857c <grid_msg_init>:


// ======================= GRID MSG INIT ======================//
void	grid_msg_init(struct grid_msg* msg){
	
	msg->header_length = 0;
    857c:	2300      	movs	r3, #0
	msg->body_length = 0;
    857e:	e9c0 3364 	strd	r3, r3, [r0, #400]	; 0x190
	msg->footer_length = 0;
    8582:	f8c0 3198 	str.w	r3, [r0, #408]	; 0x198
	
	for (uint32_t i=0; i<GRID_MSG_HEADER_maxlength; i++)
    8586:	1e42      	subs	r2, r0, #1
    8588:	f100 0113 	add.w	r1, r0, #19
	{
		msg->header[i] = 0;
    858c:	f802 3f01 	strb.w	r3, [r2, #1]!
	for (uint32_t i=0; i<GRID_MSG_HEADER_maxlength; i++)
    8590:	4291      	cmp	r1, r2
    8592:	d1fb      	bne.n	858c <grid_msg_init+0x10>
    8594:	f100 0214 	add.w	r2, r0, #20
    8598:	f200 118b 	addw	r1, r0, #395	; 0x18b
	}
	
	for (uint32_t i=0; i<GRID_MSG_BODY_maxlength; i++)
	{
		msg->body[i] = 0;
    859c:	2300      	movs	r3, #0
    859e:	f802 3b01 	strb.w	r3, [r2], #1
	for (uint32_t i=0; i<GRID_MSG_BODY_maxlength; i++)
    85a2:	428a      	cmp	r2, r1
    85a4:	d1fb      	bne.n	859e <grid_msg_init+0x22>
	}
	
	for (uint32_t i=0; i<GRID_MSG_FOOTER_maxlength; i++)
	{
		msg->footer[i] = 0;
    85a6:	f880 318b 	strb.w	r3, [r0, #395]	; 0x18b
    85aa:	f8c0 318c 	str.w	r3, [r0, #396]	; 0x18c
	}
	
		
}
    85ae:	4770      	bx	lr

000085b0 <grid_msg_init_header>:

// ======================= MSG INIT HEADER======================//

void	grid_msg_init_header(struct grid_msg* msg, uint8_t dx, uint8_t dy, uint8_t rot){
    85b0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    85b4:	461e      	mov	r6, r3
	
    
    uint8_t age = grid_sys_state.sessionid;
    85b6:	4b13      	ldr	r3, [pc, #76]	; (8604 <grid_msg_init_header+0x54>)
    
	sprintf(msg->header, GRID_BRC_frame);
    85b8:	f8df 9064 	ldr.w	r9, [pc, #100]	; 8620 <grid_msg_init_header+0x70>
    uint8_t age = grid_sys_state.sessionid;
    85bc:	795d      	ldrb	r5, [r3, #5]
	sprintf(msg->header, GRID_BRC_frame);
    85be:	2317      	movs	r3, #23
void	grid_msg_init_header(struct grid_msg* msg, uint8_t dx, uint8_t dy, uint8_t rot){
    85c0:	4604      	mov	r4, r0
    85c2:	4688      	mov	r8, r1
    85c4:	4617      	mov	r7, r2
	sprintf(msg->header, GRID_BRC_frame);
    85c6:	4910      	ldr	r1, [pc, #64]	; (8608 <grid_msg_init_header+0x58>)
    85c8:	9300      	str	r3, [sp, #0]
    85ca:	2201      	movs	r2, #1
    85cc:	230f      	movs	r3, #15
    85ce:	47c8      	blx	r9
	msg->header_length = strlen(msg->header);
    85d0:	4b0e      	ldr	r3, [pc, #56]	; (860c <grid_msg_init_header+0x5c>)
    85d2:	4620      	mov	r0, r4
    85d4:	4798      	blx	r3
	
	grid_msg_header_set_dx(msg, dx);
    85d6:	4641      	mov	r1, r8
	msg->header_length = strlen(msg->header);
    85d8:	f8c4 0190 	str.w	r0, [r4, #400]	; 0x190
	grid_msg_header_set_dx(msg, dx);
    85dc:	4b0c      	ldr	r3, [pc, #48]	; (8610 <grid_msg_init_header+0x60>)
    85de:	4620      	mov	r0, r4
    85e0:	4798      	blx	r3
	grid_msg_header_set_dy(msg, dy);
    85e2:	4639      	mov	r1, r7
    85e4:	4620      	mov	r0, r4
    85e6:	4b0b      	ldr	r3, [pc, #44]	; (8614 <grid_msg_init_header+0x64>)
    85e8:	4798      	blx	r3
	grid_msg_header_set_rot(msg, rot);
    85ea:	4631      	mov	r1, r6
    85ec:	4620      	mov	r0, r4
    85ee:	4b0a      	ldr	r3, [pc, #40]	; (8618 <grid_msg_init_header+0x68>)
    85f0:	4798      	blx	r3
    uint8_t age = grid_sys_state.sessionid;
    85f2:	b2ed      	uxtb	r5, r5
	grid_msg_header_set_age(msg, age);
    85f4:	4b09      	ldr	r3, [pc, #36]	; (861c <grid_msg_init_header+0x6c>)
    85f6:	4629      	mov	r1, r5
    85f8:	4620      	mov	r0, r4
	
	
}
    85fa:	b003      	add	sp, #12
    85fc:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	grid_msg_header_set_age(msg, age);
    8600:	4718      	bx	r3
    8602:	bf00      	nop
    8604:	2000f008 	.word	0x2000f008
    8608:	00015ce8 	.word	0x00015ce8
    860c:	0001480f 	.word	0x0001480f
    8610:	00008419 	.word	0x00008419
    8614:	00008459 	.word	0x00008459
    8618:	00008499 	.word	0x00008499
    861c:	000084b9 	.word	0x000084b9
    8620:	00014791 	.word	0x00014791

00008624 <grid_msg_packet_receive_char>:

// ======================= MSG RECEIVE CHAR ======================//
void	grid_msg_packet_receive_char(struct grid_msg* msg, uint8_t nextchar){
	
	if (msg->body_length == 0){
    8624:	f8d0 2194 	ldr.w	r2, [r0, #404]	; 0x194
    8628:	b96a      	cbnz	r2, 8646 <grid_msg_packet_receive_char+0x22>
		
		if (nextchar != GRID_CONST_EOB){
    862a:	2917      	cmp	r1, #23
			msg->header[msg->header_length] = nextchar;
    862c:	bf15      	itete	ne
    862e:	f8d0 3190 	ldrne.w	r3, [r0, #400]	; 0x190
			msg->header_length++;
		}
		else{
			msg->body[msg->body_length] = nextchar;
    8632:	7501      	strbeq	r1, [r0, #20]
			msg->header[msg->header_length] = nextchar;
    8634:	54c1      	strbne	r1, [r0, r3]
			msg->body_length++;
    8636:	2301      	moveq	r3, #1
			msg->header_length++;
    8638:	bf1a      	itte	ne
    863a:	3301      	addne	r3, #1
    863c:	f8c0 3190 	strne.w	r3, [r0, #400]	; 0x190
			msg->body_length++;
    8640:	f8c0 3194 	streq.w	r3, [r0, #404]	; 0x194
    8644:	4770      	bx	lr
			
		}
		
	}
	else if(msg->footer_length == 0){
    8646:	f8d0 3198 	ldr.w	r3, [r0, #408]	; 0x198
    864a:	b96b      	cbnz	r3, 8668 <grid_msg_packet_receive_char+0x44>
		
		if (nextchar != GRID_CONST_EOT){
    864c:	2904      	cmp	r1, #4
    864e:	d005      	beq.n	865c <grid_msg_packet_receive_char+0x38>
			msg->body[msg->body_length] = nextchar;
    8650:	1883      	adds	r3, r0, r2
			msg->body_length++;
    8652:	3201      	adds	r2, #1
			msg->body[msg->body_length] = nextchar;
    8654:	7519      	strb	r1, [r3, #20]
			msg->body_length++;
    8656:	f8c0 2194 	str.w	r2, [r0, #404]	; 0x194
    865a:	4770      	bx	lr
		}
		else{
			msg->footer[msg->footer_length] = nextchar;
    865c:	f880 118b 	strb.w	r1, [r0, #395]	; 0x18b
			msg->footer_length++;
    8660:	2301      	movs	r3, #1
		
	}
	else{
		
		msg->footer[msg->footer_length] = nextchar;
		msg->footer_length++;
    8662:	f8c0 3198 	str.w	r3, [r0, #408]	; 0x198
		
	}
	
}
    8666:	4770      	bx	lr
		msg->footer[msg->footer_length] = nextchar;
    8668:	18c2      	adds	r2, r0, r3
		msg->footer_length++;
    866a:	3301      	adds	r3, #1
		msg->footer[msg->footer_length] = nextchar;
    866c:	f882 118b 	strb.w	r1, [r2, #395]	; 0x18b
		msg->footer_length++;
    8670:	e7f7      	b.n	8662 <grid_msg_packet_receive_char+0x3e>

00008672 <grid_msg_packet_send_char>:

// ======================= GRID MSG SEND CHAR ======================//

uint8_t	grid_msg_packet_send_char(struct grid_msg* msg, uint32_t charindex){
	
	if (charindex < msg->header_length){
    8672:	f8d0 2190 	ldr.w	r2, [r0, #400]	; 0x190
    8676:	428a      	cmp	r2, r1
    8678:	d901      	bls.n	867e <grid_msg_packet_send_char+0xc>
		
		return msg->header[charindex];
    867a:	5c40      	ldrb	r0, [r0, r1]
    867c:	4770      	bx	lr
	}
	else if (charindex < msg->body_length + msg->header_length){
    867e:	f8d0 3194 	ldr.w	r3, [r0, #404]	; 0x194
    8682:	4413      	add	r3, r2
    8684:	428b      	cmp	r3, r1
    8686:	d903      	bls.n	8690 <grid_msg_packet_send_char+0x1e>
	
		return msg->body[charindex - msg->header_length];
    8688:	1a89      	subs	r1, r1, r2
    868a:	4408      	add	r0, r1
    868c:	7d00      	ldrb	r0, [r0, #20]
    868e:	4770      	bx	lr
	}
	else if (charindex < msg->footer_length + msg->body_length + msg->header_length){
    8690:	f8d0 2198 	ldr.w	r2, [r0, #408]	; 0x198
    8694:	441a      	add	r2, r3
    8696:	428a      	cmp	r2, r1
	
		return msg->footer[charindex - msg->header_length - msg->body_length];
    8698:	bf83      	ittte	hi
    869a:	1ac9      	subhi	r1, r1, r3
    869c:	1840      	addhi	r0, r0, r1
    869e:	f890 018b 	ldrbhi.w	r0, [r0, #395]	; 0x18b
	}
	else{
		// OVERRUN
		return -1;
    86a2:	20ff      	movls	r0, #255	; 0xff
	}
	
	
}
    86a4:	4770      	bx	lr
	...

000086a8 <grid_msg_packet_close>:



uint8_t	grid_msg_packet_close(struct grid_msg* msg){
    86a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    86aa:	4604      	mov	r4, r0
	
	
	sprintf(&msg->footer[msg->footer_length], "%c", GRID_CONST_EOT);
    86ac:	f8d0 0198 	ldr.w	r0, [r0, #408]	; 0x198
    86b0:	492b      	ldr	r1, [pc, #172]	; (8760 <grid_msg_packet_close+0xb8>)
    86b2:	4d2c      	ldr	r5, [pc, #176]	; (8764 <grid_msg_packet_close+0xbc>)
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    86b4:	4e2c      	ldr	r6, [pc, #176]	; (8768 <grid_msg_packet_close+0xc0>)
	sprintf(&msg->footer[msg->footer_length], "%c", GRID_CONST_EOT);
    86b6:	f200 108b 	addw	r0, r0, #395	; 0x18b
    86ba:	2204      	movs	r2, #4
    86bc:	4420      	add	r0, r4
    86be:	47a8      	blx	r5
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    86c0:	f8d4 7198 	ldr.w	r7, [r4, #408]	; 0x198
    86c4:	f207 108b 	addw	r0, r7, #395	; 0x18b
    86c8:	4420      	add	r0, r4
    86ca:	47b0      	blx	r6
	
	grid_msg_header_set_len(msg, msg->header_length + msg->body_length + msg->footer_length);
    86cc:	e9d4 3164 	ldrd	r3, r1, [r4, #400]	; 0x190
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    86d0:	4438      	add	r0, r7
	grid_msg_header_set_len(msg, msg->header_length + msg->body_length + msg->footer_length);
    86d2:	440b      	add	r3, r1
	grid_msg_header_set_id(msg, grid_sys_state.next_broadcast_message_id);	
    86d4:	4f25      	ldr	r7, [pc, #148]	; (876c <grid_msg_packet_close+0xc4>)
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    86d6:	f8c4 0198 	str.w	r0, [r4, #408]	; 0x198
	grid_msg_header_set_len(msg, msg->header_length + msg->body_length + msg->footer_length);
    86da:	1819      	adds	r1, r3, r0
    86dc:	b2c9      	uxtb	r1, r1
    86de:	4b24      	ldr	r3, [pc, #144]	; (8770 <grid_msg_packet_close+0xc8>)
    86e0:	4620      	mov	r0, r4
    86e2:	4798      	blx	r3
	grid_msg_header_set_id(msg, grid_sys_state.next_broadcast_message_id);	
    86e4:	f897 10ad 	ldrb.w	r1, [r7, #173]	; 0xad
    86e8:	4b22      	ldr	r3, [pc, #136]	; (8774 <grid_msg_packet_close+0xcc>)
    86ea:	4620      	mov	r0, r4
    86ec:	4798      	blx	r3
	
	grid_sys_state.next_broadcast_message_id++;
    86ee:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
    86f2:	3301      	adds	r3, #1
    86f4:	b2db      	uxtb	r3, r3
    86f6:	f887 30ad 	strb.w	r3, [r7, #173]	; 0xad
	
	
	uint8_t checksum = 0;
	
	for (uint32_t i=0; i<msg->header_length; i++){
    86fa:	f8d4 3190 	ldr.w	r3, [r4, #400]	; 0x190
    86fe:	4621      	mov	r1, r4
    8700:	4423      	add	r3, r4
	uint8_t checksum = 0;
    8702:	2200      	movs	r2, #0
	for (uint32_t i=0; i<msg->header_length; i++){
    8704:	4299      	cmp	r1, r3
    8706:	d11f      	bne.n	8748 <grid_msg_packet_close+0xa0>
    8708:	f8d4 3194 	ldr.w	r3, [r4, #404]	; 0x194
    870c:	4423      	add	r3, r4
    870e:	f104 0114 	add.w	r1, r4, #20
    8712:	3314      	adds	r3, #20
		checksum ^= msg->header[i];
	}
		
	for (uint32_t i=0; i<msg->body_length; i++){
    8714:	4299      	cmp	r1, r3
    8716:	d11b      	bne.n	8750 <grid_msg_packet_close+0xa8>
		checksum ^= msg->body[i];
	}
		
	for (uint32_t i=0; i<msg->footer_length; i++){
    8718:	f8d4 0198 	ldr.w	r0, [r4, #408]	; 0x198
    871c:	1823      	adds	r3, r4, r0
    871e:	f204 118b 	addw	r1, r4, #395	; 0x18b
    8722:	f203 138b 	addw	r3, r3, #395	; 0x18b
    8726:	4299      	cmp	r1, r3
    8728:	d116      	bne.n	8758 <grid_msg_packet_close+0xb0>
		checksum ^= msg->footer[i];
	}
	
	sprintf(&msg->footer[msg->footer_length], "%02x\n", checksum);
    872a:	f200 108b 	addw	r0, r0, #395	; 0x18b
    872e:	4912      	ldr	r1, [pc, #72]	; (8778 <grid_msg_packet_close+0xd0>)
    8730:	4420      	add	r0, r4
    8732:	47a8      	blx	r5
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    8734:	f8d4 5198 	ldr.w	r5, [r4, #408]	; 0x198
    8738:	f205 108b 	addw	r0, r5, #395	; 0x18b
    873c:	4420      	add	r0, r4
    873e:	47b0      	blx	r6
    8740:	4428      	add	r0, r5
    8742:	f8c4 0198 	str.w	r0, [r4, #408]	; 0x198
	
	
}
    8746:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		checksum ^= msg->header[i];
    8748:	f811 0b01 	ldrb.w	r0, [r1], #1
    874c:	4042      	eors	r2, r0
	for (uint32_t i=0; i<msg->header_length; i++){
    874e:	e7d9      	b.n	8704 <grid_msg_packet_close+0x5c>
		checksum ^= msg->body[i];
    8750:	f811 0b01 	ldrb.w	r0, [r1], #1
    8754:	4042      	eors	r2, r0
	for (uint32_t i=0; i<msg->body_length; i++){
    8756:	e7dd      	b.n	8714 <grid_msg_packet_close+0x6c>
		checksum ^= msg->footer[i];
    8758:	f811 7b01 	ldrb.w	r7, [r1], #1
    875c:	407a      	eors	r2, r7
	for (uint32_t i=0; i<msg->footer_length; i++){
    875e:	e7e2      	b.n	8726 <grid_msg_packet_close+0x7e>
    8760:	00015a3b 	.word	0x00015a3b
    8764:	00014791 	.word	0x00014791
    8768:	0001480f 	.word	0x0001480f
    876c:	2000f008 	.word	0x2000f008
    8770:	000083d9 	.word	0x000083d9
    8774:	000083f9 	.word	0x000083f9
    8778:	000166af 	.word	0x000166af

0000877c <grid_msg_packet_send_everywhere>:

uint8_t	grid_msg_packet_send_everywhere(struct grid_msg* msg){
    877c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	
	uint32_t message_length = grid_msg_packet_get_length(msg);
    8780:	4b0f      	ldr	r3, [pc, #60]	; (87c0 <grid_msg_packet_send_everywhere+0x44>)
uint8_t	grid_msg_packet_send_everywhere(struct grid_msg* msg){
    8782:	4606      	mov	r6, r0
	uint32_t message_length = grid_msg_packet_get_length(msg);
    8784:	4798      	blx	r3
	
	if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, message_length)){
    8786:	4b0f      	ldr	r3, [pc, #60]	; (87c4 <grid_msg_packet_send_everywhere+0x48>)
	uint32_t message_length = grid_msg_packet_get_length(msg);
    8788:	4604      	mov	r4, r0
	if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, message_length)){
    878a:	b281      	uxth	r1, r0
    878c:	480e      	ldr	r0, [pc, #56]	; (87c8 <grid_msg_packet_send_everywhere+0x4c>)
    878e:	4798      	blx	r3
    8790:	b978      	cbnz	r0, 87b2 <grid_msg_packet_send_everywhere+0x36>
		
		return 0;
	}
	
	
}
    8792:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(msg, i));
    8796:	4629      	mov	r1, r5
    8798:	4630      	mov	r0, r6
    879a:	47b8      	blx	r7
    879c:	4601      	mov	r1, r0
    879e:	4640      	mov	r0, r8
    87a0:	47c8      	blx	r9
		for(uint32_t i = 0; i<message_length; i++){
    87a2:	3501      	adds	r5, #1
    87a4:	42a5      	cmp	r5, r4
    87a6:	d1f6      	bne.n	8796 <grid_msg_packet_send_everywhere+0x1a>
		grid_buffer_write_acknowledge(&GRID_PORT_U.rx_buffer);
    87a8:	4807      	ldr	r0, [pc, #28]	; (87c8 <grid_msg_packet_send_everywhere+0x4c>)
    87aa:	4b08      	ldr	r3, [pc, #32]	; (87cc <grid_msg_packet_send_everywhere+0x50>)
    87ac:	4798      	blx	r3
		return 1;
    87ae:	2001      	movs	r0, #1
    87b0:	e7ef      	b.n	8792 <grid_msg_packet_send_everywhere+0x16>
			grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(msg, i));
    87b2:	4f07      	ldr	r7, [pc, #28]	; (87d0 <grid_msg_packet_send_everywhere+0x54>)
    87b4:	f8df 8010 	ldr.w	r8, [pc, #16]	; 87c8 <grid_msg_packet_send_everywhere+0x4c>
    87b8:	f8df 9018 	ldr.w	r9, [pc, #24]	; 87d4 <grid_msg_packet_send_everywhere+0x58>
		for(uint32_t i = 0; i<message_length; i++){
    87bc:	2500      	movs	r5, #0
    87be:	e7f1      	b.n	87a4 <grid_msg_packet_send_everywhere+0x28>
    87c0:	000084d9 	.word	0x000084d9
    87c4:	000047f1 	.word	0x000047f1
    87c8:	2000ebe4 	.word	0x2000ebe4
    87cc:	0000484d 	.word	0x0000484d
    87d0:	00008673 	.word	0x00008673
    87d4:	0000482d 	.word	0x0000482d

000087d8 <grid_nvm_ui_bulk_read_init>:
}


void grid_nvm_ui_bulk_read_init(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	nvm->read_bulk_page_index = 0;
    87d8:	2300      	movs	r3, #0
    87da:	f8c0 3424 	str.w	r3, [r0, #1060]	; 0x424
	nvm->read_bulk_status = 1;
    87de:	2301      	movs	r3, #1
    87e0:	f880 3428 	strb.w	r3, [r0, #1064]	; 0x428
			
}
    87e4:	4770      	bx	lr

000087e6 <grid_nvm_ui_bulk_read_is_in_progress>:

uint8_t grid_nvm_ui_bulk_read_is_in_progress(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	return nvm->read_bulk_status;
	
}
    87e6:	f890 0428 	ldrb.w	r0, [r0, #1064]	; 0x428
    87ea:	4770      	bx	lr

000087ec <grid_nvm_ui_bulk_read_next>:

void grid_nvm_ui_bulk_read_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    87ec:	b5f0      	push	{r4, r5, r6, r7, lr}
    87ee:	4604      	mov	r4, r0
    87f0:	b0ed      	sub	sp, #436	; 0x1b4
	
	if (nvm->read_bulk_status == 1){
    87f2:	f894 3428 	ldrb.w	r3, [r4, #1064]	; 0x428
    87f6:	2b01      	cmp	r3, #1
void grid_nvm_ui_bulk_read_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    87f8:	4608      	mov	r0, r1
	if (nvm->read_bulk_status == 1){
    87fa:	d12f      	bne.n	885c <grid_nvm_ui_bulk_read_next+0x70>
		uint8_t bank    = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
		uint8_t element = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
		uint8_t event   = nvm->read_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
		
		
		if (bank < ui->bank_list_length){
    87fc:	7849      	ldrb	r1, [r1, #1]
		uint8_t bank    = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    87fe:	f8d4 2424 	ldr.w	r2, [r4, #1060]	; 0x424
    8802:	23a0      	movs	r3, #160	; 0xa0
    8804:	fbb2 f3f3 	udiv	r3, r2, r3
    8808:	f003 0303 	and.w	r3, r3, #3
		if (bank < ui->bank_list_length){
    880c:	4299      	cmp	r1, r3
    880e:	d91c      	bls.n	884a <grid_nvm_ui_bulk_read_next+0x5e>
			
			if (element < ui->bank_list[bank].element_list_length){
    8810:	6845      	ldr	r5, [r0, #4]
    8812:	eb05 1303 	add.w	r3, r5, r3, lsl #4
		uint8_t element = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8816:	270a      	movs	r7, #10
			if (element < ui->bank_list[bank].element_list_length){
    8818:	7a5d      	ldrb	r5, [r3, #9]
		uint8_t element = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    881a:	fbb2 f1f7 	udiv	r1, r2, r7
    881e:	f001 060f 	and.w	r6, r1, #15
			if (element < ui->bank_list[bank].element_list_length){
    8822:	42b5      	cmp	r5, r6
    8824:	d911      	bls.n	884a <grid_nvm_ui_bulk_read_next+0x5e>
		uint8_t event   = nvm->read_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
    8826:	fb07 2111 	mls	r1, r7, r1, r2
				
				if (event < ui->bank_list[bank].element_list[element].event_list_length){
    882a:	68da      	ldr	r2, [r3, #12]
    882c:	2364      	movs	r3, #100	; 0x64
    882e:	fb06 2303 	mla	r3, r6, r3, r2
    8832:	b2ca      	uxtb	r2, r1
    8834:	f893 505c 	ldrb.w	r5, [r3, #92]	; 0x5c
    8838:	4295      	cmp	r5, r2
    883a:	d906      	bls.n	884a <grid_nvm_ui_bulk_read_next+0x5e>
					// Valid memory location
					
					int status = grid_ui_nvm_load_event_configuration(ui, nvm, &ui->bank_list[bank].element_list[element].event_list[event]);
    883c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    883e:	22bc      	movs	r2, #188	; 0xbc
    8840:	fb02 3201 	mla	r2, r2, r1, r3
    8844:	4b1f      	ldr	r3, [pc, #124]	; (88c4 <grid_nvm_ui_bulk_read_next+0xd8>)
    8846:	4621      	mov	r1, r4
    8848:	4798      	blx	r3
			}
	
		}
		
		
		if (nvm->read_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    884a:	f8d4 3424 	ldr.w	r3, [r4, #1060]	; 0x424
    884e:	f240 227e 	movw	r2, #638	; 0x27e
    8852:	4293      	cmp	r3, r2
    8854:	d804      	bhi.n	8860 <grid_nvm_ui_bulk_read_next+0x74>
			
			nvm->read_bulk_page_index++;
    8856:	3301      	adds	r3, #1
    8858:	f8c4 3424 	str.w	r3, [r4, #1060]	; 0x424
	}
	
	
	
	
}
    885c:	b06d      	add	sp, #436	; 0x1b4
    885e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			nvm->read_bulk_page_index = 0;
    8860:	2500      	movs	r5, #0
    8862:	f8c4 5424 	str.w	r5, [r4, #1060]	; 0x424
			nvm->read_bulk_status = 0;
    8866:	f884 5428 	strb.w	r5, [r4, #1064]	; 0x428
			grid_msg_init(&response);
    886a:	a805      	add	r0, sp, #20
    886c:	4b16      	ldr	r3, [pc, #88]	; (88c8 <grid_nvm_ui_bulk_read_next+0xdc>)
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    886e:	4c17      	ldr	r4, [pc, #92]	; (88cc <grid_nvm_ui_bulk_read_next+0xe0>)
			grid_msg_init(&response);
    8870:	4798      	blx	r3
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8872:	227f      	movs	r2, #127	; 0x7f
    8874:	462b      	mov	r3, r5
    8876:	4611      	mov	r1, r2
    8878:	a805      	add	r0, sp, #20
    887a:	47a0      	blx	r4
			sprintf(response_payload, GRID_CLASS_LOCALLOAD_frame);
    887c:	2303      	movs	r3, #3
    887e:	4914      	ldr	r1, [pc, #80]	; (88d0 <grid_nvm_ui_bulk_read_next+0xe4>)
    8880:	9300      	str	r3, [sp, #0]
    8882:	2202      	movs	r2, #2
    8884:	4c13      	ldr	r4, [pc, #76]	; (88d4 <grid_nvm_ui_bulk_read_next+0xe8>)
			uint8_t response_payload[10] = {0};
    8886:	f8ad 5010 	strh.w	r5, [sp, #16]
			sprintf(response_payload, GRID_CLASS_LOCALLOAD_frame);
    888a:	2371      	movs	r3, #113	; 0x71
    888c:	a802      	add	r0, sp, #8
			uint8_t response_payload[10] = {0};
    888e:	e9cd 5502 	strd	r5, r5, [sp, #8]
			sprintf(response_payload, GRID_CLASS_LOCALLOAD_frame);
    8892:	47a0      	blx	r4
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8894:	4b10      	ldr	r3, [pc, #64]	; (88d8 <grid_nvm_ui_bulk_read_next+0xec>)
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8896:	4c11      	ldr	r4, [pc, #68]	; (88dc <grid_nvm_ui_bulk_read_next+0xf0>)
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8898:	a802      	add	r0, sp, #8
    889a:	4798      	blx	r3
    889c:	a902      	add	r1, sp, #8
    889e:	4602      	mov	r2, r0
    88a0:	4b0f      	ldr	r3, [pc, #60]	; (88e0 <grid_nvm_ui_bulk_read_next+0xf4>)
    88a2:	a805      	add	r0, sp, #20
    88a4:	4798      	blx	r3
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    88a6:	230a      	movs	r3, #10
    88a8:	9300      	str	r3, [sp, #0]
    88aa:	2204      	movs	r2, #4
    88ac:	4629      	mov	r1, r5
    88ae:	a805      	add	r0, sp, #20
    88b0:	2301      	movs	r3, #1
    88b2:	47a0      	blx	r4
			grid_msg_packet_close(&response);
    88b4:	4b0b      	ldr	r3, [pc, #44]	; (88e4 <grid_nvm_ui_bulk_read_next+0xf8>)
    88b6:	a805      	add	r0, sp, #20
    88b8:	4798      	blx	r3
			grid_msg_packet_send_everywhere(&response);
    88ba:	4b0b      	ldr	r3, [pc, #44]	; (88e8 <grid_nvm_ui_bulk_read_next+0xfc>)
    88bc:	a805      	add	r0, sp, #20
    88be:	4798      	blx	r3
}
    88c0:	e7cc      	b.n	885c <grid_nvm_ui_bulk_read_next+0x70>
    88c2:	bf00      	nop
    88c4:	00009e4d 	.word	0x00009e4d
    88c8:	0000857d 	.word	0x0000857d
    88cc:	000085b1 	.word	0x000085b1
    88d0:	00015cfb 	.word	0x00015cfb
    88d4:	00014791 	.word	0x00014791
    88d8:	0001480f 	.word	0x0001480f
    88dc:	00008561 	.word	0x00008561
    88e0:	000084ed 	.word	0x000084ed
    88e4:	000086a9 	.word	0x000086a9
    88e8:	0000877d 	.word	0x0000877d

000088ec <grid_nvm_ui_bulk_store_init>:


void grid_nvm_ui_bulk_store_init(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	nvm->store_bulk_page_index = 0;
    88ec:	2300      	movs	r3, #0
    88ee:	f8c0 3434 	str.w	r3, [r0, #1076]	; 0x434
	nvm->store_bulk_status = 1;
    88f2:	2301      	movs	r3, #1
    88f4:	f880 3438 	strb.w	r3, [r0, #1080]	; 0x438
	
}
    88f8:	4770      	bx	lr

000088fa <grid_nvm_ui_bulk_store_is_in_progress>:

uint8_t grid_nvm_ui_bulk_store_is_in_progress(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	return nvm->store_bulk_status;
	
}
    88fa:	f890 0438 	ldrb.w	r0, [r0, #1080]	; 0x438
    88fe:	4770      	bx	lr

00008900 <grid_nvm_ui_bulk_store_next>:

// DO THIS!!
void grid_nvm_ui_bulk_store_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8900:	b5f0      	push	{r4, r5, r6, r7, lr}
     
    // START: NEW
    
    
	if (nvm->store_bulk_status == 1){
    8902:	f890 3438 	ldrb.w	r3, [r0, #1080]	; 0x438
    8906:	2b01      	cmp	r3, #1
void grid_nvm_ui_bulk_store_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8908:	b0ed      	sub	sp, #436	; 0x1b4
    890a:	4604      	mov	r4, r0
    890c:	460d      	mov	r5, r1
	if (nvm->store_bulk_status == 1){
    890e:	d168      	bne.n	89e2 <grid_nvm_ui_bulk_store_next+0xe2>
                        struct grid_ui_event* eve = &ui->bank_list[bank].element_list[element].event_list[event];

                        if (eve->cfg_changed_flag == 1){


                            if (grid_ui_nvm_store_event_configuration(ui, nvm, eve)){
    8910:	4f53      	ldr	r7, [pc, #332]	; (8a60 <grid_nvm_ui_bulk_store_next+0x160>)
            uint8_t bank    = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    8912:	26a0      	movs	r6, #160	; 0xa0
            if (bank < ui->bank_list_length){
    8914:	786a      	ldrb	r2, [r5, #1]
            uint8_t bank    = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    8916:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    891a:	fbb3 f1f6 	udiv	r1, r3, r6
    891e:	f001 0003 	and.w	r0, r1, #3
            if (bank < ui->bank_list_length){
    8922:	4282      	cmp	r2, r0
    8924:	d95f      	bls.n	89e6 <grid_nvm_ui_bulk_store_next+0xe6>
                if (element < ui->bank_list[bank].element_list_length){
    8926:	6869      	ldr	r1, [r5, #4]
    8928:	eb01 1100 	add.w	r1, r1, r0, lsl #4
            uint8_t element = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    892c:	f04f 0e0a 	mov.w	lr, #10
                if (element < ui->bank_list[bank].element_list_length){
    8930:	7a48      	ldrb	r0, [r1, #9]
            uint8_t element = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8932:	fbb3 f2fe 	udiv	r2, r3, lr
    8936:	f002 0c0f 	and.w	ip, r2, #15
                if (element < ui->bank_list[bank].element_list_length){
    893a:	4560      	cmp	r0, ip
    893c:	d953      	bls.n	89e6 <grid_nvm_ui_bulk_store_next+0xe6>
                    if (event < ui->bank_list[bank].element_list[element].event_list_length){
    893e:	68c9      	ldr	r1, [r1, #12]
            uint8_t event   = nvm->store_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
    8940:	fb0e 3212 	mls	r2, lr, r2, r3
                    if (event < ui->bank_list[bank].element_list[element].event_list_length){
    8944:	2364      	movs	r3, #100	; 0x64
    8946:	fb0c 1303 	mla	r3, ip, r3, r1
    894a:	b2d1      	uxtb	r1, r2
    894c:	f893 005c 	ldrb.w	r0, [r3, #92]	; 0x5c
    8950:	4288      	cmp	r0, r1
    8952:	d948      	bls.n	89e6 <grid_nvm_ui_bulk_store_next+0xe6>
                        struct grid_ui_event* eve = &ui->bank_list[bank].element_list[element].event_list[event];
    8954:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    8956:	21bc      	movs	r1, #188	; 0xbc
    8958:	fb01 3202 	mla	r2, r1, r2, r3
                        if (eve->cfg_changed_flag == 1){
    895c:	f892 30b6 	ldrb.w	r3, [r2, #182]	; 0xb6
    8960:	2b01      	cmp	r3, #1
    8962:	d140      	bne.n	89e6 <grid_nvm_ui_bulk_store_next+0xe6>
                            if (grid_ui_nvm_store_event_configuration(ui, nvm, eve)){
    8964:	4621      	mov	r1, r4
    8966:	4628      	mov	r0, r5
    8968:	47b8      	blx	r7
    896a:	3800      	subs	r0, #0
    896c:	bf18      	it	ne
    896e:	2001      	movne	r0, #1

            }
            
            

            if (nvm->store_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    8970:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    8974:	f240 227e 	movw	r2, #638	; 0x27e
    8978:	4293      	cmp	r3, r2
    897a:	d804      	bhi.n	8986 <grid_nvm_ui_bulk_store_next+0x86>



                nvm->store_bulk_page_index++;       
    897c:	3301      	adds	r3, #1
    897e:	f8c4 3434 	str.w	r3, [r4, #1076]	; 0x434
        while (something_was_stored == 0){
    8982:	2800      	cmp	r0, #0
    8984:	d0c6      	beq.n	8914 <grid_nvm_ui_bulk_store_next+0x14>
		

		
		
		
		if (nvm->store_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    8986:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    898a:	4e36      	ldr	r6, [pc, #216]	; (8a64 <grid_nvm_ui_bulk_store_next+0x164>)
    898c:	f240 227e 	movw	r2, #638	; 0x27e
    8990:	4293      	cmp	r3, r2
    8992:	d82a      	bhi.n	89ea <grid_nvm_ui_bulk_store_next+0xea>
			
            
            uint8_t intensity = abs(nvm->store_bulk_page_index%100 - 50)/1.5 + 40;
    8994:	2264      	movs	r2, #100	; 0x64
    8996:	fbb3 f0f2 	udiv	r0, r3, r2
    899a:	fb02 3010 	mls	r0, r2, r0, r3
    899e:	3832      	subs	r0, #50	; 0x32
    89a0:	2800      	cmp	r0, #0
    89a2:	bfb8      	it	lt
    89a4:	4240      	neglt	r0, r0
    89a6:	4f30      	ldr	r7, [pc, #192]	; (8a68 <grid_nvm_ui_bulk_store_next+0x168>)
    89a8:	4c30      	ldr	r4, [pc, #192]	; (8a6c <grid_nvm_ui_bulk_store_next+0x16c>)
    89aa:	4d31      	ldr	r5, [pc, #196]	; (8a70 <grid_nvm_ui_bulk_store_next+0x170>)
    89ac:	47b8      	blx	r7
    89ae:	4b31      	ldr	r3, [pc, #196]	; (8a74 <grid_nvm_ui_bulk_store_next+0x174>)
    89b0:	2200      	movs	r2, #0
    89b2:	47a0      	blx	r4
    89b4:	4b30      	ldr	r3, [pc, #192]	; (8a78 <grid_nvm_ui_bulk_store_next+0x178>)
    89b6:	4c31      	ldr	r4, [pc, #196]	; (8a7c <grid_nvm_ui_bulk_store_next+0x17c>)
    89b8:	2200      	movs	r2, #0
    89ba:	47a0      	blx	r4
    89bc:	47a8      	blx	r5
    89be:	b2c4      	uxtb	r4, r0
  
            grid_sys_alert_set_alert(&grid_sys_state, 0, intensity*0.75, intensity, 1, 1000);
    89c0:	4620      	mov	r0, r4
    89c2:	47b8      	blx	r7
    89c4:	4b2e      	ldr	r3, [pc, #184]	; (8a80 <grid_nvm_ui_bulk_store_next+0x180>)
    89c6:	4f2f      	ldr	r7, [pc, #188]	; (8a84 <grid_nvm_ui_bulk_store_next+0x184>)
    89c8:	2200      	movs	r2, #0
    89ca:	47b8      	blx	r7
    89cc:	47a8      	blx	r5
    89ce:	2301      	movs	r3, #1
    89d0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    89d4:	e9cd 3200 	strd	r3, r2, [sp]
    89d8:	2100      	movs	r1, #0
    89da:	b2c2      	uxtb	r2, r0
    89dc:	4623      	mov	r3, r4
    89de:	482a      	ldr	r0, [pc, #168]	; (8a88 <grid_nvm_ui_bulk_store_next+0x188>)
    89e0:	47b0      	blx	r6
	}
	
	
	
	
}
    89e2:	b06d      	add	sp, #436	; 0x1b4
    89e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    89e6:	2000      	movs	r0, #0
    89e8:	e7c2      	b.n	8970 <grid_nvm_ui_bulk_store_next+0x70>
			nvm->store_bulk_page_index = 0;
    89ea:	2500      	movs	r5, #0
    89ec:	f8c4 5434 	str.w	r5, [r4, #1076]	; 0x434
			nvm->store_bulk_status = 0;
    89f0:	f884 5438 	strb.w	r5, [r4, #1080]	; 0x438
			grid_msg_init(&response);
    89f4:	a805      	add	r0, sp, #20
    89f6:	4b25      	ldr	r3, [pc, #148]	; (8a8c <grid_nvm_ui_bulk_store_next+0x18c>)
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    89f8:	4c25      	ldr	r4, [pc, #148]	; (8a90 <grid_nvm_ui_bulk_store_next+0x190>)
			grid_msg_init(&response);
    89fa:	4798      	blx	r3
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    89fc:	227f      	movs	r2, #127	; 0x7f
    89fe:	462b      	mov	r3, r5
    8a00:	4611      	mov	r1, r2
    8a02:	a805      	add	r0, sp, #20
    8a04:	47a0      	blx	r4
			sprintf(response_payload, GRID_CLASS_LOCALSTORE_frame);
    8a06:	2303      	movs	r3, #3
    8a08:	4922      	ldr	r1, [pc, #136]	; (8a94 <grid_nvm_ui_bulk_store_next+0x194>)
    8a0a:	9300      	str	r3, [sp, #0]
    8a0c:	2202      	movs	r2, #2
    8a0e:	4c22      	ldr	r4, [pc, #136]	; (8a98 <grid_nvm_ui_bulk_store_next+0x198>)
			uint8_t response_payload[10] = {0};
    8a10:	f8ad 5010 	strh.w	r5, [sp, #16]
			sprintf(response_payload, GRID_CLASS_LOCALSTORE_frame);
    8a14:	2370      	movs	r3, #112	; 0x70
    8a16:	a802      	add	r0, sp, #8
			uint8_t response_payload[10] = {0};
    8a18:	e9cd 5502 	strd	r5, r5, [sp, #8]
			sprintf(response_payload, GRID_CLASS_LOCALSTORE_frame);
    8a1c:	47a0      	blx	r4
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8a1e:	4b1f      	ldr	r3, [pc, #124]	; (8a9c <grid_nvm_ui_bulk_store_next+0x19c>)
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8a20:	4c1f      	ldr	r4, [pc, #124]	; (8aa0 <grid_nvm_ui_bulk_store_next+0x1a0>)
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8a22:	a802      	add	r0, sp, #8
    8a24:	4798      	blx	r3
    8a26:	a902      	add	r1, sp, #8
    8a28:	4602      	mov	r2, r0
    8a2a:	4b1e      	ldr	r3, [pc, #120]	; (8aa4 <grid_nvm_ui_bulk_store_next+0x1a4>)
    8a2c:	a805      	add	r0, sp, #20
    8a2e:	4798      	blx	r3
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8a30:	230a      	movs	r3, #10
    8a32:	9300      	str	r3, [sp, #0]
    8a34:	4629      	mov	r1, r5
    8a36:	a805      	add	r0, sp, #20
    8a38:	2301      	movs	r3, #1
    8a3a:	2204      	movs	r2, #4
    8a3c:	47a0      	blx	r4
                grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    8a3e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    8a42:	e9cd 5300 	strd	r5, r3, [sp]
    8a46:	22ff      	movs	r2, #255	; 0xff
    8a48:	462b      	mov	r3, r5
    8a4a:	4629      	mov	r1, r5
    8a4c:	480e      	ldr	r0, [pc, #56]	; (8a88 <grid_nvm_ui_bulk_store_next+0x188>)
    8a4e:	47b0      	blx	r6
			grid_msg_packet_close(&response);
    8a50:	4b15      	ldr	r3, [pc, #84]	; (8aa8 <grid_nvm_ui_bulk_store_next+0x1a8>)
    8a52:	a805      	add	r0, sp, #20
    8a54:	4798      	blx	r3
			grid_msg_packet_send_everywhere(&response);
    8a56:	4b15      	ldr	r3, [pc, #84]	; (8aac <grid_nvm_ui_bulk_store_next+0x1ac>)
    8a58:	a805      	add	r0, sp, #20
    8a5a:	4798      	blx	r3
}
    8a5c:	e7c1      	b.n	89e2 <grid_nvm_ui_bulk_store_next+0xe2>
    8a5e:	bf00      	nop
    8a60:	00009cb1 	.word	0x00009cb1
    8a64:	000097cb 	.word	0x000097cb
    8a68:	00013d45 	.word	0x00013d45
    8a6c:	0001406d 	.word	0x0001406d
    8a70:	0001423d 	.word	0x0001423d
    8a74:	3ff80000 	.word	0x3ff80000
    8a78:	40440000 	.word	0x40440000
    8a7c:	00013aad 	.word	0x00013aad
    8a80:	3fe80000 	.word	0x3fe80000
    8a84:	00013e19 	.word	0x00013e19
    8a88:	2000f008 	.word	0x2000f008
    8a8c:	0000857d 	.word	0x0000857d
    8a90:	000085b1 	.word	0x000085b1
    8a94:	00015cfb 	.word	0x00015cfb
    8a98:	00014791 	.word	0x00014791
    8a9c:	0001480f 	.word	0x0001480f
    8aa0:	00008561 	.word	0x00008561
    8aa4:	000084ed 	.word	0x000084ed
    8aa8:	000086a9 	.word	0x000086a9
    8aac:	0000877d 	.word	0x0000877d

00008ab0 <grid_nvm_ui_bulk_clear_init>:



void grid_nvm_ui_bulk_clear_init(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	nvm->clear_bulk_page_index = 0;
    8ab0:	2300      	movs	r3, #0
    8ab2:	f8c0 342c 	str.w	r3, [r0, #1068]	; 0x42c
	nvm->clear_bulk_status = 1;
    8ab6:	2301      	movs	r3, #1
    8ab8:	f880 3430 	strb.w	r3, [r0, #1072]	; 0x430
	
}
    8abc:	4770      	bx	lr

00008abe <grid_nvm_ui_bulk_clear_is_in_progress>:

uint8_t grid_nvm_ui_bulk_clear_is_in_progress(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	return nvm->clear_bulk_status;
	
}
    8abe:	f890 0430 	ldrb.w	r0, [r0, #1072]	; 0x430
    8ac2:	4770      	bx	lr

00008ac4 <grid_nvm_ui_bulk_clear_next>:


void grid_nvm_ui_bulk_clear_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8ac4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8ac8:	4604      	mov	r4, r0
    8aca:	b0ec      	sub	sp, #432	; 0x1b0
	
	if (nvm->clear_bulk_status == 1){
    8acc:	f894 3430 	ldrb.w	r3, [r4, #1072]	; 0x430
    8ad0:	2b01      	cmp	r3, #1
void grid_nvm_ui_bulk_clear_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8ad2:	4608      	mov	r0, r1
	if (nvm->clear_bulk_status == 1){
    8ad4:	d15b      	bne.n	8b8e <grid_nvm_ui_bulk_clear_next+0xca>
		uint8_t bank    = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
		uint8_t element = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
		uint8_t event   = nvm->clear_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
		
		
		if (bank < ui->bank_list_length){
    8ad6:	7849      	ldrb	r1, [r1, #1]
		uint8_t bank    = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    8ad8:	f8d4 242c 	ldr.w	r2, [r4, #1068]	; 0x42c
    8adc:	23a0      	movs	r3, #160	; 0xa0
    8ade:	fbb2 f3f3 	udiv	r3, r2, r3
    8ae2:	f003 0303 	and.w	r3, r3, #3
		if (bank < ui->bank_list_length){
    8ae6:	4299      	cmp	r1, r3
    8ae8:	d91c      	bls.n	8b24 <grid_nvm_ui_bulk_clear_next+0x60>
			
			if (element < ui->bank_list[bank].element_list_length){
    8aea:	6845      	ldr	r5, [r0, #4]
    8aec:	eb05 1303 	add.w	r3, r5, r3, lsl #4
		uint8_t element = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8af0:	270a      	movs	r7, #10
			if (element < ui->bank_list[bank].element_list_length){
    8af2:	7a5d      	ldrb	r5, [r3, #9]
		uint8_t element = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8af4:	fbb2 f1f7 	udiv	r1, r2, r7
    8af8:	f001 060f 	and.w	r6, r1, #15
			if (element < ui->bank_list[bank].element_list_length){
    8afc:	42b5      	cmp	r5, r6
    8afe:	d911      	bls.n	8b24 <grid_nvm_ui_bulk_clear_next+0x60>
		uint8_t event   = nvm->clear_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
    8b00:	fb07 2111 	mls	r1, r7, r1, r2
				
				if (event < ui->bank_list[bank].element_list[element].event_list_length){
    8b04:	68da      	ldr	r2, [r3, #12]
    8b06:	2364      	movs	r3, #100	; 0x64
    8b08:	fb06 2303 	mla	r3, r6, r3, r2
    8b0c:	b2ca      	uxtb	r2, r1
    8b0e:	f893 505c 	ldrb.w	r5, [r3, #92]	; 0x5c
    8b12:	4295      	cmp	r5, r2
    8b14:	d906      	bls.n	8b24 <grid_nvm_ui_bulk_clear_next+0x60>
					// Valid memory location
					
					grid_ui_nvm_clear_event_configuration(ui, nvm, &ui->bank_list[bank].element_list[element].event_list[event]);		
    8b16:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    8b18:	22bc      	movs	r2, #188	; 0xbc
    8b1a:	fb02 3201 	mla	r2, r2, r1, r3
    8b1e:	4b3c      	ldr	r3, [pc, #240]	; (8c10 <grid_nvm_ui_bulk_clear_next+0x14c>)
    8b20:	4621      	mov	r1, r4
    8b22:	4798      	blx	r3
	
		}
		
		
		
		if (nvm->clear_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    8b24:	f8d4 342c 	ldr.w	r3, [r4, #1068]	; 0x42c
    8b28:	4e3a      	ldr	r6, [pc, #232]	; (8c14 <grid_nvm_ui_bulk_clear_next+0x150>)
    8b2a:	f240 227e 	movw	r2, #638	; 0x27e
    8b2e:	4293      	cmp	r3, r2
    8b30:	d830      	bhi.n	8b94 <grid_nvm_ui_bulk_clear_next+0xd0>
			
            
            uint8_t intensity = abs(nvm->clear_bulk_page_index%100 - 50)/1.5 + 40;
    8b32:	2264      	movs	r2, #100	; 0x64
    8b34:	fbb3 f0f2 	udiv	r0, r3, r2
    8b38:	fb02 3010 	mls	r0, r2, r0, r3
    8b3c:	3832      	subs	r0, #50	; 0x32
    8b3e:	2800      	cmp	r0, #0
    8b40:	bfb8      	it	lt
    8b42:	4240      	neglt	r0, r0
    8b44:	f8df 8118 	ldr.w	r8, [pc, #280]	; 8c60 <grid_nvm_ui_bulk_clear_next+0x19c>
    8b48:	4d33      	ldr	r5, [pc, #204]	; (8c18 <grid_nvm_ui_bulk_clear_next+0x154>)
    8b4a:	4f34      	ldr	r7, [pc, #208]	; (8c1c <grid_nvm_ui_bulk_clear_next+0x158>)
    8b4c:	47c0      	blx	r8
    8b4e:	4b34      	ldr	r3, [pc, #208]	; (8c20 <grid_nvm_ui_bulk_clear_next+0x15c>)
    8b50:	2200      	movs	r2, #0
    8b52:	47a8      	blx	r5
    8b54:	4b33      	ldr	r3, [pc, #204]	; (8c24 <grid_nvm_ui_bulk_clear_next+0x160>)
    8b56:	4d34      	ldr	r5, [pc, #208]	; (8c28 <grid_nvm_ui_bulk_clear_next+0x164>)
    8b58:	2200      	movs	r2, #0
    8b5a:	47a8      	blx	r5
    8b5c:	47b8      	blx	r7
    8b5e:	b2c5      	uxtb	r5, r0
  
            grid_sys_alert_set_alert(&grid_sys_state, intensity, intensity*0.75, 0, 1, 1000);
    8b60:	4628      	mov	r0, r5
    8b62:	47c0      	blx	r8
    8b64:	4b31      	ldr	r3, [pc, #196]	; (8c2c <grid_nvm_ui_bulk_clear_next+0x168>)
    8b66:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 8c64 <grid_nvm_ui_bulk_clear_next+0x1a0>
    8b6a:	2200      	movs	r2, #0
    8b6c:	47c0      	blx	r8
    8b6e:	47b8      	blx	r7
    8b70:	2301      	movs	r3, #1
    8b72:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    8b76:	e9cd 3200 	strd	r3, r2, [sp]
    8b7a:	4629      	mov	r1, r5
    8b7c:	2300      	movs	r3, #0
    8b7e:	b2c2      	uxtb	r2, r0
    8b80:	482b      	ldr	r0, [pc, #172]	; (8c30 <grid_nvm_ui_bulk_clear_next+0x16c>)
    8b82:	47b0      	blx	r6


            
            nvm->clear_bulk_page_index++;
    8b84:	f8d4 342c 	ldr.w	r3, [r4, #1068]	; 0x42c
    8b88:	3301      	adds	r3, #1
    8b8a:	f8c4 342c 	str.w	r3, [r4, #1068]	; 0x42c
	}
	
	
	
	
}
    8b8e:	b06c      	add	sp, #432	; 0x1b0
    8b90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			nvm->clear_bulk_page_index = 0;
    8b94:	2500      	movs	r5, #0
    8b96:	f8c4 542c 	str.w	r5, [r4, #1068]	; 0x42c
			nvm->clear_bulk_status = 0;
    8b9a:	f884 5430 	strb.w	r5, [r4, #1072]	; 0x430
			grid_msg_init(&response);
    8b9e:	a805      	add	r0, sp, #20
    8ba0:	4b24      	ldr	r3, [pc, #144]	; (8c34 <grid_nvm_ui_bulk_clear_next+0x170>)
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8ba2:	4c25      	ldr	r4, [pc, #148]	; (8c38 <grid_nvm_ui_bulk_clear_next+0x174>)
			grid_msg_init(&response);
    8ba4:	4798      	blx	r3
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8ba6:	227f      	movs	r2, #127	; 0x7f
    8ba8:	462b      	mov	r3, r5
    8baa:	4611      	mov	r1, r2
    8bac:	a805      	add	r0, sp, #20
    8bae:	47a0      	blx	r4
			sprintf(response_payload, GRID_CLASS_LOCALCLEAR_frame);
    8bb0:	2303      	movs	r3, #3
    8bb2:	4922      	ldr	r1, [pc, #136]	; (8c3c <grid_nvm_ui_bulk_clear_next+0x178>)
    8bb4:	9300      	str	r3, [sp, #0]
    8bb6:	2202      	movs	r2, #2
    8bb8:	4c21      	ldr	r4, [pc, #132]	; (8c40 <grid_nvm_ui_bulk_clear_next+0x17c>)
			uint8_t response_payload[10] = {0};
    8bba:	f8ad 5010 	strh.w	r5, [sp, #16]
			sprintf(response_payload, GRID_CLASS_LOCALCLEAR_frame);
    8bbe:	2372      	movs	r3, #114	; 0x72
    8bc0:	a802      	add	r0, sp, #8
			uint8_t response_payload[10] = {0};
    8bc2:	e9cd 5502 	strd	r5, r5, [sp, #8]
			sprintf(response_payload, GRID_CLASS_LOCALCLEAR_frame);
    8bc6:	47a0      	blx	r4
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8bc8:	4b1e      	ldr	r3, [pc, #120]	; (8c44 <grid_nvm_ui_bulk_clear_next+0x180>)
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8bca:	4c1f      	ldr	r4, [pc, #124]	; (8c48 <grid_nvm_ui_bulk_clear_next+0x184>)
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8bcc:	a802      	add	r0, sp, #8
    8bce:	4798      	blx	r3
    8bd0:	a902      	add	r1, sp, #8
    8bd2:	4602      	mov	r2, r0
    8bd4:	4b1d      	ldr	r3, [pc, #116]	; (8c4c <grid_nvm_ui_bulk_clear_next+0x188>)
    8bd6:	a805      	add	r0, sp, #20
    8bd8:	4798      	blx	r3
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8bda:	230a      	movs	r3, #10
    8bdc:	9300      	str	r3, [sp, #0]
    8bde:	4629      	mov	r1, r5
    8be0:	a805      	add	r0, sp, #20
    8be2:	2301      	movs	r3, #1
    8be4:	2204      	movs	r2, #4
    8be6:	47a0      	blx	r4
                grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    8be8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    8bec:	22ff      	movs	r2, #255	; 0xff
    8bee:	4629      	mov	r1, r5
    8bf0:	e9cd 5300 	strd	r5, r3, [sp]
    8bf4:	480e      	ldr	r0, [pc, #56]	; (8c30 <grid_nvm_ui_bulk_clear_next+0x16c>)
    8bf6:	462b      	mov	r3, r5
    8bf8:	47b0      	blx	r6
			grid_msg_packet_close(&response);
    8bfa:	4b15      	ldr	r3, [pc, #84]	; (8c50 <grid_nvm_ui_bulk_clear_next+0x18c>)
    8bfc:	a805      	add	r0, sp, #20
    8bfe:	4798      	blx	r3
			grid_msg_packet_send_everywhere(&response);
    8c00:	4b14      	ldr	r3, [pc, #80]	; (8c54 <grid_nvm_ui_bulk_clear_next+0x190>)
    8c02:	a805      	add	r0, sp, #20
    8c04:	4798      	blx	r3
            grid_ui_reinit_local(&grid_ui_state);
    8c06:	4814      	ldr	r0, [pc, #80]	; (8c58 <grid_nvm_ui_bulk_clear_next+0x194>)
    8c08:	4b14      	ldr	r3, [pc, #80]	; (8c5c <grid_nvm_ui_bulk_clear_next+0x198>)
    8c0a:	4798      	blx	r3
}
    8c0c:	e7bf      	b.n	8b8e <grid_nvm_ui_bulk_clear_next+0xca>
    8c0e:	bf00      	nop
    8c10:	00009ec5 	.word	0x00009ec5
    8c14:	000097cb 	.word	0x000097cb
    8c18:	0001406d 	.word	0x0001406d
    8c1c:	0001423d 	.word	0x0001423d
    8c20:	3ff80000 	.word	0x3ff80000
    8c24:	40440000 	.word	0x40440000
    8c28:	00013aad 	.word	0x00013aad
    8c2c:	3fe80000 	.word	0x3fe80000
    8c30:	2000f008 	.word	0x2000f008
    8c34:	0000857d 	.word	0x0000857d
    8c38:	000085b1 	.word	0x000085b1
    8c3c:	00015cfb 	.word	0x00015cfb
    8c40:	00014791 	.word	0x00014791
    8c44:	0001480f 	.word	0x0001480f
    8c48:	00008561 	.word	0x00008561
    8c4c:	000084ed 	.word	0x000084ed
    8c50:	000086a9 	.word	0x000086a9
    8c54:	0000877d 	.word	0x0000877d
    8c58:	2000effc 	.word	0x2000effc
    8c5c:	0000a4d1 	.word	0x0000a4d1
    8c60:	00013d45 	.word	0x00013d45
    8c64:	00013e19 	.word	0x00013e19

00008c68 <grid_nvm_clear_read_buffer>:



void grid_nvm_clear_read_buffer(struct grid_nvm_model* mod){
	
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    8c68:	f100 0309 	add.w	r3, r0, #9
    8c6c:	f200 2209 	addw	r2, r0, #521	; 0x209
		
		mod->read_buffer[i] = 255;
    8c70:	21ff      	movs	r1, #255	; 0xff
    8c72:	f803 1b01 	strb.w	r1, [r3], #1
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    8c76:	4293      	cmp	r3, r2
    8c78:	d1fb      	bne.n	8c72 <grid_nvm_clear_read_buffer+0xa>
		
	}

	mod->read_buffer_status = GRID_NVM_BUFFER_STATUS_EMPTY;
    8c7a:	2302      	movs	r3, #2
    8c7c:	f880 3210 	strb.w	r3, [r0, #528]	; 0x210
	mod->read_buffer_length = 0;
    8c80:	2300      	movs	r3, #0
    8c82:	f8c0 320c 	str.w	r3, [r0, #524]	; 0x20c
	
}
    8c86:	4770      	bx	lr

00008c88 <grid_nvm_clear_write_buffer>:

void grid_nvm_clear_write_buffer(struct grid_nvm_model* mod){
	
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    8c88:	f500 7306 	add.w	r3, r0, #536	; 0x218
    8c8c:	f500 6283 	add.w	r2, r0, #1048	; 0x418
		
		mod->write_buffer[i] = 255;
    8c90:	21ff      	movs	r1, #255	; 0xff
    8c92:	f803 1b01 	strb.w	r1, [r3], #1
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    8c96:	4293      	cmp	r3, r2
    8c98:	d1fb      	bne.n	8c92 <grid_nvm_clear_write_buffer+0xa>
		
	}
	
	mod->write_buffer_status = GRID_NVM_BUFFER_STATUS_EMPTY;
    8c9a:	2302      	movs	r3, #2
    8c9c:	f880 341c 	strb.w	r3, [r0, #1052]	; 0x41c
	mod->write_buffer_length = 0;
    8ca0:	2300      	movs	r3, #0
    8ca2:	f8c0 3418 	str.w	r3, [r0, #1048]	; 0x418
	mod->write_target_address = -1;
    8ca6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    8caa:	f8c0 3420 	str.w	r3, [r0, #1056]	; 0x420
}
    8cae:	4770      	bx	lr

00008cb0 <grid_nvm_init>:
void grid_nvm_init(struct grid_nvm_model* nvm, struct flash_descriptor* flash_instance){
    8cb0:	b510      	push	{r4, lr}
	nvm->bank_settings_page_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    8cb2:	f44f 23fe 	mov.w	r3, #520192	; 0x7f000
	nvm->flash = flash_instance;
    8cb6:	e9c0 1300 	strd	r1, r3, [r0]
	nvm->status = 1;
    8cba:	2301      	movs	r3, #1
    8cbc:	7203      	strb	r3, [r0, #8]
	nvm->read_buffer_status = GRID_NVM_BUFFER_STATUS_UNINITIALIZED;
    8cbe:	2300      	movs	r3, #0
    8cc0:	f880 3210 	strb.w	r3, [r0, #528]	; 0x210
	nvm->write_buffer_status = GRID_NVM_BUFFER_STATUS_UNINITIALIZED;
    8cc4:	f880 341c 	strb.w	r3, [r0, #1052]	; 0x41c
	nvm->read_bulk_page_index = 0;
    8cc8:	f8c0 3424 	str.w	r3, [r0, #1060]	; 0x424
	nvm->read_bulk_status = 0;
    8ccc:	f880 3428 	strb.w	r3, [r0, #1064]	; 0x428
	nvm->clear_bulk_page_index = 0;
    8cd0:	f8c0 342c 	str.w	r3, [r0, #1068]	; 0x42c
	nvm->clear_bulk_status = 0;	
    8cd4:	f880 3430 	strb.w	r3, [r0, #1072]	; 0x430
	nvm->write_bulk_page_index = 0;
    8cd8:	f8c0 343c 	str.w	r3, [r0, #1084]	; 0x43c
	nvm->write_bulk_status = 0;
    8cdc:	f880 3440 	strb.w	r3, [r0, #1088]	; 0x440
	grid_nvm_clear_read_buffer(nvm);
    8ce0:	4b02      	ldr	r3, [pc, #8]	; (8cec <grid_nvm_init+0x3c>)
    8ce2:	4798      	blx	r3
}
    8ce4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_nvm_clear_write_buffer(nvm);
    8ce8:	4b01      	ldr	r3, [pc, #4]	; (8cf0 <grid_nvm_init+0x40>)
    8cea:	4718      	bx	r3
    8cec:	00008c69 	.word	0x00008c69
    8cf0:	00008c89 	.word	0x00008c89

00008cf4 <grid_nvm_calculate_event_page_offset>:


uint32_t grid_nvm_calculate_event_page_offset(struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    8cf4:	b510      	push	{r4, lr}
	
	
	
	uint8_t bank_number		= eve->parent->parent->index;
    8cf6:	684a      	ldr	r2, [r1, #4]
    8cf8:	6853      	ldr	r3, [r2, #4]
	uint8_t element_number	= eve->parent->index;
	uint8_t event_number	= eve->index;

	return GRID_NVM_STRATEGY_BANK_size * bank_number + GRID_NVM_STRATEGY_ELEMENT_size * element_number + GRID_NVM_STRATEGY_EVENT_size * event_number;
    8cfa:	7a1c      	ldrb	r4, [r3, #8]
    8cfc:	7a13      	ldrb	r3, [r2, #8]
    8cfe:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    8d02:	20a0      	movs	r0, #160	; 0xa0
    8d04:	005b      	lsls	r3, r3, #1
    8d06:	fb10 3304 	smlabb	r3, r0, r4, r3
    8d0a:	7a08      	ldrb	r0, [r1, #8]
	
    8d0c:	4418      	add	r0, r3
    8d0e:	bd10      	pop	{r4, pc}

00008d10 <_gpio_set_pin_pull_mode.constprop.0>:
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    8d10:	01c0      	lsls	r0, r0, #7
    8d12:	f100 4082 	add.w	r0, r0, #1090519040	; 0x41000000
    8d16:	f500 4000 	add.w	r0, r0, #32768	; 0x8000
	case GPIO_PULL_OFF:
		hri_port_clear_PINCFG_PULLEN_bit(PORT, port, pin);
		break;

	case GPIO_PULL_UP:
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
    8d1a:	2301      	movs	r3, #1
    8d1c:	408b      	lsls	r3, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    8d1e:	4401      	add	r1, r0
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    8d20:	6043      	str	r3, [r0, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    8d22:	f891 2040 	ldrb.w	r2, [r1, #64]	; 0x40
    8d26:	f042 0204 	orr.w	r2, r2, #4
    8d2a:	f881 2040 	strb.w	r2, [r1, #64]	; 0x40
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    8d2e:	6183      	str	r3, [r0, #24]

	default:
		ASSERT(false);
		break;
	}
}
    8d30:	4770      	bx	lr

00008d32 <grid_task_enter_task>:
 * Author : SUKU WC
*/

#include "grid_sys.h"

enum grid_task grid_task_enter_task(struct grid_task_model* mod, enum grid_task next_task){
    8d32:	4603      	mov	r3, r0
	
	
	enum grid_task previous_task = mod->current_task;
    8d34:	7840      	ldrb	r0, [r0, #1]
	mod->current_task = next_task;
    8d36:	7059      	strb	r1, [r3, #1]
	return previous_task;
	
}
    8d38:	4770      	bx	lr

00008d3a <grid_task_timer_tick>:
	
}

void grid_task_timer_tick(struct grid_task_model* mod){
	
	mod->timer[mod->current_task]++;
    8d3a:	7843      	ldrb	r3, [r0, #1]
    8d3c:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    8d40:	6843      	ldr	r3, [r0, #4]
    8d42:	3301      	adds	r3, #1
    8d44:	6043      	str	r3, [r0, #4]
	
}
    8d46:	4770      	bx	lr

00008d48 <grid_sys_nvm_store_configuration>:
}




void grid_sys_nvm_store_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    8d48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8d4c:	f2ad 4dec 	subw	sp, sp, #1260	; 0x4ec

	struct grid_msg message;
	
	grid_msg_init(&message);
    8d50:	4b6a      	ldr	r3, [pc, #424]	; (8efc <grid_sys_nvm_store_configuration+0x1b4>)
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8d52:	4c6b      	ldr	r4, [pc, #428]	; (8f00 <grid_sys_nvm_store_configuration+0x1b8>)
	for(uint8_t i=0; i<4; i++){
		
		// BANK ENABLED	
		offset = grid_msg_body_get_length(&message);
			
		sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8d54:	f8df a1d0 	ldr.w	sl, [pc, #464]	; 8f28 <grid_sys_nvm_store_configuration+0x1e0>
void grid_sys_nvm_store_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    8d58:	4606      	mov	r6, r0
	grid_msg_init(&message);
    8d5a:	a86c      	add	r0, sp, #432	; 0x1b0
void grid_sys_nvm_store_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    8d5c:	460f      	mov	r7, r1
	grid_msg_init(&message);
    8d5e:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8d60:	22ff      	movs	r2, #255	; 0xff
    8d62:	4611      	mov	r1, r2
    8d64:	2300      	movs	r3, #0
    8d66:	a86c      	add	r0, sp, #432	; 0x1b0
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    8d68:	2500      	movs	r5, #0
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8d6a:	47a0      	blx	r4
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    8d6c:	4b65      	ldr	r3, [pc, #404]	; (8f04 <grid_sys_nvm_store_configuration+0x1bc>)
    8d6e:	9508      	str	r5, [sp, #32]
    8d70:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    8d74:	4629      	mov	r1, r5
    8d76:	a809      	add	r0, sp, #36	; 0x24
    8d78:	4798      	blx	r3
	for(uint8_t i=0; i<4; i++){
    8d7a:	3613      	adds	r6, #19
		offset = grid_msg_body_get_length(&message);
    8d7c:	4b62      	ldr	r3, [pc, #392]	; (8f08 <grid_sys_nvm_store_configuration+0x1c0>)
		payload_length = strlen(payload);
    8d7e:	f8df b1b4 	ldr.w	fp, [pc, #436]	; 8f34 <grid_sys_nvm_store_configuration+0x1ec>
			
		grid_msg_body_append_text(&message, payload, payload_length);
    8d82:	f8df 91b4 	ldr.w	r9, [pc, #436]	; 8f38 <grid_sys_nvm_store_configuration+0x1f0>
			
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    8d86:	4c61      	ldr	r4, [pc, #388]	; (8f0c <grid_sys_nvm_store_configuration+0x1c4>)
		offset = grid_msg_body_get_length(&message);
    8d88:	a86c      	add	r0, sp, #432	; 0x1b0
    8d8a:	4798      	blx	r3
		sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8d8c:	2203      	movs	r2, #3
		offset = grid_msg_body_get_length(&message);
    8d8e:	4680      	mov	r8, r0
		sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8d90:	2331      	movs	r3, #49	; 0x31
    8d92:	495f      	ldr	r1, [pc, #380]	; (8f10 <grid_sys_nvm_store_configuration+0x1c8>)
    8d94:	9200      	str	r2, [sp, #0]
    8d96:	a808      	add	r0, sp, #32
    8d98:	2202      	movs	r2, #2
    8d9a:	47d0      	blx	sl
		payload_length = strlen(payload);
    8d9c:	a808      	add	r0, sp, #32
    8d9e:	47d8      	blx	fp
		grid_msg_body_append_text(&message, payload, payload_length);
    8da0:	a908      	add	r1, sp, #32
    8da2:	b2c2      	uxtb	r2, r0
    8da4:	a86c      	add	r0, sp, #432	; 0x1b0
    8da6:	47c8      	blx	r9
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    8da8:	220e      	movs	r2, #14
    8daa:	4641      	mov	r1, r8
    8dac:	9200      	str	r2, [sp, #0]
    8dae:	2301      	movs	r3, #1
    8db0:	2204      	movs	r2, #4
    8db2:	a86c      	add	r0, sp, #432	; 0x1b0
    8db4:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_BANKNUMBER_offset, GRID_CLASS_BANKENABLED_BANKNUMBER_length, i);
    8db6:	4641      	mov	r1, r8
    8db8:	9500      	str	r5, [sp, #0]
    8dba:	2302      	movs	r3, #2
    8dbc:	2205      	movs	r2, #5
    8dbe:	a86c      	add	r0, sp, #432	; 0x1b0
    8dc0:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_ISENABLED_offset, GRID_CLASS_BANKENABLED_ISENABLED_length, sys->bank_enabled[i]);		
    8dc2:	f816 3b01 	ldrb.w	r3, [r6], #1
    8dc6:	9300      	str	r3, [sp, #0]
    8dc8:	4641      	mov	r1, r8
    8dca:	2207      	movs	r2, #7
    8dcc:	2302      	movs	r3, #2
    8dce:	a86c      	add	r0, sp, #432	; 0x1b0
    8dd0:	47a0      	blx	r4
			
		// BANK COLOR	
		offset = grid_msg_body_get_length(&message);
    8dd2:	4b4d      	ldr	r3, [pc, #308]	; (8f08 <grid_sys_nvm_store_configuration+0x1c0>)
    8dd4:	a86c      	add	r0, sp, #432	; 0x1b0
    8dd6:	4798      	blx	r3
		
		sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    8dd8:	2303      	movs	r3, #3
		offset = grid_msg_body_get_length(&message);
    8dda:	4680      	mov	r8, r0
		sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    8ddc:	494d      	ldr	r1, [pc, #308]	; (8f14 <grid_sys_nvm_store_configuration+0x1cc>)
    8dde:	9300      	str	r3, [sp, #0]
    8de0:	2202      	movs	r2, #2
    8de2:	2332      	movs	r3, #50	; 0x32
    8de4:	a808      	add	r0, sp, #32
    8de6:	47d0      	blx	sl
		payload_length = strlen(payload);
    8de8:	a808      	add	r0, sp, #32
    8dea:	47d8      	blx	fp
		
		grid_msg_body_append_text(&message, payload, payload_length);
    8dec:	a908      	add	r1, sp, #32
    8dee:	b2c2      	uxtb	r2, r0
    8df0:	a86c      	add	r0, sp, #432	; 0x1b0
    8df2:	47c8      	blx	r9

		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    8df4:	230e      	movs	r3, #14
    8df6:	4641      	mov	r1, r8
    8df8:	9300      	str	r3, [sp, #0]
    8dfa:	2204      	movs	r2, #4
    8dfc:	2301      	movs	r3, #1
    8dfe:	a86c      	add	r0, sp, #432	; 0x1b0
    8e00:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_NUM_offset, GRID_CLASS_BANKCOLOR_NUM_length, i);
    8e02:	4641      	mov	r1, r8
    8e04:	9500      	str	r5, [sp, #0]
    8e06:	2302      	movs	r3, #2
    8e08:	2205      	movs	r2, #5
    8e0a:	a86c      	add	r0, sp, #432	; 0x1b0
    8e0c:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_RED_offset, GRID_CLASS_BANKCOLOR_RED_length, sys->bank_color_r[i]);
    8e0e:	78f3      	ldrb	r3, [r6, #3]
    8e10:	9300      	str	r3, [sp, #0]
    8e12:	4641      	mov	r1, r8
    8e14:	2302      	movs	r3, #2
    8e16:	2207      	movs	r2, #7
    8e18:	a86c      	add	r0, sp, #432	; 0x1b0
    8e1a:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_GRE_offset, GRID_CLASS_BANKCOLOR_GRE_length, sys->bank_color_g[i]);
    8e1c:	79f3      	ldrb	r3, [r6, #7]
    8e1e:	9300      	str	r3, [sp, #0]
    8e20:	4641      	mov	r1, r8
    8e22:	2302      	movs	r3, #2
    8e24:	2209      	movs	r2, #9
    8e26:	a86c      	add	r0, sp, #432	; 0x1b0
    8e28:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_BLU_offset, GRID_CLASS_BANKCOLOR_BLU_length, sys->bank_color_b[i]);
    8e2a:	7af3      	ldrb	r3, [r6, #11]
    8e2c:	9300      	str	r3, [sp, #0]
    8e2e:	4641      	mov	r1, r8
    8e30:	2302      	movs	r3, #2
    8e32:	220b      	movs	r2, #11
    8e34:	a86c      	add	r0, sp, #432	; 0x1b0
    8e36:	3501      	adds	r5, #1
    8e38:	47a0      	blx	r4
	for(uint8_t i=0; i<4; i++){
    8e3a:	2d04      	cmp	r5, #4
    8e3c:	46d8      	mov	r8, fp
    8e3e:	d19d      	bne.n	8d7c <grid_sys_nvm_store_configuration+0x34>
		
		
	}
	
	grid_msg_packet_close(&message);
    8e40:	4e35      	ldr	r6, [pc, #212]	; (8f18 <grid_sys_nvm_store_configuration+0x1d0>)

	grid_nvm_clear_write_buffer(nvm);
	
	uint8_t acknowledge = 0;
	
	if (grid_msg_packet_get_length(&message)){
    8e42:	4d36      	ldr	r5, [pc, #216]	; (8f1c <grid_sys_nvm_store_configuration+0x1d4>)
	grid_msg_packet_close(&message);
    8e44:	a86c      	add	r0, sp, #432	; 0x1b0
    8e46:	47b0      	blx	r6
	grid_nvm_clear_write_buffer(nvm);
    8e48:	4b35      	ldr	r3, [pc, #212]	; (8f20 <grid_sys_nvm_store_configuration+0x1d8>)
    8e4a:	4638      	mov	r0, r7
    8e4c:	4798      	blx	r3
	if (grid_msg_packet_get_length(&message)){
    8e4e:	a86c      	add	r0, sp, #432	; 0x1b0
    8e50:	47a8      	blx	r5
    8e52:	9602      	str	r6, [sp, #8]
    8e54:	2800      	cmp	r0, #0
    8e56:	d04c      	beq.n	8ef2 <grid_sys_nvm_store_configuration+0x1aa>

		nvm->write_buffer_length = grid_msg_packet_get_length(&message);
    8e58:	a86c      	add	r0, sp, #432	; 0x1b0
    8e5a:	47a8      	blx	r5
    8e5c:	f507 7a06 	add.w	sl, r7, #536	; 0x218
		
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
			
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    8e60:	f8df b0d8 	ldr.w	fp, [pc, #216]	; 8f3c <grid_sys_nvm_store_configuration+0x1f4>
		nvm->write_buffer_length = grid_msg_packet_get_length(&message);
    8e64:	f8c7 0418 	str.w	r0, [r7, #1048]	; 0x418
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
    8e68:	2500      	movs	r5, #0
    8e6a:	4652      	mov	r2, sl
    8e6c:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
    8e70:	42ab      	cmp	r3, r5
    8e72:	d835      	bhi.n	8ee0 <grid_sys_nvm_store_configuration+0x198>
		}
		
		nvm->write_target_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    8e74:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
		flash_write(nvm->flash, nvm->write_target_address, nvm->write_buffer, nvm->write_buffer_length);
    8e78:	4d2a      	ldr	r5, [pc, #168]	; (8f24 <grid_sys_nvm_store_configuration+0x1dc>)
    8e7a:	6838      	ldr	r0, [r7, #0]
		nvm->write_target_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    8e7c:	f8c7 1420 	str.w	r1, [r7, #1056]	; 0x420
		flash_write(nvm->flash, nvm->write_target_address, nvm->write_buffer, nvm->write_buffer_length);
    8e80:	47a8      	blx	r5
		
		acknowledge = 1;
    8e82:	2501      	movs	r5, #1

	
	// Generate ACKNOWLEDGE RESPONSE
	struct grid_msg response;
	
	grid_msg_init(&response);
    8e84:	4b1d      	ldr	r3, [pc, #116]	; (8efc <grid_sys_nvm_store_configuration+0x1b4>)
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8e86:	4f1e      	ldr	r7, [pc, #120]	; (8f00 <grid_sys_nvm_store_configuration+0x1b8>)

	uint8_t response_payload[10] = {0};
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    8e88:	4e27      	ldr	r6, [pc, #156]	; (8f28 <grid_sys_nvm_store_configuration+0x1e0>)
	grid_msg_init(&response);
    8e8a:	a8d3      	add	r0, sp, #844	; 0x34c
    8e8c:	4798      	blx	r3
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8e8e:	227f      	movs	r2, #127	; 0x7f
    8e90:	4611      	mov	r1, r2
    8e92:	2300      	movs	r3, #0
    8e94:	a8d3      	add	r0, sp, #844	; 0x34c
    8e96:	47b8      	blx	r7
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    8e98:	2303      	movs	r3, #3
    8e9a:	4924      	ldr	r1, [pc, #144]	; (8f2c <grid_sys_nvm_store_configuration+0x1e4>)
    8e9c:	9300      	str	r3, [sp, #0]
    8e9e:	2202      	movs	r2, #2
	uint8_t response_payload[10] = {0};
    8ea0:	2700      	movs	r7, #0
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    8ea2:	2360      	movs	r3, #96	; 0x60
    8ea4:	a805      	add	r0, sp, #20
	uint8_t response_payload[10] = {0};
    8ea6:	e9cd 7705 	strd	r7, r7, [sp, #20]
    8eaa:	f8ad 701c 	strh.w	r7, [sp, #28]
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    8eae:	47b0      	blx	r6

	grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8eb0:	a805      	add	r0, sp, #20
    8eb2:	47c0      	blx	r8
    8eb4:	a905      	add	r1, sp, #20
    8eb6:	4602      	mov	r2, r0
    8eb8:	a8d3      	add	r0, sp, #844	; 0x34c
    8eba:	47c8      	blx	r9
	
	if (acknowledge == 1){
    8ebc:	b1dd      	cbz	r5, 8ef6 <grid_sys_nvm_store_configuration+0x1ae>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);	
    8ebe:	230a      	movs	r3, #10
	}
	else{
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);	
    8ec0:	2204      	movs	r2, #4
    8ec2:	4639      	mov	r1, r7
    8ec4:	9300      	str	r3, [sp, #0]
    8ec6:	a8d3      	add	r0, sp, #844	; 0x34c
    8ec8:	2301      	movs	r3, #1
    8eca:	47a0      	blx	r4
	}

	
	grid_msg_packet_close(&response);
    8ecc:	9b02      	ldr	r3, [sp, #8]
    8ece:	a8d3      	add	r0, sp, #844	; 0x34c
    8ed0:	4798      	blx	r3
	grid_msg_packet_send_everywhere(&response);
    8ed2:	4b17      	ldr	r3, [pc, #92]	; (8f30 <grid_sys_nvm_store_configuration+0x1e8>)
    8ed4:	a8d3      	add	r0, sp, #844	; 0x34c
    8ed6:	4798      	blx	r3
		
	
}
    8ed8:	f20d 4dec 	addw	sp, sp, #1260	; 0x4ec
    8edc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    8ee0:	4629      	mov	r1, r5
    8ee2:	a86c      	add	r0, sp, #432	; 0x1b0
    8ee4:	9203      	str	r2, [sp, #12]
    8ee6:	47d8      	blx	fp
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
    8ee8:	3501      	adds	r5, #1
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    8eea:	f80a 0b01 	strb.w	r0, [sl], #1
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
    8eee:	9a03      	ldr	r2, [sp, #12]
    8ef0:	e7bc      	b.n	8e6c <grid_sys_nvm_store_configuration+0x124>
	uint8_t acknowledge = 0;
    8ef2:	4605      	mov	r5, r0
    8ef4:	e7c6      	b.n	8e84 <grid_sys_nvm_store_configuration+0x13c>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);	
    8ef6:	230b      	movs	r3, #11
    8ef8:	e7e2      	b.n	8ec0 <grid_sys_nvm_store_configuration+0x178>
    8efa:	bf00      	nop
    8efc:	0000857d 	.word	0x0000857d
    8f00:	000085b1 	.word	0x000085b1
    8f04:	000142f1 	.word	0x000142f1
    8f08:	000084e7 	.word	0x000084e7
    8f0c:	00008561 	.word	0x00008561
    8f10:	00015d05 	.word	0x00015d05
    8f14:	00015a3e 	.word	0x00015a3e
    8f18:	000086a9 	.word	0x000086a9
    8f1c:	000084d9 	.word	0x000084d9
    8f20:	00008c89 	.word	0x00008c89
    8f24:	0000ede1 	.word	0x0000ede1
    8f28:	00014791 	.word	0x00014791
    8f2c:	00015cfb 	.word	0x00015cfb
    8f30:	0000877d 	.word	0x0000877d
    8f34:	0001480f 	.word	0x0001480f
    8f38:	000084ed 	.word	0x000084ed
    8f3c:	00008673 	.word	0x00008673

00008f40 <grid_sys_recall_configuration>:


void grid_sys_recall_configuration(struct grid_sys_model* sys, uint8_t bank){
    8f40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8f44:	f5ad 7d51 	sub.w	sp, sp, #836	; 0x344

	struct grid_msg message;
	
	grid_msg_init(&message);
    8f48:	4b48      	ldr	r3, [pc, #288]	; (906c <grid_sys_recall_configuration+0x12c>)
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8f4a:	4c49      	ldr	r4, [pc, #292]	; (9070 <grid_sys_recall_configuration+0x130>)
void grid_sys_recall_configuration(struct grid_sys_model* sys, uint8_t bank){
    8f4c:	4605      	mov	r5, r0
	grid_msg_init(&message);
    8f4e:	a869      	add	r0, sp, #420	; 0x1a4
void grid_sys_recall_configuration(struct grid_sys_model* sys, uint8_t bank){
    8f50:	468a      	mov	sl, r1
	grid_msg_init(&message);
    8f52:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8f54:	227f      	movs	r2, #127	; 0x7f
    8f56:	4611      	mov	r1, r2
    8f58:	2300      	movs	r3, #0
    8f5a:	a869      	add	r0, sp, #420	; 0x1a4
    8f5c:	47a0      	blx	r4


	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    8f5e:	2400      	movs	r4, #0
    8f60:	4b44      	ldr	r3, [pc, #272]	; (9074 <grid_sys_recall_configuration+0x134>)
    8f62:	9405      	str	r4, [sp, #20]
    8f64:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    8f68:	4621      	mov	r1, r4
    8f6a:	a806      	add	r0, sp, #24
    8f6c:	4798      	blx	r3
	uint8_t payload_length = 0;
	uint32_t offset = 0;
	
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    8f6e:	3513      	adds	r5, #19
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    8f70:	9403      	str	r4, [sp, #12]
		
		if (bank > GRID_SYS_BANK_MAXNUMBER || bank == i){
    8f72:	f1ba 0f04 	cmp.w	sl, #4
    8f76:	d803      	bhi.n	8f80 <grid_sys_recall_configuration+0x40>
    8f78:	f89d 300c 	ldrb.w	r3, [sp, #12]
    8f7c:	459a      	cmp	sl, r3
    8f7e:	d164      	bne.n	904a <grid_sys_recall_configuration+0x10a>
			
			// BANK ENABLED
			offset = grid_msg_body_get_length(&message);
    8f80:	4b3d      	ldr	r3, [pc, #244]	; (9078 <grid_sys_recall_configuration+0x138>)
		
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8f82:	4e3e      	ldr	r6, [pc, #248]	; (907c <grid_sys_recall_configuration+0x13c>)
			payload_length = strlen(payload);
		
			grid_msg_body_append_text(&message, payload, payload_length);
    8f84:	f8df 9110 	ldr.w	r9, [pc, #272]	; 9098 <grid_sys_recall_configuration+0x158>
			offset = grid_msg_body_get_length(&message);
    8f88:	a869      	add	r0, sp, #420	; 0x1a4
    8f8a:	4798      	blx	r3
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8f8c:	f04f 0b03 	mov.w	fp, #3
			offset = grid_msg_body_get_length(&message);
    8f90:	4607      	mov	r7, r0
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8f92:	2331      	movs	r3, #49	; 0x31
    8f94:	493a      	ldr	r1, [pc, #232]	; (9080 <grid_sys_recall_configuration+0x140>)
    8f96:	f8cd b000 	str.w	fp, [sp]
    8f9a:	2202      	movs	r2, #2
    8f9c:	a805      	add	r0, sp, #20
    8f9e:	47b0      	blx	r6
			payload_length = strlen(payload);
    8fa0:	4a38      	ldr	r2, [pc, #224]	; (9084 <grid_sys_recall_configuration+0x144>)
    8fa2:	a805      	add	r0, sp, #20
    8fa4:	4790      	blx	r2
		
			grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    8fa6:	f04f 080d 	mov.w	r8, #13
			grid_msg_body_append_text(&message, payload, payload_length);
    8faa:	b2c2      	uxtb	r2, r0
    8fac:	a905      	add	r1, sp, #20
    8fae:	a869      	add	r0, sp, #420	; 0x1a4
    8fb0:	47c8      	blx	r9
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8fb2:	4634      	mov	r4, r6
			grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    8fb4:	4639      	mov	r1, r7
    8fb6:	4e34      	ldr	r6, [pc, #208]	; (9088 <grid_sys_recall_configuration+0x148>)
    8fb8:	f8cd 8000 	str.w	r8, [sp]
    8fbc:	2301      	movs	r3, #1
    8fbe:	2204      	movs	r2, #4
    8fc0:	a869      	add	r0, sp, #420	; 0x1a4
    8fc2:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_BANKNUMBER_offset, GRID_CLASS_BANKENABLED_BANKNUMBER_length, i);
    8fc4:	9b03      	ldr	r3, [sp, #12]
    8fc6:	9300      	str	r3, [sp, #0]
    8fc8:	4639      	mov	r1, r7
    8fca:	2302      	movs	r3, #2
    8fcc:	2205      	movs	r2, #5
    8fce:	a869      	add	r0, sp, #420	; 0x1a4
    8fd0:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_ISENABLED_offset, GRID_CLASS_BANKENABLED_ISENABLED_length, sys->bank_enabled[i]);
    8fd2:	782b      	ldrb	r3, [r5, #0]
    8fd4:	9300      	str	r3, [sp, #0]
    8fd6:	4639      	mov	r1, r7
    8fd8:	2207      	movs	r2, #7
    8fda:	2302      	movs	r3, #2
    8fdc:	a869      	add	r0, sp, #420	; 0x1a4
    8fde:	47b0      	blx	r6
		
			// BANK COLOR
			offset = grid_msg_body_get_length(&message);
    8fe0:	4b25      	ldr	r3, [pc, #148]	; (9078 <grid_sys_recall_configuration+0x138>)
    8fe2:	a869      	add	r0, sp, #420	; 0x1a4
    8fe4:	4798      	blx	r3
		
			sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    8fe6:	2332      	movs	r3, #50	; 0x32
			offset = grid_msg_body_get_length(&message);
    8fe8:	4607      	mov	r7, r0
			sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    8fea:	4928      	ldr	r1, [pc, #160]	; (908c <grid_sys_recall_configuration+0x14c>)
    8fec:	f8cd b000 	str.w	fp, [sp]
    8ff0:	2202      	movs	r2, #2
    8ff2:	a805      	add	r0, sp, #20
    8ff4:	47a0      	blx	r4
			payload_length = strlen(payload);
    8ff6:	4a23      	ldr	r2, [pc, #140]	; (9084 <grid_sys_recall_configuration+0x144>)
    8ff8:	a805      	add	r0, sp, #20
    8ffa:	4790      	blx	r2
		
			grid_msg_body_append_text(&message, payload, payload_length);
    8ffc:	a905      	add	r1, sp, #20
    8ffe:	b2c2      	uxtb	r2, r0
    9000:	a869      	add	r0, sp, #420	; 0x1a4
    9002:	47c8      	blx	r9

			grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    9004:	2301      	movs	r3, #1
    9006:	2204      	movs	r2, #4
    9008:	4639      	mov	r1, r7
    900a:	a869      	add	r0, sp, #420	; 0x1a4
    900c:	f8cd 8000 	str.w	r8, [sp]
    9010:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_NUM_offset, GRID_CLASS_BANKCOLOR_NUM_length, i);
    9012:	9b03      	ldr	r3, [sp, #12]
    9014:	9300      	str	r3, [sp, #0]
    9016:	2205      	movs	r2, #5
    9018:	2302      	movs	r3, #2
    901a:	4639      	mov	r1, r7
    901c:	a869      	add	r0, sp, #420	; 0x1a4
    901e:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_RED_offset, GRID_CLASS_BANKCOLOR_RED_length, sys->bank_color_r[i]);
    9020:	792b      	ldrb	r3, [r5, #4]
    9022:	9300      	str	r3, [sp, #0]
    9024:	2207      	movs	r2, #7
    9026:	2302      	movs	r3, #2
    9028:	4639      	mov	r1, r7
    902a:	a869      	add	r0, sp, #420	; 0x1a4
    902c:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_GRE_offset, GRID_CLASS_BANKCOLOR_GRE_length, sys->bank_color_g[i]);
    902e:	7a2b      	ldrb	r3, [r5, #8]
    9030:	9300      	str	r3, [sp, #0]
    9032:	2209      	movs	r2, #9
    9034:	2302      	movs	r3, #2
    9036:	4639      	mov	r1, r7
    9038:	a869      	add	r0, sp, #420	; 0x1a4
    903a:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_BLU_offset, GRID_CLASS_BANKCOLOR_BLU_length, sys->bank_color_b[i]);
    903c:	7b2b      	ldrb	r3, [r5, #12]
    903e:	9300      	str	r3, [sp, #0]
    9040:	220b      	movs	r2, #11
    9042:	2302      	movs	r3, #2
    9044:	4639      	mov	r1, r7
    9046:	a869      	add	r0, sp, #420	; 0x1a4
    9048:	47b0      	blx	r6
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    904a:	9b03      	ldr	r3, [sp, #12]
    904c:	3301      	adds	r3, #1
    904e:	2b04      	cmp	r3, #4
    9050:	9303      	str	r3, [sp, #12]
    9052:	f105 0501 	add.w	r5, r5, #1
    9056:	d18c      	bne.n	8f72 <grid_sys_recall_configuration+0x32>
		}

		
	}
	
	grid_msg_packet_close(&message);
    9058:	4b0d      	ldr	r3, [pc, #52]	; (9090 <grid_sys_recall_configuration+0x150>)
    905a:	a869      	add	r0, sp, #420	; 0x1a4
    905c:	4798      	blx	r3

	grid_msg_packet_send_everywhere(&message);
    905e:	4b0d      	ldr	r3, [pc, #52]	; (9094 <grid_sys_recall_configuration+0x154>)
    9060:	a869      	add	r0, sp, #420	; 0x1a4
    9062:	4798      	blx	r3
// 	
// 	grid_msg_packet_close(&response);
// 	grid_msg_packet_send_everywhere(&response);
	
	
}
    9064:	f50d 7d51 	add.w	sp, sp, #836	; 0x344
    9068:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    906c:	0000857d 	.word	0x0000857d
    9070:	000085b1 	.word	0x000085b1
    9074:	000142f1 	.word	0x000142f1
    9078:	000084e7 	.word	0x000084e7
    907c:	00014791 	.word	0x00014791
    9080:	00015d05 	.word	0x00015d05
    9084:	0001480f 	.word	0x0001480f
    9088:	00008561 	.word	0x00008561
    908c:	00015a3e 	.word	0x00015a3e
    9090:	000086a9 	.word	0x000086a9
    9094:	0000877d 	.word	0x0000877d
    9098:	000084ed 	.word	0x000084ed

0000909c <grid_sys_nvm_load_configuration>:


void grid_sys_nvm_load_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    909c:	b5f0      	push	{r4, r5, r6, r7, lr}
    909e:	f5ad 7d6d 	sub.w	sp, sp, #948	; 0x3b4
	
	uint8_t temp[GRID_NVM_PAGE_SIZE] = {0};
    90a2:	2400      	movs	r4, #0
void grid_sys_nvm_load_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    90a4:	460e      	mov	r6, r1
	uint8_t temp[GRID_NVM_PAGE_SIZE] = {0};
    90a6:	4b2f      	ldr	r3, [pc, #188]	; (9164 <grid_sys_nvm_load_configuration+0xc8>)
    90a8:	946c      	str	r4, [sp, #432]	; 0x1b0
    90aa:	f44f 72fe 	mov.w	r2, #508	; 0x1fc
    90ae:	4621      	mov	r1, r4
    90b0:	a86d      	add	r0, sp, #436	; 0x1b4
    90b2:	4798      	blx	r3
    90b4:	ad6c      	add	r5, sp, #432	; 0x1b0
	uint16_t length = 0;
	nvm->read_source_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    90b6:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
    90ba:	f8c6 1214 	str.w	r1, [r6, #532]	; 0x214
	
	flash_read(nvm->flash, nvm->read_source_address, temp, GRID_NVM_PAGE_SIZE);
    90be:	6830      	ldr	r0, [r6, #0]
    90c0:	4e29      	ldr	r6, [pc, #164]	; (9168 <grid_sys_nvm_load_configuration+0xcc>)
    90c2:	f44f 7300 	mov.w	r3, #512	; 0x200
    90c6:	462a      	mov	r2, r5
    90c8:	47b0      	blx	r6
			}
			else if (temp[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
				copydone = 1;
			}
			else{ // NORMAL CHARACTER, can be copied
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    90ca:	4a28      	ldr	r2, [pc, #160]	; (916c <grid_sys_nvm_load_configuration+0xd0>)
	flash_read(nvm->flash, nvm->read_source_address, temp, GRID_NVM_PAGE_SIZE);
    90cc:	4621      	mov	r1, r4
	uint8_t acknowledge = 0;	
    90ce:	4626      	mov	r6, r4
	uint8_t copydone = 0;
    90d0:	4623      	mov	r3, r4
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    90d2:	f241 37b4 	movw	r7, #5044	; 0x13b4
		if (copydone == 0){
    90d6:	1c4c      	adds	r4, r1, #1
    90d8:	b943      	cbnz	r3, 90ec <grid_sys_nvm_load_configuration+0x50>
			if (temp[i] == '\n'){ // END OF PACKET, copy newline character
    90da:	5c68      	ldrb	r0, [r5, r1]
    90dc:	280a      	cmp	r0, #10
    90de:	d139      	bne.n	9154 <grid_sys_nvm_load_configuration+0xb8>
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    90e0:	4411      	add	r1, r2
    90e2:	55c8      	strb	r0, [r1, r7]
				GRID_PORT_U.rx_double_buffer_status = i+1;
    90e4:	6214      	str	r4, [r2, #32]
				GRID_PORT_U.rx_double_buffer_read_start_index = 0;
    90e6:	6293      	str	r3, [r2, #40]	; 0x28
				acknowledge = 1;
    90e8:	2301      	movs	r3, #1
				copydone = 1;
    90ea:	461e      	mov	r6, r3
	for (uint16_t i=0; i<GRID_NVM_PAGE_SIZE; i++){		
    90ec:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
    90f0:	4621      	mov	r1, r4
    90f2:	d1f0      	bne.n	90d6 <grid_sys_nvm_load_configuration+0x3a>
	
	
	// Generate ACKNOWLEDGE RESPONSE
	struct grid_msg response;
	
	grid_msg_init(&response);
    90f4:	4b1e      	ldr	r3, [pc, #120]	; (9170 <grid_sys_nvm_load_configuration+0xd4>)
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    90f6:	4c1f      	ldr	r4, [pc, #124]	; (9174 <grid_sys_nvm_load_configuration+0xd8>)

	uint8_t response_payload[10] = {0};
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    90f8:	4d1f      	ldr	r5, [pc, #124]	; (9178 <grid_sys_nvm_load_configuration+0xdc>)
	grid_msg_init(&response);
    90fa:	a805      	add	r0, sp, #20
    90fc:	4798      	blx	r3
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    90fe:	227f      	movs	r2, #127	; 0x7f
    9100:	4611      	mov	r1, r2
    9102:	2300      	movs	r3, #0
    9104:	a805      	add	r0, sp, #20
    9106:	47a0      	blx	r4
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    9108:	2303      	movs	r3, #3
    910a:	491c      	ldr	r1, [pc, #112]	; (917c <grid_sys_nvm_load_configuration+0xe0>)
    910c:	9300      	str	r3, [sp, #0]
    910e:	2202      	movs	r2, #2
	uint8_t response_payload[10] = {0};
    9110:	2400      	movs	r4, #0
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    9112:	2361      	movs	r3, #97	; 0x61
    9114:	a802      	add	r0, sp, #8
	uint8_t response_payload[10] = {0};
    9116:	e9cd 4402 	strd	r4, r4, [sp, #8]
    911a:	f8ad 4010 	strh.w	r4, [sp, #16]
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    911e:	47a8      	blx	r5

	grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    9120:	4b17      	ldr	r3, [pc, #92]	; (9180 <grid_sys_nvm_load_configuration+0xe4>)
    9122:	4d18      	ldr	r5, [pc, #96]	; (9184 <grid_sys_nvm_load_configuration+0xe8>)
    9124:	a802      	add	r0, sp, #8
    9126:	4798      	blx	r3
    9128:	4b17      	ldr	r3, [pc, #92]	; (9188 <grid_sys_nvm_load_configuration+0xec>)
    912a:	4602      	mov	r2, r0
    912c:	a902      	add	r1, sp, #8
    912e:	a805      	add	r0, sp, #20
    9130:	4798      	blx	r3
	
	if (acknowledge == 1){
    9132:	b1ae      	cbz	r6, 9160 <grid_sys_nvm_load_configuration+0xc4>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    9134:	230a      	movs	r3, #10
	}
	else{
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    9136:	2204      	movs	r2, #4
    9138:	4621      	mov	r1, r4
    913a:	9300      	str	r3, [sp, #0]
    913c:	a805      	add	r0, sp, #20
    913e:	2301      	movs	r3, #1
    9140:	47a8      	blx	r5
	}

	
	grid_msg_packet_close(&response);
    9142:	4b12      	ldr	r3, [pc, #72]	; (918c <grid_sys_nvm_load_configuration+0xf0>)
    9144:	a805      	add	r0, sp, #20
    9146:	4798      	blx	r3
	grid_msg_packet_send_everywhere(&response);
    9148:	4b11      	ldr	r3, [pc, #68]	; (9190 <grid_sys_nvm_load_configuration+0xf4>)
    914a:	a805      	add	r0, sp, #20
    914c:	4798      	blx	r3
	
}
    914e:	f50d 7d6d 	add.w	sp, sp, #948	; 0x3b4
    9152:	bdf0      	pop	{r4, r5, r6, r7, pc}
			else if (temp[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
    9154:	28ff      	cmp	r0, #255	; 0xff
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    9156:	bf16      	itet	ne
    9158:	1889      	addne	r1, r1, r2
				copydone = 1;
    915a:	2301      	moveq	r3, #1
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    915c:	55c8      	strbne	r0, [r1, r7]
    915e:	e7c5      	b.n	90ec <grid_sys_nvm_load_configuration+0x50>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    9160:	230b      	movs	r3, #11
    9162:	e7e8      	b.n	9136 <grid_sys_nvm_load_configuration+0x9a>
    9164:	000142f1 	.word	0x000142f1
    9168:	0000ed75 	.word	0x0000ed75
    916c:	2000c0b0 	.word	0x2000c0b0
    9170:	0000857d 	.word	0x0000857d
    9174:	000085b1 	.word	0x000085b1
    9178:	00014791 	.word	0x00014791
    917c:	00015cfb 	.word	0x00015cfb
    9180:	0001480f 	.word	0x0001480f
    9184:	00008561 	.word	0x00008561
    9188:	000084ed 	.word	0x000084ed
    918c:	000086a9 	.word	0x000086a9
    9190:	0000877d 	.word	0x0000877d

00009194 <grid_sys_nvm_clear_configuration>:

void grid_sys_nvm_clear_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    9194:	b530      	push	{r4, r5, lr}
    9196:	460b      	mov	r3, r1
	
	uint8_t temp[GRID_NVM_PAGE_SIZE] = {0};
	uint16_t length = 0;
	nvm->read_source_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    9198:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
void grid_sys_nvm_clear_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    919c:	b0ed      	sub	sp, #436	; 0x1b4
	nvm->read_source_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    919e:	f8c3 1214 	str.w	r1, [r3, #532]	; 0x214
	
	flash_erase(nvm->flash, GRID_NVM_GLOBAL_BASE_ADDRESS, 1);
    91a2:	2201      	movs	r2, #1
    91a4:	6818      	ldr	r0, [r3, #0]
    91a6:	4b18      	ldr	r3, [pc, #96]	; (9208 <grid_sys_nvm_clear_configuration+0x74>)

	// Generate ACKNOWLEDGE RESPONSE
	struct grid_msg response;
		
	grid_msg_init(&response);
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    91a8:	4c18      	ldr	r4, [pc, #96]	; (920c <grid_sys_nvm_clear_configuration+0x78>)

	uint8_t response_payload[10] = {0};
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    91aa:	4d19      	ldr	r5, [pc, #100]	; (9210 <grid_sys_nvm_clear_configuration+0x7c>)
	flash_erase(nvm->flash, GRID_NVM_GLOBAL_BASE_ADDRESS, 1);
    91ac:	4798      	blx	r3
	grid_msg_init(&response);
    91ae:	a805      	add	r0, sp, #20
    91b0:	4b18      	ldr	r3, [pc, #96]	; (9214 <grid_sys_nvm_clear_configuration+0x80>)
    91b2:	4798      	blx	r3
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    91b4:	227f      	movs	r2, #127	; 0x7f
    91b6:	4611      	mov	r1, r2
    91b8:	a805      	add	r0, sp, #20
    91ba:	2300      	movs	r3, #0
    91bc:	47a0      	blx	r4
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    91be:	2303      	movs	r3, #3
	uint8_t response_payload[10] = {0};
    91c0:	2400      	movs	r4, #0
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    91c2:	4915      	ldr	r1, [pc, #84]	; (9218 <grid_sys_nvm_clear_configuration+0x84>)
    91c4:	9300      	str	r3, [sp, #0]
    91c6:	2202      	movs	r2, #2
    91c8:	2362      	movs	r3, #98	; 0x62
    91ca:	a802      	add	r0, sp, #8
	uint8_t response_payload[10] = {0};
    91cc:	e9cd 4402 	strd	r4, r4, [sp, #8]
    91d0:	f8ad 4010 	strh.w	r4, [sp, #16]
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    91d4:	47a8      	blx	r5

	grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    91d6:	4b11      	ldr	r3, [pc, #68]	; (921c <grid_sys_nvm_clear_configuration+0x88>)
    91d8:	a802      	add	r0, sp, #8
    91da:	4798      	blx	r3
    91dc:	a902      	add	r1, sp, #8
    91de:	4602      	mov	r2, r0
    91e0:	4b0f      	ldr	r3, [pc, #60]	; (9220 <grid_sys_nvm_clear_configuration+0x8c>)
    91e2:	a805      	add	r0, sp, #20
    91e4:	4798      	blx	r3
		
	if (acknowledge == 1){
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    91e6:	230a      	movs	r3, #10
    91e8:	4621      	mov	r1, r4
    91ea:	2204      	movs	r2, #4
    91ec:	9300      	str	r3, [sp, #0]
    91ee:	a805      	add	r0, sp, #20
    91f0:	4c0c      	ldr	r4, [pc, #48]	; (9224 <grid_sys_nvm_clear_configuration+0x90>)
    91f2:	2301      	movs	r3, #1
    91f4:	47a0      	blx	r4
	else{
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
	}

		
	grid_msg_packet_close(&response);
    91f6:	4b0c      	ldr	r3, [pc, #48]	; (9228 <grid_sys_nvm_clear_configuration+0x94>)
    91f8:	a805      	add	r0, sp, #20
    91fa:	4798      	blx	r3
	grid_msg_packet_send_everywhere(&response);
    91fc:	4b0b      	ldr	r3, [pc, #44]	; (922c <grid_sys_nvm_clear_configuration+0x98>)
    91fe:	a805      	add	r0, sp, #20
    9200:	4798      	blx	r3
	
	
}
    9202:	b06d      	add	sp, #436	; 0x1b4
    9204:	bd30      	pop	{r4, r5, pc}
    9206:	bf00      	nop
    9208:	0000ee61 	.word	0x0000ee61
    920c:	000085b1 	.word	0x000085b1
    9210:	00014791 	.word	0x00014791
    9214:	0000857d 	.word	0x0000857d
    9218:	00015cfb 	.word	0x00015cfb
    921c:	0001480f 	.word	0x0001480f
    9220:	000084ed 	.word	0x000084ed
    9224:	00008561 	.word	0x00008561
    9228:	000086a9 	.word	0x000086a9
    922c:	0000877d 	.word	0x0000877d

00009230 <grid_debug_print_text>:



void grid_debug_print_text(uint8_t* debug_string){
    9230:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	uint32_t debug_string_length = strlen(debug_string);
    9234:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 9318 <grid_debug_print_text+0xe8>
	
	struct grid_msg message;
	
	grid_msg_init(&message);
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9238:	4c2b      	ldr	r4, [pc, #172]	; (92e8 <grid_debug_print_text+0xb8>)
	
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
	uint32_t offset = 0;
	
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_start);
    923a:	4e2c      	ldr	r6, [pc, #176]	; (92ec <grid_debug_print_text+0xbc>)
	offset += strlen(&payload[offset]);
		
	sprintf(&payload[offset], "# ");
    923c:	4f2c      	ldr	r7, [pc, #176]	; (92f0 <grid_debug_print_text+0xc0>)
void grid_debug_print_text(uint8_t* debug_string){
    923e:	f5ad 7d4c 	sub.w	sp, sp, #816	; 0x330
    9242:	4681      	mov	r9, r0
	uint32_t debug_string_length = strlen(debug_string);
    9244:	47d0      	blx	sl
	grid_msg_init(&message);
    9246:	4b2b      	ldr	r3, [pc, #172]	; (92f4 <grid_debug_print_text+0xc4>)
	uint32_t debug_string_length = strlen(debug_string);
    9248:	4680      	mov	r8, r0
	grid_msg_init(&message);
    924a:	a865      	add	r0, sp, #404	; 0x194
    924c:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    924e:	227f      	movs	r2, #127	; 0x7f
    9250:	4611      	mov	r1, r2
    9252:	2300      	movs	r3, #0
    9254:	a865      	add	r0, sp, #404	; 0x194
    9256:	47a0      	blx	r4
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9258:	2400      	movs	r4, #0
    925a:	4621      	mov	r1, r4
    925c:	4b26      	ldr	r3, [pc, #152]	; (92f8 <grid_debug_print_text+0xc8>)
    925e:	9401      	str	r4, [sp, #4]
    9260:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9264:	a802      	add	r0, sp, #8
    9266:	4798      	blx	r3
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_start);
    9268:	2202      	movs	r2, #2
    926a:	4924      	ldr	r1, [pc, #144]	; (92fc <grid_debug_print_text+0xcc>)
    926c:	2320      	movs	r3, #32
    926e:	a801      	add	r0, sp, #4
    9270:	47b0      	blx	r6
	offset += strlen(&payload[offset]);
    9272:	a801      	add	r0, sp, #4
    9274:	47d0      	blx	sl
	sprintf(&payload[offset], "# ");
    9276:	ab01      	add	r3, sp, #4
    9278:	4403      	add	r3, r0
    927a:	4921      	ldr	r1, [pc, #132]	; (9300 <grid_debug_print_text+0xd0>)
	offset += strlen(&payload[offset]);
    927c:	4605      	mov	r5, r0
	sprintf(&payload[offset], "# ");
    927e:	4618      	mov	r0, r3
    9280:	47b8      	blx	r7
	offset += strlen(&payload[offset]);
    9282:	47d0      	blx	sl
    9284:	ab01      	add	r3, sp, #4
    9286:	4405      	add	r5, r0

	for(uint32_t i=0; i<debug_string_length; i++){
    9288:	1958      	adds	r0, r3, r5
    928a:	4621      	mov	r1, r4
    928c:	4603      	mov	r3, r0
    928e:	4654      	mov	r4, sl
    9290:	4541      	cmp	r1, r8
    9292:	d006      	beq.n	92a2 <grid_debug_print_text+0x72>
		
		payload[offset+i] = debug_string[i];
    9294:	f819 2001 	ldrb.w	r2, [r9, r1]
    9298:	f803 2b01 	strb.w	r2, [r3], #1
		
		if (offset + i > GRID_PARAMETER_PACKET_marign)
    929c:	194a      	adds	r2, r1, r5
    929e:	2ac8      	cmp	r2, #200	; 0xc8
    92a0:	d91f      	bls.n	92e2 <grid_debug_print_text+0xb2>
		{
			break;
		}
	}
	offset += strlen(&payload[offset]);
    92a2:	47a0      	blx	r4
	
	
	sprintf(&payload[offset], " #");
    92a4:	ab01      	add	r3, sp, #4
	offset += strlen(&payload[offset]);
    92a6:	4405      	add	r5, r0
	sprintf(&payload[offset], " #");
    92a8:	442b      	add	r3, r5
    92aa:	4916      	ldr	r1, [pc, #88]	; (9304 <grid_debug_print_text+0xd4>)
    92ac:	4618      	mov	r0, r3
    92ae:	47b8      	blx	r7
	offset += strlen(&payload[offset]);
    92b0:	47a0      	blx	r4
	
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_end);
    92b2:	ab01      	add	r3, sp, #4
	offset += strlen(&payload[offset]);
    92b4:	4405      	add	r5, r0
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_end);
    92b6:	195f      	adds	r7, r3, r5
    92b8:	4913      	ldr	r1, [pc, #76]	; (9308 <grid_debug_print_text+0xd8>)
    92ba:	2203      	movs	r2, #3
    92bc:	4638      	mov	r0, r7
    92be:	47b0      	blx	r6
	offset += strlen(&payload[offset]);	
    92c0:	4638      	mov	r0, r7
    92c2:	47a0      	blx	r4
	
	grid_msg_body_append_text(&message, payload, offset);
    92c4:	a901      	add	r1, sp, #4
    92c6:	1942      	adds	r2, r0, r5
    92c8:	4b10      	ldr	r3, [pc, #64]	; (930c <grid_debug_print_text+0xdc>)
    92ca:	a865      	add	r0, sp, #404	; 0x194
    92cc:	4798      	blx	r3
	grid_msg_packet_close(&message);
    92ce:	4b10      	ldr	r3, [pc, #64]	; (9310 <grid_debug_print_text+0xe0>)
    92d0:	a865      	add	r0, sp, #404	; 0x194
    92d2:	4798      	blx	r3
	
	grid_msg_packet_send_everywhere(&message);
    92d4:	4b0f      	ldr	r3, [pc, #60]	; (9314 <grid_debug_print_text+0xe4>)
    92d6:	a865      	add	r0, sp, #404	; 0x194
    92d8:	4798      	blx	r3
	

	
	
}
    92da:	f50d 7d4c 	add.w	sp, sp, #816	; 0x330
    92de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	for(uint32_t i=0; i<debug_string_length; i++){
    92e2:	3101      	adds	r1, #1
    92e4:	e7d4      	b.n	9290 <grid_debug_print_text+0x60>
    92e6:	bf00      	nop
    92e8:	000085b1 	.word	0x000085b1
    92ec:	00014791 	.word	0x00014791
    92f0:	000147ff 	.word	0x000147ff
    92f4:	0000857d 	.word	0x0000857d
    92f8:	000142f1 	.word	0x000142f1
    92fc:	00015d13 	.word	0x00015d13
    9300:	00015d1b 	.word	0x00015d1b
    9304:	00015d1e 	.word	0x00015d1e
    9308:	00015a3b 	.word	0x00015a3b
    930c:	000084ed 	.word	0x000084ed
    9310:	000086a9 	.word	0x000086a9
    9314:	0000877d 	.word	0x0000877d
    9318:	0001480f 	.word	0x0001480f

0000931c <tx_cb_USART_GRID>:
static void tx_cb_USART_GRID_W(const struct usart_async_descriptor *const descr)
{
	tx_cb_USART_GRID(&GRID_PORT_W);
}

void tx_cb_USART_GRID(struct grid_port* const por){
    931c:	b530      	push	{r4, r5, lr}
	
	
	for(uint32_t i=0; i<por->tx_double_buffer_status; i++){
    931e:	f06f 052b 	mvn.w	r5, #43	; 0x2b
    9322:	8984      	ldrh	r4, [r0, #12]
    9324:	f100 032c 	add.w	r3, r0, #44	; 0x2c
    9328:	1a2d      	subs	r5, r5, r0
    932a:	2200      	movs	r2, #0
    932c:	18e9      	adds	r1, r5, r3
    932e:	428c      	cmp	r4, r1
    9330:	d801      	bhi.n	9336 <tx_cb_USART_GRID+0x1a>
		por->tx_double_buffer[i] = 0;
	}
	por->tx_double_buffer_status = 0;	
    9332:	8182      	strh	r2, [r0, #12]
}
    9334:	bd30      	pop	{r4, r5, pc}
		por->tx_double_buffer[i] = 0;
    9336:	f803 2b01 	strb.w	r2, [r3], #1
	for(uint32_t i=0; i<por->tx_double_buffer_status; i++){
    933a:	e7f7      	b.n	932c <tx_cb_USART_GRID+0x10>

0000933c <tx_cb_USART_GRID_W>:
	tx_cb_USART_GRID(&GRID_PORT_W);
    933c:	4801      	ldr	r0, [pc, #4]	; (9344 <tx_cb_USART_GRID_W+0x8>)
    933e:	4b02      	ldr	r3, [pc, #8]	; (9348 <tx_cb_USART_GRID_W+0xc>)
    9340:	4718      	bx	r3
    9342:	bf00      	nop
    9344:	200102d4 	.word	0x200102d4
    9348:	0000931d 	.word	0x0000931d

0000934c <tx_cb_USART_GRID_S>:
	tx_cb_USART_GRID(&GRID_PORT_S);
    934c:	4801      	ldr	r0, [pc, #4]	; (9354 <tx_cb_USART_GRID_S+0x8>)
    934e:	4b02      	ldr	r3, [pc, #8]	; (9358 <tx_cb_USART_GRID_S+0xc>)
    9350:	4718      	bx	r3
    9352:	bf00      	nop
    9354:	200138d4 	.word	0x200138d4
    9358:	0000931d 	.word	0x0000931d

0000935c <tx_cb_USART_GRID_E>:
	tx_cb_USART_GRID(&GRID_PORT_E);
    935c:	4801      	ldr	r0, [pc, #4]	; (9364 <tx_cb_USART_GRID_E+0x8>)
    935e:	4b02      	ldr	r3, [pc, #8]	; (9368 <tx_cb_USART_GRID_E+0xc>)
    9360:	4718      	bx	r3
    9362:	bf00      	nop
    9364:	20019870 	.word	0x20019870
    9368:	0000931d 	.word	0x0000931d

0000936c <tx_cb_USART_GRID_N>:
	tx_cb_USART_GRID(&GRID_PORT_N);
    936c:	4801      	ldr	r0, [pc, #4]	; (9374 <tx_cb_USART_GRID_N+0x8>)
    936e:	4b02      	ldr	r3, [pc, #8]	; (9378 <tx_cb_USART_GRID_N+0xc>)
    9370:	4718      	bx	r3
    9372:	bf00      	nop
    9374:	20009150 	.word	0x20009150
    9378:	0000931d 	.word	0x0000931d

0000937c <err_cb_USART_GRID>:
	err_cb_USART_GRID(&GRID_PORT_W);
}


void err_cb_USART_GRID(struct grid_port* const por){
	por->usart_error_flag = 1;	
    937c:	2301      	movs	r3, #1
    937e:	7603      	strb	r3, [r0, #24]
	
	usart_async_disable(por->usart);
    9380:	6840      	ldr	r0, [r0, #4]
    9382:	4b01      	ldr	r3, [pc, #4]	; (9388 <err_cb_USART_GRID+0xc>)
    9384:	4718      	bx	r3
    9386:	bf00      	nop
    9388:	000107e1 	.word	0x000107e1

0000938c <err_cb_USART_GRID_W>:
	err_cb_USART_GRID(&GRID_PORT_W);
    938c:	4801      	ldr	r0, [pc, #4]	; (9394 <err_cb_USART_GRID_W+0x8>)
    938e:	4b02      	ldr	r3, [pc, #8]	; (9398 <err_cb_USART_GRID_W+0xc>)
    9390:	4718      	bx	r3
    9392:	bf00      	nop
    9394:	200102d4 	.word	0x200102d4
    9398:	0000937d 	.word	0x0000937d

0000939c <err_cb_USART_GRID_S>:
	err_cb_USART_GRID(&GRID_PORT_S);
    939c:	4801      	ldr	r0, [pc, #4]	; (93a4 <err_cb_USART_GRID_S+0x8>)
    939e:	4b02      	ldr	r3, [pc, #8]	; (93a8 <err_cb_USART_GRID_S+0xc>)
    93a0:	4718      	bx	r3
    93a2:	bf00      	nop
    93a4:	200138d4 	.word	0x200138d4
    93a8:	0000937d 	.word	0x0000937d

000093ac <err_cb_USART_GRID_E>:
	err_cb_USART_GRID(&GRID_PORT_E);
    93ac:	4801      	ldr	r0, [pc, #4]	; (93b4 <err_cb_USART_GRID_E+0x8>)
    93ae:	4b02      	ldr	r3, [pc, #8]	; (93b8 <err_cb_USART_GRID_E+0xc>)
    93b0:	4718      	bx	r3
    93b2:	bf00      	nop
    93b4:	20019870 	.word	0x20019870
    93b8:	0000937d 	.word	0x0000937d

000093bc <err_cb_USART_GRID_N>:
	err_cb_USART_GRID(&GRID_PORT_N);
    93bc:	4801      	ldr	r0, [pc, #4]	; (93c4 <err_cb_USART_GRID_N+0x8>)
    93be:	4b02      	ldr	r3, [pc, #8]	; (93c8 <err_cb_USART_GRID_N+0xc>)
    93c0:	4718      	bx	r3
    93c2:	bf00      	nop
    93c4:	20009150 	.word	0x20009150
    93c8:	0000937d 	.word	0x0000937d

000093cc <grid_sys_port_reset_dma>:
#define DMA_SOUTH_RX_CHANNEL	2
#define DMA_WEST_RX_CHANNEL		3

void grid_sys_port_reset_dma(struct grid_port* por){
	
	hri_dmac_clear_CHCTRLA_ENABLE_bit(DMAC, por->dma_channel);
    93cc:	7a80      	ldrb	r0, [r0, #10]
}

static inline void hri_dmac_clear_CHCTRLA_ENABLE_bit(const void *const hw, uint8_t submodule_index)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg &= ~DMAC_CHCTRLA_ENABLE;
    93ce:	0103      	lsls	r3, r0, #4
    93d0:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    93d4:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
	_dma_enable_transaction(por->dma_channel, false);
    93d8:	2100      	movs	r1, #0
    93da:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    93dc:	f022 0202 	bic.w	r2, r2, #2
    93e0:	641a      	str	r2, [r3, #64]	; 0x40
    93e2:	4b01      	ldr	r3, [pc, #4]	; (93e8 <grid_sys_port_reset_dma+0x1c>)
    93e4:	4718      	bx	r3
    93e6:	bf00      	nop
    93e8:	0000e245 	.word	0x0000e245

000093ec <dma_transfer_complete_n_cb>:
	grid_sys_port_reset_dma(por);
    93ec:	4801      	ldr	r0, [pc, #4]	; (93f4 <dma_transfer_complete_n_cb+0x8>)
    93ee:	4b02      	ldr	r3, [pc, #8]	; (93f8 <dma_transfer_complete_n_cb+0xc>)
    93f0:	4718      	bx	r3
    93f2:	bf00      	nop
    93f4:	20009150 	.word	0x20009150
    93f8:	000093cd 	.word	0x000093cd

000093fc <dma_transfer_complete_e_cb>:
    93fc:	4801      	ldr	r0, [pc, #4]	; (9404 <dma_transfer_complete_e_cb+0x8>)
    93fe:	4b02      	ldr	r3, [pc, #8]	; (9408 <dma_transfer_complete_e_cb+0xc>)
    9400:	4718      	bx	r3
    9402:	bf00      	nop
    9404:	20019870 	.word	0x20019870
    9408:	000093cd 	.word	0x000093cd

0000940c <dma_transfer_complete_s_cb>:
    940c:	4801      	ldr	r0, [pc, #4]	; (9414 <dma_transfer_complete_s_cb+0x8>)
    940e:	4b02      	ldr	r3, [pc, #8]	; (9418 <dma_transfer_complete_s_cb+0xc>)
    9410:	4718      	bx	r3
    9412:	bf00      	nop
    9414:	200138d4 	.word	0x200138d4
    9418:	000093cd 	.word	0x000093cd

0000941c <dma_transfer_complete_w_cb>:
    941c:	4801      	ldr	r0, [pc, #4]	; (9424 <dma_transfer_complete_w_cb+0x8>)
    941e:	4b02      	ldr	r3, [pc, #8]	; (9428 <dma_transfer_complete_w_cb+0xc>)
    9420:	4718      	bx	r3
    9422:	bf00      	nop
    9424:	200102d4 	.word	0x200102d4
    9428:	000093cd 	.word	0x000093cd

0000942c <grid_sys_uart_init>:

}


void grid_sys_uart_init(){
    942c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 *                      GPIO_PULL_UP   = Pull pin high with internal resistor
 *                      GPIO_PULL_OFF  = Disable pin pull mode
 */
static inline void gpio_set_pin_pull_mode(const uint8_t pin, const enum gpio_pull_mode pull_mode)
{
	_gpio_set_pin_pull_mode((enum gpio_port)GPIO_PORT(pin), pin & 0x1F, pull_mode);
    9430:	211c      	movs	r1, #28
    9432:	4c2c      	ldr	r4, [pc, #176]	; (94e4 <grid_sys_uart_init+0xb8>)
	gpio_set_pin_pull_mode(PC28, GPIO_PULL_UP);
	gpio_set_pin_pull_mode(PC16, GPIO_PULL_UP);
	gpio_set_pin_pull_mode(PC12, GPIO_PULL_UP);
	gpio_set_pin_pull_mode(PB09, GPIO_PULL_UP);
	
	usart_async_register_callback(&USART_NORTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_N);
    9434:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 9530 <grid_sys_uart_init+0x104>
	usart_async_register_callback(&USART_EAST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_E);
    9438:	4f2b      	ldr	r7, [pc, #172]	; (94e8 <grid_sys_uart_init+0xbc>)
	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_S);
    943a:	4e2c      	ldr	r6, [pc, #176]	; (94ec <grid_sys_uart_init+0xc0>)
	usart_async_register_callback(&USART_WEST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_W);
    943c:	4d2c      	ldr	r5, [pc, #176]	; (94f0 <grid_sys_uart_init+0xc4>)
			
	// Set parity for grid uart communication
	usart_async_set_parity(&USART_NORTH, USART_PARITY_ODD);
    943e:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 9534 <grid_sys_uart_init+0x108>
    9442:	2002      	movs	r0, #2
    9444:	47a0      	blx	r4
    9446:	2110      	movs	r1, #16
    9448:	2002      	movs	r0, #2
    944a:	47a0      	blx	r4
    944c:	210c      	movs	r1, #12
    944e:	2002      	movs	r0, #2
    9450:	47a0      	blx	r4
    9452:	2109      	movs	r1, #9
    9454:	2001      	movs	r0, #1
    9456:	47a0      	blx	r4
	usart_async_register_callback(&USART_NORTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_N);
    9458:	4c26      	ldr	r4, [pc, #152]	; (94f4 <grid_sys_uart_init+0xc8>)
    945a:	4a27      	ldr	r2, [pc, #156]	; (94f8 <grid_sys_uart_init+0xcc>)
    945c:	2101      	movs	r1, #1
    945e:	4640      	mov	r0, r8
    9460:	47a0      	blx	r4
	usart_async_register_callback(&USART_EAST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_E);
    9462:	4a26      	ldr	r2, [pc, #152]	; (94fc <grid_sys_uart_init+0xd0>)
    9464:	2101      	movs	r1, #1
    9466:	4638      	mov	r0, r7
    9468:	47a0      	blx	r4
	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_S);
    946a:	4a25      	ldr	r2, [pc, #148]	; (9500 <grid_sys_uart_init+0xd4>)
    946c:	2101      	movs	r1, #1
    946e:	4630      	mov	r0, r6
    9470:	47a0      	blx	r4
	usart_async_register_callback(&USART_WEST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_W);
    9472:	4a24      	ldr	r2, [pc, #144]	; (9504 <grid_sys_uart_init+0xd8>)
    9474:	2101      	movs	r1, #1
    9476:	4628      	mov	r0, r5
    9478:	47a0      	blx	r4
	usart_async_set_parity(&USART_NORTH, USART_PARITY_ODD);
    947a:	2101      	movs	r1, #1
    947c:	4640      	mov	r0, r8
    947e:	47c8      	blx	r9
	usart_async_set_parity(&USART_EAST, USART_PARITY_ODD);	
    9480:	2101      	movs	r1, #1
    9482:	4638      	mov	r0, r7
    9484:	47c8      	blx	r9
	usart_async_set_parity(&USART_SOUTH, USART_PARITY_ODD);
    9486:	2101      	movs	r1, #1
    9488:	4630      	mov	r0, r6
    948a:	47c8      	blx	r9
	usart_async_set_parity(&USART_WEST, USART_PARITY_ODD);
    948c:	2101      	movs	r1, #1
    948e:	4628      	mov	r0, r5
    9490:	47c8      	blx	r9
	
	// Set callback function for parity error
	usart_async_register_callback(&USART_NORTH, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_N);
    9492:	4a1d      	ldr	r2, [pc, #116]	; (9508 <grid_sys_uart_init+0xdc>)
    9494:	2102      	movs	r1, #2
    9496:	4640      	mov	r0, r8
    9498:	47a0      	blx	r4
	usart_async_register_callback(&USART_EAST, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_E);
    949a:	4a1c      	ldr	r2, [pc, #112]	; (950c <grid_sys_uart_init+0xe0>)
    949c:	2102      	movs	r1, #2
    949e:	4638      	mov	r0, r7
    94a0:	47a0      	blx	r4
	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_S);
    94a2:	4a1b      	ldr	r2, [pc, #108]	; (9510 <grid_sys_uart_init+0xe4>)
    94a4:	2102      	movs	r1, #2
    94a6:	4630      	mov	r0, r6
    94a8:	47a0      	blx	r4
	usart_async_register_callback(&USART_WEST, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_W);
    94aa:	4a1a      	ldr	r2, [pc, #104]	; (9514 <grid_sys_uart_init+0xe8>)
    94ac:	2102      	movs	r1, #2
    94ae:	4628      	mov	r0, r5
    94b0:	47a0      	blx	r4
// 	usart_async_register_callback(&USART_EAST,  USART_ASYNC_RXC_CB, rx_cb_USART_GRID_E);
// 	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_RXC_CB, rx_cb_USART_GRID_S);
// 	usart_async_register_callback(&USART_WEST,  USART_ASYNC_RXC_CB, rx_cb_USART_GRID_W);

	
	usart_async_get_io_descriptor(&USART_NORTH, &grid_sys_north_io);
    94b2:	4c19      	ldr	r4, [pc, #100]	; (9518 <grid_sys_uart_init+0xec>)
    94b4:	4919      	ldr	r1, [pc, #100]	; (951c <grid_sys_uart_init+0xf0>)
    94b6:	4640      	mov	r0, r8
    94b8:	47a0      	blx	r4
	usart_async_get_io_descriptor(&USART_EAST,  &grid_sys_east_io);
    94ba:	4919      	ldr	r1, [pc, #100]	; (9520 <grid_sys_uart_init+0xf4>)
    94bc:	4638      	mov	r0, r7
    94be:	47a0      	blx	r4
	usart_async_get_io_descriptor(&USART_SOUTH, &grid_sys_south_io);
    94c0:	4918      	ldr	r1, [pc, #96]	; (9524 <grid_sys_uart_init+0xf8>)
    94c2:	4630      	mov	r0, r6
    94c4:	47a0      	blx	r4
	usart_async_get_io_descriptor(&USART_WEST,  &grid_sys_west_io);
    94c6:	4918      	ldr	r1, [pc, #96]	; (9528 <grid_sys_uart_init+0xfc>)
    94c8:	4628      	mov	r0, r5
    94ca:	47a0      	blx	r4
	
	
	usart_async_enable(&USART_NORTH);
    94cc:	4c17      	ldr	r4, [pc, #92]	; (952c <grid_sys_uart_init+0x100>)
    94ce:	4640      	mov	r0, r8
    94d0:	47a0      	blx	r4
	usart_async_enable(&USART_EAST);
    94d2:	4638      	mov	r0, r7
    94d4:	47a0      	blx	r4
	usart_async_enable(&USART_SOUTH);
    94d6:	4630      	mov	r0, r6
    94d8:	47a0      	blx	r4
	usart_async_enable(&USART_WEST);
    94da:	4628      	mov	r0, r5
    94dc:	4623      	mov	r3, r4




}
    94de:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	usart_async_enable(&USART_WEST);
    94e2:	4718      	bx	r3
    94e4:	00008d11 	.word	0x00008d11
    94e8:	2001cdb0 	.word	0x2001cdb0
    94ec:	2001cf08 	.word	0x2001cf08
    94f0:	2001ceb8 	.word	0x2001ceb8
    94f4:	00010831 	.word	0x00010831
    94f8:	0000936d 	.word	0x0000936d
    94fc:	0000935d 	.word	0x0000935d
    9500:	0000934d 	.word	0x0000934d
    9504:	0000933d 	.word	0x0000933d
    9508:	000093bd 	.word	0x000093bd
    950c:	000093ad 	.word	0x000093ad
    9510:	0000939d 	.word	0x0000939d
    9514:	0000938d 	.word	0x0000938d
    9518:	0001080d 	.word	0x0001080d
    951c:	2000f004 	.word	0x2000f004
    9520:	200138d0 	.word	0x200138d0
    9524:	20016820 	.word	0x20016820
    9528:	2001c850 	.word	0x2001c850
    952c:	000107b5 	.word	0x000107b5
    9530:	2001ce04 	.word	0x2001ce04
    9534:	00010891 	.word	0x00010891

00009538 <grid_sys_dma_rx_init_one>:



void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    9538:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
	
	uint8_t dma_rx_channel = por->dma_channel;
	
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    953a:	6843      	ldr	r3, [r0, #4]
	uint8_t dma_rx_channel = por->dma_channel;
    953c:	7a84      	ldrb	r4, [r0, #10]
void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    953e:	460f      	mov	r7, r1
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    9540:	6a19      	ldr	r1, [r3, #32]
    9542:	4b10      	ldr	r3, [pc, #64]	; (9584 <grid_sys_dma_rx_init_one+0x4c>)
void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    9544:	4605      	mov	r5, r0
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    9546:	3128      	adds	r1, #40	; 0x28
    9548:	4620      	mov	r0, r4
void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    954a:	4616      	mov	r6, r2
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    954c:	4798      	blx	r3
	_dma_set_destination_address(dma_rx_channel, (uint32_t *)por->rx_double_buffer);
    954e:	f505 519d 	add.w	r1, r5, #5024	; 0x13a0
    9552:	4b0d      	ldr	r3, [pc, #52]	; (9588 <grid_sys_dma_rx_init_one+0x50>)
    9554:	3114      	adds	r1, #20
    9556:	4620      	mov	r0, r4
    9558:	4798      	blx	r3
	_dma_set_data_amount(dma_rx_channel, (uint32_t)buffer_length);
    955a:	4639      	mov	r1, r7
    955c:	4b0b      	ldr	r3, [pc, #44]	; (958c <grid_sys_dma_rx_init_one+0x54>)
    955e:	4620      	mov	r0, r4
    9560:	4798      	blx	r3
	
	struct _dma_resource *resource_rx;
	_dma_get_channel_resource(&resource_rx, dma_rx_channel);
    9562:	4621      	mov	r1, r4
    9564:	4b0a      	ldr	r3, [pc, #40]	; (9590 <grid_sys_dma_rx_init_one+0x58>)
    9566:	a801      	add	r0, sp, #4
    9568:	4798      	blx	r3
	
	resource_rx->dma_cb.transfer_done = transfer_done_cb;
    956a:	9b01      	ldr	r3, [sp, #4]
	_dma_set_irq_state(dma_rx_channel, DMA_TRANSFER_COMPLETE_CB, true);
    956c:	2201      	movs	r2, #1
	resource_rx->dma_cb.transfer_done = transfer_done_cb;
    956e:	601e      	str	r6, [r3, #0]
	_dma_set_irq_state(dma_rx_channel, DMA_TRANSFER_COMPLETE_CB, true);
    9570:	4620      	mov	r0, r4
    9572:	4b08      	ldr	r3, [pc, #32]	; (9594 <grid_sys_dma_rx_init_one+0x5c>)
    9574:	2100      	movs	r1, #0
    9576:	4798      	blx	r3
	
	//resource_rx->dma_cb.error         = function_cb;
	_dma_enable_transaction(dma_rx_channel, false);
    9578:	4b07      	ldr	r3, [pc, #28]	; (9598 <grid_sys_dma_rx_init_one+0x60>)
    957a:	2100      	movs	r1, #0
    957c:	4620      	mov	r0, r4
    957e:	4798      	blx	r3
	

}
    9580:	b003      	add	sp, #12
    9582:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9584:	0000e1d5 	.word	0x0000e1d5
    9588:	0000e1c5 	.word	0x0000e1c5
    958c:	0000e201 	.word	0x0000e201
    9590:	0000e281 	.word	0x0000e281
    9594:	0000e19d 	.word	0x0000e19d
    9598:	0000e245 	.word	0x0000e245

0000959c <grid_sys_dma_rx_init>:

void grid_sys_dma_rx_init(){
    959c:	b510      	push	{r4, lr}
	
	grid_sys_dma_rx_init_one(&GRID_PORT_N, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_n_cb);
    959e:	4a10      	ldr	r2, [pc, #64]	; (95e0 <grid_sys_dma_rx_init+0x44>)
    95a0:	4c10      	ldr	r4, [pc, #64]	; (95e4 <grid_sys_dma_rx_init+0x48>)
    95a2:	4811      	ldr	r0, [pc, #68]	; (95e8 <grid_sys_dma_rx_init+0x4c>)
    95a4:	f241 3188 	movw	r1, #5000	; 0x1388
    95a8:	47a0      	blx	r4
	grid_sys_dma_rx_init_one(&GRID_PORT_E, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_e_cb);
    95aa:	4a10      	ldr	r2, [pc, #64]	; (95ec <grid_sys_dma_rx_init+0x50>)
    95ac:	4810      	ldr	r0, [pc, #64]	; (95f0 <grid_sys_dma_rx_init+0x54>)
    95ae:	f241 3188 	movw	r1, #5000	; 0x1388
    95b2:	47a0      	blx	r4
	grid_sys_dma_rx_init_one(&GRID_PORT_S, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_s_cb);
    95b4:	4a0f      	ldr	r2, [pc, #60]	; (95f4 <grid_sys_dma_rx_init+0x58>)
    95b6:	4810      	ldr	r0, [pc, #64]	; (95f8 <grid_sys_dma_rx_init+0x5c>)
    95b8:	f241 3188 	movw	r1, #5000	; 0x1388
    95bc:	47a0      	blx	r4
	grid_sys_dma_rx_init_one(&GRID_PORT_W, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_w_cb);
    95be:	4a0f      	ldr	r2, [pc, #60]	; (95fc <grid_sys_dma_rx_init+0x60>)
    95c0:	480f      	ldr	r0, [pc, #60]	; (9600 <grid_sys_dma_rx_init+0x64>)
    95c2:	f241 3188 	movw	r1, #5000	; 0x1388
    95c6:	47a0      	blx	r4
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    95c8:	4b0e      	ldr	r3, [pc, #56]	; (9604 <grid_sys_dma_rx_init+0x68>)
    95ca:	2200      	movs	r2, #0
    95cc:	f883 231f 	strb.w	r2, [r3, #799]	; 0x31f
    95d0:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
    95d4:	f883 2321 	strb.w	r2, [r3, #801]	; 0x321
    95d8:	f883 2322 	strb.w	r2, [r3, #802]	; 0x322
	NVIC_SetPriority(DMAC_0_IRQn, 0);
	NVIC_SetPriority(DMAC_1_IRQn, 0);
	NVIC_SetPriority(DMAC_2_IRQn, 0);
	NVIC_SetPriority(DMAC_3_IRQn, 0);
	
}
    95dc:	bd10      	pop	{r4, pc}
    95de:	bf00      	nop
    95e0:	000093ed 	.word	0x000093ed
    95e4:	00009539 	.word	0x00009539
    95e8:	20009150 	.word	0x20009150
    95ec:	000093fd 	.word	0x000093fd
    95f0:	20019870 	.word	0x20019870
    95f4:	0000940d 	.word	0x0000940d
    95f8:	200138d4 	.word	0x200138d4
    95fc:	0000941d 	.word	0x0000941d
    9600:	200102d4 	.word	0x200102d4
    9604:	e000e100 	.word	0xe000e100

00009608 <grid_sys_init>:
	return tmp;
}

static inline hri_rstc_rcause_reg_t hri_rstc_read_RCAUSE_reg(const void *const hw)
{
	return ((Rstc *)hw)->RCAUSE.reg;
    9608:	4b16      	ldr	r3, [pc, #88]	; (9664 <grid_sys_init+0x5c>)

void grid_sys_init(struct grid_sys_model* mod){
    960a:	b570      	push	{r4, r5, r6, lr}
    960c:	781b      	ldrb	r3, [r3, #0]
	
	mod->uptime = 0;
	mod->reset_cause = hri_rstc_read_RCAUSE_reg(RSTC);
    960e:	7103      	strb	r3, [r0, #4]
	mod->uptime = 0;
    9610:	2500      	movs	r5, #0
void grid_sys_init(struct grid_sys_model* mod){
    9612:	4604      	mov	r4, r0
	mod->uptime = 0;
    9614:	6005      	str	r5, [r0, #0]
	
    
	mod->sessionid = rand_sync_read8(&RAND_0);
    9616:	4b14      	ldr	r3, [pc, #80]	; (9668 <grid_sys_init+0x60>)
    9618:	4814      	ldr	r0, [pc, #80]	; (966c <grid_sys_init+0x64>)
    961a:	4798      	blx	r3
	mod->bank_color_r[3] = 100;
	mod->bank_color_g[3] = 0;
	mod->bank_color_b[3] = 200;
	
	mod->bank_enabled[0] = 1;
	mod->bank_enabled[1] = 1;
    961c:	4a14      	ldr	r2, [pc, #80]	; (9670 <grid_sys_init+0x68>)
    961e:	4b15      	ldr	r3, [pc, #84]	; (9674 <grid_sys_init+0x6c>)
	mod->bank_color_g[1] = 100;
    9620:	4915      	ldr	r1, [pc, #84]	; (9678 <grid_sys_init+0x70>)
	mod->sessionid = rand_sync_read8(&RAND_0);
    9622:	7160      	strb	r0, [r4, #5]
	mod->bank_enabled[1] = 1;
    9624:	e9c4 2304 	strd	r2, r3, [r4, #16]
	mod->bank_color_g[1] = 100;
    9628:	4b14      	ldr	r3, [pc, #80]	; (967c <grid_sys_init+0x74>)
	mod->bank_setting_changed_flag = 0;
	
	mod->bank_init_flag = 0;


	mod->bank_activebank_number = 0;
    962a:	73e5      	strb	r5, [r4, #15]
	mod->bank_color_g[1] = 100;
    962c:	e9c4 1306 	strd	r1, r3, [r4, #24]
	mod->bank_color_b[1] = 0;
    9630:	f44f 5348 	mov.w	r3, #12800	; 0x3200
    9634:	8423      	strh	r3, [r4, #32]
	mod->bank_color_b[3] = 200;
    9636:	23c8      	movs	r3, #200	; 0xc8
    9638:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	if (banknumber == 255){
			
		//mod->bank_activebank_number = 0;
		mod->bank_activebank_valid = 0;
		
		mod->bank_active_changed = 1;
    963c:	4b10      	ldr	r3, [pc, #64]	; (9680 <grid_sys_init+0x78>)
	mod->bank_activebank_color_r = 0;
    963e:	6265      	str	r5, [r4, #36]	; 0x24
		mod->bank_active_changed = 1;
    9640:	2201      	movs	r2, #1
    9642:	745a      	strb	r2, [r3, #17]
				
		mod->bank_activebank_color_r = 127;
    9644:	f647 727f 	movw	r2, #32639	; 0x7f7f
		mod->bank_activebank_valid = 0;
    9648:	f883 5023 	strb.w	r5, [r3, #35]	; 0x23
		mod->bank_activebank_color_r = 127;
    964c:	849a      	strh	r2, [r3, #36]	; 0x24
		mod->bank_activebank_color_g = 127;
		mod->bank_activebank_color_b = 127;
    964e:	227f      	movs	r2, #127	; 0x7f
    9650:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
	grid_port_init_all();
    9654:	4b0b      	ldr	r3, [pc, #44]	; (9684 <grid_sys_init+0x7c>)
    9656:	4798      	blx	r3
	grid_sys_uart_init();
    9658:	4b0b      	ldr	r3, [pc, #44]	; (9688 <grid_sys_init+0x80>)
    965a:	4798      	blx	r3
}
    965c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	grid_sys_dma_rx_init();
    9660:	4b0a      	ldr	r3, [pc, #40]	; (968c <grid_sys_init+0x84>)
    9662:	4718      	bx	r3
    9664:	40000c00 	.word	0x40000c00
    9668:	0000e7b5 	.word	0x0000e7b5
    966c:	2001cd7c 	.word	0x2001cd7c
    9670:	01000001 	.word	0x01000001
    9674:	00010101 	.word	0x00010101
    9678:	646432c8 	.word	0x646432c8
    967c:	c800c864 	.word	0xc800c864
    9680:	2000f008 	.word	0x2000f008
    9684:	0000511d 	.word	0x0000511d
    9688:	0000942d 	.word	0x0000942d
    968c:	0000959d 	.word	0x0000959d

00009690 <grid_sys_bank_enable>:
	if (banknumber<GRID_SYS_BANK_MAXNUMBER){
    9690:	2903      	cmp	r1, #3
		mod->bank_enabled[banknumber] = 1;
    9692:	bf9e      	ittt	ls
    9694:	1809      	addls	r1, r1, r0
    9696:	2301      	movls	r3, #1
    9698:	74cb      	strbls	r3, [r1, #19]
}
    969a:	4770      	bx	lr

0000969c <grid_sys_bank_disable>:
	if (banknumber<GRID_SYS_BANK_MAXNUMBER){
    969c:	2903      	cmp	r1, #3
		mod->bank_enabled[banknumber] = 0;
    969e:	bf9e      	ittt	ls
    96a0:	1809      	addls	r1, r1, r0
    96a2:	2300      	movls	r3, #0
    96a4:	74cb      	strbls	r3, [r1, #19]
}
    96a6:	4770      	bx	lr

000096a8 <grid_sys_bank_set_color>:
	if (banknumber>GRID_SYS_BANK_MAXNUMBER){
    96a8:	2904      	cmp	r1, #4
    96aa:	d901      	bls.n	96b0 <grid_sys_bank_set_color+0x8>
		return false;
    96ac:	2000      	movs	r0, #0
    96ae:	4770      	bx	lr
	mod->bank_color_r[banknumber] = ((rgb&0x00FF0000)>>16);
    96b0:	4401      	add	r1, r0
    96b2:	0c13      	lsrs	r3, r2, #16
    96b4:	75cb      	strb	r3, [r1, #23]
	mod->bank_color_g[banknumber] = ((rgb&0x0000FF00)>>8);
    96b6:	0a13      	lsrs	r3, r2, #8
    96b8:	76cb      	strb	r3, [r1, #27]
	mod->bank_color_b[banknumber] = ((rgb&0x000000FF)>>0);
    96ba:	77ca      	strb	r2, [r1, #31]
}
    96bc:	4770      	bx	lr

000096be <grid_sys_get_bank_num>:
}
    96be:	7bc0      	ldrb	r0, [r0, #15]
    96c0:	4770      	bx	lr

000096c2 <grid_sys_get_bank_valid>:
}
    96c2:	f890 0023 	ldrb.w	r0, [r0, #35]	; 0x23
    96c6:	4770      	bx	lr

000096c8 <grid_sys_get_bank_red>:
}
    96c8:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24
    96cc:	4770      	bx	lr

000096ce <grid_sys_get_bank_gre>:
}
    96ce:	f890 0025 	ldrb.w	r0, [r0, #37]	; 0x25
    96d2:	4770      	bx	lr

000096d4 <grid_sys_get_bank_blu>:
}
    96d4:	f890 0026 	ldrb.w	r0, [r0, #38]	; 0x26
    96d8:	4770      	bx	lr

000096da <grid_sys_get_map_state>:
}
    96da:	7c00      	ldrb	r0, [r0, #16]
    96dc:	4770      	bx	lr

000096de <grid_sys_get_bank_next>:
uint8_t grid_sys_get_bank_next(struct grid_sys_model* mod){
    96de:	b530      	push	{r4, r5, lr}
    96e0:	4602      	mov	r2, r0
	return mod->bank_activebank_number;
    96e2:	7bc0      	ldrb	r0, [r0, #15]
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    96e4:	1c43      	adds	r3, r0, #1
    96e6:	1d44      	adds	r4, r0, #5
		uint8_t bank_check = (current_active+i+1)%GRID_SYS_BANK_MAXNUMBER;
    96e8:	f003 0103 	and.w	r1, r3, #3
		if (mod->bank_enabled[bank_check] == 1){
    96ec:	1855      	adds	r5, r2, r1
    96ee:	7ced      	ldrb	r5, [r5, #19]
    96f0:	2d01      	cmp	r5, #1
    96f2:	d003      	beq.n	96fc <grid_sys_get_bank_next+0x1e>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    96f4:	3301      	adds	r3, #1
    96f6:	42a3      	cmp	r3, r4
    96f8:	d1f6      	bne.n	96e8 <grid_sys_get_bank_next+0xa>
}
    96fa:	bd30      	pop	{r4, r5, pc}
		uint8_t bank_check = (current_active+i+1)%GRID_SYS_BANK_MAXNUMBER;
    96fc:	b2c8      	uxtb	r0, r1
    96fe:	e7fc      	b.n	96fa <grid_sys_get_bank_next+0x1c>

00009700 <grid_sys_get_bank_number_of_first_valid>:
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    9700:	f100 0213 	add.w	r2, r0, #19
uint8_t grid_sys_get_bank_number_of_first_valid(struct grid_sys_model* mod){
    9704:	2300      	movs	r3, #0
		if (mod->bank_enabled[i] == 1){
    9706:	f812 1b01 	ldrb.w	r1, [r2], #1
    970a:	2901      	cmp	r1, #1
    970c:	b2d8      	uxtb	r0, r3
    970e:	d003      	beq.n	9718 <grid_sys_get_bank_number_of_first_valid+0x18>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    9710:	3301      	adds	r3, #1
    9712:	2b04      	cmp	r3, #4
    9714:	d1f7      	bne.n	9706 <grid_sys_get_bank_number_of_first_valid+0x6>
	return 255;
    9716:	20ff      	movs	r0, #255	; 0xff
}
    9718:	4770      	bx	lr

0000971a <grid_sys_set_bank>:
	if (banknumber == 255){
    971a:	29ff      	cmp	r1, #255	; 0xff
    971c:	d10b      	bne.n	9736 <grid_sys_set_bank+0x1c>
		mod->bank_active_changed = 1;
    971e:	2301      	movs	r3, #1
    9720:	7443      	strb	r3, [r0, #17]
		mod->bank_activebank_valid = 0;
    9722:	2300      	movs	r3, #0
    9724:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
		mod->bank_activebank_color_r = 127;
    9728:	f647 737f 	movw	r3, #32639	; 0x7f7f
    972c:	8483      	strh	r3, [r0, #36]	; 0x24
		mod->bank_activebank_color_b = 127;
    972e:	237f      	movs	r3, #127	; 0x7f
			
			mod->bank_active_changed = 1;
			
			mod->bank_activebank_color_r = mod->bank_color_r[mod->bank_activebank_number];
			mod->bank_activebank_color_g = mod->bank_color_g[mod->bank_activebank_number];
			mod->bank_activebank_color_b = mod->bank_color_b[mod->bank_activebank_number];	
    9730:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
		//grid_debug_print_text("Invalid Bank Number");	
				
	}

	
}
    9734:	4770      	bx	lr
	else if (banknumber<GRID_SYS_BANK_MAXNUMBER){
    9736:	2903      	cmp	r1, #3
    9738:	d8fc      	bhi.n	9734 <grid_sys_set_bank+0x1a>
		mod->bank_init_flag = 1;
    973a:	2301      	movs	r3, #1
    973c:	f880 3027 	strb.w	r3, [r0, #39]	; 0x27
		if (mod->bank_enabled[banknumber] == 1){
    9740:	1843      	adds	r3, r0, r1
    9742:	7cda      	ldrb	r2, [r3, #19]
    9744:	2a01      	cmp	r2, #1
    9746:	d1f5      	bne.n	9734 <grid_sys_set_bank+0x1a>
			mod->bank_activebank_number = banknumber;
    9748:	73c1      	strb	r1, [r0, #15]
			mod->bank_activebank_valid = 1;
    974a:	f880 2023 	strb.w	r2, [r0, #35]	; 0x23
			mod->bank_active_changed = 1;
    974e:	7442      	strb	r2, [r0, #17]
			mod->bank_activebank_color_r = mod->bank_color_r[mod->bank_activebank_number];
    9750:	7dda      	ldrb	r2, [r3, #23]
    9752:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
			mod->bank_activebank_color_g = mod->bank_color_g[mod->bank_activebank_number];
    9756:	7eda      	ldrb	r2, [r3, #27]
    9758:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
			mod->bank_activebank_color_b = mod->bank_color_b[mod->bank_activebank_number];	
    975c:	7fdb      	ldrb	r3, [r3, #31]
    975e:	e7e7      	b.n	9730 <grid_sys_set_bank+0x16>

00009760 <grid_sys_rtc_get_time>:

// REALTIME

uint32_t grid_sys_rtc_get_time(struct grid_sys_model* mod){
	return mod->realtime;
}
    9760:	6a80      	ldr	r0, [r0, #40]	; 0x28
    9762:	4770      	bx	lr

00009764 <grid_sys_rtc_get_elapsed_time>:
	mod->realtime = tvalue;
}

uint32_t grid_sys_rtc_get_elapsed_time(struct grid_sys_model* mod, uint32_t t_old){
	
	return mod->realtime-t_old;
    9764:	6a80      	ldr	r0, [r0, #40]	; 0x28
	
	

}
    9766:	1a40      	subs	r0, r0, r1
    9768:	4770      	bx	lr

0000976a <grid_sys_rtc_tick_time>:

void grid_sys_rtc_tick_time(struct grid_sys_model* mod){
	
	mod->realtime++;
    976a:	6a83      	ldr	r3, [r0, #40]	; 0x28
    976c:	3301      	adds	r3, #1
    976e:	6283      	str	r3, [r0, #40]	; 0x28
	if (mod->uptime != -1){
    9770:	6803      	ldr	r3, [r0, #0]
    9772:	1c5a      	adds	r2, r3, #1
		mod->uptime++;
    9774:	bf1c      	itt	ne
    9776:	3301      	addne	r3, #1
    9778:	6003      	strne	r3, [r0, #0]
	}
	
}
    977a:	4770      	bx	lr

0000977c <grid_sys_alert_read_color_changed_flag>:

uint8_t grid_sys_alert_read_color_changed_flag(struct grid_sys_model* mod){
		
	return mod->alert_color_changed;
	
}
    977c:	7b80      	ldrb	r0, [r0, #14]
    977e:	4770      	bx	lr

00009780 <grid_sys_alert_clear_color_changed_flag>:
	
}

void grid_sys_alert_clear_color_changed_flag(struct grid_sys_model* mod){
	
	mod->alert_color_changed = 0;
    9780:	2300      	movs	r3, #0
    9782:	7383      	strb	r3, [r0, #14]
	
}
    9784:	4770      	bx	lr

00009786 <grid_sys_alert_get_color_intensity>:

uint8_t grid_sys_alert_get_color_intensity(struct grid_sys_model* mod){
	
	if (mod->alert_style == 0){ // TRIANGLE
    9786:	7b03      	ldrb	r3, [r0, #12]
    9788:	b963      	cbnz	r3, 97a4 <grid_sys_alert_get_color_intensity+0x1e>
		
		return (250-abs(mod->alert_state/2-250))/2;
    978a:	8940      	ldrh	r0, [r0, #10]
    978c:	0840      	lsrs	r0, r0, #1
    978e:	38fa      	subs	r0, #250	; 0xfa
    9790:	2800      	cmp	r0, #0
    9792:	bfb8      	it	lt
    9794:	4240      	neglt	r0, r0
    9796:	f1c0 00fa 	rsb	r0, r0, #250	; 0xfa
    979a:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
    979e:	f3c0 0047 	ubfx	r0, r0, #1, #8
    97a2:	4770      	bx	lr
	}
	else if (mod->alert_style == 1){ // SQUARE
    97a4:	2b01      	cmp	r3, #1
    97a6:	d107      	bne.n	97b8 <grid_sys_alert_get_color_intensity+0x32>
		
		return 255*(mod->alert_state/250%2);
    97a8:	8940      	ldrh	r0, [r0, #10]
    97aa:	23fa      	movs	r3, #250	; 0xfa
    97ac:	fbb0 f0f3 	udiv	r0, r0, r3
    97b0:	f340 0000 	sbfx	r0, r0, #0, #1
    97b4:	b2c0      	uxtb	r0, r0
    97b6:	4770      	bx	lr
	}
	else if (mod->alert_style == 2){ // CONST
    97b8:	2b02      	cmp	r3, #2
    97ba:	d105      	bne.n	97c8 <grid_sys_alert_get_color_intensity+0x42>
		
		return 255*(mod->alert_state>100);
    97bc:	8940      	ldrh	r0, [r0, #10]
    97be:	2864      	cmp	r0, #100	; 0x64
    97c0:	bf8c      	ite	hi
    97c2:	20ff      	movhi	r0, #255	; 0xff
    97c4:	2000      	movls	r0, #0
    97c6:	4770      	bx	lr
	}
	
	
}
    97c8:	4770      	bx	lr

000097ca <grid_sys_alert_set_alert>:
	mod->alert_color_green = green;
	mod->alert_color_blue = blue;
		
}

void grid_sys_alert_set_alert(struct grid_sys_model* mod, uint8_t red, uint8_t green, uint8_t blue, uint8_t style, uint16_t duration){
    97ca:	b510      	push	{r4, lr}
	mod->alert_color_blue = blue;
    97cc:	7203      	strb	r3, [r0, #8]
	
	grid_sys_alert_set_color(mod, red, green, blue);

	
	mod->alert_state = duration;
    97ce:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    97d2:	8143      	strh	r3, [r0, #10]
	mod->alert_color_changed = 1;
    97d4:	2401      	movs	r4, #1
	mod->alert_style = style;
    97d6:	f89d 3008 	ldrb.w	r3, [sp, #8]
	mod->alert_color_changed = 1;
    97da:	7384      	strb	r4, [r0, #14]
	mod->alert_color_red = red;
    97dc:	7181      	strb	r1, [r0, #6]
	mod->alert_color_green = green;
    97de:	71c2      	strb	r2, [r0, #7]
	mod->alert_style = style;
    97e0:	7303      	strb	r3, [r0, #12]
	
}
    97e2:	bd10      	pop	{r4, pc}

000097e4 <grid_sys_alert_get_color_r>:

uint8_t grid_sys_alert_get_color_r(struct grid_sys_model* mod){
	
	return mod->alert_color_red;
}
    97e4:	7980      	ldrb	r0, [r0, #6]
    97e6:	4770      	bx	lr

000097e8 <grid_sys_alert_get_color_g>:

uint8_t grid_sys_alert_get_color_g(struct grid_sys_model* mod){
	
	return mod->alert_color_green;
}
    97e8:	79c0      	ldrb	r0, [r0, #7]
    97ea:	4770      	bx	lr

000097ec <grid_sys_alert_get_color_b>:

uint8_t grid_sys_alert_get_color_b(struct grid_sys_model* mod){
	
	return mod->alert_color_blue;
}
    97ec:	7a00      	ldrb	r0, [r0, #8]
    97ee:	4770      	bx	lr

000097f0 <grid_sys_read_hex_char_value>:

uint8_t grid_sys_read_hex_char_value(uint8_t ascii, uint8_t* error_flag){
		
	uint8_t result = 0;
	
	if (ascii>47 && ascii<58){
    97f0:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    97f4:	b2db      	uxtb	r3, r3
    97f6:	2b09      	cmp	r3, #9
    97f8:	d905      	bls.n	9806 <grid_sys_read_hex_char_value+0x16>
		result = ascii-48;
	}
	else if(ascii>96 && ascii<103){
    97fa:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
    97fe:	2b05      	cmp	r3, #5
    9800:	d803      	bhi.n	980a <grid_sys_read_hex_char_value+0x1a>
		result = ascii - 97 + 10;
    9802:	3857      	subs	r0, #87	; 0x57
    9804:	b2c3      	uxtb	r3, r0
			*error_flag = ascii;
		}
	}
	
	return result;	
}
    9806:	4618      	mov	r0, r3
    9808:	4770      	bx	lr
		if (error_flag != NULL){
    980a:	b111      	cbz	r1, 9812 <grid_sys_read_hex_char_value+0x22>
			*error_flag = ascii;
    980c:	7008      	strb	r0, [r1, #0]
	uint8_t result = 0;
    980e:	2300      	movs	r3, #0
    9810:	e7f9      	b.n	9806 <grid_sys_read_hex_char_value+0x16>
    9812:	460b      	mov	r3, r1
    9814:	e7f7      	b.n	9806 <grid_sys_read_hex_char_value+0x16>
	...

00009818 <grid_sys_read_hex_string_value>:

uint32_t grid_sys_read_hex_string_value(uint8_t* start_location, uint8_t length, uint8_t* error_flag){
    9818:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	
	uint32_t result  = 0;
	
	for(uint8_t i=0; i<length; i++){
		
		result += grid_sys_read_hex_char_value(start_location[i], error_flag) << (length-i-1)*4;
    981a:	4f08      	ldr	r7, [pc, #32]	; (983c <grid_sys_read_hex_string_value+0x24>)
    981c:	1e45      	subs	r5, r0, #1
    981e:	008c      	lsls	r4, r1, #2
	uint32_t result  = 0;
    9820:	2600      	movs	r6, #0
	for(uint8_t i=0; i<length; i++){
    9822:	3c04      	subs	r4, #4
    9824:	1d23      	adds	r3, r4, #4
    9826:	d101      	bne.n	982c <grid_sys_read_hex_string_value+0x14>

		
	}

	return result;
}
    9828:	4630      	mov	r0, r6
    982a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		result += grid_sys_read_hex_char_value(start_location[i], error_flag) << (length-i-1)*4;
    982c:	f815 0f01 	ldrb.w	r0, [r5, #1]!
    9830:	4611      	mov	r1, r2
    9832:	47b8      	blx	r7
    9834:	40a0      	lsls	r0, r4
    9836:	4406      	add	r6, r0
	for(uint8_t i=0; i<length; i++){
    9838:	e7f3      	b.n	9822 <grid_sys_read_hex_string_value+0xa>
    983a:	bf00      	nop
    983c:	000097f1 	.word	0x000097f1

00009840 <grid_sys_write_hex_string_value>:

void grid_sys_write_hex_string_value(uint8_t* start_location, uint8_t size, uint32_t value){
    9840:	b530      	push	{r4, r5, lr}
    9842:	b085      	sub	sp, #20
	
	uint8_t str[10];
	
	sprintf(str, "%08x", value);
    9844:	4b0a      	ldr	r3, [pc, #40]	; (9870 <grid_sys_write_hex_string_value+0x30>)
void grid_sys_write_hex_string_value(uint8_t* start_location, uint8_t size, uint32_t value){
    9846:	460c      	mov	r4, r1
    9848:	4605      	mov	r5, r0
	sprintf(str, "%08x", value);
    984a:	490a      	ldr	r1, [pc, #40]	; (9874 <grid_sys_write_hex_string_value+0x34>)
    984c:	a801      	add	r0, sp, #4
    984e:	4798      	blx	r3
		
	for(uint8_t i=0; i<size; i++){	
    9850:	aa01      	add	r2, sp, #4
    9852:	f1c4 0308 	rsb	r3, r4, #8
    9856:	4413      	add	r3, r2
    9858:	2200      	movs	r2, #0
    985a:	b2d1      	uxtb	r1, r2
    985c:	428c      	cmp	r4, r1
    985e:	d801      	bhi.n	9864 <grid_sys_write_hex_string_value+0x24>
		start_location[i] = str[8-size+i];	
	}

}
    9860:	b005      	add	sp, #20
    9862:	bd30      	pop	{r4, r5, pc}
		start_location[i] = str[8-size+i];	
    9864:	f813 1b01 	ldrb.w	r1, [r3], #1
    9868:	54a9      	strb	r1, [r5, r2]
	for(uint8_t i=0; i<size; i++){	
    986a:	3201      	adds	r2, #1
    986c:	e7f5      	b.n	985a <grid_sys_write_hex_string_value+0x1a>
    986e:	bf00      	nop
    9870:	00014791 	.word	0x00014791
    9874:	00015d21 	.word	0x00015d21

00009878 <grid_sys_get_id>:



uint32_t grid_sys_get_id(uint32_t* return_array){
			
	return_array[0] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_0);
    9878:	4b06      	ldr	r3, [pc, #24]	; (9894 <grid_sys_get_id+0x1c>)
    987a:	681b      	ldr	r3, [r3, #0]
    987c:	6003      	str	r3, [r0, #0]
	return_array[1] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_1);
    987e:	4b06      	ldr	r3, [pc, #24]	; (9898 <grid_sys_get_id+0x20>)
    9880:	681b      	ldr	r3, [r3, #0]
    9882:	6043      	str	r3, [r0, #4]
	return_array[2] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_2);
    9884:	4b05      	ldr	r3, [pc, #20]	; (989c <grid_sys_get_id+0x24>)
    9886:	681b      	ldr	r3, [r3, #0]
    9888:	6083      	str	r3, [r0, #8]
	return_array[3] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_3);
    988a:	4b05      	ldr	r3, [pc, #20]	; (98a0 <grid_sys_get_id+0x28>)
    988c:	681b      	ldr	r3, [r3, #0]
    988e:	60c3      	str	r3, [r0, #12]
	
	return 1;
	
}
    9890:	2001      	movs	r0, #1
    9892:	4770      	bx	lr
    9894:	008061fc 	.word	0x008061fc
    9898:	00806010 	.word	0x00806010
    989c:	00806014 	.word	0x00806014
    98a0:	00806018 	.word	0x00806018

000098a4 <grid_sys_get_hwcfg>:

uint32_t grid_sys_get_hwcfg(){
    98a4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	
	// Read the register for the first time, then later just return the saved value

	if (grid_sys_hwfcg == -1){
    98a8:	4e30      	ldr	r6, [pc, #192]	; (996c <grid_sys_get_hwcfg+0xc8>)
    98aa:	6833      	ldr	r3, [r6, #0]
    98ac:	3301      	adds	r3, #1
    98ae:	d158      	bne.n	9962 <grid_sys_get_hwcfg+0xbe>
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    98b0:	4c2f      	ldr	r4, [pc, #188]	; (9970 <grid_sys_get_hwcfg+0xcc>)
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    98b2:	4b30      	ldr	r3, [pc, #192]	; (9974 <grid_sys_get_hwcfg+0xd0>)
		gpio_set_pin_direction(HWCFG_CLOCK, GPIO_DIRECTION_OUT);
		gpio_set_pin_direction(HWCFG_DATA, GPIO_DIRECTION_IN);
			
		// LOAD DATA
		gpio_set_pin_level(HWCFG_SHIFT, 0);
		delay_ms(1);
    98b4:	4f30      	ldr	r7, [pc, #192]	; (9978 <grid_sys_get_hwcfg+0xd4>)
	CRITICAL_SECTION_ENTER();
    98b6:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 9984 <grid_sys_get_hwcfg+0xe0>
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    98ba:	f44f 5500 	mov.w	r5, #8192	; 0x2000
    98be:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
    98c2:	f44f 4280 	mov.w	r2, #16384	; 0x4000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    98c6:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    98ca:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    98ce:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    98d2:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    98d6:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    98da:	f8c4 20a8 	str.w	r2, [r4, #168]	; 0xa8
    98de:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    98e2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    98e6:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    98ea:	4b24      	ldr	r3, [pc, #144]	; (997c <grid_sys_get_hwcfg+0xd8>)
    98ec:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    98f0:	f1a3 2380 	sub.w	r3, r3, #2147516416	; 0x80008000
    98f4:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    98f8:	2001      	movs	r0, #1
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    98fa:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    98fe:	47b8      	blx	r7
    9900:	f04f 0a00 	mov.w	sl, #0
			
			
			
		uint8_t hwcfg_value = 0;
    9904:	46d3      	mov	fp, sl
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    9906:	46a8      	mov	r8, r5
			
		for(uint8_t i = 0; i<8; i++){ // now we need to shift in the remaining 7 values
				
			// SHIFT DATA
			gpio_set_pin_level(HWCFG_SHIFT, 1); //This outputs the first value to HWCFG_DATA
			delay_ms(1);
    9908:	2001      	movs	r0, #1
    990a:	f8c4 8098 	str.w	r8, [r4, #152]	; 0x98
    990e:	47b8      	blx	r7
    9910:	a801      	add	r0, sp, #4
    9912:	47c8      	blx	r9
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    9914:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    9918:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    991c:	f8d4 5090 	ldr.w	r5, [r4, #144]	; 0x90
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    9920:	405d      	eors	r5, r3
    9922:	4015      	ands	r5, r2
    9924:	405d      	eors	r5, r3
	CRITICAL_SECTION_LEAVE();
    9926:	a801      	add	r0, sp, #4
    9928:	4b15      	ldr	r3, [pc, #84]	; (9980 <grid_sys_get_hwcfg+0xdc>)
    992a:	4798      	blx	r3
				
				
			if(gpio_get_pin_level(HWCFG_DATA)){
    992c:	042b      	lsls	r3, r5, #16
					
				hwcfg_value |= (1<<i);
    992e:	bf41      	itttt	mi
    9930:	2301      	movmi	r3, #1
    9932:	fa03 f30a 	lslmi.w	r3, r3, sl
    9936:	ea43 0b0b 	orrmi.w	fp, r3, fp
    993a:	fa5f fb8b 	uxtbmi.w	fp, fp
				}else{
					
					
			}
				
			if(i!=7){
    993e:	f1ba 0f07 	cmp.w	sl, #7
    9942:	d007      	beq.n	9954 <grid_sys_get_hwcfg+0xb0>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    9944:	f44f 4580 	mov.w	r5, #16384	; 0x4000
    9948:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
					
				// Clock rise
				gpio_set_pin_level(HWCFG_CLOCK, 1);
					
				delay_ms(1);
    994c:	2001      	movs	r0, #1
    994e:	47b8      	blx	r7
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    9950:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
		for(uint8_t i = 0; i<8; i++){ // now we need to shift in the remaining 7 values
    9954:	f10a 0a01 	add.w	sl, sl, #1
    9958:	f1ba 0f08 	cmp.w	sl, #8
    995c:	d1d4      	bne.n	9908 <grid_sys_get_hwcfg+0x64>
				gpio_set_pin_level(HWCFG_CLOCK, 0);
			}
							
		}
		
		grid_sys_hwfcg = hwcfg_value;
    995e:	f8c6 b000 	str.w	fp, [r6]
	}

	
	return grid_sys_hwfcg;

}
    9962:	6830      	ldr	r0, [r6, #0]
    9964:	b003      	add	sp, #12
    9966:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    996a:	bf00      	nop
    996c:	2000034c 	.word	0x2000034c
    9970:	41008000 	.word	0x41008000
    9974:	40002000 	.word	0x40002000
    9978:	0000dd8d 	.word	0x0000dd8d
    997c:	40028000 	.word	0x40028000
    9980:	00011b17 	.word	0x00011b17
    9984:	00011b09 	.word	0x00011b09

00009988 <grid_msg_calculate_checksum_of_packet_string>:
	grid_sys_ping(&GRID_PORT_S);
	grid_sys_ping(&GRID_PORT_W);
	
}

uint8_t grid_msg_calculate_checksum_of_packet_string(uint8_t* str, uint32_t length){
    9988:	b510      	push	{r4, lr}
	
	uint8_t checksum = 0;
	for (uint32_t i=0; i<length-3; i++){
    998a:	2300      	movs	r3, #0
uint8_t grid_msg_calculate_checksum_of_packet_string(uint8_t* str, uint32_t length){
    998c:	4602      	mov	r2, r0
	for (uint32_t i=0; i<length-3; i++){
    998e:	3903      	subs	r1, #3
	uint8_t checksum = 0;
    9990:	4618      	mov	r0, r3
	for (uint32_t i=0; i<length-3; i++){
    9992:	4299      	cmp	r1, r3
    9994:	d800      	bhi.n	9998 <grid_msg_calculate_checksum_of_packet_string+0x10>
		checksum ^= str[i];
	}
	
	return checksum;
	
}
    9996:	bd10      	pop	{r4, pc}
		checksum ^= str[i];
    9998:	5cd4      	ldrb	r4, [r2, r3]
	for (uint32_t i=0; i<length-3; i++){
    999a:	3301      	adds	r3, #1
		checksum ^= str[i];
    999c:	4060      	eors	r0, r4
	for (uint32_t i=0; i<length-3; i++){
    999e:	e7f8      	b.n	9992 <grid_msg_calculate_checksum_of_packet_string+0xa>

000099a0 <grid_msg_checksum_read>:
	return checksum;
	
}


uint8_t grid_msg_checksum_read(uint8_t* str, uint32_t length){
    99a0:	b507      	push	{r0, r1, r2, lr}
	uint8_t error_flag;
	return grid_sys_read_hex_string_value(&str[length-3], 2, &error_flag);
    99a2:	1ecb      	subs	r3, r1, #3
    99a4:	f10d 0207 	add.w	r2, sp, #7
    99a8:	2102      	movs	r1, #2
    99aa:	4418      	add	r0, r3
    99ac:	4b02      	ldr	r3, [pc, #8]	; (99b8 <grid_msg_checksum_read+0x18>)
    99ae:	4798      	blx	r3
}
    99b0:	b2c0      	uxtb	r0, r0
    99b2:	b003      	add	sp, #12
    99b4:	f85d fb04 	ldr.w	pc, [sp], #4
    99b8:	00009819 	.word	0x00009819

000099bc <grid_msg_checksum_write>:
// 	sprintf(checksum_string, "%02x", checksum);
// 
// 	message[length-3] = checksum_string[0];
// 	message[length-2] = checksum_string[1];
	
	grid_sys_write_hex_string_value(&message[length-3], 2, checksum);
    99bc:	1ecb      	subs	r3, r1, #3
    99be:	4418      	add	r0, r3
    99c0:	2102      	movs	r1, #2
    99c2:	4b01      	ldr	r3, [pc, #4]	; (99c8 <grid_msg_checksum_write+0xc>)
    99c4:	4718      	bx	r3
    99c6:	bf00      	nop
    99c8:	00009841 	.word	0x00009841

000099cc <grid_msg_get_parameter>:
}


// MESSAGE PARAMETER FUNCTIONS

uint32_t grid_msg_get_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint8_t* error){
    99cc:	b410      	push	{r4}
    99ce:	460c      	mov	r4, r1
		
	return grid_sys_read_hex_string_value(&message[offset], length, error);	
    99d0:	4420      	add	r0, r4
uint32_t grid_msg_get_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint8_t* error){
    99d2:	4611      	mov	r1, r2
}
    99d4:	f85d 4b04 	ldr.w	r4, [sp], #4
	return grid_sys_read_hex_string_value(&message[offset], length, error);	
    99d8:	461a      	mov	r2, r3
    99da:	4b01      	ldr	r3, [pc, #4]	; (99e0 <grid_msg_get_parameter+0x14>)
    99dc:	4718      	bx	r3
    99de:	bf00      	nop
    99e0:	00009819 	.word	0x00009819

000099e4 <grid_msg_set_parameter>:

uint32_t grid_msg_set_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint32_t value, uint8_t* error){
    99e4:	b510      	push	{r4, lr}
    99e6:	460c      	mov	r4, r1
	
	grid_sys_write_hex_string_value(&message[offset], length, value);
    99e8:	4420      	add	r0, r4
uint32_t grid_msg_set_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint32_t value, uint8_t* error){
    99ea:	4611      	mov	r1, r2
	grid_sys_write_hex_string_value(&message[offset], length, value);
    99ec:	461a      	mov	r2, r3
    99ee:	4b01      	ldr	r3, [pc, #4]	; (99f4 <grid_msg_set_parameter+0x10>)
    99f0:	4798      	blx	r3
	
}
    99f2:	bd10      	pop	{r4, pc}
    99f4:	00009841 	.word	0x00009841

000099f8 <grid_msg_find_recent>:

uint8_t grid_msg_find_recent(struct grid_sys_model* model, uint32_t fingerprint){
	
    //uint32_t fingerprint = updated_id*256*256*256 + updated_dx*256*256 + updated_dy*256 + updated_age;
    
	for(GRID_SYS_RECENT_MESSAGES_INDEX_T i = 0; i<GRID_SYS_RECENT_MESSAGES_LENGTH; i++){
    99f8:	f100 032c 	add.w	r3, r0, #44	; 0x2c
    99fc:	30ac      	adds	r0, #172	; 0xac
		
		if (model->recent_messages[i%GRID_SYS_RECENT_MESSAGES_LENGTH] == fingerprint){
    99fe:	f853 2b04 	ldr.w	r2, [r3], #4
    9a02:	428a      	cmp	r2, r1
    9a04:	d003      	beq.n	9a0e <grid_msg_find_recent+0x16>
	for(GRID_SYS_RECENT_MESSAGES_INDEX_T i = 0; i<GRID_SYS_RECENT_MESSAGES_LENGTH; i++){
    9a06:	4283      	cmp	r3, r0
    9a08:	d1f9      	bne.n	99fe <grid_msg_find_recent+0x6>
			
		}
		
	}
	
	return 0;
    9a0a:	2000      	movs	r0, #0
    9a0c:	4770      	bx	lr
			return 1;
    9a0e:	2001      	movs	r0, #1
}
    9a10:	4770      	bx	lr

00009a12 <grid_msg_push_recent>:

void grid_msg_push_recent(struct grid_sys_model* model, uint32_t fingerprint){
	
	model->recent_messages_index+=1;
    9a12:	f890 30ac 	ldrb.w	r3, [r0, #172]	; 0xac
    9a16:	3301      	adds	r3, #1
	model->recent_messages_index%=GRID_SYS_RECENT_MESSAGES_LENGTH;
    9a18:	f003 031f 	and.w	r3, r3, #31
    9a1c:	f880 30ac 	strb.w	r3, [r0, #172]	; 0xac
	
	model->recent_messages[model->recent_messages_index] = fingerprint;
    9a20:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    9a24:	62c1      	str	r1, [r0, #44]	; 0x2c
	
}
    9a26:	4770      	bx	lr

00009a28 <grid_ui_model_init>:
	}
	
}


void grid_ui_model_init(struct grid_ui_model* mod, uint8_t bank_list_length){
    9a28:	b538      	push	{r3, r4, r5, lr}
	
	mod->status = GRID_UI_STATUS_INITIALIZED;
    9a2a:	2301      	movs	r3, #1
    9a2c:	7003      	strb	r3, [r0, #0]
void grid_ui_model_init(struct grid_ui_model* mod, uint8_t bank_list_length){
    9a2e:	4605      	mov	r5, r0
	
	mod->bank_list_length = bank_list_length;	
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9a30:	4b09      	ldr	r3, [pc, #36]	; (9a58 <grid_ui_model_init+0x30>)
	mod->bank_list_length = bank_list_length;	
    9a32:	7041      	strb	r1, [r0, #1]
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9a34:	0108      	lsls	r0, r1, #4
void grid_ui_model_init(struct grid_ui_model* mod, uint8_t bank_list_length){
    9a36:	460c      	mov	r4, r1
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9a38:	4798      	blx	r3
	
	for(uint8_t i=0; i<bank_list_length; i++){
    9a3a:	2300      	movs	r3, #0
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9a3c:	6068      	str	r0, [r5, #4]
		
		mod->bank_list[i].status = GRID_UI_STATUS_UNDEFINED;		
    9a3e:	461a      	mov	r2, r3
	for(uint8_t i=0; i<bank_list_length; i++){
    9a40:	b2d9      	uxtb	r1, r3
    9a42:	428c      	cmp	r4, r1
    9a44:	f100 0010 	add.w	r0, r0, #16
    9a48:	d800      	bhi.n	9a4c <grid_ui_model_init+0x24>
		mod->bank_list[i].element_list_length = 0;
		
	}
	
}
    9a4a:	bd38      	pop	{r3, r4, r5, pc}
		mod->bank_list[i].status = GRID_UI_STATUS_UNDEFINED;		
    9a4c:	f800 2c10 	strb.w	r2, [r0, #-16]
		mod->bank_list[i].element_list_length = 0;
    9a50:	f800 2c07 	strb.w	r2, [r0, #-7]
	for(uint8_t i=0; i<bank_list_length; i++){
    9a54:	3301      	adds	r3, #1
    9a56:	e7f3      	b.n	9a40 <grid_ui_model_init+0x18>
    9a58:	000142c5 	.word	0x000142c5

00009a5c <grid_ui_bank_init>:

void grid_ui_bank_init(struct grid_ui_model* parent, uint8_t index, uint8_t element_list_length){
    9a5c:	b538      	push	{r3, r4, r5, lr}
	
	struct grid_ui_bank* bank = &parent->bank_list[index];
    9a5e:	6843      	ldr	r3, [r0, #4]
    9a60:	eb03 1501 	add.w	r5, r3, r1, lsl #4
void grid_ui_bank_init(struct grid_ui_model* parent, uint8_t index, uint8_t element_list_length){
    9a64:	4614      	mov	r4, r2
	struct grid_ui_bank* bank = &parent->bank_list[index];
    9a66:	010a      	lsls	r2, r1, #4
	bank->parent = parent;
    9a68:	6068      	str	r0, [r5, #4]
	bank->index = index;
    9a6a:	7229      	strb	r1, [r5, #8]
	
	
	bank->status = GRID_UI_STATUS_INITIALIZED;
	
	bank->element_list_length = element_list_length;
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9a6c:	2064      	movs	r0, #100	; 0x64
	bank->status = GRID_UI_STATUS_INITIALIZED;
    9a6e:	2101      	movs	r1, #1
    9a70:	5499      	strb	r1, [r3, r2]
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9a72:	4360      	muls	r0, r4
    9a74:	4b08      	ldr	r3, [pc, #32]	; (9a98 <grid_ui_bank_init+0x3c>)
	bank->element_list_length = element_list_length;
    9a76:	726c      	strb	r4, [r5, #9]
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9a78:	4798      	blx	r3
	
	for(uint8_t i=0; i<element_list_length; i++){
    9a7a:	2300      	movs	r3, #0
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9a7c:	60e8      	str	r0, [r5, #12]
		
		bank->element_list[i].status = GRID_UI_STATUS_UNDEFINED;
    9a7e:	461a      	mov	r2, r3
	for(uint8_t i=0; i<element_list_length; i++){
    9a80:	b2d9      	uxtb	r1, r3
    9a82:	428c      	cmp	r4, r1
    9a84:	f100 0064 	add.w	r0, r0, #100	; 0x64
    9a88:	d800      	bhi.n	9a8c <grid_ui_bank_init+0x30>
		bank->element_list[i].event_list_length = 0;
		
	}
	
}
    9a8a:	bd38      	pop	{r3, r4, r5, pc}
		bank->element_list[i].status = GRID_UI_STATUS_UNDEFINED;
    9a8c:	f800 2c64 	strb.w	r2, [r0, #-100]
		bank->element_list[i].event_list_length = 0;
    9a90:	f800 2c08 	strb.w	r2, [r0, #-8]
	for(uint8_t i=0; i<element_list_length; i++){
    9a94:	3301      	adds	r3, #1
    9a96:	e7f3      	b.n	9a80 <grid_ui_bank_init+0x24>
    9a98:	000142c5 	.word	0x000142c5

00009a9c <grid_ui_nvm_store_all_configuration>:
	
}



void grid_ui_nvm_store_all_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm){
    9a9c:	460b      	mov	r3, r1
	
    grid_nvm_ui_bulk_store_init(nvm, ui);
    9a9e:	4601      	mov	r1, r0
    9aa0:	4618      	mov	r0, r3
    9aa2:	4b01      	ldr	r3, [pc, #4]	; (9aa8 <grid_ui_nvm_store_all_configuration+0xc>)
    9aa4:	4718      	bx	r3
    9aa6:	bf00      	nop
    9aa8:	000088ed 	.word	0x000088ed

00009aac <grid_ui_nvm_load_all_configuration>:

}

void grid_ui_nvm_load_all_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm){
    9aac:	460b      	mov	r3, r1
	
	grid_nvm_ui_bulk_read_init(nvm, ui);
    9aae:	4601      	mov	r1, r0
    9ab0:	4618      	mov	r0, r3
    9ab2:	4b01      	ldr	r3, [pc, #4]	; (9ab8 <grid_ui_nvm_load_all_configuration+0xc>)
    9ab4:	4718      	bx	r3
    9ab6:	bf00      	nop
    9ab8:	000087d9 	.word	0x000087d9

00009abc <grid_ui_nvm_clear_all_configuration>:

		
	
}

void grid_ui_nvm_clear_all_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm){
    9abc:	460b      	mov	r3, r1
	
	grid_nvm_ui_bulk_clear_init(nvm, ui);
    9abe:	4601      	mov	r1, r0
    9ac0:	4618      	mov	r0, r3
    9ac2:	4b01      	ldr	r3, [pc, #4]	; (9ac8 <grid_ui_nvm_clear_all_configuration+0xc>)
    9ac4:	4718      	bx	r3
    9ac6:	bf00      	nop
    9ac8:	00008ab1 	.word	0x00008ab1

00009acc <grid_ui_recall_event_configuration>:

}


uint8_t grid_ui_recall_event_configuration(struct grid_ui_model* ui, uint8_t bank, uint8_t element, enum grid_ui_event_t event_type){
    9acc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9ad0:	4698      	mov	r8, r3
	
	struct grid_ui_element* ele = NULL;
	struct grid_ui_event* eve = NULL;
	uint8_t event_index = 255;
	
	if (bank < ui->bank_list_length){
    9ad2:	7843      	ldrb	r3, [r0, #1]
    9ad4:	428b      	cmp	r3, r1
uint8_t grid_ui_recall_event_configuration(struct grid_ui_model* ui, uint8_t bank, uint8_t element, enum grid_ui_event_t event_type){
    9ad6:	f5ad 7d4f 	sub.w	sp, sp, #828	; 0x33c
    9ada:	460e      	mov	r6, r1
    9adc:	4615      	mov	r5, r2
	if (bank < ui->bank_list_length){
    9ade:	f240 8082 	bls.w	9be6 <grid_ui_recall_event_configuration+0x11a>
		
		if (element < ui->bank_list[bank].element_list_length){
    9ae2:	6843      	ldr	r3, [r0, #4]
    9ae4:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    9ae8:	7a5a      	ldrb	r2, [r3, #9]
    9aea:	42aa      	cmp	r2, r5
    9aec:	d97b      	bls.n	9be6 <grid_ui_recall_event_configuration+0x11a>
			
			ele = &ui->bank_list[bank].element_list[element];
    9aee:	68da      	ldr	r2, [r3, #12]
    9af0:	2364      	movs	r3, #100	; 0x64
    9af2:	fb05 2303 	mla	r3, r5, r3, r2
			
			for(uint8_t i=0; i<ele->event_list_length; i++){
    9af6:	2200      	movs	r2, #0
    9af8:	f893 c05c 	ldrb.w	ip, [r3, #92]	; 0x5c
	uint8_t event_index = 255;
    9afc:	20ff      	movs	r0, #255	; 0xff
	struct grid_ui_event* eve = NULL;
    9afe:	4614      	mov	r4, r2
				if (ele->event_list[i].type == event_type){
    9b00:	f04f 0ebc 	mov.w	lr, #188	; 0xbc
    9b04:	b2d7      	uxtb	r7, r2
			for(uint8_t i=0; i<ele->event_list_length; i++){
    9b06:	45bc      	cmp	ip, r7
    9b08:	d862      	bhi.n	9bd0 <grid_ui_recall_event_configuration+0x104>
		
		
	}
	
	
	if (event_index != 255){ // OK
    9b0a:	28ff      	cmp	r0, #255	; 0xff
    9b0c:	d06b      	beq.n	9be6 <grid_ui_recall_event_configuration+0x11a>
		
		struct grid_msg message;

		grid_msg_init(&message);
    9b0e:	4b5b      	ldr	r3, [pc, #364]	; (9c7c <grid_ui_recall_event_configuration+0x1b0>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9b10:	4d5b      	ldr	r5, [pc, #364]	; (9c80 <grid_ui_recall_event_configuration+0x1b4>)
		uint32_t offset = 0;



		// BANK ENABLED
		offset = grid_msg_body_get_length(&message);
    9b12:	f8df a190 	ldr.w	sl, [pc, #400]	; 9ca4 <grid_ui_recall_event_configuration+0x1d8>

		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9b16:	f8df 9190 	ldr.w	r9, [pc, #400]	; 9ca8 <grid_ui_recall_event_configuration+0x1dc>
		payload_length = strlen(payload);
    9b1a:	f8df 8190 	ldr.w	r8, [pc, #400]	; 9cac <grid_ui_recall_event_configuration+0x1e0>

		grid_msg_body_append_text(&message, payload, payload_length);
    9b1e:	4f59      	ldr	r7, [pc, #356]	; (9c84 <grid_ui_recall_event_configuration+0x1b8>)

		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    9b20:	4e59      	ldr	r6, [pc, #356]	; (9c88 <grid_ui_recall_event_configuration+0x1bc>)
		grid_msg_init(&message);
    9b22:	a867      	add	r0, sp, #412	; 0x19c
    9b24:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9b26:	227f      	movs	r2, #127	; 0x7f
    9b28:	4611      	mov	r1, r2
    9b2a:	2300      	movs	r3, #0
    9b2c:	a867      	add	r0, sp, #412	; 0x19c
    9b2e:	47a8      	blx	r5
		uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9b30:	2100      	movs	r1, #0
    9b32:	4b56      	ldr	r3, [pc, #344]	; (9c8c <grid_ui_recall_event_configuration+0x1c0>)
    9b34:	9103      	str	r1, [sp, #12]
    9b36:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9b3a:	a804      	add	r0, sp, #16
    9b3c:	4798      	blx	r3
		offset = grid_msg_body_get_length(&message);
    9b3e:	a867      	add	r0, sp, #412	; 0x19c
    9b40:	47d0      	blx	sl
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9b42:	2380      	movs	r3, #128	; 0x80
		offset = grid_msg_body_get_length(&message);
    9b44:	4605      	mov	r5, r0
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9b46:	4952      	ldr	r1, [pc, #328]	; (9c90 <grid_ui_recall_event_configuration+0x1c4>)
    9b48:	2202      	movs	r2, #2
    9b4a:	a803      	add	r0, sp, #12
    9b4c:	47c8      	blx	r9
		payload_length = strlen(payload);
    9b4e:	a803      	add	r0, sp, #12
    9b50:	47c0      	blx	r8
		grid_msg_body_append_text(&message, payload, payload_length);
    9b52:	a903      	add	r1, sp, #12
    9b54:	b2c2      	uxtb	r2, r0
    9b56:	a867      	add	r0, sp, #412	; 0x19c
    9b58:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    9b5a:	230d      	movs	r3, #13
    9b5c:	9300      	str	r3, [sp, #0]
    9b5e:	2204      	movs	r2, #4
    9b60:	2301      	movs	r3, #1
    9b62:	4629      	mov	r1, r5
    9b64:	a867      	add	r0, sp, #412	; 0x19c
    9b66:	47b0      	blx	r6
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, eve->parent->parent->index);
    9b68:	6863      	ldr	r3, [r4, #4]
    9b6a:	685b      	ldr	r3, [r3, #4]
    9b6c:	7a1b      	ldrb	r3, [r3, #8]
    9b6e:	9300      	str	r3, [sp, #0]
    9b70:	2205      	movs	r2, #5
    9b72:	2302      	movs	r3, #2
    9b74:	4629      	mov	r1, r5
    9b76:	a867      	add	r0, sp, #412	; 0x19c
    9b78:	47b0      	blx	r6
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, eve->parent->index);
    9b7a:	6863      	ldr	r3, [r4, #4]
    9b7c:	7a1b      	ldrb	r3, [r3, #8]
    9b7e:	9300      	str	r3, [sp, #0]
    9b80:	2207      	movs	r2, #7
    9b82:	2302      	movs	r3, #2
    9b84:	4629      	mov	r1, r5
    9b86:	a867      	add	r0, sp, #412	; 0x19c
    9b88:	47b0      	blx	r6
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eve->type);
    9b8a:	7aa3      	ldrb	r3, [r4, #10]
    9b8c:	9300      	str	r3, [sp, #0]
    9b8e:	2209      	movs	r2, #9
    9b90:	2302      	movs	r3, #2
    9b92:	4629      	mov	r1, r5
    9b94:	a867      	add	r0, sp, #412	; 0x19c
    9b96:	47b0      	blx	r6

		offset = grid_msg_body_get_length(&message);
    9b98:	a867      	add	r0, sp, #412	; 0x19c
    9b9a:	47d0      	blx	sl
		grid_msg_body_append_text_escaped(&message, eve->action_string, eve->action_string_length);
    9b9c:	4b3d      	ldr	r3, [pc, #244]	; (9c94 <grid_ui_recall_event_configuration+0x1c8>)
    9b9e:	6b22      	ldr	r2, [r4, #48]	; 0x30
    9ba0:	f104 0134 	add.w	r1, r4, #52	; 0x34
    9ba4:	a867      	add	r0, sp, #412	; 0x19c
    9ba6:	4798      	blx	r3





		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_end);
    9ba8:	493b      	ldr	r1, [pc, #236]	; (9c98 <grid_ui_recall_event_configuration+0x1cc>)
    9baa:	2203      	movs	r2, #3
    9bac:	a803      	add	r0, sp, #12
    9bae:	47c8      	blx	r9
		payload_length = strlen(payload);
    9bb0:	a803      	add	r0, sp, #12
    9bb2:	47c0      	blx	r8

		grid_msg_body_append_text(&message, payload, payload_length);
    9bb4:	a903      	add	r1, sp, #12
    9bb6:	b2c2      	uxtb	r2, r0
    9bb8:	a867      	add	r0, sp, #412	; 0x19c
    9bba:	47b8      	blx	r7
		payload_length = strlen(payload);

		grid_msg_body_append_text(&message, payload, payload_length);


		grid_msg_packet_close(&message);
    9bbc:	4b37      	ldr	r3, [pc, #220]	; (9c9c <grid_ui_recall_event_configuration+0x1d0>)
    9bbe:	a867      	add	r0, sp, #412	; 0x19c
    9bc0:	4798      	blx	r3
		grid_msg_packet_send_everywhere(&message);		
    9bc2:	4b37      	ldr	r3, [pc, #220]	; (9ca0 <grid_ui_recall_event_configuration+0x1d4>)
    9bc4:	a867      	add	r0, sp, #412	; 0x19c
    9bc6:	4798      	blx	r3
		
		
	}

	
}
    9bc8:	f50d 7d4f 	add.w	sp, sp, #828	; 0x33c
    9bcc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (ele->event_list[i].type == event_type){
    9bd0:	6e19      	ldr	r1, [r3, #96]	; 0x60
    9bd2:	fb0e 1102 	mla	r1, lr, r2, r1
    9bd6:	3201      	adds	r2, #1
    9bd8:	f891 900a 	ldrb.w	r9, [r1, #10]
    9bdc:	45c1      	cmp	r9, r8
    9bde:	bf04      	itt	eq
    9be0:	4638      	moveq	r0, r7
    9be2:	460c      	moveq	r4, r1
			for(uint8_t i=0; i<ele->event_list_length; i++){
    9be4:	e78e      	b.n	9b04 <grid_ui_recall_event_configuration+0x38>
		grid_msg_init(&message);
    9be6:	a867      	add	r0, sp, #412	; 0x19c
    9be8:	4b24      	ldr	r3, [pc, #144]	; (9c7c <grid_ui_recall_event_configuration+0x1b0>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9bea:	4c25      	ldr	r4, [pc, #148]	; (9c80 <grid_ui_recall_event_configuration+0x1b4>)
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9bec:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 9ca8 <grid_ui_recall_event_configuration+0x1dc>
		payload_length = strlen(payload);
    9bf0:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 9cac <grid_ui_recall_event_configuration+0x1e0>
		grid_msg_body_append_text(&message, payload, payload_length);
    9bf4:	f8df 908c 	ldr.w	r9, [pc, #140]	; 9c84 <grid_ui_recall_event_configuration+0x1b8>
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    9bf8:	4f23      	ldr	r7, [pc, #140]	; (9c88 <grid_ui_recall_event_configuration+0x1bc>)
		grid_msg_init(&message);
    9bfa:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9bfc:	227f      	movs	r2, #127	; 0x7f
    9bfe:	4611      	mov	r1, r2
    9c00:	a867      	add	r0, sp, #412	; 0x19c
    9c02:	2300      	movs	r3, #0
    9c04:	47a0      	blx	r4
		uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9c06:	2100      	movs	r1, #0
    9c08:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9c0c:	4b1f      	ldr	r3, [pc, #124]	; (9c8c <grid_ui_recall_event_configuration+0x1c0>)
    9c0e:	9103      	str	r1, [sp, #12]
    9c10:	a804      	add	r0, sp, #16
    9c12:	4798      	blx	r3
		offset = grid_msg_body_get_length(&message);
    9c14:	4b23      	ldr	r3, [pc, #140]	; (9ca4 <grid_ui_recall_event_configuration+0x1d8>)
    9c16:	a867      	add	r0, sp, #412	; 0x19c
    9c18:	4798      	blx	r3
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9c1a:	2380      	movs	r3, #128	; 0x80
		offset = grid_msg_body_get_length(&message);
    9c1c:	4604      	mov	r4, r0
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9c1e:	491c      	ldr	r1, [pc, #112]	; (9c90 <grid_ui_recall_event_configuration+0x1c4>)
    9c20:	2202      	movs	r2, #2
    9c22:	a803      	add	r0, sp, #12
    9c24:	47d8      	blx	fp
		payload_length = strlen(payload);
    9c26:	a803      	add	r0, sp, #12
    9c28:	47d0      	blx	sl
		grid_msg_body_append_text(&message, payload, payload_length);
    9c2a:	a903      	add	r1, sp, #12
    9c2c:	b2c2      	uxtb	r2, r0
    9c2e:	a867      	add	r0, sp, #412	; 0x19c
    9c30:	47c8      	blx	r9
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    9c32:	230b      	movs	r3, #11
    9c34:	9300      	str	r3, [sp, #0]
    9c36:	4621      	mov	r1, r4
    9c38:	a867      	add	r0, sp, #412	; 0x19c
    9c3a:	2301      	movs	r3, #1
    9c3c:	2204      	movs	r2, #4
    9c3e:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, bank);
    9c40:	4621      	mov	r1, r4
    9c42:	a867      	add	r0, sp, #412	; 0x19c
    9c44:	9600      	str	r6, [sp, #0]
    9c46:	2302      	movs	r3, #2
    9c48:	2205      	movs	r2, #5
    9c4a:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, element);
    9c4c:	4621      	mov	r1, r4
    9c4e:	a867      	add	r0, sp, #412	; 0x19c
    9c50:	9500      	str	r5, [sp, #0]
    9c52:	2302      	movs	r3, #2
    9c54:	2207      	movs	r2, #7
    9c56:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, event_type);
    9c58:	2302      	movs	r3, #2
    9c5a:	4621      	mov	r1, r4
    9c5c:	a867      	add	r0, sp, #412	; 0x19c
    9c5e:	f8cd 8000 	str.w	r8, [sp]
    9c62:	2209      	movs	r2, #9
    9c64:	47b8      	blx	r7
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_end);
    9c66:	490c      	ldr	r1, [pc, #48]	; (9c98 <grid_ui_recall_event_configuration+0x1cc>)
    9c68:	2203      	movs	r2, #3
    9c6a:	a803      	add	r0, sp, #12
    9c6c:	47d8      	blx	fp
		payload_length = strlen(payload);
    9c6e:	a803      	add	r0, sp, #12
    9c70:	47d0      	blx	sl
		grid_msg_body_append_text(&message, payload, payload_length);
    9c72:	a903      	add	r1, sp, #12
    9c74:	b2c2      	uxtb	r2, r0
    9c76:	a867      	add	r0, sp, #412	; 0x19c
    9c78:	47c8      	blx	r9
    9c7a:	e79f      	b.n	9bbc <grid_ui_recall_event_configuration+0xf0>
    9c7c:	0000857d 	.word	0x0000857d
    9c80:	000085b1 	.word	0x000085b1
    9c84:	000084ed 	.word	0x000084ed
    9c88:	00008561 	.word	0x00008561
    9c8c:	000142f1 	.word	0x000142f1
    9c90:	00015dc9 	.word	0x00015dc9
    9c94:	0000850d 	.word	0x0000850d
    9c98:	00015a3b 	.word	0x00015a3b
    9c9c:	000086a9 	.word	0x000086a9
    9ca0:	0000877d 	.word	0x0000877d
    9ca4:	000084e7 	.word	0x000084e7
    9ca8:	00014791 	.word	0x00014791
    9cac:	0001480f 	.word	0x0001480f

00009cb0 <grid_ui_nvm_store_event_configuration>:



uint8_t grid_ui_nvm_store_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    9cb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9cb4:	f5ad 7d4f 	sub.w	sp, sp, #828	; 0x33c
	

	struct grid_msg message;

	grid_msg_init(&message);
    9cb8:	4b52      	ldr	r3, [pc, #328]	; (9e04 <grid_ui_nvm_store_event_configuration+0x154>)
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9cba:	4e53      	ldr	r6, [pc, #332]	; (9e08 <grid_ui_nvm_store_event_configuration+0x158>)
	uint32_t offset = 0;



	// BANK ENABLED
	offset = grid_msg_body_get_length(&message);
    9cbc:	f8df b178 	ldr.w	fp, [pc, #376]	; 9e38 <grid_ui_nvm_store_event_configuration+0x188>

	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9cc0:	f8df a178 	ldr.w	sl, [pc, #376]	; 9e3c <grid_ui_nvm_store_event_configuration+0x18c>
	payload_length = strlen(payload);

	grid_msg_body_append_text(&message, payload, payload_length);
    9cc4:	f8df 9178 	ldr.w	r9, [pc, #376]	; 9e40 <grid_ui_nvm_store_event_configuration+0x190>

	grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    9cc8:	f8df 8178 	ldr.w	r8, [pc, #376]	; 9e44 <grid_ui_nvm_store_event_configuration+0x194>
	grid_msg_init(&message);
    9ccc:	a867      	add	r0, sp, #412	; 0x19c
uint8_t grid_ui_nvm_store_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    9cce:	4614      	mov	r4, r2
    9cd0:	460d      	mov	r5, r1
	grid_msg_init(&message);
    9cd2:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9cd4:	22ff      	movs	r2, #255	; 0xff
    9cd6:	4611      	mov	r1, r2
    9cd8:	2300      	movs	r3, #0
    9cda:	a867      	add	r0, sp, #412	; 0x19c
    9cdc:	47b0      	blx	r6
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9cde:	2600      	movs	r6, #0
    9ce0:	4b4a      	ldr	r3, [pc, #296]	; (9e0c <grid_ui_nvm_store_event_configuration+0x15c>)
    9ce2:	9603      	str	r6, [sp, #12]
    9ce4:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9ce8:	4631      	mov	r1, r6
    9cea:	a804      	add	r0, sp, #16
    9cec:	4798      	blx	r3
	offset = grid_msg_body_get_length(&message);
    9cee:	a867      	add	r0, sp, #412	; 0x19c
    9cf0:	47d8      	blx	fp
	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9cf2:	4947      	ldr	r1, [pc, #284]	; (9e10 <grid_ui_nvm_store_event_configuration+0x160>)
	offset = grid_msg_body_get_length(&message);
    9cf4:	4607      	mov	r7, r0
	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9cf6:	2202      	movs	r2, #2
    9cf8:	2380      	movs	r3, #128	; 0x80
    9cfa:	a803      	add	r0, sp, #12
    9cfc:	47d0      	blx	sl
	payload_length = strlen(payload);
    9cfe:	4b45      	ldr	r3, [pc, #276]	; (9e14 <grid_ui_nvm_store_event_configuration+0x164>)
    9d00:	a803      	add	r0, sp, #12
    9d02:	4798      	blx	r3
	grid_msg_body_append_text(&message, payload, payload_length);
    9d04:	a903      	add	r1, sp, #12
    9d06:	b2c2      	uxtb	r2, r0
    9d08:	a867      	add	r0, sp, #412	; 0x19c
    9d0a:	47c8      	blx	r9
	grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    9d0c:	230e      	movs	r3, #14
    9d0e:	4639      	mov	r1, r7
    9d10:	9300      	str	r3, [sp, #0]
    9d12:	2204      	movs	r2, #4
    9d14:	2301      	movs	r3, #1
    9d16:	a867      	add	r0, sp, #412	; 0x19c
    9d18:	47c0      	blx	r8
	grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, eve->parent->parent->index);
    9d1a:	6863      	ldr	r3, [r4, #4]
    9d1c:	685b      	ldr	r3, [r3, #4]
    9d1e:	7a1b      	ldrb	r3, [r3, #8]
    9d20:	9300      	str	r3, [sp, #0]
    9d22:	4639      	mov	r1, r7
    9d24:	2302      	movs	r3, #2
    9d26:	2205      	movs	r2, #5
    9d28:	a867      	add	r0, sp, #412	; 0x19c
    9d2a:	47c0      	blx	r8
	grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, eve->parent->index);
    9d2c:	6863      	ldr	r3, [r4, #4]
    9d2e:	7a1b      	ldrb	r3, [r3, #8]
    9d30:	9300      	str	r3, [sp, #0]
    9d32:	4639      	mov	r1, r7
    9d34:	2302      	movs	r3, #2
    9d36:	2207      	movs	r2, #7
    9d38:	a867      	add	r0, sp, #412	; 0x19c
    9d3a:	47c0      	blx	r8
	grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eve->type);
    9d3c:	7aa3      	ldrb	r3, [r4, #10]
    9d3e:	9300      	str	r3, [sp, #0]
    9d40:	4639      	mov	r1, r7
    9d42:	2302      	movs	r3, #2
    9d44:	2209      	movs	r2, #9
    9d46:	a867      	add	r0, sp, #412	; 0x19c
    9d48:	47c0      	blx	r8

	offset = grid_msg_body_get_length(&message);
    9d4a:	a867      	add	r0, sp, #412	; 0x19c
    9d4c:	47d8      	blx	fp
	grid_msg_body_append_text_escaped(&message, eve->action_string, eve->action_string_length);
    9d4e:	4b32      	ldr	r3, [pc, #200]	; (9e18 <grid_ui_nvm_store_event_configuration+0x168>)
    9d50:	6b22      	ldr	r2, [r4, #48]	; 0x30
    9d52:	f104 0134 	add.w	r1, r4, #52	; 0x34
    9d56:	a867      	add	r0, sp, #412	; 0x19c
    9d58:	4798      	blx	r3





	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_end);
    9d5a:	4930      	ldr	r1, [pc, #192]	; (9e1c <grid_ui_nvm_store_event_configuration+0x16c>)
    9d5c:	2203      	movs	r2, #3
    9d5e:	a803      	add	r0, sp, #12
    9d60:	47d0      	blx	sl
	payload_length = strlen(payload);
    9d62:	4b2c      	ldr	r3, [pc, #176]	; (9e14 <grid_ui_nvm_store_event_configuration+0x164>)
    9d64:	a803      	add	r0, sp, #12
    9d66:	4798      	blx	r3

	grid_msg_body_append_text(&message, payload, payload_length);
    9d68:	a903      	add	r1, sp, #12
    9d6a:	b2c2      	uxtb	r2, r0
    9d6c:	a867      	add	r0, sp, #412	; 0x19c
    9d6e:	47c8      	blx	r9


	grid_msg_packet_close(&message);
    9d70:	4b2b      	ldr	r3, [pc, #172]	; (9e20 <grid_ui_nvm_store_event_configuration+0x170>)
    9d72:	a867      	add	r0, sp, #412	; 0x19c
    9d74:	4798      	blx	r3

	grid_nvm_clear_write_buffer(nvm);
    9d76:	4b2b      	ldr	r3, [pc, #172]	; (9e24 <grid_ui_nvm_store_event_configuration+0x174>)
    9d78:	4628      	mov	r0, r5
    9d7a:	4798      	blx	r3

	uint32_t message_length = grid_msg_packet_get_length(&message);
    9d7c:	4b2a      	ldr	r3, [pc, #168]	; (9e28 <grid_ui_nvm_store_event_configuration+0x178>)
    9d7e:	a867      	add	r0, sp, #412	; 0x19c
    9d80:	4798      	blx	r3

	if (message_length){
    9d82:	4607      	mov	r7, r0
    9d84:	b970      	cbnz	r0, 9da4 <grid_ui_nvm_store_event_configuration+0xf4>
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
		}

	}

	uint32_t event_page_offset = grid_nvm_calculate_event_page_offset(nvm, eve);
    9d86:	4621      	mov	r1, r4
    9d88:	4b28      	ldr	r3, [pc, #160]	; (9e2c <grid_ui_nvm_store_event_configuration+0x17c>)
    9d8a:	4628      	mov	r0, r5
    9d8c:	4798      	blx	r3
	nvm->write_target_address = GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset;
    9d8e:	f500 6080 	add.w	r0, r0, #1024	; 0x400
    9d92:	0241      	lsls	r1, r0, #9
    9d94:	f8c5 1420 	str.w	r1, [r5, #1056]	; 0x420
	int status = 0;
	
	
	uint8_t debugtext[200] = {0};

	if (eve->cfg_default_flag == 1 && eve->cfg_flashempty_flag == 0){
    9d98:	f894 60b7 	ldrb.w	r6, [r4, #183]	; 0xb7
    9d9c:	2e01      	cmp	r6, #1
    9d9e:	d010      	beq.n	9dc2 <grid_ui_nvm_store_event_configuration+0x112>
	int status = 0;
    9da0:	2000      	movs	r0, #0
    9da2:	e019      	b.n	9dd8 <grid_ui_nvm_store_event_configuration+0x128>
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    9da4:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 9e48 <grid_ui_nvm_store_event_configuration+0x198>
		nvm->write_buffer_length = message_length;
    9da8:	f8c5 0418 	str.w	r0, [r5, #1048]	; 0x418
		for(uint32_t i = 0; i<message_length; i++){
    9dac:	f505 7806 	add.w	r8, r5, #536	; 0x218
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    9db0:	4631      	mov	r1, r6
    9db2:	a867      	add	r0, sp, #412	; 0x19c
    9db4:	47c8      	blx	r9
		for(uint32_t i = 0; i<message_length; i++){
    9db6:	3601      	adds	r6, #1
    9db8:	42b7      	cmp	r7, r6
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    9dba:	f808 0b01 	strb.w	r0, [r8], #1
		for(uint32_t i = 0; i<message_length; i++){
    9dbe:	d1f7      	bne.n	9db0 <grid_ui_nvm_store_event_configuration+0x100>
    9dc0:	e7e1      	b.n	9d86 <grid_ui_nvm_store_event_configuration+0xd6>
	if (eve->cfg_default_flag == 1 && eve->cfg_flashempty_flag == 0){
    9dc2:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
    9dc6:	2b00      	cmp	r3, #0
    9dc8:	d1ea      	bne.n	9da0 <grid_ui_nvm_store_event_configuration+0xf0>
		
		//sprintf(debugtext, "Cfg: Default B:%d E:%d Ev:%d => Page: %d Status: %d", eve->parent->parent->index, eve->parent->index, eve->index, event_page_offset, status);
		flash_erase(nvm->flash, nvm->write_target_address, 1);
    9dca:	6828      	ldr	r0, [r5, #0]
    9dcc:	4b18      	ldr	r3, [pc, #96]	; (9e30 <grid_ui_nvm_store_event_configuration+0x180>)
    9dce:	4632      	mov	r2, r6
    9dd0:	4798      	blx	r3
		eve->cfg_flashempty_flag = 1;
    9dd2:	f884 60b8 	strb.w	r6, [r4, #184]	; 0xb8
		status = 1;
    9dd6:	4630      	mov	r0, r6
	}
	
	
	if (eve->cfg_default_flag == 0 && eve->cfg_changed_flag == 1){
    9dd8:	f8b4 60b6 	ldrh.w	r6, [r4, #182]	; 0xb6
    9ddc:	2e01      	cmp	r6, #1
    9dde:	d109      	bne.n	9df4 <grid_ui_nvm_store_event_configuration+0x144>
		
		//sprintf(debugtext, "Cfg: Store B:%d E:%d Ev:%d => Page: %d Status: %d", eve->parent->parent->index, eve->parent->index, eve->index, event_page_offset, status);		
		flash_write(nvm->flash, nvm->write_target_address, nvm->write_buffer, GRID_NVM_PAGE_SIZE);
    9de0:	f8d5 1420 	ldr.w	r1, [r5, #1056]	; 0x420
    9de4:	6828      	ldr	r0, [r5, #0]
    9de6:	f505 7206 	add.w	r2, r5, #536	; 0x218
    9dea:	f44f 7300 	mov.w	r3, #512	; 0x200
    9dee:	4d11      	ldr	r5, [pc, #68]	; (9e34 <grid_ui_nvm_store_event_configuration+0x184>)
    9df0:	47a8      	blx	r5
		status = 1;
    9df2:	4630      	mov	r0, r6
	}


	//grid_debug_print_text(debugtext);

	eve->cfg_changed_flag = 0;
    9df4:	2300      	movs	r3, #0
    9df6:	f884 30b6 	strb.w	r3, [r4, #182]	; 0xb6
	
	return status;
	
}
    9dfa:	f50d 7d4f 	add.w	sp, sp, #828	; 0x33c
    9dfe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9e02:	bf00      	nop
    9e04:	0000857d 	.word	0x0000857d
    9e08:	000085b1 	.word	0x000085b1
    9e0c:	000142f1 	.word	0x000142f1
    9e10:	00015dc9 	.word	0x00015dc9
    9e14:	0001480f 	.word	0x0001480f
    9e18:	0000850d 	.word	0x0000850d
    9e1c:	00015a3b 	.word	0x00015a3b
    9e20:	000086a9 	.word	0x000086a9
    9e24:	00008c89 	.word	0x00008c89
    9e28:	000084d9 	.word	0x000084d9
    9e2c:	00008cf5 	.word	0x00008cf5
    9e30:	0000ee61 	.word	0x0000ee61
    9e34:	0000ede1 	.word	0x0000ede1
    9e38:	000084e7 	.word	0x000084e7
    9e3c:	00014791 	.word	0x00014791
    9e40:	000084ed 	.word	0x000084ed
    9e44:	00008561 	.word	0x00008561
    9e48:	00008673 	.word	0x00008673

00009e4c <grid_ui_nvm_load_event_configuration>:



uint8_t grid_ui_nvm_load_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    9e4c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
		
	grid_nvm_clear_read_buffer(nvm);
    9e4e:	4b19      	ldr	r3, [pc, #100]	; (9eb4 <grid_ui_nvm_load_event_configuration+0x68>)
uint8_t grid_ui_nvm_load_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    9e50:	9201      	str	r2, [sp, #4]
    9e52:	460c      	mov	r4, r1
	grid_nvm_clear_read_buffer(nvm);
    9e54:	4608      	mov	r0, r1
    9e56:	4798      	blx	r3
	
	uint32_t event_page_offset = grid_nvm_calculate_event_page_offset(nvm, eve);	
    9e58:	9901      	ldr	r1, [sp, #4]
    9e5a:	4b17      	ldr	r3, [pc, #92]	; (9eb8 <grid_ui_nvm_load_event_configuration+0x6c>)
    9e5c:	4620      	mov	r0, r4
    9e5e:	4798      	blx	r3
	nvm->read_source_address = GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset;	
    9e60:	f500 6080 	add.w	r0, r0, #1024	; 0x400
    9e64:	0241      	lsls	r1, r0, #9
	

	int status = flash_read(nvm->flash, nvm->read_source_address, nvm->read_buffer, GRID_NVM_PAGE_SIZE);	
    9e66:	f104 0609 	add.w	r6, r4, #9
	nvm->read_source_address = GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset;	
    9e6a:	f8c4 1214 	str.w	r1, [r4, #532]	; 0x214
	int status = flash_read(nvm->flash, nvm->read_source_address, nvm->read_buffer, GRID_NVM_PAGE_SIZE);	
    9e6e:	6820      	ldr	r0, [r4, #0]
    9e70:	4c12      	ldr	r4, [pc, #72]	; (9ebc <grid_ui_nvm_load_event_configuration+0x70>)
    9e72:	f44f 7300 	mov.w	r3, #512	; 0x200
    9e76:	4632      	mov	r2, r6
    9e78:	47a0      	blx	r4
    9e7a:	2300      	movs	r3, #0
			}
			else if (nvm->read_buffer[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
				copydone = 1;
			}
			else{ // NORMAL CHARACTER, can be copied
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9e7c:	4c10      	ldr	r4, [pc, #64]	; (9ec0 <grid_ui_nvm_load_event_configuration+0x74>)
	uint8_t cfgfound = 0;
    9e7e:	4618      	mov	r0, r3
	uint8_t copydone = 0;
    9e80:	4619      	mov	r1, r3
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9e82:	f241 37b4 	movw	r7, #5044	; 0x13b4
		if (copydone == 0){
    9e86:	1c5a      	adds	r2, r3, #1
    9e88:	b971      	cbnz	r1, 9ea8 <grid_ui_nvm_load_event_configuration+0x5c>
			if (nvm->read_buffer[i] == '\n'){ // END OF PACKET, copy newline character
    9e8a:	5cf5      	ldrb	r5, [r6, r3]
    9e8c:	2d0a      	cmp	r5, #10
    9e8e:	d106      	bne.n	9e9e <grid_ui_nvm_load_event_configuration+0x52>
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9e90:	4423      	add	r3, r4
				cfgfound=2;
    9e92:	2002      	movs	r0, #2
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9e94:	55dd      	strb	r5, [r3, r7]
				GRID_PORT_U.rx_double_buffer_status = i+1;
    9e96:	6222      	str	r2, [r4, #32]
				GRID_PORT_U.rx_double_buffer_read_start_index = 0;
    9e98:	62a1      	str	r1, [r4, #40]	; 0x28
				copydone = 1;
    9e9a:	2101      	movs	r1, #1
    9e9c:	e004      	b.n	9ea8 <grid_ui_nvm_load_event_configuration+0x5c>
			else if (nvm->read_buffer[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
    9e9e:	2dff      	cmp	r5, #255	; 0xff
    9ea0:	d0fb      	beq.n	9e9a <grid_ui_nvm_load_event_configuration+0x4e>
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9ea2:	4423      	add	r3, r4
				
				cfgfound=1;
    9ea4:	2001      	movs	r0, #1
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9ea6:	55dd      	strb	r5, [r3, r7]
	for (uint16_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    9ea8:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    9eac:	4613      	mov	r3, r2
    9eae:	d1ea      	bne.n	9e86 <grid_ui_nvm_load_event_configuration+0x3a>
	}
	
	return cfgfound;
	
	
}
    9eb0:	b003      	add	sp, #12
    9eb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9eb4:	00008c69 	.word	0x00008c69
    9eb8:	00008cf5 	.word	0x00008cf5
    9ebc:	0000ed75 	.word	0x0000ed75
    9ec0:	2000c0b0 	.word	0x2000c0b0

00009ec4 <grid_ui_nvm_clear_event_configuration>:
uint8_t grid_ui_nvm_clear_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    9ec4:	b510      	push	{r4, lr}
    9ec6:	460c      	mov	r4, r1
		
		uint32_t event_page_offset = grid_nvm_calculate_event_page_offset(nvm, eve);
    9ec8:	4b06      	ldr	r3, [pc, #24]	; (9ee4 <grid_ui_nvm_clear_event_configuration+0x20>)
    9eca:	4611      	mov	r1, r2
    9ecc:	4620      	mov	r0, r4
    9ece:	4798      	blx	r3
		
		

		flash_erase(nvm->flash, GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset, 1);
    9ed0:	f500 6080 	add.w	r0, r0, #1024	; 0x400
    9ed4:	0241      	lsls	r1, r0, #9
    9ed6:	4b04      	ldr	r3, [pc, #16]	; (9ee8 <grid_ui_nvm_clear_event_configuration+0x24>)
    9ed8:	6820      	ldr	r0, [r4, #0]
    9eda:	2201      	movs	r2, #1
    9edc:	4798      	blx	r3

		
		
		return 1;
		
}
    9ede:	2001      	movs	r0, #1
    9ee0:	bd10      	pop	{r4, pc}
    9ee2:	bf00      	nop
    9ee4:	00008cf5 	.word	0x00008cf5
    9ee8:	0000ee61 	.word	0x0000ee61

00009eec <grid_ui_event_register_actionstring>:
	ele->event_list[event_index].cfg_default_flag = 1;	
	
}


void grid_ui_event_register_actionstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type, uint8_t* action_string, uint32_t action_string_length){
    9eec:	b5f0      	push	{r4, r5, r6, r7, lr}
		
	uint8_t event_index = 255;
	
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9eee:	f890 c05c 	ldrb.w	ip, [r0, #92]	; 0x5c
    9ef2:	2500      	movs	r5, #0
	uint8_t event_index = 255;
    9ef4:	24ff      	movs	r4, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    9ef6:	f04f 0ebc 	mov.w	lr, #188	; 0xbc
    9efa:	b2ef      	uxtb	r7, r5
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9efc:	45bc      	cmp	ip, r7
    9efe:	d819      	bhi.n	9f34 <grid_ui_event_register_actionstring+0x48>
			event_index = i;
		}
	}
	
	if (event_index == 255){
    9f00:	2cff      	cmp	r4, #255	; 0xff
    9f02:	d016      	beq.n	9f32 <grid_ui_event_register_actionstring+0x46>
	
	
	
	// Clear Action String
	for(uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
		ele->event_list[event_index].action_string[i] = 0;
    9f04:	21bc      	movs	r1, #188	; 0xbc
    9f06:	fb14 f401 	smulbb	r4, r4, r1
    9f0a:	6e01      	ldr	r1, [r0, #96]	; 0x60
    9f0c:	4421      	add	r1, r4
    9f0e:	f101 0434 	add.w	r4, r1, #52	; 0x34
    9f12:	f101 06b6 	add.w	r6, r1, #182	; 0xb6
    9f16:	4620      	mov	r0, r4
    9f18:	2500      	movs	r5, #0
    9f1a:	f800 5b01 	strb.w	r5, [r0], #1
	for(uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
    9f1e:	4286      	cmp	r6, r0
    9f20:	d1fb      	bne.n	9f1a <grid_ui_event_register_actionstring+0x2e>
	}
	ele->event_list[event_index].action_string_length = 0;
    9f22:	630d      	str	r5, [r1, #48]	; 0x30
	

	uint8_t escaped_characters = 0;
	
	for (uint32_t i=0; i<action_string_length; i++){
    9f24:	2000      	movs	r0, #0
    9f26:	4298      	cmp	r0, r3
    9f28:	d10d      	bne.n	9f46 <grid_ui_event_register_actionstring+0x5a>
	}
	

	ele->event_list[event_index].action_string_length = action_string_length;
	
	ele->event_list[event_index].cfg_changed_flag = 1;
    9f2a:	2301      	movs	r3, #1
	ele->event_list[event_index].action_string_length = action_string_length;
    9f2c:	6308      	str	r0, [r1, #48]	; 0x30
	ele->event_list[event_index].cfg_changed_flag = 1;
    9f2e:	f881 30b6 	strb.w	r3, [r1, #182]	; 0xb6
	
	
}
    9f32:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    9f34:	6e06      	ldr	r6, [r0, #96]	; 0x60
    9f36:	fb0e 6605 	mla	r6, lr, r5, r6
    9f3a:	3501      	adds	r5, #1
    9f3c:	7ab6      	ldrb	r6, [r6, #10]
    9f3e:	428e      	cmp	r6, r1
    9f40:	bf08      	it	eq
    9f42:	463c      	moveq	r4, r7
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9f44:	e7d9      	b.n	9efa <grid_ui_event_register_actionstring+0xe>
		if (ele->event_list[event_index].action_string[i] > 127){
    9f46:	5616      	ldrsb	r6, [r2, r0]
		ele->event_list[event_index].action_string[i] = action_string[i];
    9f48:	5c15      	ldrb	r5, [r2, r0]
		if (ele->event_list[event_index].action_string[i] > 127){
    9f4a:	2e00      	cmp	r6, #0
			ele->event_list[event_index].action_string[i] -= 128;
    9f4c:	bfb8      	it	lt
    9f4e:	3d80      	sublt	r5, #128	; 0x80
    9f50:	7025      	strb	r5, [r4, #0]
	for (uint32_t i=0; i<action_string_length; i++){
    9f52:	3001      	adds	r0, #1
    9f54:	3401      	adds	r4, #1
    9f56:	e7e6      	b.n	9f26 <grid_ui_event_register_actionstring+0x3a>

00009f58 <grid_ui_event_generate_actionstring>:
void grid_ui_event_generate_actionstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    9f58:	b5f0      	push	{r4, r5, r6, r7, lr}
    9f5a:	4605      	mov	r5, r0
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9f5c:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
void grid_ui_event_generate_actionstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    9f60:	b0a3      	sub	sp, #140	; 0x8c
    9f62:	460c      	mov	r4, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9f64:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    9f66:	26ff      	movs	r6, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    9f68:	27bc      	movs	r7, #188	; 0xbc
    9f6a:	b2d9      	uxtb	r1, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9f6c:	4288      	cmp	r0, r1
    9f6e:	d82a      	bhi.n	9fc6 <grid_ui_event_generate_actionstring+0x6e>
	if (event_index == 255){
    9f70:	2eff      	cmp	r6, #255	; 0xff
    9f72:	d026      	beq.n	9fc2 <grid_ui_event_generate_actionstring+0x6a>
	uint8_t action_string[GRID_UI_ACTION_STRING_maxlength] = {0};
    9f74:	4b35      	ldr	r3, [pc, #212]	; (a04c <grid_ui_event_generate_actionstring+0xf4>)
    9f76:	2100      	movs	r1, #0
    9f78:	227e      	movs	r2, #126	; 0x7e
    9f7a:	a802      	add	r0, sp, #8
    9f7c:	9101      	str	r1, [sp, #4]
    9f7e:	4798      	blx	r3
	if (ele->type == GRID_UI_ELEMENT_BUTTON){
    9f80:	7a6b      	ldrb	r3, [r5, #9]
    9f82:	2b02      	cmp	r3, #2
    9f84:	d12c      	bne.n	9fe0 <grid_ui_event_generate_actionstring+0x88>
		switch(event_type){
    9f86:	2c04      	cmp	r4, #4
    9f88:	d026      	beq.n	9fd8 <grid_ui_event_generate_actionstring+0x80>
    9f8a:	2c05      	cmp	r4, #5
    9f8c:	d026      	beq.n	9fdc <grid_ui_event_generate_actionstring+0x84>
    9f8e:	b91c      	cbnz	r4, 9f98 <grid_ui_event_generate_actionstring+0x40>
			case GRID_UI_EVENT_INIT:	sprintf(action_string, GRID_ACTIONSTRING_INIT_BUT);		break;
    9f90:	492f      	ldr	r1, [pc, #188]	; (a050 <grid_ui_event_generate_actionstring+0xf8>)
			case GRID_UI_EVENT_DR:          sprintf(action_string, GRID_ACTIONSTRING_DR_ENC);	break;
    9f92:	4b30      	ldr	r3, [pc, #192]	; (a054 <grid_ui_event_generate_actionstring+0xfc>)
    9f94:	a801      	add	r0, sp, #4
    9f96:	4798      	blx	r3
	if (strlen(action_string)){
    9f98:	f89d 3004 	ldrb.w	r3, [sp, #4]
    9f9c:	b143      	cbz	r3, 9fb0 <grid_ui_event_generate_actionstring+0x58>
		grid_ui_event_register_actionstring(ele, event_type, action_string, strlen(action_string));
    9f9e:	4b2e      	ldr	r3, [pc, #184]	; (a058 <grid_ui_event_generate_actionstring+0x100>)
    9fa0:	a801      	add	r0, sp, #4
    9fa2:	4798      	blx	r3
    9fa4:	4621      	mov	r1, r4
    9fa6:	4603      	mov	r3, r0
    9fa8:	4c2c      	ldr	r4, [pc, #176]	; (a05c <grid_ui_event_generate_actionstring+0x104>)
    9faa:	aa01      	add	r2, sp, #4
    9fac:	4628      	mov	r0, r5
    9fae:	47a0      	blx	r4
	ele->event_list[event_index].cfg_changed_flag = 0;
    9fb0:	23bc      	movs	r3, #188	; 0xbc
    9fb2:	fb16 f603 	smulbb	r6, r6, r3
    9fb6:	6e2b      	ldr	r3, [r5, #96]	; 0x60
    9fb8:	441e      	add	r6, r3
    9fba:	f44f 7380 	mov.w	r3, #256	; 0x100
    9fbe:	f8a6 30b6 	strh.w	r3, [r6, #182]	; 0xb6
}
    9fc2:	b023      	add	sp, #140	; 0x8c
    9fc4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    9fc6:	6e2a      	ldr	r2, [r5, #96]	; 0x60
    9fc8:	fb07 2203 	mla	r2, r7, r3, r2
    9fcc:	3301      	adds	r3, #1
    9fce:	7a92      	ldrb	r2, [r2, #10]
    9fd0:	42a2      	cmp	r2, r4
    9fd2:	bf08      	it	eq
    9fd4:	460e      	moveq	r6, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9fd6:	e7c8      	b.n	9f6a <grid_ui_event_generate_actionstring+0x12>
			case GRID_UI_EVENT_DP:		sprintf(action_string, GRID_ACTIONSTRING_DP_BUT);		break;
    9fd8:	4921      	ldr	r1, [pc, #132]	; (a060 <grid_ui_event_generate_actionstring+0x108>)
    9fda:	e7da      	b.n	9f92 <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_DR:		sprintf(action_string, GRID_ACTIONSTRING_DR_BUT);		break;
    9fdc:	4921      	ldr	r1, [pc, #132]	; (a064 <grid_ui_event_generate_actionstring+0x10c>)
    9fde:	e7d8      	b.n	9f92 <grid_ui_event_generate_actionstring+0x3a>
	else if (ele->type == GRID_UI_ELEMENT_POTENTIOMETER){
    9fe0:	2b01      	cmp	r3, #1
    9fe2:	d105      	bne.n	9ff0 <grid_ui_event_generate_actionstring+0x98>
		switch(event_type){
    9fe4:	2c00      	cmp	r4, #0
    9fe6:	d0d3      	beq.n	9f90 <grid_ui_event_generate_actionstring+0x38>
    9fe8:	2c01      	cmp	r4, #1
    9fea:	d1d5      	bne.n	9f98 <grid_ui_event_generate_actionstring+0x40>
			case GRID_UI_EVENT_AVC7:	sprintf(action_string, GRID_ACTIONSTRING_AVC7_POT);		break;
    9fec:	491e      	ldr	r1, [pc, #120]	; (a068 <grid_ui_event_generate_actionstring+0x110>)
    9fee:	e7d0      	b.n	9f92 <grid_ui_event_generate_actionstring+0x3a>
	else if (ele->type == GRID_UI_ELEMENT_ENCODER){
    9ff0:	2b03      	cmp	r3, #3
    9ff2:	d1d1      	bne.n	9f98 <grid_ui_event_generate_actionstring+0x40>
		switch(event_type){
    9ff4:	2c0d      	cmp	r4, #13
    9ff6:	d8cf      	bhi.n	9f98 <grid_ui_event_generate_actionstring+0x40>
    9ff8:	a301      	add	r3, pc, #4	; (adr r3, a000 <grid_ui_event_generate_actionstring+0xa8>)
    9ffa:	f853 f024 	ldr.w	pc, [r3, r4, lsl #2]
    9ffe:	bf00      	nop
    a000:	0000a039 	.word	0x0000a039
    a004:	0000a03d 	.word	0x0000a03d
    a008:	00009f99 	.word	0x00009f99
    a00c:	00009f99 	.word	0x00009f99
    a010:	0000a045 	.word	0x0000a045
    a014:	0000a049 	.word	0x0000a049
    a018:	00009f99 	.word	0x00009f99
    a01c:	00009f99 	.word	0x00009f99
    a020:	00009f99 	.word	0x00009f99
    a024:	00009f99 	.word	0x00009f99
    a028:	00009f99 	.word	0x00009f99
    a02c:	00009f99 	.word	0x00009f99
    a030:	00009f99 	.word	0x00009f99
    a034:	0000a041 	.word	0x0000a041
			case GRID_UI_EVENT_INIT:        sprintf(action_string, GRID_ACTIONSTRING_INIT_ENC);	break;
    a038:	490c      	ldr	r1, [pc, #48]	; (a06c <grid_ui_event_generate_actionstring+0x114>)
    a03a:	e7aa      	b.n	9f92 <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_AVC7:        sprintf(action_string, GRID_ACTIONSTRING_AVC7_ENC);	break;
    a03c:	490c      	ldr	r1, [pc, #48]	; (a070 <grid_ui_event_generate_actionstring+0x118>)
    a03e:	e7a8      	b.n	9f92 <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_ENCPUSHROT:	sprintf(action_string, GRID_ACTIONSTRING_PUSHROT_ENC);	break;
    a040:	490c      	ldr	r1, [pc, #48]	; (a074 <grid_ui_event_generate_actionstring+0x11c>)
    a042:	e7a6      	b.n	9f92 <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_DP:          sprintf(action_string, GRID_ACTIONSTRING_DP_ENC);	break;
    a044:	490c      	ldr	r1, [pc, #48]	; (a078 <grid_ui_event_generate_actionstring+0x120>)
    a046:	e7a4      	b.n	9f92 <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_DR:          sprintf(action_string, GRID_ACTIONSTRING_DR_ENC);	break;
    a048:	490c      	ldr	r1, [pc, #48]	; (a07c <grid_ui_event_generate_actionstring+0x124>)
    a04a:	e7a2      	b.n	9f92 <grid_ui_event_generate_actionstring+0x3a>
    a04c:	000142f1 	.word	0x000142f1
    a050:	00015dd7 	.word	0x00015dd7
    a054:	000147ff 	.word	0x000147ff
    a058:	0001480f 	.word	0x0001480f
    a05c:	00009eed 	.word	0x00009eed
    a060:	00015dfc 	.word	0x00015dfc
    a064:	00015e2b 	.word	0x00015e2b
    a068:	00015e5a 	.word	0x00015e5a
    a06c:	00015e89 	.word	0x00015e89
    a070:	00015ed2 	.word	0x00015ed2
    a074:	00015f3c 	.word	0x00015f3c
    a078:	00015f6b 	.word	0x00015f6b
    a07c:	00015f9a 	.word	0x00015f9a

0000a080 <grid_ui_reinit>:
void grid_ui_reinit(struct grid_ui_model* ui){
    a080:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a084:	4606      	mov	r6, r0
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a086:	2700      	movs	r7, #0
    a088:	7873      	ldrb	r3, [r6, #1]
    a08a:	b2fc      	uxtb	r4, r7
    a08c:	42a3      	cmp	r3, r4
    a08e:	d805      	bhi.n	a09c <grid_ui_reinit+0x1c>
	grid_sys_state.bank_active_changed = 1;
    a090:	4b18      	ldr	r3, [pc, #96]	; (a0f4 <grid_ui_reinit+0x74>)
    a092:	2201      	movs	r2, #1
    a094:	745a      	strb	r2, [r3, #17]
}
    a096:	b003      	add	sp, #12
    a098:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		struct grid_ui_bank* bank = &ui->bank_list[i];
    a09c:	6873      	ldr	r3, [r6, #4]
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a09e:	f04f 0800 	mov.w	r8, #0
		struct grid_ui_bank* bank = &ui->bank_list[i];
    a0a2:	eb03 1404 	add.w	r4, r3, r4, lsl #4
			struct grid_ui_element* ele = &bank->element_list[j];
    a0a6:	f04f 0b64 	mov.w	fp, #100	; 0x64
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a0aa:	7a63      	ldrb	r3, [r4, #9]
    a0ac:	fa5f f088 	uxtb.w	r0, r8
    a0b0:	4283      	cmp	r3, r0
    a0b2:	d801      	bhi.n	a0b8 <grid_ui_reinit+0x38>
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a0b4:	3701      	adds	r7, #1
    a0b6:	e7e7      	b.n	a088 <grid_ui_reinit+0x8>
			struct grid_ui_element* ele = &bank->element_list[j];
    a0b8:	68e3      	ldr	r3, [r4, #12]
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a0ba:	f04f 0900 	mov.w	r9, #0
			struct grid_ui_element* ele = &bank->element_list[j];
    a0be:	fb0b 3000 	mla	r0, fp, r0, r3
				struct grid_ui_event* eve = &ele->event_list[k];
    a0c2:	f04f 0abc 	mov.w	sl, #188	; 0xbc
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a0c6:	f890 105c 	ldrb.w	r1, [r0, #92]	; 0x5c
    a0ca:	fa5f f589 	uxtb.w	r5, r9
    a0ce:	42a9      	cmp	r1, r5
    a0d0:	d802      	bhi.n	a0d8 <grid_ui_reinit+0x58>
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a0d2:	f108 0801 	add.w	r8, r8, #1
    a0d6:	e7e8      	b.n	a0aa <grid_ui_reinit+0x2a>
				struct grid_ui_event* eve = &ele->event_list[k];
    a0d8:	6e01      	ldr	r1, [r0, #96]	; 0x60
				grid_ui_event_generate_actionstring(ele, eve->type);
    a0da:	4b07      	ldr	r3, [pc, #28]	; (a0f8 <grid_ui_reinit+0x78>)
    a0dc:	9001      	str	r0, [sp, #4]
				struct grid_ui_event* eve = &ele->event_list[k];
    a0de:	fb0a 1505 	mla	r5, sl, r5, r1
				grid_ui_event_generate_actionstring(ele, eve->type);
    a0e2:	f109 0901 	add.w	r9, r9, #1
    a0e6:	7aa9      	ldrb	r1, [r5, #10]
    a0e8:	4798      	blx	r3
}


void grid_ui_event_reset(struct grid_ui_event* eve){
	
	eve->trigger = GRID_UI_STATUS_READY;
    a0ea:	2204      	movs	r2, #4
    a0ec:	9801      	ldr	r0, [sp, #4]
    a0ee:	726a      	strb	r2, [r5, #9]
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a0f0:	e7e9      	b.n	a0c6 <grid_ui_reinit+0x46>
    a0f2:	bf00      	nop
    a0f4:	2000f008 	.word	0x2000f008
    a0f8:	00009f59 	.word	0x00009f59

0000a0fc <grid_ui_event_find>:
uint8_t grid_ui_event_find(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a0fc:	b5f0      	push	{r4, r5, r6, r7, lr}
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a0fe:	f890 605c 	ldrb.w	r6, [r0, #92]	; 0x5c
    a102:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    a104:	22ff      	movs	r2, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a106:	27bc      	movs	r7, #188	; 0xbc
    a108:	b2dd      	uxtb	r5, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a10a:	42ae      	cmp	r6, r5
    a10c:	d801      	bhi.n	a112 <grid_ui_event_find+0x16>
}
    a10e:	4610      	mov	r0, r2
    a110:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    a112:	6e04      	ldr	r4, [r0, #96]	; 0x60
    a114:	fb07 4403 	mla	r4, r7, r3, r4
    a118:	3301      	adds	r3, #1
    a11a:	7aa4      	ldrb	r4, [r4, #10]
    a11c:	428c      	cmp	r4, r1
    a11e:	bf08      	it	eq
    a120:	462a      	moveq	r2, r5
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a122:	e7f1      	b.n	a108 <grid_ui_event_find+0xc>

0000a124 <grid_ui_event_trigger>:
	if (event_index == 255){
    a124:	29ff      	cmp	r1, #255	; 0xff
    a126:	d005      	beq.n	a134 <grid_ui_event_trigger+0x10>
	eve->trigger = GRID_UI_STATUS_TRIGGERED;
    a128:	6e02      	ldr	r2, [r0, #96]	; 0x60
    a12a:	23bc      	movs	r3, #188	; 0xbc
    a12c:	fb01 2103 	mla	r1, r1, r3, r2
    a130:	2305      	movs	r3, #5
    a132:	724b      	strb	r3, [r1, #9]
}
    a134:	4770      	bx	lr

0000a136 <grid_ui_event_trigger_local>:
	if (event_index == 255){
    a136:	29ff      	cmp	r1, #255	; 0xff
    a138:	d005      	beq.n	a146 <grid_ui_event_trigger_local+0x10>
	eve->trigger = GRID_UI_STATUS_TRIGGERED_LOCAL;
    a13a:	6e02      	ldr	r2, [r0, #96]	; 0x60
    a13c:	23bc      	movs	r3, #188	; 0xbc
    a13e:	fb01 2103 	mla	r1, r1, r3, r2
    a142:	2306      	movs	r3, #6
    a144:	724b      	strb	r3, [r1, #9]
}
    a146:	4770      	bx	lr

0000a148 <grid_ui_smart_trigger>:
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a148:	6840      	ldr	r0, [r0, #4]
    a14a:	eb00 1001 	add.w	r0, r0, r1, lsl #4
void grid_ui_smart_trigger(struct grid_ui_model* mod, uint8_t bank, uint8_t element, enum grid_ui_event_t event){
    a14e:	b510      	push	{r4, lr}
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a150:	68c4      	ldr	r4, [r0, #12]
    a152:	2064      	movs	r0, #100	; 0x64
    a154:	fb02 4400 	mla	r4, r2, r0, r4
    a158:	4619      	mov	r1, r3
    a15a:	4620      	mov	r0, r4
    a15c:	4b05      	ldr	r3, [pc, #20]	; (a174 <grid_ui_smart_trigger+0x2c>)
    a15e:	4798      	blx	r3
	if (event_index == 255){
    a160:	28ff      	cmp	r0, #255	; 0xff
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a162:	4601      	mov	r1, r0
	if (event_index == 255){
    a164:	d004      	beq.n	a170 <grid_ui_smart_trigger+0x28>
	grid_ui_event_trigger(&mod->bank_list[bank].element_list[element], event_index);
    a166:	4620      	mov	r0, r4
    a168:	4b03      	ldr	r3, [pc, #12]	; (a178 <grid_ui_smart_trigger+0x30>)
}
    a16a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_ui_event_trigger(&mod->bank_list[bank].element_list[element], event_index);
    a16e:	4718      	bx	r3
}
    a170:	bd10      	pop	{r4, pc}
    a172:	bf00      	nop
    a174:	0000a0fd 	.word	0x0000a0fd
    a178:	0000a125 	.word	0x0000a125

0000a17c <grid_ui_event_register_eventstring>:
void grid_ui_event_register_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type, uint8_t* event_string, uint32_t event_string_length){
    a17c:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a180:	4604      	mov	r4, r0
	grid_debug_print_text("Register Action");
    a182:	4e28      	ldr	r6, [pc, #160]	; (a224 <grid_ui_event_register_eventstring+0xa8>)
    a184:	4828      	ldr	r0, [pc, #160]	; (a228 <grid_ui_event_register_eventstring+0xac>)
void grid_ui_event_register_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type, uint8_t* event_string, uint32_t event_string_length){
    a186:	4699      	mov	r9, r3
    a188:	4688      	mov	r8, r1
    a18a:	4692      	mov	sl, r2
	grid_debug_print_text("Register Action");
    a18c:	47b0      	blx	r6
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a18e:	f894 005c 	ldrb.w	r0, [r4, #92]	; 0x5c
    a192:	46b3      	mov	fp, r6
    a194:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    a196:	25ff      	movs	r5, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a198:	26bc      	movs	r6, #188	; 0xbc
    a19a:	b2d9      	uxtb	r1, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a19c:	4288      	cmp	r0, r1
    a19e:	d807      	bhi.n	a1b0 <grid_ui_event_register_eventstring+0x34>
	if (event_index == 255){
    a1a0:	2dff      	cmp	r5, #255	; 0xff
    a1a2:	d10e      	bne.n	a1c2 <grid_ui_event_register_eventstring+0x46>
		grid_debug_print_text("Event Not Found");
    a1a4:	4821      	ldr	r0, [pc, #132]	; (a22c <grid_ui_event_register_eventstring+0xb0>)
    a1a6:	465b      	mov	r3, fp
}
    a1a8:	b001      	add	sp, #4
    a1aa:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		grid_debug_print_text("Event Not Found");
    a1ae:	4718      	bx	r3
		if (ele->event_list[i].type == event_type){
    a1b0:	6e22      	ldr	r2, [r4, #96]	; 0x60
    a1b2:	fb06 2203 	mla	r2, r6, r3, r2
    a1b6:	3301      	adds	r3, #1
    a1b8:	7a92      	ldrb	r2, [r2, #10]
    a1ba:	4542      	cmp	r2, r8
    a1bc:	bf08      	it	eq
    a1be:	460d      	moveq	r5, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a1c0:	e7eb      	b.n	a19a <grid_ui_event_register_eventstring+0x1e>
		ele->event_list[event_index].event_string[i] = 0;
    a1c2:	23bc      	movs	r3, #188	; 0xbc
    a1c4:	fb15 f503 	smulbb	r5, r5, r3
    a1c8:	6e23      	ldr	r3, [r4, #96]	; 0x60
    a1ca:	442b      	add	r3, r5
    a1cc:	f103 0210 	add.w	r2, r3, #16
    a1d0:	f103 002e 	add.w	r0, r3, #46	; 0x2e
    a1d4:	2100      	movs	r1, #0
    a1d6:	f802 1b01 	strb.w	r1, [r2], #1
	for(uint32_t i=0; i<GRID_UI_EVENT_STRING_maxlength; i++){
    a1da:	4282      	cmp	r2, r0
    a1dc:	d1fb      	bne.n	a1d6 <grid_ui_event_register_eventstring+0x5a>
			grid_debug_print_text(" Escaped Char Found ");
    a1de:	4814      	ldr	r0, [pc, #80]	; (a230 <grid_ui_event_register_eventstring+0xb4>)
	ele->event_list[event_index].event_string_length = 0;
    a1e0:	60d9      	str	r1, [r3, #12]
	for (uint32_t i=0; i<event_string_length; i++){
    a1e2:	2600      	movs	r6, #0
    a1e4:	6e27      	ldr	r7, [r4, #96]	; 0x60
    a1e6:	454e      	cmp	r6, r9
    a1e8:	442f      	add	r7, r5
    a1ea:	d10b      	bne.n	a204 <grid_ui_event_register_eventstring+0x88>
	grid_ui_smart_trigger(ele->parent->parent, ele->parent->index, ele->index, event_type);
    a1ec:	6860      	ldr	r0, [r4, #4]
	ele->event_list[event_index].event_string_length = event_string_length;
    a1ee:	60fe      	str	r6, [r7, #12]
	grid_ui_smart_trigger(ele->parent->parent, ele->parent->index, ele->index, event_type);
    a1f0:	7a22      	ldrb	r2, [r4, #8]
    a1f2:	4c10      	ldr	r4, [pc, #64]	; (a234 <grid_ui_event_register_eventstring+0xb8>)
    a1f4:	7a01      	ldrb	r1, [r0, #8]
    a1f6:	6840      	ldr	r0, [r0, #4]
    a1f8:	4643      	mov	r3, r8
    a1fa:	46a4      	mov	ip, r4
}
    a1fc:	b001      	add	sp, #4
    a1fe:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_ui_smart_trigger(ele->parent->parent, ele->parent->index, ele->index, event_type);
    a202:	4760      	bx	ip
		ele->event_list[event_index].event_string[i] = event_string[i];
    a204:	f81a 3006 	ldrb.w	r3, [sl, r6]
    a208:	4437      	add	r7, r6
    a20a:	743b      	strb	r3, [r7, #16]
		if (ele->event_list[event_index].event_string[i] > 127){
    a20c:	061b      	lsls	r3, r3, #24
    a20e:	d507      	bpl.n	a220 <grid_ui_event_register_eventstring+0xa4>
			grid_debug_print_text(" Escaped Char Found ");
    a210:	47d8      	blx	fp
			ele->event_list[event_index].event_string[i] -= 128;
    a212:	6e23      	ldr	r3, [r4, #96]	; 0x60
    a214:	4806      	ldr	r0, [pc, #24]	; (a230 <grid_ui_event_register_eventstring+0xb4>)
    a216:	442b      	add	r3, r5
    a218:	4433      	add	r3, r6
    a21a:	7c1a      	ldrb	r2, [r3, #16]
    a21c:	3a80      	subs	r2, #128	; 0x80
    a21e:	741a      	strb	r2, [r3, #16]
	for (uint32_t i=0; i<event_string_length; i++){
    a220:	3601      	adds	r6, #1
    a222:	e7df      	b.n	a1e4 <grid_ui_event_register_eventstring+0x68>
    a224:	00009231 	.word	0x00009231
    a228:	00015fc9 	.word	0x00015fc9
    a22c:	00015fd9 	.word	0x00015fd9
    a230:	00015fe9 	.word	0x00015fe9
    a234:	0000a149 	.word	0x0000a149

0000a238 <grid_ui_event_generate_eventstring>:
void grid_ui_event_generate_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a238:	b5f0      	push	{r4, r5, r6, r7, lr}
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a23a:	f890 605c 	ldrb.w	r6, [r0, #92]	; 0x5c
void grid_ui_event_generate_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a23e:	b089      	sub	sp, #36	; 0x24
    a240:	4605      	mov	r5, r0
    a242:	460c      	mov	r4, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a244:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    a246:	22ff      	movs	r2, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a248:	27bc      	movs	r7, #188	; 0xbc
    a24a:	b2d8      	uxtb	r0, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a24c:	4286      	cmp	r6, r0
    a24e:	d81a      	bhi.n	a286 <grid_ui_event_generate_eventstring+0x4e>
	if (event_index == 255){
    a250:	2aff      	cmp	r2, #255	; 0xff
    a252:	d016      	beq.n	a282 <grid_ui_event_generate_eventstring+0x4a>
	uint8_t event_string[GRID_UI_EVENT_STRING_maxlength] = {0};	
    a254:	4b27      	ldr	r3, [pc, #156]	; (a2f4 <grid_ui_event_generate_eventstring+0xbc>)
    a256:	2100      	movs	r1, #0
    a258:	221a      	movs	r2, #26
    a25a:	a801      	add	r0, sp, #4
    a25c:	9100      	str	r1, [sp, #0]
    a25e:	4798      	blx	r3
	if (ele->type == GRID_UI_ELEMENT_BUTTON){
    a260:	7a6b      	ldrb	r3, [r5, #9]
    a262:	2b02      	cmp	r3, #2
    a264:	d132      	bne.n	a2cc <grid_ui_event_generate_eventstring+0x94>
		if (event_type == GRID_UI_EVENT_INIT){
    a266:	b9bc      	cbnz	r4, a298 <grid_ui_event_generate_eventstring+0x60>
			sprintf(event_string, GRID_EVENTSTRING_INIT_BUT); // !!
    a268:	4923      	ldr	r1, [pc, #140]	; (a2f8 <grid_ui_event_generate_eventstring+0xc0>)
    a26a:	4b24      	ldr	r3, [pc, #144]	; (a2fc <grid_ui_event_generate_eventstring+0xc4>)
    a26c:	4668      	mov	r0, sp
    a26e:	4798      	blx	r3
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a270:	4b23      	ldr	r3, [pc, #140]	; (a300 <grid_ui_event_generate_eventstring+0xc8>)
    a272:	4668      	mov	r0, sp
    a274:	4798      	blx	r3
    a276:	466a      	mov	r2, sp
    a278:	4603      	mov	r3, r0
    a27a:	2100      	movs	r1, #0
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a27c:	4c21      	ldr	r4, [pc, #132]	; (a304 <grid_ui_event_generate_eventstring+0xcc>)
    a27e:	4628      	mov	r0, r5
    a280:	47a0      	blx	r4
}
    a282:	b009      	add	sp, #36	; 0x24
    a284:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    a286:	6e29      	ldr	r1, [r5, #96]	; 0x60
    a288:	fb07 1103 	mla	r1, r7, r3, r1
    a28c:	3301      	adds	r3, #1
    a28e:	7a89      	ldrb	r1, [r1, #10]
    a290:	42a1      	cmp	r1, r4
    a292:	bf08      	it	eq
    a294:	4602      	moveq	r2, r0
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a296:	e7d8      	b.n	a24a <grid_ui_event_generate_eventstring+0x12>
		else if (event_type == GRID_UI_EVENT_DP){
    a298:	2c04      	cmp	r4, #4
    a29a:	d10a      	bne.n	a2b2 <grid_ui_event_generate_eventstring+0x7a>
			sprintf(event_string, GRID_EVENTSTRING_DP_BUT); // !!
    a29c:	491a      	ldr	r1, [pc, #104]	; (a308 <grid_ui_event_generate_eventstring+0xd0>)
    a29e:	4b17      	ldr	r3, [pc, #92]	; (a2fc <grid_ui_event_generate_eventstring+0xc4>)
    a2a0:	4668      	mov	r0, sp
    a2a2:	4798      	blx	r3
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a2a4:	4b16      	ldr	r3, [pc, #88]	; (a300 <grid_ui_event_generate_eventstring+0xc8>)
    a2a6:	4668      	mov	r0, sp
    a2a8:	4798      	blx	r3
    a2aa:	466a      	mov	r2, sp
    a2ac:	4603      	mov	r3, r0
    a2ae:	2104      	movs	r1, #4
    a2b0:	e7e4      	b.n	a27c <grid_ui_event_generate_eventstring+0x44>
		else if (event_type == GRID_UI_EVENT_DR){
    a2b2:	2c05      	cmp	r4, #5
    a2b4:	d1e5      	bne.n	a282 <grid_ui_event_generate_eventstring+0x4a>
			sprintf(event_string, GRID_EVENTSTRING_DR_BUT); // !!
    a2b6:	4915      	ldr	r1, [pc, #84]	; (a30c <grid_ui_event_generate_eventstring+0xd4>)
			sprintf(event_string, GRID_EVENTSTRING_PUSHROT_ENC); // !!
    a2b8:	4b10      	ldr	r3, [pc, #64]	; (a2fc <grid_ui_event_generate_eventstring+0xc4>)
    a2ba:	4668      	mov	r0, sp
    a2bc:	4798      	blx	r3
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a2be:	4b10      	ldr	r3, [pc, #64]	; (a300 <grid_ui_event_generate_eventstring+0xc8>)
    a2c0:	4668      	mov	r0, sp
    a2c2:	4798      	blx	r3
    a2c4:	466a      	mov	r2, sp
    a2c6:	4603      	mov	r3, r0
    a2c8:	4621      	mov	r1, r4
    a2ca:	e7d7      	b.n	a27c <grid_ui_event_generate_eventstring+0x44>
	else if (ele->type == GRID_UI_ELEMENT_POTENTIOMETER){
    a2cc:	2b01      	cmp	r3, #1
    a2ce:	d105      	bne.n	a2dc <grid_ui_event_generate_eventstring+0xa4>
		if (event_type == GRID_UI_EVENT_INIT){
    a2d0:	2c00      	cmp	r4, #0
    a2d2:	d0c9      	beq.n	a268 <grid_ui_event_generate_eventstring+0x30>
		else if (event_type == GRID_UI_EVENT_AVC7){
    a2d4:	2c01      	cmp	r4, #1
    a2d6:	d1d4      	bne.n	a282 <grid_ui_event_generate_eventstring+0x4a>
			sprintf(event_string, GRID_EVENTSTRING_AVC7_POT); // !!
    a2d8:	490d      	ldr	r1, [pc, #52]	; (a310 <grid_ui_event_generate_eventstring+0xd8>)
    a2da:	e7ed      	b.n	a2b8 <grid_ui_event_generate_eventstring+0x80>
	else if (ele->type == GRID_UI_ELEMENT_ENCODER){
    a2dc:	2b03      	cmp	r3, #3
    a2de:	d1d0      	bne.n	a282 <grid_ui_event_generate_eventstring+0x4a>
		if (event_type == GRID_UI_EVENT_INIT){
    a2e0:	2c00      	cmp	r4, #0
    a2e2:	d0c1      	beq.n	a268 <grid_ui_event_generate_eventstring+0x30>
		else if (event_type == GRID_UI_EVENT_AVC7){
    a2e4:	2c01      	cmp	r4, #1
    a2e6:	d101      	bne.n	a2ec <grid_ui_event_generate_eventstring+0xb4>
			sprintf(event_string, GRID_EVENTSTRING_AVC7_ENC); // !!
    a2e8:	490a      	ldr	r1, [pc, #40]	; (a314 <grid_ui_event_generate_eventstring+0xdc>)
    a2ea:	e7e5      	b.n	a2b8 <grid_ui_event_generate_eventstring+0x80>
		else if (event_type == GRID_UI_EVENT_ENCPUSHROT){
    a2ec:	2c0d      	cmp	r4, #13
    a2ee:	d1d3      	bne.n	a298 <grid_ui_event_generate_eventstring+0x60>
			sprintf(event_string, GRID_EVENTSTRING_PUSHROT_ENC); // !!
    a2f0:	4909      	ldr	r1, [pc, #36]	; (a318 <grid_ui_event_generate_eventstring+0xe0>)
    a2f2:	e7e1      	b.n	a2b8 <grid_ui_event_generate_eventstring+0x80>
    a2f4:	000142f1 	.word	0x000142f1
    a2f8:	00015ffe 	.word	0x00015ffe
    a2fc:	000147ff 	.word	0x000147ff
    a300:	0001480f 	.word	0x0001480f
    a304:	0000a17d 	.word	0x0000a17d
    a308:	00016017 	.word	0x00016017
    a30c:	00016035 	.word	0x00016035
    a310:	00016053 	.word	0x00016053
    a314:	00016071 	.word	0x00016071
    a318:	0001608f 	.word	0x0001608f

0000a31c <grid_ui_event_init>:
void grid_ui_event_init(struct grid_ui_element* parent, uint8_t index, enum grid_ui_event_t event_type){
    a31c:	b570      	push	{r4, r5, r6, lr}
	struct grid_ui_event* eve = &parent->event_list[index];
    a31e:	6e06      	ldr	r6, [r0, #96]	; 0x60
void grid_ui_event_init(struct grid_ui_element* parent, uint8_t index, enum grid_ui_event_t event_type){
    a320:	4615      	mov	r5, r2
	struct grid_ui_event* eve = &parent->event_list[index];
    a322:	22bc      	movs	r2, #188	; 0xbc
    a324:	fb11 f202 	smulbb	r2, r1, r2
    a328:	18b4      	adds	r4, r6, r2
	eve->cfg_changed_flag = 0;
    a32a:	2300      	movs	r3, #0
	eve->index = index;
    a32c:	7221      	strb	r1, [r4, #8]
	eve->status = GRID_UI_STATUS_READY;
    a32e:	2104      	movs	r1, #4
	eve->parent = parent;
    a330:	6060      	str	r0, [r4, #4]
	eve->cfg_changed_flag = 0;
    a332:	f884 30b6 	strb.w	r3, [r4, #182]	; 0xb6
	eve->type   = event_type;	
    a336:	72a5      	strb	r5, [r4, #10]
	eve->status = GRID_UI_STATUS_READY;
    a338:	54b1      	strb	r1, [r6, r2]
	for (uint32_t i=0; i<GRID_UI_EVENT_STRING_maxlength; i++){
    a33a:	f104 0210 	add.w	r2, r4, #16
    a33e:	f104 012e 	add.w	r1, r4, #46	; 0x2e
		eve->event_string[i] = 0;
    a342:	f802 3b01 	strb.w	r3, [r2], #1
	for (uint32_t i=0; i<GRID_UI_EVENT_STRING_maxlength; i++){
    a346:	428a      	cmp	r2, r1
    a348:	d1fb      	bne.n	a342 <grid_ui_event_init+0x26>
	eve->event_string_length = 0;
    a34a:	60e3      	str	r3, [r4, #12]
	for (uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
    a34c:	f104 01b6 	add.w	r1, r4, #182	; 0xb6
    a350:	f104 0334 	add.w	r3, r4, #52	; 0x34
		eve->action_string[i] = 0;
    a354:	2200      	movs	r2, #0
    a356:	f803 2b01 	strb.w	r2, [r3], #1
	for (uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
    a35a:	4299      	cmp	r1, r3
    a35c:	d1fb      	bne.n	a356 <grid_ui_event_init+0x3a>
	grid_ui_event_generate_eventstring(eve->parent, event_type);
    a35e:	4b08      	ldr	r3, [pc, #32]	; (a380 <grid_ui_event_init+0x64>)
	eve->action_string_length = 0;
    a360:	6322      	str	r2, [r4, #48]	; 0x30
	grid_ui_event_generate_eventstring(eve->parent, event_type);
    a362:	4629      	mov	r1, r5
    a364:	4798      	blx	r3
	grid_ui_event_generate_actionstring(eve->parent, event_type);	
    a366:	4b07      	ldr	r3, [pc, #28]	; (a384 <grid_ui_event_init+0x68>)
    a368:	6860      	ldr	r0, [r4, #4]
    a36a:	4629      	mov	r1, r5
    a36c:	4798      	blx	r3
	eve->cfg_changed_flag = 0;
    a36e:	f44f 7380 	mov.w	r3, #256	; 0x100
    a372:	f8a4 30b6 	strh.w	r3, [r4, #182]	; 0xb6
	eve->cfg_flashempty_flag = 1;
    a376:	2301      	movs	r3, #1
    a378:	f884 30b8 	strb.w	r3, [r4, #184]	; 0xb8
}
    a37c:	bd70      	pop	{r4, r5, r6, pc}
    a37e:	bf00      	nop
    a380:	0000a239 	.word	0x0000a239
    a384:	00009f59 	.word	0x00009f59

0000a388 <grid_ui_element_init>:
void grid_ui_element_init(struct grid_ui_bank* parent, uint8_t index, enum grid_ui_element_t element_type){
    a388:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct grid_ui_element* ele = &parent->element_list[index];
    a38c:	2364      	movs	r3, #100	; 0x64
void grid_ui_element_init(struct grid_ui_bank* parent, uint8_t index, enum grid_ui_element_t element_type){
    a38e:	4615      	mov	r5, r2
	struct grid_ui_element* ele = &parent->element_list[index];
    a390:	68c2      	ldr	r2, [r0, #12]
    a392:	fb11 f303 	smulbb	r3, r1, r3
    a396:	18d4      	adds	r4, r2, r3
	ele->index = index;
    a398:	7221      	strb	r1, [r4, #8]
	ele->status = GRID_UI_STATUS_INITIALIZED;
    a39a:	2101      	movs	r1, #1
	ele->parent = parent;
    a39c:	6060      	str	r0, [r4, #4]
	ele->status = GRID_UI_STATUS_INITIALIZED;
    a39e:	54d1      	strb	r1, [r2, r3]
	ele->type = element_type;
    a3a0:	7265      	strb	r5, [r4, #9]
	for(uint8_t i=0; i<GRID_TEMPLATE_UI_PARAMETER_LIST_LENGTH; i++){
    a3a2:	f104 030c 	add.w	r3, r4, #12
    a3a6:	f104 025c 	add.w	r2, r4, #92	; 0x5c
		ele->template_parameter_list[i] = 0;
    a3aa:	2100      	movs	r1, #0
    a3ac:	f843 1b04 	str.w	r1, [r3], #4
	for(uint8_t i=0; i<GRID_TEMPLATE_UI_PARAMETER_LIST_LENGTH; i++){
    a3b0:	429a      	cmp	r2, r3
    a3b2:	d1fb      	bne.n	a3ac <grid_ui_element_init+0x24>
	if (element_type == GRID_UI_ELEMENT_SYSTEM){
    a3b4:	bb1d      	cbnz	r5, a3fe <grid_ui_element_init+0x76>
		ele->event_list_length = 6;
    a3b6:	2306      	movs	r3, #6
    a3b8:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a3bc:	f44f 608d 	mov.w	r0, #1128	; 0x468
    a3c0:	4b34      	ldr	r3, [pc, #208]	; (a494 <grid_ui_element_init+0x10c>)
    a3c2:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a3c4:	462a      	mov	r2, r5
    a3c6:	4629      	mov	r1, r5
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a3c8:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a3ca:	4d33      	ldr	r5, [pc, #204]	; (a498 <grid_ui_element_init+0x110>)
    a3cc:	4620      	mov	r0, r4
    a3ce:	47a8      	blx	r5
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_HEARTBEAT); // Heartbeat
    a3d0:	220c      	movs	r2, #12
    a3d2:	2101      	movs	r1, #1
    a3d4:	4620      	mov	r0, r4
    a3d6:	47a8      	blx	r5
		grid_ui_event_init(ele, 2, GRID_UI_EVENT_MAPMODE_PRESS); // Mapmode press
    a3d8:	2207      	movs	r2, #7
    a3da:	2102      	movs	r1, #2
    a3dc:	4620      	mov	r0, r4
    a3de:	47a8      	blx	r5
		grid_ui_event_init(ele, 3, GRID_UI_EVENT_MAPMODE_RELEASE); // Mapmode release
    a3e0:	2208      	movs	r2, #8
    a3e2:	2103      	movs	r1, #3
    a3e4:	4620      	mov	r0, r4
    a3e6:	47a8      	blx	r5
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_CFG_RESPONSE); //
    a3e8:	2209      	movs	r2, #9
    a3ea:	2104      	movs	r1, #4
    a3ec:	4620      	mov	r0, r4
    a3ee:	47a8      	blx	r5
		grid_ui_event_init(ele, 5, GRID_UI_EVENT_CFG_REQUEST); //
    a3f0:	220a      	movs	r2, #10
    a3f2:	2105      	movs	r1, #5
    a3f4:	4620      	mov	r0, r4
    a3f6:	462b      	mov	r3, r5
}
    a3f8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_ENCPUSHROT); // Absolute Value Change (7bit)
    a3fc:	4718      	bx	r3
	else if (element_type == GRID_UI_ELEMENT_POTENTIOMETER){
    a3fe:	2d01      	cmp	r5, #1
    a400:	d111      	bne.n	a426 <grid_ui_element_init+0x9e>
		ele->event_list_length = 2;
    a402:	2302      	movs	r3, #2
    a404:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a408:	f44f 70bc 	mov.w	r0, #376	; 0x178
    a40c:	4b21      	ldr	r3, [pc, #132]	; (a494 <grid_ui_element_init+0x10c>)
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a40e:	4e22      	ldr	r6, [pc, #136]	; (a498 <grid_ui_element_init+0x110>)
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a410:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a412:	2200      	movs	r2, #0
    a414:	4611      	mov	r1, r2
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a416:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a418:	4620      	mov	r0, r4
    a41a:	47b0      	blx	r6
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_AVC7); // Absolute Value Change (7bit)
    a41c:	462a      	mov	r2, r5
    a41e:	4629      	mov	r1, r5
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_ENCPUSHROT); // Absolute Value Change (7bit)
    a420:	4620      	mov	r0, r4
    a422:	4633      	mov	r3, r6
    a424:	e7e8      	b.n	a3f8 <grid_ui_element_init+0x70>
	else if (element_type == GRID_UI_ELEMENT_BUTTON){
    a426:	2d02      	cmp	r5, #2
    a428:	d113      	bne.n	a452 <grid_ui_element_init+0xca>
		ele->event_list_length = 3;
    a42a:	2303      	movs	r3, #3
    a42c:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a430:	f44f 700d 	mov.w	r0, #564	; 0x234
    a434:	4b17      	ldr	r3, [pc, #92]	; (a494 <grid_ui_element_init+0x10c>)
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a436:	4e18      	ldr	r6, [pc, #96]	; (a498 <grid_ui_element_init+0x110>)
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a438:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a43a:	2200      	movs	r2, #0
    a43c:	4611      	mov	r1, r2
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a43e:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a440:	4620      	mov	r0, r4
    a442:	47b0      	blx	r6
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_DP);	// Press
    a444:	2204      	movs	r2, #4
    a446:	2101      	movs	r1, #1
    a448:	4620      	mov	r0, r4
    a44a:	47b0      	blx	r6
		grid_ui_event_init(ele, 2, GRID_UI_EVENT_DR);	// Release
    a44c:	2205      	movs	r2, #5
    a44e:	4629      	mov	r1, r5
    a450:	e7e6      	b.n	a420 <grid_ui_element_init+0x98>
	else if (element_type == GRID_UI_ELEMENT_ENCODER){
    a452:	2d03      	cmp	r5, #3
    a454:	d11b      	bne.n	a48e <grid_ui_element_init+0x106>
		ele->event_list_length = 5;
    a456:	2705      	movs	r7, #5
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a458:	4b0e      	ldr	r3, [pc, #56]	; (a494 <grid_ui_element_init+0x10c>)
		ele->event_list_length = 5;
    a45a:	f884 705c 	strb.w	r7, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a45e:	f44f 706b 	mov.w	r0, #940	; 0x3ac
    a462:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a464:	2200      	movs	r2, #0
    a466:	4e0c      	ldr	r6, [pc, #48]	; (a498 <grid_ui_element_init+0x110>)
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a468:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a46a:	4611      	mov	r1, r2
    a46c:	4620      	mov	r0, r4
    a46e:	47b0      	blx	r6
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_DP);	// Press
    a470:	2204      	movs	r2, #4
    a472:	2101      	movs	r1, #1
    a474:	4620      	mov	r0, r4
    a476:	47b0      	blx	r6
		grid_ui_event_init(ele, 2, GRID_UI_EVENT_DR);	// Release
    a478:	463a      	mov	r2, r7
    a47a:	2102      	movs	r1, #2
    a47c:	4620      	mov	r0, r4
    a47e:	47b0      	blx	r6
		grid_ui_event_init(ele, 3, GRID_UI_EVENT_AVC7); // Absolute Value Change (7bit)
    a480:	2201      	movs	r2, #1
    a482:	4629      	mov	r1, r5
    a484:	4620      	mov	r0, r4
    a486:	47b0      	blx	r6
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_ENCPUSHROT); // Absolute Value Change (7bit)
    a488:	220d      	movs	r2, #13
    a48a:	2104      	movs	r1, #4
    a48c:	e7c8      	b.n	a420 <grid_ui_element_init+0x98>
}
    a48e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a492:	bf00      	nop
    a494:	000142c5 	.word	0x000142c5
    a498:	0000a31d 	.word	0x0000a31d

0000a49c <grid_ui_smart_trigger_local>:
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a49c:	6840      	ldr	r0, [r0, #4]
    a49e:	eb00 1001 	add.w	r0, r0, r1, lsl #4
void grid_ui_smart_trigger_local(struct grid_ui_model* mod, uint8_t bank, uint8_t element, enum grid_ui_event_t event){
    a4a2:	b510      	push	{r4, lr}
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a4a4:	68c4      	ldr	r4, [r0, #12]
    a4a6:	2064      	movs	r0, #100	; 0x64
    a4a8:	fb02 4400 	mla	r4, r2, r0, r4
    a4ac:	4619      	mov	r1, r3
    a4ae:	4620      	mov	r0, r4
    a4b0:	4b05      	ldr	r3, [pc, #20]	; (a4c8 <grid_ui_smart_trigger_local+0x2c>)
    a4b2:	4798      	blx	r3
	if (event_index == 255){
    a4b4:	28ff      	cmp	r0, #255	; 0xff
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a4b6:	4601      	mov	r1, r0
	if (event_index == 255){
    a4b8:	d004      	beq.n	a4c4 <grid_ui_smart_trigger_local+0x28>
    grid_ui_event_trigger_local(&mod->bank_list[bank].element_list[element], event_index);
    a4ba:	4620      	mov	r0, r4
    a4bc:	4b03      	ldr	r3, [pc, #12]	; (a4cc <grid_ui_smart_trigger_local+0x30>)
}
    a4be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    grid_ui_event_trigger_local(&mod->bank_list[bank].element_list[element], event_index);
    a4c2:	4718      	bx	r3
}
    a4c4:	bd10      	pop	{r4, pc}
    a4c6:	bf00      	nop
    a4c8:	0000a0fd 	.word	0x0000a0fd
    a4cc:	0000a137 	.word	0x0000a137

0000a4d0 <grid_ui_reinit_local>:
void grid_ui_reinit_local(struct grid_ui_model* ui){
    a4d0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a4d4:	4604      	mov	r4, r0
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a4d6:	f04f 0800 	mov.w	r8, #0
    a4da:	7863      	ldrb	r3, [r4, #1]
    a4dc:	fa5f f788 	uxtb.w	r7, r8
    a4e0:	42bb      	cmp	r3, r7
    a4e2:	d805      	bhi.n	a4f0 <grid_ui_reinit_local+0x20>
	grid_sys_state.bank_active_changed = 1;
    a4e4:	4b1c      	ldr	r3, [pc, #112]	; (a558 <grid_ui_reinit_local+0x88>)
    a4e6:	2201      	movs	r2, #1
    a4e8:	745a      	strb	r2, [r3, #17]
}
    a4ea:	b003      	add	sp, #12
    a4ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		struct grid_ui_bank* bank = &ui->bank_list[i];
    a4f0:	6866      	ldr	r6, [r4, #4]
    a4f2:	eb06 1307 	add.w	r3, r6, r7, lsl #4
    a4f6:	9300      	str	r3, [sp, #0]
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a4f8:	f04f 0900 	mov.w	r9, #0
    a4fc:	9b00      	ldr	r3, [sp, #0]
    a4fe:	7a5b      	ldrb	r3, [r3, #9]
    a500:	fa5f fb89 	uxtb.w	fp, r9
    a504:	455b      	cmp	r3, fp
    a506:	d802      	bhi.n	a50e <grid_ui_reinit_local+0x3e>
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a508:	f108 0801 	add.w	r8, r8, #1
    a50c:	e7e5      	b.n	a4da <grid_ui_reinit_local+0xa>
			struct grid_ui_element* ele = &bank->element_list[j];
    a50e:	9b00      	ldr	r3, [sp, #0]
    a510:	68db      	ldr	r3, [r3, #12]
    a512:	2564      	movs	r5, #100	; 0x64
    a514:	fb05 350b 	mla	r5, r5, fp, r3
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a518:	f04f 0a00 	mov.w	sl, #0
    a51c:	f895 105c 	ldrb.w	r1, [r5, #92]	; 0x5c
    a520:	fa5f f38a 	uxtb.w	r3, sl
    a524:	4299      	cmp	r1, r3
    a526:	d802      	bhi.n	a52e <grid_ui_reinit_local+0x5e>
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a528:	f109 0901 	add.w	r9, r9, #1
    a52c:	e7e6      	b.n	a4fc <grid_ui_reinit_local+0x2c>
				struct grid_ui_event* eve = &ele->event_list[k];
    a52e:	6e29      	ldr	r1, [r5, #96]	; 0x60
                grid_ui_smart_trigger_local(ui, i, j, eve->type);
    a530:	4e0a      	ldr	r6, [pc, #40]	; (a55c <grid_ui_reinit_local+0x8c>)
				struct grid_ui_event* eve = &ele->event_list[k];
    a532:	22bc      	movs	r2, #188	; 0xbc
    a534:	fb02 1303 	mla	r3, r2, r3, r1
				grid_ui_event_generate_actionstring(ele, eve->type);
    a538:	9301      	str	r3, [sp, #4]
    a53a:	7a99      	ldrb	r1, [r3, #10]
    a53c:	4b08      	ldr	r3, [pc, #32]	; (a560 <grid_ui_reinit_local+0x90>)
    a53e:	4628      	mov	r0, r5
    a540:	4798      	blx	r3
	eve->trigger = GRID_UI_STATUS_READY;
    a542:	9b01      	ldr	r3, [sp, #4]
    a544:	2104      	movs	r1, #4
    a546:	7259      	strb	r1, [r3, #9]
                grid_ui_smart_trigger_local(ui, i, j, eve->type);
    a548:	465a      	mov	r2, fp
    a54a:	7a9b      	ldrb	r3, [r3, #10]
    a54c:	4639      	mov	r1, r7
    a54e:	4620      	mov	r0, r4
    a550:	47b0      	blx	r6
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a552:	f10a 0a01 	add.w	sl, sl, #1
    a556:	e7e1      	b.n	a51c <grid_ui_reinit_local+0x4c>
    a558:	2000f008 	.word	0x2000f008
    a55c:	0000a49d 	.word	0x0000a49d
    a560:	00009f59 	.word	0x00009f59

0000a564 <grid_ui_event_render_action>:
		return 0;
	}
			
}

uint32_t grid_ui_event_render_action(struct grid_ui_event* eve, uint8_t* target_string){
    a564:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a568:	f5ad 7d03 	sub.w	sp, sp, #524	; 0x20c
    a56c:	4606      	mov	r6, r0

	
	uint8_t temp[500] = {0};
    a56e:	ac05      	add	r4, sp, #20
    a570:	4b74      	ldr	r3, [pc, #464]	; (a744 <grid_ui_event_render_action+0x1e0>)
uint32_t grid_ui_event_render_action(struct grid_ui_event* eve, uint8_t* target_string){
    a572:	9102      	str	r1, [sp, #8]
	uint8_t temp[500] = {0};
    a574:	f44f 72f8 	mov.w	r2, #496	; 0x1f0
    a578:	2100      	movs	r1, #0
    a57a:	a806      	add	r0, sp, #24
    a57c:	6021      	str	r1, [r4, #0]
    a57e:	4798      	blx	r3

	uint32_t i=0;
	
	// copy event string
	for(true; i<eve->event_string_length; i++){
    a580:	68f3      	ldr	r3, [r6, #12]
    a582:	18f1      	adds	r1, r6, r3
    a584:	f106 0210 	add.w	r2, r6, #16
    a588:	4620      	mov	r0, r4
    a58a:	3110      	adds	r1, #16
    a58c:	4291      	cmp	r1, r2
    a58e:	d11e      	bne.n	a5ce <grid_ui_event_render_action+0x6a>
		temp[i] = eve->event_string[i];
	
	}

	// copy action string
	for(true; i<(eve->event_string_length + eve->action_string_length); i++){
    a590:	6b32      	ldr	r2, [r6, #48]	; 0x30
    a592:	f106 0134 	add.w	r1, r6, #52	; 0x34
    a596:	441a      	add	r2, r3
    a598:	429a      	cmp	r2, r3
    a59a:	d81d      	bhi.n	a5d8 <grid_ui_event_render_action+0x74>


	uint32_t total_substituted_length = 0;

	uint8_t condition_state = 0;
	uint8_t condition_istrue = 0;
    a59c:	2700      	movs	r7, #0
	uint8_t condition_state = 0;
    a59e:	9701      	str	r7, [sp, #4]
	uint32_t total_substituted_length = 0;
    a5a0:	463d      	mov	r5, r7
	uint32_t block_start = 0;
    a5a2:	9700      	str	r7, [sp, #0]


	for(i=0; i<(eve->event_string_length + eve->action_string_length) ; i++){
    a5a4:	463c      	mov	r4, r7
    a5a6:	68f0      	ldr	r0, [r6, #12]
    a5a8:	6b33      	ldr	r3, [r6, #48]	; 0x30
    a5aa:	4418      	add	r0, r3
    a5ac:	42a0      	cmp	r0, r4
    a5ae:	d818      	bhi.n	a5e2 <grid_ui_event_render_action+0x7e>

	}
	
	
	// RESET ENCODER RELATIVE TEMPLATE PARAMETER VALUES
	if(eve->parent->type == GRID_UI_ELEMENT_ENCODER){	
    a5b0:	6873      	ldr	r3, [r6, #4]
    a5b2:	7a5a      	ldrb	r2, [r3, #9]
    a5b4:	2a03      	cmp	r2, #3
		eve->parent->template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL] = 255;	
    a5b6:	bf08      	it	eq
    a5b8:	22ff      	moveq	r2, #255	; 0xff
    }
	
	
	return eve->event_string_length + eve->action_string_length - total_substituted_length;
		
}
    a5ba:	eba0 0005 	sub.w	r0, r0, r5
		eve->parent->template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_LOW] = 255;	
    a5be:	bf04      	itt	eq
    a5c0:	e9c3 220d 	strdeq	r2, r2, [r3, #52]	; 0x34
		eve->parent->template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_HIGH] = 255;	
    a5c4:	63da      	streq	r2, [r3, #60]	; 0x3c
}
    a5c6:	f50d 7d03 	add.w	sp, sp, #524	; 0x20c
    a5ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		temp[i] = eve->event_string[i];
    a5ce:	f812 5b01 	ldrb.w	r5, [r2], #1
    a5d2:	f800 5b01 	strb.w	r5, [r0], #1
	for(true; i<eve->event_string_length; i++){
    a5d6:	e7d9      	b.n	a58c <grid_ui_event_render_action+0x28>
		temp[i] = eve->action_string[i - eve->event_string_length];
    a5d8:	f811 0b01 	ldrb.w	r0, [r1], #1
    a5dc:	54e0      	strb	r0, [r4, r3]
	for(true; i<(eve->event_string_length + eve->action_string_length); i++){
    a5de:	3301      	adds	r3, #1
    a5e0:	e7da      	b.n	a598 <grid_ui_event_render_action+0x34>
		target_string[i-total_substituted_length] = temp[i];
    a5e2:	f10d 0914 	add.w	r9, sp, #20
    a5e6:	9a02      	ldr	r2, [sp, #8]
    a5e8:	f819 3004 	ldrb.w	r3, [r9, r4]
    a5ec:	eba4 0805 	sub.w	r8, r4, r5
		if (temp[i] == '{'){
    a5f0:	2b7b      	cmp	r3, #123	; 0x7b
		target_string[i-total_substituted_length] = temp[i];
    a5f2:	f802 3008 	strb.w	r3, [r2, r8]
		if (temp[i] == '{'){
    a5f6:	f000 80a2 	beq.w	a73e <grid_ui_event_render_action+0x1da>
		else if (temp[i] == '}'){
    a5fa:	2b7d      	cmp	r3, #125	; 0x7d
    a5fc:	f104 0a01 	add.w	sl, r4, #1
    a600:	d145      	bne.n	a68e <grid_ui_event_render_action+0x12a>
			if (block_length){
    a602:	9b00      	ldr	r3, [sp, #0]
    a604:	ebba 0b03 	subs.w	fp, sl, r3
    a608:	d030      	beq.n	a66c <grid_ui_event_render_action+0x108>
				grid_expr_set_current_event(&grid_expr_state, eve);
    a60a:	4b4f      	ldr	r3, [pc, #316]	; (a748 <grid_ui_event_render_action+0x1e4>)
    a60c:	484f      	ldr	r0, [pc, #316]	; (a74c <grid_ui_event_render_action+0x1e8>)
    a60e:	4631      	mov	r1, r6
    a610:	4798      	blx	r3
				grid_expr_evaluate(&grid_expr_state, &temp[block_start+1], block_length-2); // -2 to not include {
    a612:	9b00      	ldr	r3, [sp, #0]
    a614:	484d      	ldr	r0, [pc, #308]	; (a74c <grid_ui_event_render_action+0x1e8>)
    a616:	3301      	adds	r3, #1
    a618:	f1ab 0202 	sub.w	r2, fp, #2
    a61c:	eb09 0103 	add.w	r1, r9, r3
    a620:	b2d2      	uxtb	r2, r2
    a622:	f8df 9134 	ldr.w	r9, [pc, #308]	; a758 <grid_ui_event_render_action+0x1f4>
    a626:	9303      	str	r3, [sp, #12]
    a628:	47c8      	blx	r9
					target_string[i-total_substituted_length-block_length+1+j] = 0;	
    a62a:	9b03      	ldr	r3, [sp, #12]
				for (uint8_t j = 0; j<block_length; j++){
    a62c:	2100      	movs	r1, #0
					target_string[i-total_substituted_length-block_length+1+j] = 0;	
    a62e:	eb08 0003 	add.w	r0, r8, r3
    a632:	eba0 0e0a 	sub.w	lr, r0, sl
    a636:	468c      	mov	ip, r1
				for (uint8_t j = 0; j<block_length; j++){
    a638:	b2ca      	uxtb	r2, r1
    a63a:	4593      	cmp	fp, r2
    a63c:	f101 0101 	add.w	r1, r1, #1
    a640:	d816      	bhi.n	a670 <grid_ui_event_render_action+0x10c>
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    a642:	4498      	add	r8, r3
    a644:	9b02      	ldr	r3, [sp, #8]
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    a646:	4a41      	ldr	r2, [pc, #260]	; (a74c <grid_ui_event_render_action+0x1e8>)
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    a648:	eba8 0a0a 	sub.w	sl, r8, sl
    a64c:	2000      	movs	r0, #0
    a64e:	449a      	add	sl, r3
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    a650:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
    a654:	b2c1      	uxtb	r1, r0
    a656:	428b      	cmp	r3, r1
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    a658:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    a65c:	d80d      	bhi.n	a67a <grid_ui_event_render_action+0x116>
				total_substituted_length += block_length - grid_expr_state.output_string_length;
    a65e:	1aed      	subs	r5, r5, r3
				if (condition_state == 1){
    a660:	9b01      	ldr	r3, [sp, #4]
				total_substituted_length += block_length - grid_expr_state.output_string_length;
    a662:	445d      	add	r5, fp
				if (condition_state == 1){
    a664:	b113      	cbz	r3, a66c <grid_ui_event_render_action+0x108>
					condition_istrue = grid_expr_state.return_value;
    a666:	f8d2 71fc 	ldr.w	r7, [r2, #508]	; 0x1fc
    a66a:	b2ff      	uxtb	r7, r7
	for(i=0; i<(eve->event_string_length + eve->action_string_length) ; i++){
    a66c:	3401      	adds	r4, #1
    a66e:	e79a      	b.n	a5a6 <grid_ui_event_render_action+0x42>
					target_string[i-total_substituted_length-block_length+1+j] = 0;	
    a670:	9802      	ldr	r0, [sp, #8]
    a672:	4402      	add	r2, r0
    a674:	f802 c00e 	strb.w	ip, [r2, lr]
				for (uint8_t j = 0; j<block_length; j++){
    a678:	e7de      	b.n	a638 <grid_ui_event_render_action+0xd4>
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    a67a:	f1c3 03fa 	rsb	r3, r3, #250	; 0xfa
    a67e:	440b      	add	r3, r1
    a680:	4413      	add	r3, r2
    a682:	3001      	adds	r0, #1
    a684:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
    a688:	f80a 3001 	strb.w	r3, [sl, r1]
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    a68c:	e7e0      	b.n	a650 <grid_ui_event_render_action+0xec>
		else if(temp[i] == '#'){
    a68e:	2b23      	cmp	r3, #35	; 0x23
    a690:	d1ec      	bne.n	a66c <grid_ui_event_render_action+0x108>
			if (temp[i+1] == 'I' && temp[i+2] == 'F' ){
    a692:	f819 300a 	ldrb.w	r3, [r9, sl]
    a696:	2b49      	cmp	r3, #73	; 0x49
    a698:	d109      	bne.n	a6ae <grid_ui_event_render_action+0x14a>
    a69a:	1ca3      	adds	r3, r4, #2
    a69c:	f819 2003 	ldrb.w	r2, [r9, r3]
    a6a0:	2a46      	cmp	r2, #70	; 0x46
    a6a2:	d1e3      	bne.n	a66c <grid_ui_event_render_action+0x108>
				i+=2;
    a6a4:	461c      	mov	r4, r3
				condition_state = 1;
    a6a6:	2301      	movs	r3, #1
				total_substituted_length += 3;
    a6a8:	3503      	adds	r5, #3
				condition_state = 1;
    a6aa:	9301      	str	r3, [sp, #4]
    a6ac:	e7de      	b.n	a66c <grid_ui_event_render_action+0x108>
			}else if (temp[i+1] == 'T' && temp[i+2] == 'H' ){
    a6ae:	2b54      	cmp	r3, #84	; 0x54
    a6b0:	d121      	bne.n	a6f6 <grid_ui_event_render_action+0x192>
    a6b2:	1ca3      	adds	r3, r4, #2
    a6b4:	f819 2003 	ldrb.w	r2, [r9, r3]
    a6b8:	2a48      	cmp	r2, #72	; 0x48
    a6ba:	d1d7      	bne.n	a66c <grid_ui_event_render_action+0x108>
				if (!condition_istrue){
    a6bc:	bbaf      	cbnz	r7, a72a <grid_ui_event_render_action+0x1c6>
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    a6be:	f04f 0801 	mov.w	r8, #1
    a6c2:	e009      	b.n	a6d8 <grid_ui_event_render_action+0x174>
						else if(j==(eve->event_string_length + eve->action_string_length)-i-1){
    a6c4:	3b01      	subs	r3, #1
    a6c6:	4543      	cmp	r3, r8
    a6c8:	d102      	bne.n	a6d0 <grid_ui_event_render_action+0x16c>
							printf("Syntax Error!\r\n");
    a6ca:	4821      	ldr	r0, [pc, #132]	; (a750 <grid_ui_event_render_action+0x1ec>)
    a6cc:	4b21      	ldr	r3, [pc, #132]	; (a754 <grid_ui_event_render_action+0x1f0>)
    a6ce:	4798      	blx	r3
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    a6d0:	f108 0801 	add.w	r8, r8, #1
    a6d4:	fa5f f888 	uxtb.w	r8, r8
    a6d8:	68f3      	ldr	r3, [r6, #12]
    a6da:	6b32      	ldr	r2, [r6, #48]	; 0x30
    a6dc:	4413      	add	r3, r2
    a6de:	1b1b      	subs	r3, r3, r4
    a6e0:	4598      	cmp	r8, r3
    a6e2:	d2c3      	bcs.n	a66c <grid_ui_event_render_action+0x108>
						if (temp[i+j] == '#'){
    a6e4:	eb08 0204 	add.w	r2, r8, r4
    a6e8:	f819 1002 	ldrb.w	r1, [r9, r2]
    a6ec:	2923      	cmp	r1, #35	; 0x23
    a6ee:	d1e9      	bne.n	a6c4 <grid_ui_event_render_action+0x160>
							total_substituted_length += j;
    a6f0:	4445      	add	r5, r8
							i+=j-1;
    a6f2:	1e54      	subs	r4, r2, #1
							break;
    a6f4:	e7ba      	b.n	a66c <grid_ui_event_render_action+0x108>
			}else if (temp[i+1] == 'E' && temp[i+2] == 'L' ){
    a6f6:	2b45      	cmp	r3, #69	; 0x45
    a6f8:	d1b8      	bne.n	a66c <grid_ui_event_render_action+0x108>
    a6fa:	1ca3      	adds	r3, r4, #2
    a6fc:	f819 2003 	ldrb.w	r2, [r9, r3]
    a700:	2a4c      	cmp	r2, #76	; 0x4c
    a702:	d115      	bne.n	a730 <grid_ui_event_render_action+0x1cc>
				if (condition_istrue){
    a704:	b18f      	cbz	r7, a72a <grid_ui_event_render_action+0x1c6>
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    a706:	6b32      	ldr	r2, [r6, #48]	; 0x30
    a708:	68f3      	ldr	r3, [r6, #12]
    a70a:	4413      	add	r3, r2
    a70c:	1b1a      	subs	r2, r3, r4
    a70e:	2301      	movs	r3, #1
    a710:	4293      	cmp	r3, r2
    a712:	d2ab      	bcs.n	a66c <grid_ui_event_render_action+0x108>
						if (temp[i+j] == '#'){
    a714:	1919      	adds	r1, r3, r4
    a716:	f819 0001 	ldrb.w	r0, [r9, r1]
    a71a:	2823      	cmp	r0, #35	; 0x23
    a71c:	d102      	bne.n	a724 <grid_ui_event_render_action+0x1c0>
							total_substituted_length += j;
    a71e:	441d      	add	r5, r3
							i+=j-1;
    a720:	1e4c      	subs	r4, r1, #1
							break;
    a722:	e7a3      	b.n	a66c <grid_ui_event_render_action+0x108>
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    a724:	3301      	adds	r3, #1
    a726:	b2db      	uxtb	r3, r3
    a728:	e7f2      	b.n	a710 <grid_ui_event_render_action+0x1ac>
					total_substituted_length += 3;
    a72a:	3503      	adds	r5, #3
					i+=2;
    a72c:	461c      	mov	r4, r3
    a72e:	e79d      	b.n	a66c <grid_ui_event_render_action+0x108>
			}else if (temp[i+1] == 'E' && temp[i+2] == 'N' ){
    a730:	2a4e      	cmp	r2, #78	; 0x4e
    a732:	d19b      	bne.n	a66c <grid_ui_event_render_action+0x108>
				condition_istrue = 0;
    a734:	2700      	movs	r7, #0
				total_substituted_length += 3;
    a736:	3503      	adds	r5, #3
				i+=2;
    a738:	461c      	mov	r4, r3
				condition_state = 0;
    a73a:	9701      	str	r7, [sp, #4]
    a73c:	e796      	b.n	a66c <grid_ui_event_render_action+0x108>
    a73e:	9400      	str	r4, [sp, #0]
    a740:	e794      	b.n	a66c <grid_ui_event_render_action+0x108>
    a742:	bf00      	nop
    a744:	000142f1 	.word	0x000142f1
    a748:	000063c9 	.word	0x000063c9
    a74c:	20013220 	.word	0x20013220
    a750:	000160ad 	.word	0x000160ad
    a754:	0001455d 	.word	0x0001455d
    a758:	00006b59 	.word	0x00006b59

0000a75c <grid_port_process_ui>:
void grid_port_process_ui(struct grid_port* por){
    a75c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    a760:	4fb1      	ldr	r7, [pc, #708]	; (aa28 <grid_port_process_ui+0x2cc>)
void grid_port_process_ui(struct grid_port* por){
    a762:	f5ad 7d57 	sub.w	sp, sp, #860	; 0x35c
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    a766:	2100      	movs	r1, #0
void grid_port_process_ui(struct grid_port* por){
    a768:	9001      	str	r0, [sp, #4]
	uint8_t message_local_action_available = 0;
    a76a:	4688      	mov	r8, r1
	uint8_t message_broadcast_action_available = 0;
    a76c:	460d      	mov	r5, r1
    a76e:	46ba      	mov	sl, r7
			for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    a770:	f04f 0c64 	mov.w	ip, #100	; 0x64
				if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a774:	f04f 0ebc 	mov.w	lr, #188	; 0xbc
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    a778:	787a      	ldrb	r2, [r7, #1]
    a77a:	b2cb      	uxtb	r3, r1
    a77c:	429a      	cmp	r2, r3
    a77e:	d95e      	bls.n	a83e <grid_port_process_ui+0xe2>
		for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    a780:	011b      	lsls	r3, r3, #4
    a782:	2400      	movs	r4, #0
    a784:	e02e      	b.n	a7e4 <grid_port_process_ui+0x88>
				if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a786:	f8da 9004 	ldr.w	r9, [sl, #4]
    a78a:	4499      	add	r9, r3
    a78c:	fb0e f000 	mul.w	r0, lr, r0
    a790:	f8d9 900c 	ldr.w	r9, [r9, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    a794:	4491      	add	r9, r2
    a796:	3601      	adds	r6, #1
    a798:	f8d9 9060 	ldr.w	r9, [r9, #96]	; 0x60
    a79c:	4481      	add	r9, r0
    a79e:	f899 9009 	ldrb.w	r9, [r9, #9]
    a7a2:	f1b9 0f05 	cmp.w	r9, #5
				if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a7a6:	f8da 9004 	ldr.w	r9, [sl, #4]
    a7aa:	4499      	add	r9, r3
					message_broadcast_action_available++;
    a7ac:	bf08      	it	eq
    a7ae:	3501      	addeq	r5, #1
				if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a7b0:	f8d9 900c 	ldr.w	r9, [r9, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    a7b4:	4491      	add	r9, r2
					message_broadcast_action_available++;
    a7b6:	bf08      	it	eq
    a7b8:	b2ed      	uxtbeq	r5, r5
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    a7ba:	f8d9 9060 	ldr.w	r9, [r9, #96]	; 0x60
    a7be:	4448      	add	r0, r9
    a7c0:	7a40      	ldrb	r0, [r0, #9]
    a7c2:	2806      	cmp	r0, #6
                    message_local_action_available++;
    a7c4:	bf04      	itt	eq
    a7c6:	f108 0801 	addeq.w	r8, r8, #1
    a7ca:	fa5f f888 	uxtbeq.w	r8, r8
			for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    a7ce:	f8da 0004 	ldr.w	r0, [sl, #4]
    a7d2:	4418      	add	r0, r3
    a7d4:	68c0      	ldr	r0, [r0, #12]
    a7d6:	4410      	add	r0, r2
    a7d8:	f890 905c 	ldrb.w	r9, [r0, #92]	; 0x5c
    a7dc:	b2f0      	uxtb	r0, r6
    a7de:	4581      	cmp	r9, r0
    a7e0:	d8d1      	bhi.n	a786 <grid_port_process_ui+0x2a>
		for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    a7e2:	3401      	adds	r4, #1
    a7e4:	f8da 2004 	ldr.w	r2, [sl, #4]
    a7e8:	441a      	add	r2, r3
    a7ea:	7a50      	ldrb	r0, [r2, #9]
    a7ec:	b2e2      	uxtb	r2, r4
    a7ee:	4290      	cmp	r0, r2
    a7f0:	d903      	bls.n	a7fa <grid_port_process_ui+0x9e>
			for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    a7f2:	fb0c f202 	mul.w	r2, ip, r2
    a7f6:	2600      	movs	r6, #0
    a7f8:	e7e9      	b.n	a7ce <grid_port_process_ui+0x72>
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    a7fa:	3101      	adds	r1, #1
    a7fc:	e7bc      	b.n	a778 <grid_port_process_ui+0x1c>
			if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    a7fe:	6870      	ldr	r0, [r6, #4]
    a800:	68c0      	ldr	r0, [r0, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    a802:	eb00 0e03 	add.w	lr, r0, r3
    a806:	3201      	adds	r2, #1
    a808:	f8de 0060 	ldr.w	r0, [lr, #96]	; 0x60
    a80c:	fb0c 0009 	mla	r0, ip, r9, r0
    a810:	7a40      	ldrb	r0, [r0, #9]
    a812:	2805      	cmp	r0, #5
				message_broadcast_action_available++;
    a814:	bf04      	itt	eq
    a816:	3501      	addeq	r5, #1
    a818:	b2ed      	uxtbeq	r5, r5
		for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    a81a:	6870      	ldr	r0, [r6, #4]
    a81c:	68c0      	ldr	r0, [r0, #12]
    a81e:	4418      	add	r0, r3
    a820:	fa5f f982 	uxtb.w	r9, r2
    a824:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
    a828:	4548      	cmp	r0, r9
    a82a:	d8e8      	bhi.n	a7fe <grid_port_process_ui+0xa2>
	for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    a82c:	3101      	adds	r1, #1
    a82e:	6863      	ldr	r3, [r4, #4]
    a830:	7a5a      	ldrb	r2, [r3, #9]
    a832:	b2cb      	uxtb	r3, r1
    a834:	429a      	cmp	r2, r3
    a836:	d909      	bls.n	a84c <grid_port_process_ui+0xf0>
		for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    a838:	437b      	muls	r3, r7
    a83a:	2200      	movs	r2, #0
    a83c:	e7ed      	b.n	a81a <grid_port_process_ui+0xbe>
	for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    a83e:	4c7b      	ldr	r4, [pc, #492]	; (aa2c <grid_port_process_ui+0x2d0>)
    a840:	2100      	movs	r1, #0
    a842:	4626      	mov	r6, r4
		for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    a844:	2764      	movs	r7, #100	; 0x64
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    a846:	f04f 0cbc 	mov.w	ip, #188	; 0xbc
    a84a:	e7f0      	b.n	a82e <grid_port_process_ui+0xd2>
	struct grid_port* port[4] = {&GRID_PORT_N, &GRID_PORT_E, &GRID_PORT_S, &GRID_PORT_W};
    a84c:	4b78      	ldr	r3, [pc, #480]	; (aa30 <grid_port_process_ui+0x2d4>)
    a84e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    a850:	ae07      	add	r6, sp, #28
    a852:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
    a856:	2404      	movs	r4, #4
		if (port[k]->ping_flag == 1){
    a858:	f856 7b04 	ldr.w	r7, [r6], #4
    a85c:	f642 7348 	movw	r3, #12104	; 0x2f48
    a860:	5cfb      	ldrb	r3, [r7, r3]
    a862:	2b01      	cmp	r3, #1
    a864:	d11f      	bne.n	a8a6 <grid_port_process_ui+0x14a>
			if (grid_buffer_write_init(&port[k]->tx_buffer, port[k]->ping_packet_length)){
    a866:	f642 7347 	movw	r3, #12103	; 0x2f47
    a86a:	f507 591c 	add.w	r9, r7, #9984	; 0x2700
    a86e:	f109 093c 	add.w	r9, r9, #60	; 0x3c
    a872:	18fa      	adds	r2, r7, r3
    a874:	5cf9      	ldrb	r1, [r7, r3]
    a876:	4b6f      	ldr	r3, [pc, #444]	; (aa34 <grid_port_process_ui+0x2d8>)
    a878:	9202      	str	r2, [sp, #8]
    a87a:	4648      	mov	r0, r9
    a87c:	4798      	blx	r3
    a87e:	b170      	cbz	r0, a89e <grid_port_process_ui+0x142>
				for(uint32_t i = 0; i<port[k]->ping_packet_length; i++){
    a880:	4b6d      	ldr	r3, [pc, #436]	; (aa38 <grid_port_process_ui+0x2dc>)
    a882:	f507 5b3c 	add.w	fp, r7, #12032	; 0x2f00
    a886:	f10b 0b33 	add.w	fp, fp, #51	; 0x33
    a88a:	1bdb      	subs	r3, r3, r7
    a88c:	9a02      	ldr	r2, [sp, #8]
    a88e:	7811      	ldrb	r1, [r2, #0]
    a890:	eb03 020b 	add.w	r2, r3, fp
    a894:	4291      	cmp	r1, r2
    a896:	d826      	bhi.n	a8e6 <grid_port_process_ui+0x18a>
				grid_buffer_write_acknowledge(&port[k]->tx_buffer);
    a898:	4b68      	ldr	r3, [pc, #416]	; (aa3c <grid_port_process_ui+0x2e0>)
    a89a:	4648      	mov	r0, r9
    a89c:	4798      	blx	r3
			port[k]->ping_flag = 0;
    a89e:	f642 7248 	movw	r2, #12104	; 0x2f48
    a8a2:	2300      	movs	r3, #0
    a8a4:	54bb      	strb	r3, [r7, r2]
	for (uint8_t k = 0; k<4; k++){
    a8a6:	3c01      	subs	r4, #1
    a8a8:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
    a8ac:	d1d4      	bne.n	a858 <grid_port_process_ui+0xfc>
	if (message_local_action_available){
    a8ae:	f1b8 0f00 	cmp.w	r8, #0
    a8b2:	d07e      	beq.n	a9b2 <grid_port_process_ui+0x256>
		grid_msg_init(&message);
    a8b4:	4b62      	ldr	r3, [pc, #392]	; (aa40 <grid_port_process_ui+0x2e4>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a8b6:	4e63      	ldr	r6, [pc, #396]	; (aa44 <grid_port_process_ui+0x2e8>)
		grid_msg_init(&message);
    a8b8:	a86f      	add	r0, sp, #444	; 0x1bc
    a8ba:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a8bc:	227f      	movs	r2, #127	; 0x7f
    a8be:	4611      	mov	r1, r2
    a8c0:	4623      	mov	r3, r4
    a8c2:	a86f      	add	r0, sp, #444	; 0x1bc
    a8c4:	47b0      	blx	r6
		uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};				
    a8c6:	4b60      	ldr	r3, [pc, #384]	; (aa48 <grid_port_process_ui+0x2ec>)
    a8c8:	940b      	str	r4, [sp, #44]	; 0x2c
    a8ca:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    a8ce:	4621      	mov	r1, r4
    a8d0:	a80c      	add	r0, sp, #48	; 0x30
    a8d2:	4798      	blx	r3
		uint32_t offset=0;
    a8d4:	46a0      	mov	r8, r4
		for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++)
    a8d6:	f89a 3001 	ldrb.w	r3, [sl, #1]
    a8da:	b2e6      	uxtb	r6, r4
    a8dc:	42b3      	cmp	r3, r6
    a8de:	d956      	bls.n	a98e <grid_port_process_ui+0x232>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    a8e0:	0136      	lsls	r6, r6, #4
    a8e2:	2300      	movs	r3, #0
    a8e4:	e043      	b.n	a96e <grid_port_process_ui+0x212>
    a8e6:	9303      	str	r3, [sp, #12]
					grid_buffer_write_character(&port[k]->tx_buffer, port[k]->ping_packet[i]);
    a8e8:	f81b 1b01 	ldrb.w	r1, [fp], #1
    a8ec:	4b57      	ldr	r3, [pc, #348]	; (aa4c <grid_port_process_ui+0x2f0>)
    a8ee:	4648      	mov	r0, r9
    a8f0:	4798      	blx	r3
    a8f2:	9b03      	ldr	r3, [sp, #12]
				for(uint32_t i = 0; i<port[k]->ping_packet_length; i++){
    a8f4:	e7ca      	b.n	a88c <grid_port_process_ui+0x130>
					if (offset>GRID_PARAMETER_PACKET_marign){
    a8f6:	f1b8 0fc8 	cmp.w	r8, #200	; 0xc8
    a8fa:	d829      	bhi.n	a950 <grid_port_process_ui+0x1f4>
						CRITICAL_SECTION_ENTER()
    a8fc:	4b54      	ldr	r3, [pc, #336]	; (aa50 <grid_port_process_ui+0x2f4>)
    a8fe:	a805      	add	r0, sp, #20
    a900:	4798      	blx	r3
						if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a902:	f8da 3004 	ldr.w	r3, [sl, #4]
    a906:	4433      	add	r3, r6
    a908:	22bc      	movs	r2, #188	; 0xbc
    a90a:	68db      	ldr	r3, [r3, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    a90c:	443b      	add	r3, r7
						if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a90e:	fb02 fb0b 	mul.w	fp, r2, fp
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    a912:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    a914:	445b      	add	r3, fp
    a916:	7a5b      	ldrb	r3, [r3, #9]
    a918:	2b06      	cmp	r3, #6
    a91a:	d116      	bne.n	a94a <grid_port_process_ui+0x1ee>
                            offset += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &payload[offset]);
    a91c:	f8da 3004 	ldr.w	r3, [sl, #4]
    a920:	4433      	add	r3, r6
    a922:	68db      	ldr	r3, [r3, #12]
    a924:	443b      	add	r3, r7
    a926:	6e18      	ldr	r0, [r3, #96]	; 0x60
    a928:	ab0b      	add	r3, sp, #44	; 0x2c
    a92a:	eb03 0108 	add.w	r1, r3, r8
    a92e:	4458      	add	r0, fp
    a930:	4b48      	ldr	r3, [pc, #288]	; (aa54 <grid_port_process_ui+0x2f8>)
    a932:	4798      	blx	r3
                            grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    a934:	f8da 3004 	ldr.w	r3, [sl, #4]
    a938:	4433      	add	r3, r6
                            offset += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &payload[offset]);
    a93a:	4480      	add	r8, r0
                            grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    a93c:	68db      	ldr	r3, [r3, #12]
	eve->trigger = GRID_UI_STATUS_READY;
    a93e:	443b      	add	r3, r7
    a940:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    a942:	449b      	add	fp, r3
    a944:	2304      	movs	r3, #4
    a946:	f88b 3009 	strb.w	r3, [fp, #9]
						CRITICAL_SECTION_LEAVE()
    a94a:	4b43      	ldr	r3, [pc, #268]	; (aa58 <grid_port_process_ui+0x2fc>)
    a94c:	a805      	add	r0, sp, #20
    a94e:	4798      	blx	r3
                for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    a950:	f109 0901 	add.w	r9, r9, #1
    a954:	f8da 3004 	ldr.w	r3, [sl, #4]
    a958:	4433      	add	r3, r6
    a95a:	fa5f fb89 	uxtb.w	fp, r9
    a95e:	68db      	ldr	r3, [r3, #12]
    a960:	443b      	add	r3, r7
    a962:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    a966:	455b      	cmp	r3, fp
    a968:	d8c5      	bhi.n	a8f6 <grid_port_process_ui+0x19a>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    a96a:	9b02      	ldr	r3, [sp, #8]
    a96c:	3301      	adds	r3, #1
    a96e:	9302      	str	r3, [sp, #8]
    a970:	f8da 3004 	ldr.w	r3, [sl, #4]
    a974:	4433      	add	r3, r6
    a976:	7a5a      	ldrb	r2, [r3, #9]
    a978:	f89d 3008 	ldrb.w	r3, [sp, #8]
    a97c:	429a      	cmp	r2, r3
    a97e:	d904      	bls.n	a98a <grid_port_process_ui+0x22e>
                for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    a980:	2764      	movs	r7, #100	; 0x64
    a982:	435f      	muls	r7, r3
    a984:	f04f 0900 	mov.w	r9, #0
    a988:	e7e4      	b.n	a954 <grid_port_process_ui+0x1f8>
		for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++)
    a98a:	3401      	adds	r4, #1
    a98c:	e7a3      	b.n	a8d6 <grid_port_process_ui+0x17a>
		grid_msg_body_append_text(&message, payload, offset);
    a98e:	a90b      	add	r1, sp, #44	; 0x2c
    a990:	4642      	mov	r2, r8
    a992:	4b32      	ldr	r3, [pc, #200]	; (aa5c <grid_port_process_ui+0x300>)
    a994:	a86f      	add	r0, sp, #444	; 0x1bc
    a996:	4798      	blx	r3
		grid_msg_packet_close(&message);
    a998:	4b31      	ldr	r3, [pc, #196]	; (aa60 <grid_port_process_ui+0x304>)
    a99a:	a86f      	add	r0, sp, #444	; 0x1bc
    a99c:	4798      	blx	r3
		uint32_t message_length = grid_msg_packet_get_length(&message);
    a99e:	4b31      	ldr	r3, [pc, #196]	; (aa64 <grid_port_process_ui+0x308>)
    a9a0:	a86f      	add	r0, sp, #444	; 0x1bc
    a9a2:	4798      	blx	r3
		if (grid_buffer_write_init(&GRID_PORT_U.tx_buffer, message_length)){
    a9a4:	4b23      	ldr	r3, [pc, #140]	; (aa34 <grid_port_process_ui+0x2d8>)
		uint32_t message_length = grid_msg_packet_get_length(&message);
    a9a6:	4604      	mov	r4, r0
		if (grid_buffer_write_init(&GRID_PORT_U.tx_buffer, message_length)){
    a9a8:	b281      	uxth	r1, r0
    a9aa:	482f      	ldr	r0, [pc, #188]	; (aa68 <grid_port_process_ui+0x30c>)
    a9ac:	4798      	blx	r3
    a9ae:	2800      	cmp	r0, #0
    a9b0:	d132      	bne.n	aa18 <grid_port_process_ui+0x2bc>
	if (por->cooldown > 0){
    a9b2:	9b01      	ldr	r3, [sp, #4]
    a9b4:	681b      	ldr	r3, [r3, #0]
    a9b6:	b12b      	cbz	r3, a9c4 <grid_port_process_ui+0x268>
		por->cooldown--;
    a9b8:	3b01      	subs	r3, #1
    a9ba:	9a01      	ldr	r2, [sp, #4]
	if (por->cooldown > 10){
    a9bc:	2b0a      	cmp	r3, #10
		por->cooldown--;
    a9be:	6013      	str	r3, [r2, #0]
	if (por->cooldown > 10){
    a9c0:	f200 80fc 	bhi.w	abbc <grid_port_process_ui+0x460>
	if (message_broadcast_action_available){
    a9c4:	2d00      	cmp	r5, #0
    a9c6:	f000 80f9 	beq.w	abbc <grid_port_process_ui+0x460>
		grid_msg_init(&message);
    a9ca:	4b1d      	ldr	r3, [pc, #116]	; (aa40 <grid_port_process_ui+0x2e4>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a9cc:	4c1d      	ldr	r4, [pc, #116]	; (aa44 <grid_port_process_ui+0x2e8>)
		for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    a9ce:	f8df 805c 	ldr.w	r8, [pc, #92]	; aa2c <grid_port_process_ui+0x2d0>
		grid_msg_init(&message);
    a9d2:	a86f      	add	r0, sp, #444	; 0x1bc
    a9d4:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a9d6:	227f      	movs	r2, #127	; 0x7f
    a9d8:	2300      	movs	r3, #0
    a9da:	4611      	mov	r1, r2
    a9dc:	a86f      	add	r0, sp, #444	; 0x1bc
    a9de:	47a0      	blx	r4
		for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    a9e0:	2700      	movs	r7, #0
    a9e2:	4645      	mov	r5, r8
    a9e4:	f8d8 3004 	ldr.w	r3, [r8, #4]
    a9e8:	7a5a      	ldrb	r2, [r3, #9]
    a9ea:	b2fb      	uxtb	r3, r7
    a9ec:	429a      	cmp	r2, r3
    a9ee:	f240 80d2 	bls.w	ab96 <grid_port_process_ui+0x43a>
			for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    a9f2:	2464      	movs	r4, #100	; 0x64
					CRITICAL_SECTION_LEAVE()
    a9f4:	f8df b060 	ldr.w	fp, [pc, #96]	; aa58 <grid_port_process_ui+0x2fc>
			for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    a9f8:	435c      	muls	r4, r3
    a9fa:	2600      	movs	r6, #0
    a9fc:	e067      	b.n	aace <grid_port_process_ui+0x372>
				grid_buffer_write_character(&GRID_PORT_U.tx_buffer, grid_msg_packet_send_char(&message, i));
    a9fe:	4631      	mov	r1, r6
    aa00:	a86f      	add	r0, sp, #444	; 0x1bc
    aa02:	47b8      	blx	r7
    aa04:	4601      	mov	r1, r0
    aa06:	4640      	mov	r0, r8
    aa08:	47c8      	blx	r9
			for(uint32_t i = 0; i<message_length; i++){
    aa0a:	3601      	adds	r6, #1
    aa0c:	42a6      	cmp	r6, r4
    aa0e:	d1f6      	bne.n	a9fe <grid_port_process_ui+0x2a2>
			grid_buffer_write_acknowledge(&GRID_PORT_U.tx_buffer);
    aa10:	4b0a      	ldr	r3, [pc, #40]	; (aa3c <grid_port_process_ui+0x2e0>)
    aa12:	4815      	ldr	r0, [pc, #84]	; (aa68 <grid_port_process_ui+0x30c>)
    aa14:	4798      	blx	r3
		}
    aa16:	e7cc      	b.n	a9b2 <grid_port_process_ui+0x256>
				grid_buffer_write_character(&GRID_PORT_U.tx_buffer, grid_msg_packet_send_char(&message, i));
    aa18:	4f14      	ldr	r7, [pc, #80]	; (aa6c <grid_port_process_ui+0x310>)
    aa1a:	f8df 804c 	ldr.w	r8, [pc, #76]	; aa68 <grid_port_process_ui+0x30c>
    aa1e:	f8df 902c 	ldr.w	r9, [pc, #44]	; aa4c <grid_port_process_ui+0x2f0>
			for(uint32_t i = 0; i<message_length; i++){
    aa22:	2600      	movs	r6, #0
    aa24:	e7f2      	b.n	aa0c <grid_port_process_ui+0x2b0>
    aa26:	bf00      	nop
    aa28:	2000effc 	.word	0x2000effc
    aa2c:	2001c7c0 	.word	0x2001c7c0
    aa30:	000160bc 	.word	0x000160bc
    aa34:	000047f1 	.word	0x000047f1
    aa38:	ffffd0cd 	.word	0xffffd0cd
    aa3c:	0000484d 	.word	0x0000484d
    aa40:	0000857d 	.word	0x0000857d
    aa44:	000085b1 	.word	0x000085b1
    aa48:	000142f1 	.word	0x000142f1
    aa4c:	0000482d 	.word	0x0000482d
    aa50:	00011b09 	.word	0x00011b09
    aa54:	0000a565 	.word	0x0000a565
    aa58:	00011b17 	.word	0x00011b17
    aa5c:	000084ed 	.word	0x000084ed
    aa60:	000086a9 	.word	0x000086a9
    aa64:	000084d9 	.word	0x000084d9
    aa68:	2000e7ec 	.word	0x2000e7ec
    aa6c:	00008673 	.word	0x00008673
				if (grid_msg_packet_get_length(&message)>GRID_PARAMETER_PACKET_marign){
    aa70:	4b5e      	ldr	r3, [pc, #376]	; (abec <grid_port_process_ui+0x490>)
    aa72:	a86f      	add	r0, sp, #444	; 0x1bc
    aa74:	4798      	blx	r3
    aa76:	28c8      	cmp	r0, #200	; 0xc8
    aa78:	d828      	bhi.n	aacc <grid_port_process_ui+0x370>
					CRITICAL_SECTION_ENTER()
    aa7a:	4b5d      	ldr	r3, [pc, #372]	; (abf0 <grid_port_process_ui+0x494>)
    aa7c:	a806      	add	r0, sp, #24
    aa7e:	4798      	blx	r3
					if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    aa80:	686b      	ldr	r3, [r5, #4]
    aa82:	68db      	ldr	r3, [r3, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    aa84:	4423      	add	r3, r4
					if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    aa86:	22bc      	movs	r2, #188	; 0xbc
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    aa88:	6e1b      	ldr	r3, [r3, #96]	; 0x60
					if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    aa8a:	fb02 f909 	mul.w	r9, r2, r9
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    aa8e:	444b      	add	r3, r9
    aa90:	7a5b      	ldrb	r3, [r3, #9]
    aa92:	2b05      	cmp	r3, #5
    aa94:	d118      	bne.n	aac8 <grid_port_process_ui+0x36c>
						uint32_t offset = grid_msg_body_get_length(&message); 
    aa96:	4b57      	ldr	r3, [pc, #348]	; (abf4 <grid_port_process_ui+0x498>)
    aa98:	a86f      	add	r0, sp, #444	; 0x1bc
    aa9a:	4798      	blx	r3
						message.body_length += grid_ui_event_render_action(&grid_core_state.bank_list[0].element_list[i].event_list[j], &message.body[offset]);
    aa9c:	686b      	ldr	r3, [r5, #4]
    aa9e:	68db      	ldr	r3, [r3, #12]
    aaa0:	4423      	add	r3, r4
    aaa2:	3014      	adds	r0, #20
    aaa4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    aaa6:	aa6f      	add	r2, sp, #444	; 0x1bc
    aaa8:	1811      	adds	r1, r2, r0
    aaaa:	eb03 0009 	add.w	r0, r3, r9
    aaae:	4b52      	ldr	r3, [pc, #328]	; (abf8 <grid_port_process_ui+0x49c>)
    aab0:	4798      	blx	r3
    aab2:	9bd4      	ldr	r3, [sp, #848]	; 0x350
    aab4:	4418      	add	r0, r3
						grid_ui_event_reset(&grid_core_state.bank_list[0].element_list[i].event_list[j]);
    aab6:	686b      	ldr	r3, [r5, #4]
						message.body_length += grid_ui_event_render_action(&grid_core_state.bank_list[0].element_list[i].event_list[j], &message.body[offset]);
    aab8:	90d4      	str	r0, [sp, #848]	; 0x350
						grid_ui_event_reset(&grid_core_state.bank_list[0].element_list[i].event_list[j]);
    aaba:	68db      	ldr	r3, [r3, #12]
	eve->trigger = GRID_UI_STATUS_READY;
    aabc:	4423      	add	r3, r4
    aabe:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    aac0:	4499      	add	r9, r3
    aac2:	2304      	movs	r3, #4
    aac4:	f889 3009 	strb.w	r3, [r9, #9]
					CRITICAL_SECTION_LEAVE()
    aac8:	a806      	add	r0, sp, #24
    aaca:	47d8      	blx	fp
			for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    aacc:	3601      	adds	r6, #1
    aace:	686b      	ldr	r3, [r5, #4]
    aad0:	68db      	ldr	r3, [r3, #12]
    aad2:	4423      	add	r3, r4
    aad4:	fa5f f986 	uxtb.w	r9, r6
    aad8:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    aadc:	454b      	cmp	r3, r9
    aade:	d8c7      	bhi.n	aa70 <grid_port_process_ui+0x314>
		for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    aae0:	3701      	adds	r7, #1
    aae2:	e77f      	b.n	a9e4 <grid_port_process_ui+0x288>
					if (grid_msg_packet_get_length(&message)>GRID_PARAMETER_PACKET_marign){
    aae4:	4b41      	ldr	r3, [pc, #260]	; (abec <grid_port_process_ui+0x490>)
    aae6:	a86f      	add	r0, sp, #444	; 0x1bc
    aae8:	4798      	blx	r3
    aaea:	28c8      	cmp	r0, #200	; 0xc8
    aaec:	d82e      	bhi.n	ab4c <grid_port_process_ui+0x3f0>
						CRITICAL_SECTION_ENTER()
    aaee:	4b40      	ldr	r3, [pc, #256]	; (abf0 <grid_port_process_ui+0x494>)
    aaf0:	a80b      	add	r0, sp, #44	; 0x2c
    aaf2:	4798      	blx	r3
						if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    aaf4:	f8da 3004 	ldr.w	r3, [sl, #4]
    aaf8:	4423      	add	r3, r4
    aafa:	22bc      	movs	r2, #188	; 0xbc
    aafc:	68db      	ldr	r3, [r3, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    aafe:	442b      	add	r3, r5
						if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    ab00:	fb02 f909 	mul.w	r9, r2, r9
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    ab04:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ab06:	444b      	add	r3, r9
    ab08:	7a5b      	ldrb	r3, [r3, #9]
    ab0a:	2b05      	cmp	r3, #5
    ab0c:	d11c      	bne.n	ab48 <grid_port_process_ui+0x3ec>
							uint32_t offset = grid_msg_body_get_length(&message); 
    ab0e:	4b39      	ldr	r3, [pc, #228]	; (abf4 <grid_port_process_ui+0x498>)
    ab10:	a86f      	add	r0, sp, #444	; 0x1bc
    ab12:	4798      	blx	r3
							message.body_length += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &message.body[offset]);
    ab14:	f8da 3004 	ldr.w	r3, [sl, #4]
    ab18:	4423      	add	r3, r4
    ab1a:	3014      	adds	r0, #20
    ab1c:	68db      	ldr	r3, [r3, #12]
    ab1e:	442b      	add	r3, r5
    ab20:	aa6f      	add	r2, sp, #444	; 0x1bc
    ab22:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ab24:	1811      	adds	r1, r2, r0
    ab26:	eb03 0009 	add.w	r0, r3, r9
    ab2a:	4b33      	ldr	r3, [pc, #204]	; (abf8 <grid_port_process_ui+0x49c>)
    ab2c:	4798      	blx	r3
    ab2e:	9bd4      	ldr	r3, [sp, #848]	; 0x350
    ab30:	4418      	add	r0, r3
							grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    ab32:	f8da 3004 	ldr.w	r3, [sl, #4]
							message.body_length += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &message.body[offset]);
    ab36:	90d4      	str	r0, [sp, #848]	; 0x350
							grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    ab38:	4423      	add	r3, r4
    ab3a:	68db      	ldr	r3, [r3, #12]
	eve->trigger = GRID_UI_STATUS_READY;
    ab3c:	442b      	add	r3, r5
    ab3e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ab40:	4499      	add	r9, r3
    ab42:	2304      	movs	r3, #4
    ab44:	f889 3009 	strb.w	r3, [r9, #9]
						CRITICAL_SECTION_LEAVE()
    ab48:	a80b      	add	r0, sp, #44	; 0x2c
    ab4a:	47d8      	blx	fp
				for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){ //j=1 because init is local
    ab4c:	f108 0801 	add.w	r8, r8, #1
    ab50:	f8da 3004 	ldr.w	r3, [sl, #4]
    ab54:	4423      	add	r3, r4
    ab56:	fa5f f988 	uxtb.w	r9, r8
    ab5a:	68db      	ldr	r3, [r3, #12]
    ab5c:	442b      	add	r3, r5
    ab5e:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    ab62:	454b      	cmp	r3, r9
    ab64:	d8be      	bhi.n	aae4 <grid_port_process_ui+0x388>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    ab66:	3601      	adds	r6, #1
    ab68:	f8da 3004 	ldr.w	r3, [sl, #4]
    ab6c:	4423      	add	r3, r4
    ab6e:	7a5a      	ldrb	r2, [r3, #9]
    ab70:	b2f3      	uxtb	r3, r6
    ab72:	429a      	cmp	r2, r3
    ab74:	d906      	bls.n	ab84 <grid_port_process_ui+0x428>
				for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){ //j=1 because init is local
    ab76:	2564      	movs	r5, #100	; 0x64
						CRITICAL_SECTION_LEAVE()
    ab78:	f8df b094 	ldr.w	fp, [pc, #148]	; ac10 <grid_port_process_ui+0x4b4>
				for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){ //j=1 because init is local
    ab7c:	435d      	muls	r5, r3
    ab7e:	f04f 0800 	mov.w	r8, #0
    ab82:	e7e5      	b.n	ab50 <grid_port_process_ui+0x3f4>
		for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    ab84:	3701      	adds	r7, #1
    ab86:	f89a 3001 	ldrb.w	r3, [sl, #1]
    ab8a:	b2fc      	uxtb	r4, r7
    ab8c:	42a3      	cmp	r3, r4
    ab8e:	d904      	bls.n	ab9a <grid_port_process_ui+0x43e>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    ab90:	0124      	lsls	r4, r4, #4
    ab92:	2600      	movs	r6, #0
    ab94:	e7e8      	b.n	ab68 <grid_port_process_ui+0x40c>
    ab96:	2700      	movs	r7, #0
    ab98:	e7f5      	b.n	ab86 <grid_port_process_ui+0x42a>
		por->cooldown += 10;
    ab9a:	9b01      	ldr	r3, [sp, #4]
    ab9c:	9a01      	ldr	r2, [sp, #4]
    ab9e:	681b      	ldr	r3, [r3, #0]
    aba0:	330a      	adds	r3, #10
    aba2:	6013      	str	r3, [r2, #0]
		grid_msg_packet_close(&message);
    aba4:	a86f      	add	r0, sp, #444	; 0x1bc
    aba6:	4b15      	ldr	r3, [pc, #84]	; (abfc <grid_port_process_ui+0x4a0>)
    aba8:	4798      	blx	r3
		uint32_t length = grid_msg_packet_get_length(&message);
    abaa:	4b10      	ldr	r3, [pc, #64]	; (abec <grid_port_process_ui+0x490>)
    abac:	a86f      	add	r0, sp, #444	; 0x1bc
    abae:	4798      	blx	r3
		if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, length)){
    abb0:	4b13      	ldr	r3, [pc, #76]	; (ac00 <grid_port_process_ui+0x4a4>)
		uint32_t length = grid_msg_packet_get_length(&message);
    abb2:	4604      	mov	r4, r0
		if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, length)){
    abb4:	b281      	uxth	r1, r0
    abb6:	4813      	ldr	r0, [pc, #76]	; (ac04 <grid_port_process_ui+0x4a8>)
    abb8:	4798      	blx	r3
    abba:	b988      	cbnz	r0, abe0 <grid_port_process_ui+0x484>
}
    abbc:	f50d 7d57 	add.w	sp, sp, #860	; 0x35c
    abc0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(&message, i));
    abc4:	a86f      	add	r0, sp, #444	; 0x1bc
    abc6:	47b0      	blx	r6
    abc8:	4601      	mov	r1, r0
    abca:	4638      	mov	r0, r7
    abcc:	47c0      	blx	r8
			for(uint16_t i = 0; i<length; i++){
    abce:	b2a9      	uxth	r1, r5
    abd0:	428c      	cmp	r4, r1
    abd2:	f105 0501 	add.w	r5, r5, #1
    abd6:	d8f5      	bhi.n	abc4 <grid_port_process_ui+0x468>
			grid_buffer_write_acknowledge(&GRID_PORT_U.rx_buffer);
    abd8:	4b0b      	ldr	r3, [pc, #44]	; (ac08 <grid_port_process_ui+0x4ac>)
    abda:	480a      	ldr	r0, [pc, #40]	; (ac04 <grid_port_process_ui+0x4a8>)
    abdc:	4798      	blx	r3
		}
    abde:	e7ed      	b.n	abbc <grid_port_process_ui+0x460>
				grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(&message, i));
    abe0:	4e0a      	ldr	r6, [pc, #40]	; (ac0c <grid_port_process_ui+0x4b0>)
    abe2:	4f08      	ldr	r7, [pc, #32]	; (ac04 <grid_port_process_ui+0x4a8>)
    abe4:	f8df 802c 	ldr.w	r8, [pc, #44]	; ac14 <grid_port_process_ui+0x4b8>
    abe8:	2500      	movs	r5, #0
    abea:	e7f0      	b.n	abce <grid_port_process_ui+0x472>
    abec:	000084d9 	.word	0x000084d9
    abf0:	00011b09 	.word	0x00011b09
    abf4:	000084e7 	.word	0x000084e7
    abf8:	0000a565 	.word	0x0000a565
    abfc:	000086a9 	.word	0x000086a9
    ac00:	000047f1 	.word	0x000047f1
    ac04:	2000ebe4 	.word	0x2000ebe4
    ac08:	0000484d 	.word	0x0000484d
    ac0c:	00008673 	.word	0x00008673
    ac10:	00011b17 	.word	0x00011b17
    ac14:	0000482d 	.word	0x0000482d

0000ac18 <grid_usb_serial_bulkout_cb>:
	//grid_sys_alert_set_alert(&grid_sys_state, 255,255,0,2,300);
//	cdcdf_acm_read((uint8_t *)cdcdf_demo_buf, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS);
	
	//cdcdf_acm_write(cdcdf_demo_buf, count); /* Echo data */
	return false;                           /* No error. */
}
    ac18:	2000      	movs	r0, #0
    ac1a:	4770      	bx	lr

0000ac1c <grid_usb_serial_statechange_cb>:

//	cdcdf_acm_read((uint8_t *)cdcdf_demo_buf, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS); /* Another read */
	return false;                                                                                 /* No error. */
}
static bool grid_usb_serial_statechange_cb(usb_cdc_control_signal_t state)
{
    ac1c:	b513      	push	{r0, r1, r4, lr}
	
	//grid_sys_alert_set_alert(&grid_sys_state, 0,255,255,2,300);
	
	if (state.rs232.DTR || 1) {
		/* After connection the R/W callbacks can be registered */
		cdcdf_acm_register_callback(CDCDF_ACM_CB_READ, (FUNC_PTR)grid_usb_serial_bulkout_cb);
    ac1e:	4c06      	ldr	r4, [pc, #24]	; (ac38 <grid_usb_serial_statechange_cb+0x1c>)
{
    ac20:	f8ad 0004 	strh.w	r0, [sp, #4]
		cdcdf_acm_register_callback(CDCDF_ACM_CB_READ, (FUNC_PTR)grid_usb_serial_bulkout_cb);
    ac24:	4905      	ldr	r1, [pc, #20]	; (ac3c <grid_usb_serial_statechange_cb+0x20>)
    ac26:	2000      	movs	r0, #0
    ac28:	47a0      	blx	r4
		cdcdf_acm_register_callback(CDCDF_ACM_CB_WRITE, (FUNC_PTR)grid_usb_serial_bulkin_cb);
    ac2a:	4905      	ldr	r1, [pc, #20]	; (ac40 <grid_usb_serial_statechange_cb+0x24>)
    ac2c:	2001      	movs	r0, #1
    ac2e:	47a0      	blx	r4
		/* Start Rx */
		//cdcdf_acm_read((uint8_t *)cdcdf_demo_buf, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS);
	}
	return false; /* No error. */
}
    ac30:	2000      	movs	r0, #0
    ac32:	b002      	add	sp, #8
    ac34:	bd10      	pop	{r4, pc}
    ac36:	bf00      	nop
    ac38:	0000bd7d 	.word	0x0000bd7d
    ac3c:	0000ac19 	.word	0x0000ac19
    ac40:	0000ac95 	.word	0x0000ac95

0000ac44 <grid_usb_midi_bulkin_cb>:

	grid_sys_alert_set_alert(&grid_sys_state, 255,255,0,2,300);
	return false;
}
static bool grid_usb_midi_bulkin_cb(const uint8_t ep, const enum usb_xfer_code rc, const uint32_t count)
{
    ac44:	b513      	push	{r0, r1, r4, lr}

	grid_sys_alert_set_alert(&grid_sys_state, 255,0,255,2,300);
    ac46:	2302      	movs	r3, #2
    ac48:	f44f 7296 	mov.w	r2, #300	; 0x12c
    ac4c:	e9cd 3200 	strd	r3, r2, [sp]
    ac50:	23ff      	movs	r3, #255	; 0xff
    ac52:	4804      	ldr	r0, [pc, #16]	; (ac64 <grid_usb_midi_bulkin_cb+0x20>)
    ac54:	4c04      	ldr	r4, [pc, #16]	; (ac68 <grid_usb_midi_bulkin_cb+0x24>)
    ac56:	2200      	movs	r2, #0
    ac58:	4619      	mov	r1, r3
    ac5a:	47a0      	blx	r4
	return false;
}
    ac5c:	2000      	movs	r0, #0
    ac5e:	b002      	add	sp, #8
    ac60:	bd10      	pop	{r4, pc}
    ac62:	bf00      	nop
    ac64:	2000f008 	.word	0x2000f008
    ac68:	000097cb 	.word	0x000097cb

0000ac6c <grid_usb_midi_bulkout_cb>:
{
    ac6c:	b513      	push	{r0, r1, r4, lr}
	grid_sys_alert_set_alert(&grid_sys_state, 255,255,0,2,300);
    ac6e:	2302      	movs	r3, #2
    ac70:	f44f 7296 	mov.w	r2, #300	; 0x12c
    ac74:	e9cd 3200 	strd	r3, r2, [sp]
    ac78:	22ff      	movs	r2, #255	; 0xff
    ac7a:	4804      	ldr	r0, [pc, #16]	; (ac8c <grid_usb_midi_bulkout_cb+0x20>)
    ac7c:	4c04      	ldr	r4, [pc, #16]	; (ac90 <grid_usb_midi_bulkout_cb+0x24>)
    ac7e:	2300      	movs	r3, #0
    ac80:	4611      	mov	r1, r2
    ac82:	47a0      	blx	r4
}
    ac84:	2000      	movs	r0, #0
    ac86:	b002      	add	sp, #8
    ac88:	bd10      	pop	{r4, pc}
    ac8a:	bf00      	nop
    ac8c:	2000f008 	.word	0x2000f008
    ac90:	000097cb 	.word	0x000097cb

0000ac94 <grid_usb_serial_bulkin_cb>:
    ac94:	2000      	movs	r0, #0
    ac96:	4770      	bx	lr

0000ac98 <grid_usb_serial_init>:
	cdcdf_acm_register_callback(CDCDF_ACM_CB_STATE_C, (FUNC_PTR)grid_usb_serial_statechange_cb);
    ac98:	4901      	ldr	r1, [pc, #4]	; (aca0 <grid_usb_serial_init+0x8>)
    ac9a:	4b02      	ldr	r3, [pc, #8]	; (aca4 <grid_usb_serial_init+0xc>)
    ac9c:	2003      	movs	r0, #3
    ac9e:	4718      	bx	r3
    aca0:	0000ac1d 	.word	0x0000ac1d
    aca4:	0000bd7d 	.word	0x0000bd7d

0000aca8 <grid_keyboard_cleanup>:
uint8_t grid_keyboard_cleanup(struct grid_keyboard_model* kb){
	
	uint8_t changed_flag = 0;
	
	// Remove all inactive (released) keys
	for(uint8_t i=0; i<kb->key_active_count; i++){
    aca8:	2300      	movs	r3, #0
uint8_t grid_keyboard_cleanup(struct grid_keyboard_model* kb){
    acaa:	b5f0      	push	{r4, r5, r6, r7, lr}
			
			changed_flag = 1;
			
			kb->key_list[i].ismodifier = 0;
			kb->key_list[i].ispressed = 0;
			kb->key_list[i].keycode = 255;	
    acac:	f04f 0cff 	mov.w	ip, #255	; 0xff
uint8_t grid_keyboard_cleanup(struct grid_keyboard_model* kb){
    acb0:	4604      	mov	r4, r0
			// Pop item, move each remaining after this forvard one index
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
				
				kb->key_list[j-1] = kb->key_list[j];
				
				kb->key_list[j].ismodifier = 0;
    acb2:	469e      	mov	lr, r3
	uint8_t changed_flag = 0;
    acb4:	4618      	mov	r0, r3
	for(uint8_t i=0; i<kb->key_active_count; i++){
    acb6:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    acba:	429d      	cmp	r5, r3
    acbc:	d800      	bhi.n	acc0 <grid_keyboard_cleanup+0x18>
		// USB SEND
	}
	
	return changed_flag;
	
}
    acbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (kb->key_list[i].ispressed == false){
    acc0:	eb04 01c3 	add.w	r1, r4, r3, lsl #3
    acc4:	7d8f      	ldrb	r7, [r1, #22]
    acc6:	b98f      	cbnz	r7, acec <grid_keyboard_cleanup+0x44>
    acc8:	1c5a      	adds	r2, r3, #1
    acca:	b2d6      	uxtb	r6, r2
			kb->key_list[i].ismodifier = 0;
    accc:	754f      	strb	r7, [r1, #21]
			kb->key_list[i].ispressed = 0;
    acce:	758f      	strb	r7, [r1, #22]
			kb->key_list[i].keycode = 255;	
    acd0:	f881 c014 	strb.w	ip, [r1, #20]
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    acd4:	eb04 02c6 	add.w	r2, r4, r6, lsl #3
    acd8:	42b5      	cmp	r5, r6
    acda:	f102 0208 	add.w	r2, r2, #8
    acde:	d108      	bne.n	acf2 <grid_keyboard_cleanup+0x4a>
			kb->key_active_count--;
    ace0:	3d01      	subs	r5, #1
			i--; // Retest this index, because it now points to a new item
    ace2:	3b01      	subs	r3, #1
			kb->key_active_count--;
    ace4:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
			i--; // Retest this index, because it now points to a new item
    ace8:	b2db      	uxtb	r3, r3
			changed_flag = 1;
    acea:	2001      	movs	r0, #1
	for(uint8_t i=0; i<kb->key_active_count; i++){
    acec:	3301      	adds	r3, #1
    acee:	b2db      	uxtb	r3, r3
    acf0:	e7e1      	b.n	acb6 <grid_keyboard_cleanup+0xe>
				kb->key_list[j-1] = kb->key_list[j];
    acf2:	e9d2 0103 	ldrd	r0, r1, [r2, #12]
    acf6:	1d17      	adds	r7, r2, #4
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    acf8:	3601      	adds	r6, #1
				kb->key_list[j-1] = kb->key_list[j];
    acfa:	e887 0003 	stmia.w	r7, {r0, r1}
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    acfe:	b2f6      	uxtb	r6, r6
				kb->key_list[j].ismodifier = 0;
    ad00:	f882 e00d 	strb.w	lr, [r2, #13]
				kb->key_list[j].ispressed = 0;
    ad04:	f882 e00e 	strb.w	lr, [r2, #14]
				kb->key_list[j].keycode = 255;
    ad08:	f882 c00c 	strb.w	ip, [r2, #12]
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    ad0c:	e7e4      	b.n	acd8 <grid_keyboard_cleanup+0x30>
	...

0000ad10 <grid_keyboard_keychange>:


uint8_t grid_keyboard_keychange(struct grid_keyboard_model* kb, struct grid_keyboard_event_desc* key){
    ad10:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ad14:	4604      	mov	r4, r0
	uint8_t item_index = 255;
	uint8_t remove_flag = 0;
	uint8_t changed_flag = 0;
	

	grid_keyboard_cleanup(kb);
    ad16:	f8df 814c 	ldr.w	r8, [pc, #332]	; ae64 <grid_keyboard_keychange+0x154>
uint8_t grid_keyboard_keychange(struct grid_keyboard_model* kb, struct grid_keyboard_event_desc* key){
    ad1a:	b0ec      	sub	sp, #432	; 0x1b0
    ad1c:	460d      	mov	r5, r1
	grid_keyboard_cleanup(kb);
    ad1e:	47c0      	blx	r8
	

	for(uint8_t i=0; i<kb->key_active_count; i++){
    ad20:	2200      	movs	r2, #0
    ad22:	f894 c044 	ldrb.w	ip, [r4, #68]	; 0x44
    ad26:	4626      	mov	r6, r4
    ad28:	4623      	mov	r3, r4
	uint8_t changed_flag = 0;
    ad2a:	4691      	mov	r9, r2
	uint8_t item_index = 255;
    ad2c:	27ff      	movs	r7, #255	; 0xff
				if (key->ispressed == true){
					// OK nothing to do here
				}
				else{
					// Release the damn key
					kb->key_list[i].ispressed = false;
    ad2e:	4696      	mov	lr, r2
    ad30:	b2d1      	uxtb	r1, r2
	for(uint8_t i=0; i<kb->key_active_count; i++){
    ad32:	458c      	cmp	ip, r1
    ad34:	d82e      	bhi.n	ad94 <grid_keyboard_keychange+0x84>
		}
		
	}
	
	
	uint8_t print_happened = grid_keyboard_cleanup(kb);
    ad36:	4620      	mov	r0, r4
    ad38:	47c0      	blx	r8
	
	
	if (item_index == 255){
    ad3a:	2fff      	cmp	r7, #255	; 0xff
    ad3c:	d143      	bne.n	adc6 <grid_keyboard_keychange+0xb6>
		
		// item not in list
		
		if (kb->key_active_count< GRID_KEYBOARD_KEY_maxcount){
    ad3e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    ad42:	2b05      	cmp	r3, #5
    ad44:	d83f      	bhi.n	adc6 <grid_keyboard_keychange+0xb6>
			
			if (key->ispressed == true){
    ad46:	78aa      	ldrb	r2, [r5, #2]
    ad48:	2a01      	cmp	r2, #1
    ad4a:	d13c      	bne.n	adc6 <grid_keyboard_keychange+0xb6>
				
				kb->key_list[kb->key_active_count] = *key;
    ad4c:	e895 0003 	ldmia.w	r5, {r0, r1}
    ad50:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
    ad54:	3214      	adds	r2, #20
				kb->key_active_count++;
    ad56:	3301      	adds	r3, #1
				kb->key_list[kb->key_active_count] = *key;
    ad58:	e882 0003 	stmia.w	r2, {r0, r1}
				kb->key_active_count++;
    ad5c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		}
		
	}
	
	
	if (changed_flag == 1){
    ad60:	f104 0112 	add.w	r1, r4, #18
	uint8_t item_index = 255;
    ad64:	4623      	mov	r3, r4
//		}
			
		
		for(uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++){
		
			kb->hid_key_array[i].b_modifier = kb->key_list[i].ismodifier;
    ad66:	7d72      	ldrb	r2, [r6, #21]
    ad68:	3a00      	subs	r2, #0
    ad6a:	bf18      	it	ne
    ad6c:	2201      	movne	r2, #1
    ad6e:	705a      	strb	r2, [r3, #1]
			kb->hid_key_array[i].key_id = kb->key_list[i].keycode;
    ad70:	7d32      	ldrb	r2, [r6, #20]
    ad72:	701a      	strb	r2, [r3, #0]
			kb->hid_key_array[i].state = kb->key_list[i].ispressed;
    ad74:	7db2      	ldrb	r2, [r6, #22]
    ad76:	709a      	strb	r2, [r3, #2]
		for(uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++){
    ad78:	3303      	adds	r3, #3
    ad7a:	428b      	cmp	r3, r1
    ad7c:	f106 0608 	add.w	r6, r6, #8
    ad80:	d1f1      	bne.n	ad66 <grid_keyboard_keychange+0x56>
		
		}
        
        
        if (kb->isenabled){
    ad82:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    ad86:	b325      	cbz	r5, add2 <grid_keyboard_keychange+0xc2>
            
            
    		hiddf_keyboard_keys_state_change(kb->hid_key_array, kb->key_active_count);    
    ad88:	f894 1044 	ldrb.w	r1, [r4, #68]	; 0x44
    ad8c:	4b2b      	ldr	r3, [pc, #172]	; (ae3c <grid_keyboard_keychange+0x12c>)
    ad8e:	4620      	mov	r0, r4
    ad90:	4798      	blx	r3
    ad92:	e01b      	b.n	adcc <grid_keyboard_keychange+0xbc>
		if (kb->key_list[i].keycode == key->keycode && kb->key_list[i].ismodifier == key->ismodifier){
    ad94:	f893 a014 	ldrb.w	sl, [r3, #20]
    ad98:	7828      	ldrb	r0, [r5, #0]
    ad9a:	4582      	cmp	sl, r0
    ad9c:	d111      	bne.n	adc2 <grid_keyboard_keychange+0xb2>
    ad9e:	f893 a015 	ldrb.w	sl, [r3, #21]
    ada2:	7868      	ldrb	r0, [r5, #1]
    ada4:	4582      	cmp	sl, r0
    ada6:	d10c      	bne.n	adc2 <grid_keyboard_keychange+0xb2>
			if (kb->key_list[i].ispressed == true){
    ada8:	7d98      	ldrb	r0, [r3, #22]
    adaa:	2801      	cmp	r0, #1
    adac:	d105      	bne.n	adba <grid_keyboard_keychange+0xaa>
				if (key->ispressed == true){
    adae:	78af      	ldrb	r7, [r5, #2]
    adb0:	2f01      	cmp	r7, #1
    adb2:	d002      	beq.n	adba <grid_keyboard_keychange+0xaa>
					kb->key_list[i].ispressed = false;
    adb4:	f883 e016 	strb.w	lr, [r3, #22]
					changed_flag = 1;
    adb8:	4681      	mov	r9, r0
	for(uint8_t i=0; i<kb->key_active_count; i++){
    adba:	3201      	adds	r2, #1
    adbc:	3308      	adds	r3, #8
	uint8_t item_index = 255;
    adbe:	460f      	mov	r7, r1
    adc0:	e7b6      	b.n	ad30 <grid_keyboard_keychange+0x20>
    adc2:	4639      	mov	r1, r7
    adc4:	e7f9      	b.n	adba <grid_keyboard_keychange+0xaa>
	if (changed_flag == 1){
    adc6:	f1b9 0f00 	cmp.w	r9, #0
    adca:	d1c9      	bne.n	ad60 <grid_keyboard_keychange+0x50>
		
		
		// USB SEND
	}
	
}
    adcc:	b06c      	add	sp, #432	; 0x1b0
    adce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            grid_msg_init(&response);
    add2:	a805      	add	r0, sp, #20
    add4:	4b1a      	ldr	r3, [pc, #104]	; (ae40 <grid_keyboard_keychange+0x130>)
            grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    add6:	4e1b      	ldr	r6, [pc, #108]	; (ae44 <grid_keyboard_keychange+0x134>)
            grid_msg_init(&response);
    add8:	4798      	blx	r3
            grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    adda:	227f      	movs	r2, #127	; 0x7f
    addc:	462b      	mov	r3, r5
    adde:	4611      	mov	r1, r2
    ade0:	a805      	add	r0, sp, #20
    ade2:	47b0      	blx	r6
            sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    ade4:	2303      	movs	r3, #3
    ade6:	4918      	ldr	r1, [pc, #96]	; (ae48 <grid_keyboard_keychange+0x138>)
    ade8:	9300      	str	r3, [sp, #0]
    adea:	2202      	movs	r2, #2
    adec:	4e17      	ldr	r6, [pc, #92]	; (ae4c <grid_keyboard_keychange+0x13c>)
            uint8_t response_payload[10] = {0};
    adee:	f8ad 5010 	strh.w	r5, [sp, #16]
            sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    adf2:	2392      	movs	r3, #146	; 0x92
    adf4:	a802      	add	r0, sp, #8
            uint8_t response_payload[10] = {0};
    adf6:	e9cd 5502 	strd	r5, r5, [sp, #8]
            sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    adfa:	47b0      	blx	r6
            grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    adfc:	4b14      	ldr	r3, [pc, #80]	; (ae50 <grid_keyboard_keychange+0x140>)
    adfe:	a802      	add	r0, sp, #8
    ae00:	4798      	blx	r3
    ae02:	a902      	add	r1, sp, #8
    ae04:	4602      	mov	r2, r0
    ae06:	4b13      	ldr	r3, [pc, #76]	; (ae54 <grid_keyboard_keychange+0x144>)
    ae08:	a805      	add	r0, sp, #20
    ae0a:	4798      	blx	r3
            grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, kb->isenabled);
    ae0c:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    ae10:	9300      	str	r3, [sp, #0]
    ae12:	4c11      	ldr	r4, [pc, #68]	; (ae58 <grid_keyboard_keychange+0x148>)
    ae14:	4629      	mov	r1, r5
    ae16:	a805      	add	r0, sp, #20
    ae18:	2302      	movs	r3, #2
    ae1a:	2205      	movs	r2, #5
    ae1c:	47a0      	blx	r4
            grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    ae1e:	230d      	movs	r3, #13
    ae20:	9300      	str	r3, [sp, #0]
    ae22:	2204      	movs	r2, #4
    ae24:	4629      	mov	r1, r5
    ae26:	a805      	add	r0, sp, #20
    ae28:	2301      	movs	r3, #1
    ae2a:	47a0      	blx	r4
            grid_msg_packet_close(&response);
    ae2c:	4b0b      	ldr	r3, [pc, #44]	; (ae5c <grid_keyboard_keychange+0x14c>)
    ae2e:	a805      	add	r0, sp, #20
    ae30:	4798      	blx	r3
            grid_msg_packet_send_everywhere(&response);
    ae32:	4b0b      	ldr	r3, [pc, #44]	; (ae60 <grid_keyboard_keychange+0x150>)
    ae34:	a805      	add	r0, sp, #20
    ae36:	4798      	blx	r3
    ae38:	e7c8      	b.n	adcc <grid_keyboard_keychange+0xbc>
    ae3a:	bf00      	nop
    ae3c:	0000ea81 	.word	0x0000ea81
    ae40:	0000857d 	.word	0x0000857d
    ae44:	000085b1 	.word	0x000085b1
    ae48:	00015a50 	.word	0x00015a50
    ae4c:	00014791 	.word	0x00014791
    ae50:	0001480f 	.word	0x0001480f
    ae54:	000084ed 	.word	0x000084ed
    ae58:	00008561 	.word	0x00008561
    ae5c:	000086a9 	.word	0x000086a9
    ae60:	0000877d 	.word	0x0000877d
    ae64:	0000aca9 	.word	0x0000aca9

0000ae68 <grid_midi_buffer_init>:



void grid_midi_buffer_init(struct grid_midi_event_desc* buf, uint16_t length){
    ae68:	b510      	push	{r4, lr}
	
	
	for (uint16_t i=0; i<length; i++)
    ae6a:	2300      	movs	r3, #0
	{
		buf[i].byte0 = 0;
    ae6c:	461a      	mov	r2, r3
	for (uint16_t i=0; i<length; i++)
    ae6e:	b29c      	uxth	r4, r3
    ae70:	42a1      	cmp	r1, r4
    ae72:	f100 0004 	add.w	r0, r0, #4
    ae76:	d800      	bhi.n	ae7a <grid_midi_buffer_init+0x12>
		buf[i].byte1 = 0;
		buf[i].byte2 = 0;
		buf[i].byte3 = 0;
	}
	
}
    ae78:	bd10      	pop	{r4, pc}
		buf[i].byte0 = 0;
    ae7a:	f800 2c04 	strb.w	r2, [r0, #-4]
		buf[i].byte1 = 0;
    ae7e:	f800 2c03 	strb.w	r2, [r0, #-3]
		buf[i].byte2 = 0;
    ae82:	f800 2c02 	strb.w	r2, [r0, #-2]
		buf[i].byte3 = 0;
    ae86:	f800 2c01 	strb.w	r2, [r0, #-1]
	for (uint16_t i=0; i<length; i++)
    ae8a:	3301      	adds	r3, #1
    ae8c:	e7ef      	b.n	ae6e <grid_midi_buffer_init+0x6>
	...

0000ae90 <grid_usb_midi_init>:
	grid_midi_tx_write_index = 0;
    ae90:	4b0a      	ldr	r3, [pc, #40]	; (aebc <grid_usb_midi_init+0x2c>)
	grid_midi_buffer_init(grid_midi_tx_buffer, GRID_MIDI_TX_BUFFER_length);
    ae92:	480b      	ldr	r0, [pc, #44]	; (aec0 <grid_usb_midi_init+0x30>)
{
    ae94:	b510      	push	{r4, lr}
	grid_midi_tx_write_index = 0;
    ae96:	2400      	movs	r4, #0
    ae98:	801c      	strh	r4, [r3, #0]
	grid_midi_tx_read_index = 0;
    ae9a:	4b0a      	ldr	r3, [pc, #40]	; (aec4 <grid_usb_midi_init+0x34>)
	grid_midi_buffer_init(grid_midi_tx_buffer, GRID_MIDI_TX_BUFFER_length);
    ae9c:	f44f 7196 	mov.w	r1, #300	; 0x12c
	grid_midi_tx_read_index = 0;
    aea0:	801c      	strh	r4, [r3, #0]
	grid_midi_buffer_init(grid_midi_tx_buffer, GRID_MIDI_TX_BUFFER_length);
    aea2:	4b09      	ldr	r3, [pc, #36]	; (aec8 <grid_usb_midi_init+0x38>)
    aea4:	4798      	blx	r3
	audiodf_midi_register_callback(AUDIODF_MIDI_CB_READ, (FUNC_PTR)grid_usb_midi_bulkout_cb);
    aea6:	4620      	mov	r0, r4
    aea8:	4c08      	ldr	r4, [pc, #32]	; (aecc <grid_usb_midi_init+0x3c>)
    aeaa:	4909      	ldr	r1, [pc, #36]	; (aed0 <grid_usb_midi_init+0x40>)
    aeac:	47a0      	blx	r4
	audiodf_midi_register_callback(AUDIODF_MIDI_CB_WRITE, (FUNC_PTR)grid_usb_midi_bulkin_cb);
    aeae:	4623      	mov	r3, r4
    aeb0:	4908      	ldr	r1, [pc, #32]	; (aed4 <grid_usb_midi_init+0x44>)
}
    aeb2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	audiodf_midi_register_callback(AUDIODF_MIDI_CB_WRITE, (FUNC_PTR)grid_usb_midi_bulkin_cb);
    aeb6:	2001      	movs	r0, #1
    aeb8:	4718      	bx	r3
    aeba:	bf00      	nop
    aebc:	2000c0a4 	.word	0x2000c0a4
    aec0:	20013420 	.word	0x20013420
    aec4:	20010260 	.word	0x20010260
    aec8:	0000ae69 	.word	0x0000ae69
    aecc:	0000453d 	.word	0x0000453d
    aed0:	0000ac6d 	.word	0x0000ac6d
    aed4:	0000ac45 	.word	0x0000ac45

0000aed8 <grid_midi_tx_push>:

uint8_t grid_midi_tx_push(struct grid_midi_event_desc midi_event){


	grid_midi_tx_buffer[grid_midi_tx_write_index] = midi_event;
    aed8:	4907      	ldr	r1, [pc, #28]	; (aef8 <grid_midi_tx_push+0x20>)
    aeda:	4a08      	ldr	r2, [pc, #32]	; (aefc <grid_midi_tx_push+0x24>)
    aedc:	880b      	ldrh	r3, [r1, #0]
    aede:	f842 0023 	str.w	r0, [r2, r3, lsl #2]

	grid_midi_tx_write_index = (grid_midi_tx_write_index+1)%GRID_MIDI_TX_BUFFER_length;
    aee2:	f44f 7096 	mov.w	r0, #300	; 0x12c
    aee6:	3301      	adds	r3, #1
uint8_t grid_midi_tx_push(struct grid_midi_event_desc midi_event){
    aee8:	b082      	sub	sp, #8
	grid_midi_tx_write_index = (grid_midi_tx_write_index+1)%GRID_MIDI_TX_BUFFER_length;
    aeea:	fbb3 f2f0 	udiv	r2, r3, r0
    aeee:	fb00 3312 	mls	r3, r0, r2, r3
    aef2:	800b      	strh	r3, [r1, #0]




}
    aef4:	b002      	add	sp, #8
    aef6:	4770      	bx	lr
    aef8:	2000c0a4 	.word	0x2000c0a4
    aefc:	20013420 	.word	0x20013420

0000af00 <grid_midi_tx_pop>:

uint8_t grid_midi_tx_pop(){
    af00:	b538      	push	{r3, r4, r5, lr}

	if (grid_midi_tx_read_index != grid_midi_tx_write_index){
    af02:	4c0f      	ldr	r4, [pc, #60]	; (af40 <grid_midi_tx_pop+0x40>)
    af04:	4b0f      	ldr	r3, [pc, #60]	; (af44 <grid_midi_tx_pop+0x44>)
    af06:	8822      	ldrh	r2, [r4, #0]
    af08:	881b      	ldrh	r3, [r3, #0]
    af0a:	429a      	cmp	r2, r3
    af0c:	d017      	beq.n	af3e <grid_midi_tx_pop+0x3e>
		
		if (audiodf_midi_write_status() != USB_BUSY){
    af0e:	4b0e      	ldr	r3, [pc, #56]	; (af48 <grid_midi_tx_pop+0x48>)
    af10:	4798      	blx	r3
    af12:	2801      	cmp	r0, #1
    af14:	d013      	beq.n	af3e <grid_midi_tx_pop+0x3e>

			uint8_t byte0 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte0;
    af16:	8825      	ldrh	r5, [r4, #0]
			uint8_t byte1 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte1;
			uint8_t byte2 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte2;
			uint8_t byte3 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte3;
    af18:	480c      	ldr	r0, [pc, #48]	; (af4c <grid_midi_tx_pop+0x4c>)
    af1a:	eb00 0185 	add.w	r1, r0, r5, lsl #2
			
			audiodf_midi_write(byte0, byte1, byte2, byte3);
    af1e:	f810 0025 	ldrb.w	r0, [r0, r5, lsl #2]
    af22:	78cb      	ldrb	r3, [r1, #3]
    af24:	788a      	ldrb	r2, [r1, #2]
    af26:	4d0a      	ldr	r5, [pc, #40]	; (af50 <grid_midi_tx_pop+0x50>)
    af28:	7849      	ldrb	r1, [r1, #1]
    af2a:	47a8      	blx	r5

			grid_midi_tx_read_index = (grid_midi_tx_read_index+1)%GRID_MIDI_TX_BUFFER_length;
    af2c:	8823      	ldrh	r3, [r4, #0]
    af2e:	f44f 7196 	mov.w	r1, #300	; 0x12c
    af32:	3301      	adds	r3, #1
    af34:	fbb3 f2f1 	udiv	r2, r3, r1
    af38:	fb01 3312 	mls	r3, r1, r2, r3
    af3c:	8023      	strh	r3, [r4, #0]

		}
		
	}

}
    af3e:	bd38      	pop	{r3, r4, r5, pc}
    af40:	20010260 	.word	0x20010260
    af44:	2000c0a4 	.word	0x2000c0a4
    af48:	00004501 	.word	0x00004501
    af4c:	20013420 	.word	0x20013420
    af50:	000044d9 	.word	0x000044d9

0000af54 <grid_keyboard_buffer_init>:


void grid_keyboard_buffer_init(struct grid_keyboard_event_desc* buf, uint16_t length){
    af54:	b510      	push	{r4, lr}
	
	
	for (uint16_t i=0; i<length; i++)
    af56:	2300      	movs	r3, #0
	{
		buf[i].ismodifier = 0;
    af58:	461a      	mov	r2, r3
	for (uint16_t i=0; i<length; i++)
    af5a:	b29c      	uxth	r4, r3
    af5c:	42a1      	cmp	r1, r4
    af5e:	f100 0008 	add.w	r0, r0, #8
    af62:	d800      	bhi.n	af66 <grid_keyboard_buffer_init+0x12>
		buf[i].keycode = 0;
		buf[i].ispressed = 0;
		buf[i].delay = 0;
	}
	
}
    af64:	bd10      	pop	{r4, pc}
		buf[i].ismodifier = 0;
    af66:	f800 2c07 	strb.w	r2, [r0, #-7]
		buf[i].keycode = 0;
    af6a:	f800 2c08 	strb.w	r2, [r0, #-8]
		buf[i].ispressed = 0;
    af6e:	f800 2c06 	strb.w	r2, [r0, #-6]
		buf[i].delay = 0;
    af72:	f840 2c04 	str.w	r2, [r0, #-4]
	for (uint16_t i=0; i<length; i++)
    af76:	3301      	adds	r3, #1
    af78:	e7ef      	b.n	af5a <grid_keyboard_buffer_init+0x6>
	...

0000af7c <grid_keyboard_init>:
void grid_keyboard_init(struct grid_keyboard_model* kb){
    af7c:	b570      	push	{r4, r5, r6, lr}
    grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    af7e:	4b13      	ldr	r3, [pc, #76]	; (afcc <grid_keyboard_init+0x50>)
void grid_keyboard_init(struct grid_keyboard_model* kb){
    af80:	4605      	mov	r5, r0
    grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    af82:	4813      	ldr	r0, [pc, #76]	; (afd0 <grid_keyboard_init+0x54>)
    af84:	4798      	blx	r3
    af86:	4b13      	ldr	r3, [pc, #76]	; (afd4 <grid_keyboard_init+0x58>)
    af88:	6018      	str	r0, [r3, #0]
    grid_keyboard_tx_write_index = 0;
    af8a:	4b13      	ldr	r3, [pc, #76]	; (afd8 <grid_keyboard_init+0x5c>)
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    af8c:	4813      	ldr	r0, [pc, #76]	; (afdc <grid_keyboard_init+0x60>)
    grid_keyboard_tx_write_index = 0;
    af8e:	2400      	movs	r4, #0
    af90:	801c      	strh	r4, [r3, #0]
	grid_keyboard_tx_read_index = 0;
    af92:	4b13      	ldr	r3, [pc, #76]	; (afe0 <grid_keyboard_init+0x64>)
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    af94:	f44f 7196 	mov.w	r1, #300	; 0x12c
	grid_keyboard_tx_read_index = 0;
    af98:	801c      	strh	r4, [r3, #0]
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    af9a:	4b12      	ldr	r3, [pc, #72]	; (afe4 <grid_keyboard_init+0x68>)
    af9c:	4798      	blx	r3
	for (uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++)
    af9e:	f105 0612 	add.w	r6, r5, #18
    afa2:	462a      	mov	r2, r5
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    afa4:	4629      	mov	r1, r5
		kb->hid_key_array[i].b_modifier = false;
    afa6:	4623      	mov	r3, r4
		kb->hid_key_array[i].key_id = 255;
    afa8:	20ff      	movs	r0, #255	; 0xff
		kb->hid_key_array[i].b_modifier = false;
    afaa:	7053      	strb	r3, [r2, #1]
		kb->hid_key_array[i].key_id = 255;
    afac:	7010      	strb	r0, [r2, #0]
		kb->hid_key_array[i].state = HID_KB_KEY_UP;
    afae:	7093      	strb	r3, [r2, #2]
		kb->key_list[i].ismodifier = 0;
    afb0:	3203      	adds	r2, #3
	for (uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++)
    afb2:	42b2      	cmp	r2, r6
		kb->key_list[i].ismodifier = 0;
    afb4:	754b      	strb	r3, [r1, #21]
		kb->key_list[i].ispressed = 0;
    afb6:	758b      	strb	r3, [r1, #22]
		kb->key_list[i].keycode = 255;
    afb8:	7508      	strb	r0, [r1, #20]
	for (uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++)
    afba:	f101 0108 	add.w	r1, r1, #8
    afbe:	d1f4      	bne.n	afaa <grid_keyboard_init+0x2e>
	kb->key_active_count = 0;
    afc0:	f44f 7380 	mov.w	r3, #256	; 0x100
    afc4:	f8a5 3044 	strh.w	r3, [r5, #68]	; 0x44
}
    afc8:	bd70      	pop	{r4, r5, r6, pc}
    afca:	bf00      	nop
    afcc:	00009761 	.word	0x00009761
    afd0:	2000f008 	.word	0x2000f008
    afd4:	2001c7cc 	.word	0x2001c7cc
    afd8:	2000f0b8 	.word	0x2000f0b8
    afdc:	2000f0bc 	.word	0x2000f0bc
    afe0:	200102ac 	.word	0x200102ac
    afe4:	0000af55 	.word	0x0000af55

0000afe8 <grid_keyboard_tx_push>:

uint8_t grid_keyboard_tx_push(struct grid_keyboard_event_desc keyboard_event){
    afe8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    afea:	466c      	mov	r4, sp
    afec:	e884 0003 	stmia.w	r4, {r0, r1}


	grid_keyboard_tx_buffer[grid_keyboard_tx_write_index] = keyboard_event;
    aff0:	4d09      	ldr	r5, [pc, #36]	; (b018 <grid_keyboard_tx_push+0x30>)
    aff2:	4a0a      	ldr	r2, [pc, #40]	; (b01c <grid_keyboard_tx_push+0x34>)
    aff4:	882b      	ldrh	r3, [r5, #0]
    aff6:	e894 0003 	ldmia.w	r4, {r0, r1}
    affa:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
    affe:	e882 0003 	stmia.w	r2, {r0, r1}

	grid_keyboard_tx_write_index = (grid_keyboard_tx_write_index+1)%GRID_KEYBOARD_TX_BUFFER_length;
    b002:	f44f 7196 	mov.w	r1, #300	; 0x12c
    b006:	3301      	adds	r3, #1
    b008:	fbb3 f2f1 	udiv	r2, r3, r1
    b00c:	fb01 3312 	mls	r3, r1, r2, r3
    b010:	802b      	strh	r3, [r5, #0]



}
    b012:	b003      	add	sp, #12
    b014:	bd30      	pop	{r4, r5, pc}
    b016:	bf00      	nop
    b018:	2000f0b8 	.word	0x2000f0b8
    b01c:	2000f0bc 	.word	0x2000f0bc

0000b020 <grid_keyboard_tx_pop>:

uint8_t grid_keyboard_tx_pop(){
    b020:	b573      	push	{r0, r1, r4, r5, r6, lr}

	if (grid_keyboard_tx_read_index != grid_keyboard_tx_write_index){
    b022:	4b17      	ldr	r3, [pc, #92]	; (b080 <grid_keyboard_tx_pop+0x60>)
    b024:	4c17      	ldr	r4, [pc, #92]	; (b084 <grid_keyboard_tx_pop+0x64>)
    b026:	881b      	ldrh	r3, [r3, #0]
    b028:	8822      	ldrh	r2, [r4, #0]
    b02a:	429a      	cmp	r2, r3
    b02c:	d026      	beq.n	b07c <grid_keyboard_tx_pop+0x5c>
		
        
        
        uint32_t elapsed = grid_sys_rtc_get_elapsed_time(&grid_sys_state, grid_keyboard_tx_rtc_lasttimestamp);
    b02e:	4d16      	ldr	r5, [pc, #88]	; (b088 <grid_keyboard_tx_pop+0x68>)
    b030:	4b16      	ldr	r3, [pc, #88]	; (b08c <grid_keyboard_tx_pop+0x6c>)
    b032:	6829      	ldr	r1, [r5, #0]
    b034:	4816      	ldr	r0, [pc, #88]	; (b090 <grid_keyboard_tx_pop+0x70>)
    b036:	4798      	blx	r3
        
        
		if (elapsed > grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].delay*RTC1MS){
    b038:	8822      	ldrh	r2, [r4, #0]
    b03a:	4b16      	ldr	r3, [pc, #88]	; (b094 <grid_keyboard_tx_pop+0x74>)
    b03c:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
    b040:	684e      	ldr	r6, [r1, #4]
    b042:	ebb0 1f06 	cmp.w	r0, r6, lsl #4
    b046:	d919      	bls.n	b07c <grid_keyboard_tx_pop+0x5c>
            
            struct grid_keyboard_event_desc key;
            
            key.ismodifier = grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].ismodifier;
            key.keycode =    grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].keycode;
    b048:	f833 3032 	ldrh.w	r3, [r3, r2, lsl #3]
            key.ispressed =  grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].ispressed;
    b04c:	7889      	ldrb	r1, [r1, #2]
            key.keycode =    grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].keycode;
    b04e:	f8ad 3000 	strh.w	r3, [sp]
            key.delay = 0;
    b052:	2300      	movs	r3, #0
            key.ispressed =  grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].ispressed;
    b054:	f88d 1002 	strb.w	r1, [sp, #2]
            key.delay = 0;
    b058:	9301      	str	r3, [sp, #4]
            
                  
            //grid_sys_alert_set_alert(&grid_sys_state, 255, 255, 255, 0, 50);
            
            grid_keyboard_keychange(&grid_keyboard_state, &key);
    b05a:	4669      	mov	r1, sp
    b05c:	4b0e      	ldr	r3, [pc, #56]	; (b098 <grid_keyboard_tx_pop+0x78>)
    b05e:	480f      	ldr	r0, [pc, #60]	; (b09c <grid_keyboard_tx_pop+0x7c>)
    b060:	4798      	blx	r3

			grid_keyboard_tx_read_index = (grid_keyboard_tx_read_index+1)%GRID_KEYBOARD_TX_BUFFER_length;
    b062:	8823      	ldrh	r3, [r4, #0]
            
            grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    b064:	480a      	ldr	r0, [pc, #40]	; (b090 <grid_keyboard_tx_pop+0x70>)
			grid_keyboard_tx_read_index = (grid_keyboard_tx_read_index+1)%GRID_KEYBOARD_TX_BUFFER_length;
    b066:	f44f 7196 	mov.w	r1, #300	; 0x12c
    b06a:	3301      	adds	r3, #1
    b06c:	fbb3 f2f1 	udiv	r2, r3, r1
    b070:	fb01 3312 	mls	r3, r1, r2, r3
    b074:	8023      	strh	r3, [r4, #0]
            grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    b076:	4b0a      	ldr	r3, [pc, #40]	; (b0a0 <grid_keyboard_tx_pop+0x80>)
    b078:	4798      	blx	r3
    b07a:	6028      	str	r0, [r5, #0]

		}
		
	}

}
    b07c:	b002      	add	sp, #8
    b07e:	bd70      	pop	{r4, r5, r6, pc}
    b080:	2000f0b8 	.word	0x2000f0b8
    b084:	200102ac 	.word	0x200102ac
    b088:	2001c7cc 	.word	0x2001c7cc
    b08c:	00009765 	.word	0x00009765
    b090:	2000f008 	.word	0x2000f008
    b094:	2000f0bc 	.word	0x2000f0bc
    b098:	0000ad11 	.word	0x0000ad11
    b09c:	20010264 	.word	0x20010264
    b0a0:	00009761 	.word	0x00009761

0000b0a4 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    b0a4:	b570      	push	{r4, r5, r6, lr}
    b0a6:	460d      	mov	r5, r1
    b0a8:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    b0aa:	4604      	mov	r4, r0
    b0ac:	b110      	cbz	r0, b0b4 <io_write+0x10>
    b0ae:	1e08      	subs	r0, r1, #0
    b0b0:	bf18      	it	ne
    b0b2:	2001      	movne	r0, #1
    b0b4:	4905      	ldr	r1, [pc, #20]	; (b0cc <io_write+0x28>)
    b0b6:	4b06      	ldr	r3, [pc, #24]	; (b0d0 <io_write+0x2c>)
    b0b8:	2234      	movs	r2, #52	; 0x34
    b0ba:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
    b0bc:	6823      	ldr	r3, [r4, #0]
    b0be:	4632      	mov	r2, r6
    b0c0:	4629      	mov	r1, r5
    b0c2:	4620      	mov	r0, r4
}
    b0c4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->write(io_descr, buf, length);
    b0c8:	4718      	bx	r3
    b0ca:	bf00      	nop
    b0cc:	000160cc 	.word	0x000160cc
    b0d0:	0000e03d 	.word	0x0000e03d

0000b0d4 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    b0d4:	b570      	push	{r4, r5, r6, lr}
    b0d6:	460d      	mov	r5, r1
    b0d8:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    b0da:	4604      	mov	r4, r0
    b0dc:	b110      	cbz	r0, b0e4 <io_read+0x10>
    b0de:	1e08      	subs	r0, r1, #0
    b0e0:	bf18      	it	ne
    b0e2:	2001      	movne	r0, #1
    b0e4:	4905      	ldr	r1, [pc, #20]	; (b0fc <io_read+0x28>)
    b0e6:	4b06      	ldr	r3, [pc, #24]	; (b100 <io_read+0x2c>)
    b0e8:	223d      	movs	r2, #61	; 0x3d
    b0ea:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
    b0ec:	6863      	ldr	r3, [r4, #4]
    b0ee:	4632      	mov	r2, r6
    b0f0:	4629      	mov	r1, r5
    b0f2:	4620      	mov	r0, r4
}
    b0f4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->read(io_descr, buf, length);
    b0f8:	4718      	bx	r3
    b0fa:	bf00      	nop
    b0fc:	000160cc 	.word	0x000160cc
    b100:	0000e03d 	.word	0x0000e03d

0000b104 <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
    b104:	f100 0308 	add.w	r3, r0, #8
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    b108:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
    b10c:	e9c0 2302 	strd	r2, r3, [r0, #8]
	pxList->pxIndex = (ListItem_t *)&(
    b110:	6043      	str	r3, [r0, #4]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
    b112:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
    b114:	2300      	movs	r3, #0
    b116:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList);
	listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList);
}
    b118:	4770      	bx	lr

0000b11a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    b11a:	2300      	movs	r3, #0
    b11c:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
}
    b11e:	4770      	bx	lr

0000b120 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
    b120:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
    b122:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    b124:	689a      	ldr	r2, [r3, #8]
    b126:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    b128:	689a      	ldr	r2, [r3, #8]
    b12a:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
    b12c:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    b12e:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    b130:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    b132:	3301      	adds	r3, #1
    b134:	6003      	str	r3, [r0, #0]
}
    b136:	4770      	bx	lr

0000b138 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    b138:	b530      	push	{r4, r5, lr}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    b13a:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if (xValueOfInsertion == portMAX_DELAY) {
    b13c:	1c63      	adds	r3, r4, #1
    b13e:	d10a      	bne.n	b156 <vListInsert+0x1e>
		pxIterator = pxList->xListEnd.pxPrevious;
    b140:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
    b142:	685a      	ldr	r2, [r3, #4]
    b144:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    b146:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious         = pxIterator;
    b148:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
    b14a:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    b14c:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    b14e:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    b150:	3301      	adds	r3, #1
    b152:	6003      	str	r3, [r0, #0]
}
    b154:	bd30      	pop	{r4, r5, pc}
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    b156:	f100 0208 	add.w	r2, r0, #8
    b15a:	4613      	mov	r3, r2
    b15c:	6852      	ldr	r2, [r2, #4]
    b15e:	6815      	ldr	r5, [r2, #0]
    b160:	42a5      	cmp	r5, r4
    b162:	d9fa      	bls.n	b15a <vListInsert+0x22>
    b164:	e7ed      	b.n	b142 <vListInsert+0xa>

0000b166 <uxListRemove>:
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    b166:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
    b16a:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    b16c:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    b16e:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
    b170:	6859      	ldr	r1, [r3, #4]
    b172:	4281      	cmp	r1, r0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    b174:	bf08      	it	eq
    b176:	605a      	streq	r2, [r3, #4]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    b178:	2200      	movs	r2, #0
    b17a:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
    b17c:	681a      	ldr	r2, [r3, #0]
    b17e:	3a01      	subs	r2, #1
    b180:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    b182:	6818      	ldr	r0, [r3, #0]
}
    b184:	4770      	bx	lr
	...

0000b188 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
    b188:	4808      	ldr	r0, [pc, #32]	; (b1ac <prvPortStartFirstTask+0x24>)
    b18a:	6800      	ldr	r0, [r0, #0]
    b18c:	6800      	ldr	r0, [r0, #0]
    b18e:	f380 8808 	msr	MSP, r0
    b192:	f04f 0000 	mov.w	r0, #0
    b196:	f380 8814 	msr	CONTROL, r0
    b19a:	b662      	cpsie	i
    b19c:	b661      	cpsie	f
    b19e:	f3bf 8f4f 	dsb	sy
    b1a2:	f3bf 8f6f 	isb	sy
    b1a6:	df00      	svc	0
    b1a8:	bf00      	nop
	               " cpsie f				\n"
	               " dsb					\n"
	               " isb					\n"
	               " svc 0					\n" /* System call to start first task. */
	               " nop					\n");
}
    b1aa:	0000      	.short	0x0000
    b1ac:	e000ed08 	.word	0xe000ed08

0000b1b0 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP(void)
{
	__asm volatile("	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
    b1b0:	f8df 000c 	ldr.w	r0, [pc, #12]	; b1c0 <vPortEnableVFP+0x10>
    b1b4:	6801      	ldr	r1, [r0, #0]
    b1b6:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    b1ba:	6001      	str	r1, [r0, #0]
    b1bc:	4770      	bx	lr
	               "	ldr r1, [r0]				\n"
	               "								\n"
	               "	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
	               "	str r1, [r0]				\n"
	               "	bx r14						");
}
    b1be:	0000      	.short	0x0000
    b1c0:	e000ed88 	.word	0xe000ed88

0000b1c4 <prvTaskExitError>:
{
    b1c4:	b082      	sub	sp, #8
	volatile uint32_t ulDummy = 0;
    b1c6:	2300      	movs	r3, #0
    b1c8:	9301      	str	r3, [sp, #4]
	configASSERT(uxCriticalNesting == ~0UL);
    b1ca:	4b0d      	ldr	r3, [pc, #52]	; (b200 <prvTaskExitError+0x3c>)
    b1cc:	681b      	ldr	r3, [r3, #0]
    b1ce:	3301      	adds	r3, #1
    b1d0:	d008      	beq.n	b1e4 <prvTaskExitError+0x20>

portFORCE_INLINE static void vPortRaiseBASEPRI(void)
{
	uint32_t ulNewBASEPRI;

	__asm volatile("	mov %0, %1												\n"
    b1d2:	f04f 0380 	mov.w	r3, #128	; 0x80
    b1d6:	f383 8811 	msr	BASEPRI, r3
    b1da:	f3bf 8f6f 	isb	sy
    b1de:	f3bf 8f4f 	dsb	sy
    b1e2:	e7fe      	b.n	b1e2 <prvTaskExitError+0x1e>
    b1e4:	f04f 0380 	mov.w	r3, #128	; 0x80
    b1e8:	f383 8811 	msr	BASEPRI, r3
    b1ec:	f3bf 8f6f 	isb	sy
    b1f0:	f3bf 8f4f 	dsb	sy
	while (ulDummy == 0) {
    b1f4:	9b01      	ldr	r3, [sp, #4]
    b1f6:	2b00      	cmp	r3, #0
    b1f8:	d0fc      	beq.n	b1f4 <prvTaskExitError+0x30>
}
    b1fa:	b002      	add	sp, #8
    b1fc:	4770      	bx	lr
    b1fe:	bf00      	nop
    b200:	20000350 	.word	0x20000350

0000b204 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
    b204:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    b208:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
    b20c:	4b07      	ldr	r3, [pc, #28]	; (b22c <pxPortInitialiseStack+0x28>)
    b20e:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* PC */
    b212:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXC_RETURN;
    b216:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* PC */
    b21a:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = (StackType_t)pvParameters; /* R0 */
    b21e:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
    b222:	f840 3c24 	str.w	r3, [r0, #-36]
}
    b226:	3844      	subs	r0, #68	; 0x44
    b228:	4770      	bx	lr
    b22a:	bf00      	nop
    b22c:	0000b1c5 	.word	0x0000b1c5

0000b230 <SVCall_Handler>:
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
    b230:	4b07      	ldr	r3, [pc, #28]	; (b250 <pxCurrentTCBConst2>)
    b232:	6819      	ldr	r1, [r3, #0]
    b234:	6808      	ldr	r0, [r1, #0]
    b236:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b23a:	f380 8809 	msr	PSP, r0
    b23e:	f3bf 8f6f 	isb	sy
    b242:	f04f 0000 	mov.w	r0, #0
    b246:	f380 8811 	msr	BASEPRI, r0
    b24a:	4770      	bx	lr
    b24c:	f3af 8000 	nop.w

0000b250 <pxCurrentTCBConst2>:
    b250:	200090ac 	.word	0x200090ac

0000b254 <vPortEnterCritical>:
    b254:	f04f 0380 	mov.w	r3, #128	; 0x80
    b258:	f383 8811 	msr	BASEPRI, r3
    b25c:	f3bf 8f6f 	isb	sy
    b260:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
    b264:	4a0a      	ldr	r2, [pc, #40]	; (b290 <vPortEnterCritical+0x3c>)
    b266:	6813      	ldr	r3, [r2, #0]
    b268:	3301      	adds	r3, #1
	if (uxCriticalNesting == 1) {
    b26a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
    b26c:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 1) {
    b26e:	d10d      	bne.n	b28c <vPortEnterCritical+0x38>
		configASSERT((portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK) == 0);
    b270:	4b08      	ldr	r3, [pc, #32]	; (b294 <vPortEnterCritical+0x40>)
    b272:	681b      	ldr	r3, [r3, #0]
    b274:	f013 0fff 	tst.w	r3, #255	; 0xff
    b278:	d008      	beq.n	b28c <vPortEnterCritical+0x38>
    b27a:	f04f 0380 	mov.w	r3, #128	; 0x80
    b27e:	f383 8811 	msr	BASEPRI, r3
    b282:	f3bf 8f6f 	isb	sy
    b286:	f3bf 8f4f 	dsb	sy
    b28a:	e7fe      	b.n	b28a <vPortEnterCritical+0x36>
}
    b28c:	4770      	bx	lr
    b28e:	bf00      	nop
    b290:	20000350 	.word	0x20000350
    b294:	e000ed04 	.word	0xe000ed04

0000b298 <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
    b298:	4a08      	ldr	r2, [pc, #32]	; (b2bc <vPortExitCritical+0x24>)
    b29a:	6813      	ldr	r3, [r2, #0]
    b29c:	b943      	cbnz	r3, b2b0 <vPortExitCritical+0x18>
    b29e:	f04f 0380 	mov.w	r3, #128	; 0x80
    b2a2:	f383 8811 	msr	BASEPRI, r3
    b2a6:	f3bf 8f6f 	isb	sy
    b2aa:	f3bf 8f4f 	dsb	sy
    b2ae:	e7fe      	b.n	b2ae <vPortExitCritical+0x16>
	uxCriticalNesting--;
    b2b0:	3b01      	subs	r3, #1
    b2b2:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
    b2b4:	b90b      	cbnz	r3, b2ba <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    b2b6:	f383 8811 	msr	BASEPRI, r3
}
    b2ba:	4770      	bx	lr
    b2bc:	20000350 	.word	0x20000350

0000b2c0 <PendSV_Handler>:
	__asm volatile(
    b2c0:	f3ef 8009 	mrs	r0, PSP
    b2c4:	f3bf 8f6f 	isb	sy
    b2c8:	4b15      	ldr	r3, [pc, #84]	; (b320 <pxCurrentTCBConst>)
    b2ca:	681a      	ldr	r2, [r3, #0]
    b2cc:	f01e 0f10 	tst.w	lr, #16
    b2d0:	bf08      	it	eq
    b2d2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    b2d6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b2da:	6010      	str	r0, [r2, #0]
    b2dc:	e92d 0009 	stmdb	sp!, {r0, r3}
    b2e0:	f04f 0080 	mov.w	r0, #128	; 0x80
    b2e4:	f380 8811 	msr	BASEPRI, r0
    b2e8:	f3bf 8f4f 	dsb	sy
    b2ec:	f3bf 8f6f 	isb	sy
    b2f0:	f007 fb80 	bl	129f4 <vTaskSwitchContext>
    b2f4:	f04f 0000 	mov.w	r0, #0
    b2f8:	f380 8811 	msr	BASEPRI, r0
    b2fc:	bc09      	pop	{r0, r3}
    b2fe:	6819      	ldr	r1, [r3, #0]
    b300:	6808      	ldr	r0, [r1, #0]
    b302:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b306:	f01e 0f10 	tst.w	lr, #16
    b30a:	bf08      	it	eq
    b30c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    b310:	f380 8809 	msr	PSP, r0
    b314:	f3bf 8f6f 	isb	sy
    b318:	4770      	bx	lr
    b31a:	bf00      	nop
    b31c:	f3af 8000 	nop.w

0000b320 <pxCurrentTCBConst>:
    b320:	200090ac 	.word	0x200090ac

0000b324 <SysTick_Handler>:
{
    b324:	b508      	push	{r3, lr}
	__asm volatile("	mov %0, %1												\n"
    b326:	f04f 0380 	mov.w	r3, #128	; 0x80
    b32a:	f383 8811 	msr	BASEPRI, r3
    b32e:	f3bf 8f6f 	isb	sy
    b332:	f3bf 8f4f 	dsb	sy
		if (xTaskIncrementTick() != pdFALSE) {
    b336:	4b05      	ldr	r3, [pc, #20]	; (b34c <SysTick_Handler+0x28>)
    b338:	4798      	blx	r3
    b33a:	b118      	cbz	r0, b344 <SysTick_Handler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    b33c:	4b04      	ldr	r3, [pc, #16]	; (b350 <SysTick_Handler+0x2c>)
    b33e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    b342:	601a      	str	r2, [r3, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    b344:	2300      	movs	r3, #0
    b346:	f383 8811 	msr	BASEPRI, r3
}
    b34a:	bd08      	pop	{r3, pc}
    b34c:	000127a5 	.word	0x000127a5
    b350:	e000ed04 	.word	0xe000ed04

0000b354 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG          = 0UL;
    b354:	4b05      	ldr	r3, [pc, #20]	; (b36c <vPortSetupTimerInterrupt+0x18>)
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    b356:	4906      	ldr	r1, [pc, #24]	; (b370 <vPortSetupTimerInterrupt+0x1c>)
	portNVIC_SYSTICK_CTRL_REG          = 0UL;
    b358:	2200      	movs	r2, #0
    b35a:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    b35c:	600a      	str	r2, [r1, #0]
	portNVIC_SYSTICK_LOAD_REG = (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
    b35e:	4a05      	ldr	r2, [pc, #20]	; (b374 <vPortSetupTimerInterrupt+0x20>)
    b360:	f645 51bf 	movw	r1, #23999	; 0x5dbf
    b364:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = (portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT);
    b366:	2207      	movs	r2, #7
    b368:	601a      	str	r2, [r3, #0]
}
    b36a:	4770      	bx	lr
    b36c:	e000e010 	.word	0xe000e010
    b370:	e000e018 	.word	0xe000e018
    b374:	e000e014 	.word	0xe000e014

0000b378 <xPortStartScheduler>:
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    b378:	4b37      	ldr	r3, [pc, #220]	; (b458 <xPortStartScheduler+0xe0>)
    b37a:	4a38      	ldr	r2, [pc, #224]	; (b45c <xPortStartScheduler+0xe4>)
{
    b37c:	b513      	push	{r0, r1, r4, lr}
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    b37e:	6819      	ldr	r1, [r3, #0]
    b380:	4291      	cmp	r1, r2
    b382:	d108      	bne.n	b396 <xPortStartScheduler+0x1e>
	__asm volatile("	mov %0, %1												\n"
    b384:	f04f 0380 	mov.w	r3, #128	; 0x80
    b388:	f383 8811 	msr	BASEPRI, r3
    b38c:	f3bf 8f6f 	isb	sy
    b390:	f3bf 8f4f 	dsb	sy
    b394:	e7fe      	b.n	b394 <xPortStartScheduler+0x1c>
	configASSERT(portCPUID != portCORTEX_M7_r0p0_ID);
    b396:	681a      	ldr	r2, [r3, #0]
    b398:	4b31      	ldr	r3, [pc, #196]	; (b460 <xPortStartScheduler+0xe8>)
    b39a:	429a      	cmp	r2, r3
    b39c:	d108      	bne.n	b3b0 <xPortStartScheduler+0x38>
    b39e:	f04f 0380 	mov.w	r3, #128	; 0x80
    b3a2:	f383 8811 	msr	BASEPRI, r3
    b3a6:	f3bf 8f6f 	isb	sy
    b3aa:	f3bf 8f4f 	dsb	sy
    b3ae:	e7fe      	b.n	b3ae <xPortStartScheduler+0x36>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    b3b0:	4b2c      	ldr	r3, [pc, #176]	; (b464 <xPortStartScheduler+0xec>)
    b3b2:	781a      	ldrb	r2, [r3, #0]
    b3b4:	b2d2      	uxtb	r2, r2
    b3b6:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    b3b8:	22ff      	movs	r2, #255	; 0xff
    b3ba:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    b3bc:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    b3be:	4a2a      	ldr	r2, [pc, #168]	; (b468 <xPortStartScheduler+0xf0>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    b3c0:	b2db      	uxtb	r3, r3
    b3c2:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    b3c6:	f89d 3003 	ldrb.w	r3, [sp, #3]
    b3ca:	f003 0380 	and.w	r3, r3, #128	; 0x80
    b3ce:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    b3d0:	2307      	movs	r3, #7
    b3d2:	6053      	str	r3, [r2, #4]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
    b3d4:	2100      	movs	r1, #0
    b3d6:	f89d 0003 	ldrb.w	r0, [sp, #3]
    b3da:	0600      	lsls	r0, r0, #24
    b3dc:	f103 34ff 	add.w	r4, r3, #4294967295	; 0xffffffff
    b3e0:	d40c      	bmi.n	b3fc <xPortStartScheduler+0x84>
    b3e2:	b111      	cbz	r1, b3ea <xPortStartScheduler+0x72>
			configASSERT((portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue) == configPRIO_BITS);
    b3e4:	2b04      	cmp	r3, #4
    b3e6:	6053      	str	r3, [r2, #4]
    b3e8:	d011      	beq.n	b40e <xPortStartScheduler+0x96>
    b3ea:	f04f 0380 	mov.w	r3, #128	; 0x80
    b3ee:	f383 8811 	msr	BASEPRI, r3
    b3f2:	f3bf 8f6f 	isb	sy
    b3f6:	f3bf 8f4f 	dsb	sy
    b3fa:	e7fe      	b.n	b3fa <xPortStartScheduler+0x82>
			ucMaxPriorityValue <<= (uint8_t)0x01;
    b3fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
    b400:	005b      	lsls	r3, r3, #1
    b402:	b2db      	uxtb	r3, r3
    b404:	f88d 3003 	strb.w	r3, [sp, #3]
    b408:	2101      	movs	r1, #1
    b40a:	4623      	mov	r3, r4
    b40c:	e7e3      	b.n	b3d6 <xPortStartScheduler+0x5e>
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    b40e:	f44f 6380 	mov.w	r3, #1024	; 0x400
    b412:	6053      	str	r3, [r2, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    b414:	9b01      	ldr	r3, [sp, #4]
    b416:	4a13      	ldr	r2, [pc, #76]	; (b464 <xPortStartScheduler+0xec>)
    b418:	b2db      	uxtb	r3, r3
    b41a:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    b41c:	4b13      	ldr	r3, [pc, #76]	; (b46c <xPortStartScheduler+0xf4>)
    b41e:	681a      	ldr	r2, [r3, #0]
    b420:	f442 0260 	orr.w	r2, r2, #14680064	; 0xe00000
    b424:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
    b426:	681a      	ldr	r2, [r3, #0]
    b428:	f042 4260 	orr.w	r2, r2, #3758096384	; 0xe0000000
    b42c:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
    b42e:	4b10      	ldr	r3, [pc, #64]	; (b470 <xPortStartScheduler+0xf8>)
    b430:	4798      	blx	r3
	uxCriticalNesting = 0;
    b432:	4b10      	ldr	r3, [pc, #64]	; (b474 <xPortStartScheduler+0xfc>)
    b434:	2400      	movs	r4, #0
    b436:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
    b438:	4b0f      	ldr	r3, [pc, #60]	; (b478 <xPortStartScheduler+0x100>)
    b43a:	4798      	blx	r3
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
    b43c:	4a0f      	ldr	r2, [pc, #60]	; (b47c <xPortStartScheduler+0x104>)
    b43e:	6813      	ldr	r3, [r2, #0]
    b440:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    b444:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
    b446:	4b0e      	ldr	r3, [pc, #56]	; (b480 <xPortStartScheduler+0x108>)
    b448:	4798      	blx	r3
	vTaskSwitchContext();
    b44a:	4b0e      	ldr	r3, [pc, #56]	; (b484 <xPortStartScheduler+0x10c>)
    b44c:	4798      	blx	r3
	prvTaskExitError();
    b44e:	4b0e      	ldr	r3, [pc, #56]	; (b488 <xPortStartScheduler+0x110>)
    b450:	4798      	blx	r3
}
    b452:	4620      	mov	r0, r4
    b454:	b002      	add	sp, #8
    b456:	bd10      	pop	{r4, pc}
    b458:	e000ed00 	.word	0xe000ed00
    b45c:	410fc271 	.word	0x410fc271
    b460:	410fc270 	.word	0x410fc270
    b464:	e000e400 	.word	0xe000e400
    b468:	20000800 	.word	0x20000800
    b46c:	e000ed20 	.word	0xe000ed20
    b470:	0000b355 	.word	0x0000b355
    b474:	20000350 	.word	0x20000350
    b478:	0000b1b1 	.word	0x0000b1b1
    b47c:	e000ef34 	.word	0xe000ef34
    b480:	0000b189 	.word	0x0000b189
    b484:	000129f5 	.word	0x000129f5
    b488:	0000b1c5 	.word	0x0000b1c5

0000b48c <vPortValidateInterruptPriority>:
{
	uint32_t ulCurrentInterrupt;
	uint8_t  ucCurrentPriority;

	/* Obtain the number of the currently executing interrupt. */
	__asm volatile("mrs %0, ipsr" : "=r"(ulCurrentInterrupt)::"memory");
    b48c:	f3ef 8305 	mrs	r3, IPSR

	/* Is the interrupt number a user defined interrupt? */
	if (ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER) {
    b490:	2b0f      	cmp	r3, #15
    b492:	4a10      	ldr	r2, [pc, #64]	; (b4d4 <vPortValidateInterruptPriority+0x48>)
    b494:	d90d      	bls.n	b4b2 <vPortValidateInterruptPriority+0x26>
		/* Look up the interrupt's priority. */
		ucCurrentPriority = pcInterruptPriorityRegisters[ulCurrentInterrupt];
    b496:	4910      	ldr	r1, [pc, #64]	; (b4d8 <vPortValidateInterruptPriority+0x4c>)
    b498:	5c5b      	ldrb	r3, [r3, r1]
		interrupt entry is as fast and simple as possible.

		The following links provide detailed information:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html
		http://www.freertos.org/FAQHelp.html */
		configASSERT(ucCurrentPriority >= ucMaxSysCallPriority);
    b49a:	7811      	ldrb	r1, [r2, #0]
    b49c:	4299      	cmp	r1, r3
    b49e:	d908      	bls.n	b4b2 <vPortValidateInterruptPriority+0x26>
    b4a0:	f04f 0380 	mov.w	r3, #128	; 0x80
    b4a4:	f383 8811 	msr	BASEPRI, r3
    b4a8:	f3bf 8f6f 	isb	sy
    b4ac:	f3bf 8f4f 	dsb	sy
    b4b0:	e7fe      	b.n	b4b0 <vPortValidateInterruptPriority+0x24>
	configuration then the correct setting can be achieved on all Cortex-M
	devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
	scheduler.  Note however that some vendor specific peripheral libraries
	assume a non-zero priority group setting, in which cases using a value
	of zero will result in unpredictable behaviour. */
	configASSERT((portAIRCR_REG & portPRIORITY_GROUP_MASK) <= ulMaxPRIGROUPValue);
    b4b2:	4b0a      	ldr	r3, [pc, #40]	; (b4dc <vPortValidateInterruptPriority+0x50>)
    b4b4:	6852      	ldr	r2, [r2, #4]
    b4b6:	681b      	ldr	r3, [r3, #0]
    b4b8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    b4bc:	4293      	cmp	r3, r2
    b4be:	d908      	bls.n	b4d2 <vPortValidateInterruptPriority+0x46>
    b4c0:	f04f 0380 	mov.w	r3, #128	; 0x80
    b4c4:	f383 8811 	msr	BASEPRI, r3
    b4c8:	f3bf 8f6f 	isb	sy
    b4cc:	f3bf 8f4f 	dsb	sy
    b4d0:	e7fe      	b.n	b4d0 <vPortValidateInterruptPriority+0x44>
}
    b4d2:	4770      	bx	lr
    b4d4:	20000800 	.word	0x20000800
    b4d8:	e000e3f0 	.word	0xe000e3f0
    b4dc:	e000ed0c 	.word	0xe000ed0c

0000b4e0 <i2c_m_async_write>:

/**
 * \brief Async version of I2C I/O write
 */
static int32_t i2c_m_async_write(struct io_descriptor *const io, const uint8_t *buf, const uint16_t n)
{
    b4e0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct i2c_m_async_desc *i2c = CONTAINER_OF(io, struct i2c_m_async_desc, io);
	struct _i2c_m_msg        msg;
	int32_t                  ret;

	msg.addr   = i2c->slave_addr;
    b4e2:	8a83      	ldrh	r3, [r0, #20]
    b4e4:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
	msg.flags  = I2C_M_STOP;
    b4e8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    b4ec:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = (uint8_t *)buf;
    b4f0:	9103      	str	r1, [sp, #12]

	/* start transfer then return */
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b4f2:	4b05      	ldr	r3, [pc, #20]	; (b508 <i2c_m_async_write+0x28>)
	msg.len    = n;
    b4f4:	9202      	str	r2, [sp, #8]
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b4f6:	a901      	add	r1, sp, #4
    b4f8:	3828      	subs	r0, #40	; 0x28
{
    b4fa:	4614      	mov	r4, r2
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b4fc:	4798      	blx	r3
		/* error occurred */
		return ret;
	}

	return (int32_t)n;
}
    b4fe:	2800      	cmp	r0, #0
    b500:	bf08      	it	eq
    b502:	4620      	moveq	r0, r4
    b504:	b004      	add	sp, #16
    b506:	bd10      	pop	{r4, pc}
    b508:	00011169 	.word	0x00011169

0000b50c <i2c_m_async_read>:
{
    b50c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	msg.addr   = i2c->slave_addr;
    b50e:	8a83      	ldrh	r3, [r0, #20]
    b510:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
    b514:	f248 0301 	movw	r3, #32769	; 0x8001
    b518:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = buf;
    b51c:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b51e:	4b05      	ldr	r3, [pc, #20]	; (b534 <i2c_m_async_read+0x28>)
	msg.len    = n;
    b520:	9202      	str	r2, [sp, #8]
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b522:	a901      	add	r1, sp, #4
    b524:	3828      	subs	r0, #40	; 0x28
{
    b526:	4614      	mov	r4, r2
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b528:	4798      	blx	r3
}
    b52a:	2800      	cmp	r0, #0
    b52c:	bf08      	it	eq
    b52e:	4620      	moveq	r0, r4
    b530:	b004      	add	sp, #16
    b532:	bd10      	pop	{r4, pc}
    b534:	00011169 	.word	0x00011169

0000b538 <i2c_tx_complete>:
	if (!(i2c_dev->service.msg.flags & I2C_M_BUSY)) {
    b538:	8842      	ldrh	r2, [r0, #2]
    b53a:	05d2      	lsls	r2, r2, #23
    b53c:	d402      	bmi.n	b544 <i2c_tx_complete+0xc>
		if (i2c->i2c_cb.tx_complete) {
    b53e:	6b43      	ldr	r3, [r0, #52]	; 0x34
    b540:	b103      	cbz	r3, b544 <i2c_tx_complete+0xc>
			i2c->i2c_cb.tx_complete(i2c);
    b542:	4718      	bx	r3
}
    b544:	4770      	bx	lr

0000b546 <i2c_rx_complete>:
	if (!(i2c_dev->service.msg.flags & I2C_M_BUSY)) {
    b546:	8842      	ldrh	r2, [r0, #2]
    b548:	05d2      	lsls	r2, r2, #23
    b54a:	d402      	bmi.n	b552 <i2c_rx_complete+0xc>
		if (i2c->i2c_cb.rx_complete) {
    b54c:	6b83      	ldr	r3, [r0, #56]	; 0x38
    b54e:	b103      	cbz	r3, b552 <i2c_rx_complete+0xc>
			i2c->i2c_cb.rx_complete(i2c);
    b550:	4718      	bx	r3
}
    b552:	4770      	bx	lr

0000b554 <i2c_error>:
	if (!(i2c_dev->service.msg.flags & I2C_M_BUSY)) {
    b554:	8842      	ldrh	r2, [r0, #2]
    b556:	05d2      	lsls	r2, r2, #23
    b558:	d402      	bmi.n	b560 <i2c_error+0xc>
		if (i2c->i2c_cb.error) {
    b55a:	6b03      	ldr	r3, [r0, #48]	; 0x30
    b55c:	b103      	cbz	r3, b560 <i2c_error+0xc>
			i2c->i2c_cb.error(i2c, error);
    b55e:	4718      	bx	r3
}
    b560:	4770      	bx	lr
	...

0000b564 <i2c_m_async_init>:

/**
 * \brief Async version of i2c initialize
 */
int32_t i2c_m_async_init(struct i2c_m_async_desc *const i2c, void *const hw)
{
    b564:	b570      	push	{r4, r5, r6, lr}
	int32_t init_status;
	ASSERT(i2c);
    b566:	4604      	mov	r4, r0
    b568:	3800      	subs	r0, #0
{
    b56a:	460d      	mov	r5, r1
	ASSERT(i2c);
    b56c:	bf18      	it	ne
    b56e:	2001      	movne	r0, #1
    b570:	490e      	ldr	r1, [pc, #56]	; (b5ac <i2c_m_async_init+0x48>)
    b572:	4b0f      	ldr	r3, [pc, #60]	; (b5b0 <i2c_m_async_init+0x4c>)
    b574:	2289      	movs	r2, #137	; 0x89
    b576:	4798      	blx	r3

	init_status = _i2c_m_async_init(&i2c->device, hw);
    b578:	4629      	mov	r1, r5
    b57a:	4b0e      	ldr	r3, [pc, #56]	; (b5b4 <i2c_m_async_init+0x50>)
    b57c:	4620      	mov	r0, r4
    b57e:	4798      	blx	r3
	if (init_status) {
    b580:	4605      	mov	r5, r0
    b582:	b980      	cbnz	r0, b5a6 <i2c_m_async_init+0x42>
		return init_status;
	}
	/* Init I/O */
	i2c->io.read  = i2c_m_async_read;
    b584:	4b0c      	ldr	r3, [pc, #48]	; (b5b8 <i2c_m_async_init+0x54>)
    b586:	62e3      	str	r3, [r4, #44]	; 0x2c
	i2c->io.write = i2c_m_async_write;
    b588:	4b0c      	ldr	r3, [pc, #48]	; (b5bc <i2c_m_async_init+0x58>)

	/* Init callbacks */
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_TX_COMPLETE, (FUNC_PTR)i2c_tx_complete);
    b58a:	4a0d      	ldr	r2, [pc, #52]	; (b5c0 <i2c_m_async_init+0x5c>)
    b58c:	4e0d      	ldr	r6, [pc, #52]	; (b5c4 <i2c_m_async_init+0x60>)
	i2c->io.write = i2c_m_async_write;
    b58e:	62a3      	str	r3, [r4, #40]	; 0x28
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_TX_COMPLETE, (FUNC_PTR)i2c_tx_complete);
    b590:	2101      	movs	r1, #1
    b592:	4620      	mov	r0, r4
    b594:	47b0      	blx	r6
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_RX_COMPLETE, (FUNC_PTR)i2c_rx_complete);
    b596:	4a0c      	ldr	r2, [pc, #48]	; (b5c8 <i2c_m_async_init+0x64>)
    b598:	2102      	movs	r1, #2
    b59a:	4620      	mov	r0, r4
    b59c:	47b0      	blx	r6
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_ERROR, (FUNC_PTR)i2c_error);
    b59e:	4a0b      	ldr	r2, [pc, #44]	; (b5cc <i2c_m_async_init+0x68>)
    b5a0:	4629      	mov	r1, r5
    b5a2:	4620      	mov	r0, r4
    b5a4:	47b0      	blx	r6

	return ERR_NONE;
}
    b5a6:	4628      	mov	r0, r5
    b5a8:	bd70      	pop	{r4, r5, r6, pc}
    b5aa:	bf00      	nop
    b5ac:	000160e0 	.word	0x000160e0
    b5b0:	0000e03d 	.word	0x0000e03d
    b5b4:	000110ed 	.word	0x000110ed
    b5b8:	0000b50d 	.word	0x0000b50d
    b5bc:	0000b4e1 	.word	0x0000b4e1
    b5c0:	0000b539 	.word	0x0000b539
    b5c4:	00011271 	.word	0x00011271
    b5c8:	0000b547 	.word	0x0000b547
    b5cc:	0000b555 	.word	0x0000b555

0000b5d0 <prvInsertBlockIntoFreeList>:
	BlockLink_t *pxIterator;
	uint8_t *    puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for (pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert;
    b5d0:	4b0f      	ldr	r3, [pc, #60]	; (b610 <prvInsertBlockIntoFreeList+0x40>)
{
    b5d2:	b530      	push	{r4, r5, lr}
    b5d4:	461d      	mov	r5, r3
	for (pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert;
    b5d6:	461a      	mov	r2, r3
    b5d8:	681b      	ldr	r3, [r3, #0]
    b5da:	4283      	cmp	r3, r0
    b5dc:	d3fb      	bcc.n	b5d6 <prvInsertBlockIntoFreeList+0x6>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = (uint8_t *)pxIterator;
	if ((puc + pxIterator->xBlockSize) == (uint8_t *)pxBlockToInsert) {
    b5de:	6854      	ldr	r4, [r2, #4]
    b5e0:	1911      	adds	r1, r2, r4
    b5e2:	4288      	cmp	r0, r1
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    b5e4:	bf01      	itttt	eq
    b5e6:	6841      	ldreq	r1, [r0, #4]
    b5e8:	4610      	moveq	r0, r2
    b5ea:	1909      	addeq	r1, r1, r4
    b5ec:	6051      	streq	r1, [r2, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = (uint8_t *)pxBlockToInsert;
	if ((puc + pxBlockToInsert->xBlockSize) == (uint8_t *)pxIterator->pxNextFreeBlock) {
    b5ee:	6844      	ldr	r4, [r0, #4]
    b5f0:	1901      	adds	r1, r0, r4
    b5f2:	428b      	cmp	r3, r1
    b5f4:	d106      	bne.n	b604 <prvInsertBlockIntoFreeList+0x34>
		if (pxIterator->pxNextFreeBlock != pxEnd) {
    b5f6:	68a9      	ldr	r1, [r5, #8]
    b5f8:	428b      	cmp	r3, r1
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    b5fa:	bf1f      	itttt	ne
    b5fc:	6859      	ldrne	r1, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    b5fe:	681b      	ldrne	r3, [r3, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    b600:	1909      	addne	r1, r1, r4
    b602:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if (pxIterator != pxBlockToInsert) {
    b604:	4290      	cmp	r0, r2
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    b606:	6003      	str	r3, [r0, #0]
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    b608:	bf18      	it	ne
    b60a:	6010      	strne	r0, [r2, #0]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}
}
    b60c:	bd30      	pop	{r4, r5, pc}
    b60e:	bf00      	nop
    b610:	20000808 	.word	0x20000808

0000b614 <pvPortMalloc>:
{
    b614:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if (pxEnd == NULL) {
    b618:	4d39      	ldr	r5, [pc, #228]	; (b700 <pvPortMalloc+0xec>)
	vTaskSuspendAll();
    b61a:	4b3a      	ldr	r3, [pc, #232]	; (b704 <pvPortMalloc+0xf0>)
{
    b61c:	4604      	mov	r4, r0
	vTaskSuspendAll();
    b61e:	4798      	blx	r3
		if (pxEnd == NULL) {
    b620:	68ab      	ldr	r3, [r5, #8]
    b622:	b9bb      	cbnz	r3, b654 <pvPortMalloc+0x40>
	uxAddress = (size_t)ucHeap;
    b624:	4a38      	ldr	r2, [pc, #224]	; (b708 <pvPortMalloc+0xf4>)
	uxAddress -= xHeapStructSize;
    b626:	4b39      	ldr	r3, [pc, #228]	; (b70c <pvPortMalloc+0xf8>)
	if ((uxAddress & portBYTE_ALIGNMENT_MASK) != 0) {
    b628:	0756      	lsls	r6, r2, #29
		uxAddress += (portBYTE_ALIGNMENT - 1);
    b62a:	bf18      	it	ne
    b62c:	3207      	addne	r2, #7
	uxAddress &= ~((size_t)portBYTE_ALIGNMENT_MASK);
    b62e:	f023 0307 	bic.w	r3, r3, #7
		uxAddress &= ~((size_t)portBYTE_ALIGNMENT_MASK);
    b632:	bf18      	it	ne
    b634:	f022 0207 	bicne.w	r2, r2, #7
	xStart.xBlockSize      = (size_t)0;
    b638:	2100      	movs	r1, #0
    b63a:	6069      	str	r1, [r5, #4]
	xStart.pxNextFreeBlock = (void *)pucAlignedHeap;
    b63c:	602a      	str	r2, [r5, #0]
	pxEnd->pxNextFreeBlock = NULL;
    b63e:	e9c3 1100 	strd	r1, r1, [r3]
	pxFirstFreeBlock->xBlockSize      = uxAddress - (size_t)pxFirstFreeBlock;
    b642:	1a99      	subs	r1, r3, r2
	xFreeBytesRemaining            = pxFirstFreeBlock->xBlockSize;
    b644:	e9c5 1103 	strd	r1, r1, [r5, #12]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    b648:	e9c2 3100 	strd	r3, r1, [r2]
	pxEnd                  = (void *)uxAddress;
    b64c:	60ab      	str	r3, [r5, #8]
	xBlockAllocatedBit = ((size_t)1) << ((sizeof(size_t) * heapBITS_PER_BYTE) - 1);
    b64e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    b652:	616b      	str	r3, [r5, #20]
		if ((xWantedSize & xBlockAllocatedBit) == 0) {
    b654:	f8d5 8014 	ldr.w	r8, [r5, #20]
    b658:	ea18 0f04 	tst.w	r8, r4
    b65c:	d14b      	bne.n	b6f6 <pvPortMalloc+0xe2>
			if (xWantedSize > 0) {
    b65e:	2c00      	cmp	r4, #0
    b660:	d03c      	beq.n	b6dc <pvPortMalloc+0xc8>
				xWantedSize += xHeapStructSize;
    b662:	f104 0308 	add.w	r3, r4, #8
				if ((xWantedSize & portBYTE_ALIGNMENT_MASK) != 0x00) {
    b666:	0760      	lsls	r0, r4, #29
					xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
    b668:	bf1c      	itt	ne
    b66a:	f023 0307 	bicne.w	r3, r3, #7
    b66e:	3308      	addne	r3, #8
			if ((xWantedSize > 0) && (xWantedSize <= xFreeBytesRemaining)) {
    b670:	2b00      	cmp	r3, #0
    b672:	d040      	beq.n	b6f6 <pvPortMalloc+0xe2>
    b674:	692f      	ldr	r7, [r5, #16]
    b676:	429f      	cmp	r7, r3
    b678:	d33d      	bcc.n	b6f6 <pvPortMalloc+0xe2>
				pxBlock         = xStart.pxNextFreeBlock;
    b67a:	682e      	ldr	r6, [r5, #0]
				pxPreviousBlock = &xStart;
    b67c:	4820      	ldr	r0, [pc, #128]	; (b700 <pvPortMalloc+0xec>)
				while ((pxBlock->xBlockSize < xWantedSize) && (pxBlock->pxNextFreeBlock != NULL)) {
    b67e:	6872      	ldr	r2, [r6, #4]
    b680:	429a      	cmp	r2, r3
    b682:	d201      	bcs.n	b688 <pvPortMalloc+0x74>
    b684:	6831      	ldr	r1, [r6, #0]
    b686:	b9a1      	cbnz	r1, b6b2 <pvPortMalloc+0x9e>
				if (pxBlock != pxEnd) {
    b688:	68a9      	ldr	r1, [r5, #8]
    b68a:	42b1      	cmp	r1, r6
    b68c:	d033      	beq.n	b6f6 <pvPortMalloc+0xe2>
					if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    b68e:	1ad2      	subs	r2, r2, r3
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    b690:	6831      	ldr	r1, [r6, #0]
					pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + xHeapStructSize);
    b692:	6804      	ldr	r4, [r0, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    b694:	6001      	str	r1, [r0, #0]
					if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    b696:	2a10      	cmp	r2, #16
    b698:	d912      	bls.n	b6c0 <pvPortMalloc+0xac>
						pxNewBlockLink = (void *)(((uint8_t *)pxBlock) + xWantedSize);
    b69a:	18f0      	adds	r0, r6, r3
						configASSERT((((size_t)pxNewBlockLink) & portBYTE_ALIGNMENT_MASK) == 0);
    b69c:	0741      	lsls	r1, r0, #29
    b69e:	d00b      	beq.n	b6b8 <pvPortMalloc+0xa4>
    b6a0:	f04f 0380 	mov.w	r3, #128	; 0x80
    b6a4:	f383 8811 	msr	BASEPRI, r3
    b6a8:	f3bf 8f6f 	isb	sy
    b6ac:	f3bf 8f4f 	dsb	sy
    b6b0:	e7fe      	b.n	b6b0 <pvPortMalloc+0x9c>
    b6b2:	4630      	mov	r0, r6
    b6b4:	460e      	mov	r6, r1
    b6b6:	e7e2      	b.n	b67e <pvPortMalloc+0x6a>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    b6b8:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize        = xWantedSize;
    b6ba:	6073      	str	r3, [r6, #4]
						prvInsertBlockIntoFreeList(pxNewBlockLink);
    b6bc:	4b14      	ldr	r3, [pc, #80]	; (b710 <pvPortMalloc+0xfc>)
    b6be:	4798      	blx	r3
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    b6c0:	6873      	ldr	r3, [r6, #4]
					if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
    b6c2:	68e9      	ldr	r1, [r5, #12]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    b6c4:	1aff      	subs	r7, r7, r3
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    b6c6:	ea48 0303 	orr.w	r3, r8, r3
					if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
    b6ca:	428f      	cmp	r7, r1
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    b6cc:	6073      	str	r3, [r6, #4]
					pxBlock->pxNextFreeBlock = NULL;
    b6ce:	f04f 0300 	mov.w	r3, #0
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    b6d2:	612f      	str	r7, [r5, #16]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    b6d4:	bf38      	it	cc
    b6d6:	60ef      	strcc	r7, [r5, #12]
					pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + xHeapStructSize);
    b6d8:	3408      	adds	r4, #8
					pxBlock->pxNextFreeBlock = NULL;
    b6da:	6033      	str	r3, [r6, #0]
	(void)xTaskResumeAll();
    b6dc:	4b0d      	ldr	r3, [pc, #52]	; (b714 <pvPortMalloc+0x100>)
    b6de:	4798      	blx	r3
	configASSERT((((size_t)pvReturn) & (size_t)portBYTE_ALIGNMENT_MASK) == 0);
    b6e0:	0763      	lsls	r3, r4, #29
    b6e2:	d00a      	beq.n	b6fa <pvPortMalloc+0xe6>
    b6e4:	f04f 0380 	mov.w	r3, #128	; 0x80
    b6e8:	f383 8811 	msr	BASEPRI, r3
    b6ec:	f3bf 8f6f 	isb	sy
    b6f0:	f3bf 8f4f 	dsb	sy
    b6f4:	e7fe      	b.n	b6f4 <pvPortMalloc+0xe0>
	void *       pvReturn = NULL;
    b6f6:	2400      	movs	r4, #0
    b6f8:	e7f0      	b.n	b6dc <pvPortMalloc+0xc8>
}
    b6fa:	4620      	mov	r0, r4
    b6fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b700:	20000808 	.word	0x20000808
    b704:	00012761 	.word	0x00012761
    b708:	20000820 	.word	0x20000820
    b70c:	20008518 	.word	0x20008518
    b710:	0000b5d1 	.word	0x0000b5d1
    b714:	000128a9 	.word	0x000128a9

0000b718 <vPortFree>:
{
    b718:	b570      	push	{r4, r5, r6, lr}
	if (pv != NULL) {
    b71a:	4604      	mov	r4, r0
    b71c:	b368      	cbz	r0, b77a <vPortFree+0x62>
		configASSERT((pxLink->xBlockSize & xBlockAllocatedBit) != 0);
    b71e:	4d17      	ldr	r5, [pc, #92]	; (b77c <vPortFree+0x64>)
    b720:	f850 3c04 	ldr.w	r3, [r0, #-4]
    b724:	696a      	ldr	r2, [r5, #20]
    b726:	4213      	tst	r3, r2
    b728:	d108      	bne.n	b73c <vPortFree+0x24>
    b72a:	f04f 0380 	mov.w	r3, #128	; 0x80
    b72e:	f383 8811 	msr	BASEPRI, r3
    b732:	f3bf 8f6f 	isb	sy
    b736:	f3bf 8f4f 	dsb	sy
    b73a:	e7fe      	b.n	b73a <vPortFree+0x22>
		configASSERT(pxLink->pxNextFreeBlock == NULL);
    b73c:	f850 1c08 	ldr.w	r1, [r0, #-8]
    b740:	b141      	cbz	r1, b754 <vPortFree+0x3c>
    b742:	f04f 0380 	mov.w	r3, #128	; 0x80
    b746:	f383 8811 	msr	BASEPRI, r3
    b74a:	f3bf 8f6f 	isb	sy
    b74e:	f3bf 8f4f 	dsb	sy
    b752:	e7fe      	b.n	b752 <vPortFree+0x3a>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    b754:	ea23 0302 	bic.w	r3, r3, r2
    b758:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
    b75c:	4b08      	ldr	r3, [pc, #32]	; (b780 <vPortFree+0x68>)
    b75e:	4798      	blx	r3
					xFreeBytesRemaining += pxLink->xBlockSize;
    b760:	692a      	ldr	r2, [r5, #16]
    b762:	f854 3c04 	ldr.w	r3, [r4, #-4]
    b766:	4413      	add	r3, r2
    b768:	612b      	str	r3, [r5, #16]
					prvInsertBlockIntoFreeList(((BlockLink_t *)pxLink));
    b76a:	f1a4 0008 	sub.w	r0, r4, #8
    b76e:	4b05      	ldr	r3, [pc, #20]	; (b784 <vPortFree+0x6c>)
    b770:	4798      	blx	r3
}
    b772:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				(void)xTaskResumeAll();
    b776:	4b04      	ldr	r3, [pc, #16]	; (b788 <vPortFree+0x70>)
    b778:	4718      	bx	r3
}
    b77a:	bd70      	pop	{r4, r5, r6, pc}
    b77c:	20000808 	.word	0x20000808
    b780:	00012761 	.word	0x00012761
    b784:	0000b5d1 	.word	0x0000b5d1
    b788:	000128a9 	.word	0x000128a9

0000b78c <_wdt_init>:

/**
 * \brief WDT initialization function
 */
int32_t _wdt_init(struct wdt_dev *const dev)
{
    b78c:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	ASSERT(dev && dev->hw);
    b78e:	4604      	mov	r4, r0
    b790:	b118      	cbz	r0, b79a <_wdt_init+0xe>
    b792:	6800      	ldr	r0, [r0, #0]
    b794:	3800      	subs	r0, #0
    b796:	bf18      	it	ne
    b798:	2001      	movne	r0, #1
    b79a:	4b12      	ldr	r3, [pc, #72]	; (b7e4 <_wdt_init+0x58>)
    b79c:	4912      	ldr	r1, [pc, #72]	; (b7e8 <_wdt_init+0x5c>)
    b79e:	2250      	movs	r2, #80	; 0x50
    b7a0:	4798      	blx	r3

	if (hri_wdt_get_CTRLA_ALWAYSON_bit(dev->hw) || hri_wdt_get_CTRLA_ENABLE_bit(dev->hw)) {
    b7a2:	6823      	ldr	r3, [r4, #0]
typedef uint8_t  hri_wdt_intenset_reg_t;
typedef uint8_t  hri_wdt_intflag_reg_t;

static inline void hri_wdt_wait_for_sync(const void *const hw, hri_wdt_syncbusy_reg_t reg)
{
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    b7a4:	689a      	ldr	r2, [r3, #8]
    b7a6:	f012 0f0e 	tst.w	r2, #14
    b7aa:	d1fb      	bne.n	b7a4 <_wdt_init+0x18>

static inline bool hri_wdt_get_CTRLA_ALWAYSON_bit(const void *const hw)
{
	uint8_t tmp;
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
	tmp = ((Wdt *)hw)->CTRLA.reg;
    b7ac:	781a      	ldrb	r2, [r3, #0]
    b7ae:	09d2      	lsrs	r2, r2, #7
    b7b0:	d115      	bne.n	b7de <_wdt_init+0x52>
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    b7b2:	689a      	ldr	r2, [r3, #8]
    b7b4:	f012 0f0e 	tst.w	r2, #14
    b7b8:	d1fb      	bne.n	b7b2 <_wdt_init+0x26>
	tmp = ((Wdt *)hw)->CTRLA.reg;
    b7ba:	781a      	ldrb	r2, [r3, #0]
    b7bc:	0792      	lsls	r2, r2, #30
    b7be:	d40e      	bmi.n	b7de <_wdt_init+0x52>
	((Wdt *)hw)->CTRLA.reg &= ~WDT_CTRLA_WEN;
    b7c0:	781a      	ldrb	r2, [r3, #0]
    b7c2:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
    b7c6:	701a      	strb	r2, [r3, #0]
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    b7c8:	6898      	ldr	r0, [r3, #8]
    b7ca:	f010 000e 	ands.w	r0, r0, #14
    b7ce:	d1fb      	bne.n	b7c8 <_wdt_init+0x3c>

static inline void hri_wdt_write_CONFIG_PER_bf(const void *const hw, hri_wdt_config_reg_t data)
{
	uint8_t tmp;
	WDT_CRITICAL_SECTION_ENTER();
	tmp = ((Wdt *)hw)->CONFIG.reg;
    b7d0:	785a      	ldrb	r2, [r3, #1]
	tmp &= ~WDT_CONFIG_PER_Msk;
    b7d2:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= WDT_CONFIG_PER(data);
    b7d6:	f042 020b 	orr.w	r2, r2, #11
	((Wdt *)hw)->CONFIG.reg = tmp;
    b7da:	705a      	strb	r2, [r3, #1]

		hri_wdt_write_CONFIG_PER_bf(dev->hw, CONF_WDT_PER);
	}

	return ERR_NONE;
}
    b7dc:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
    b7de:	f06f 0010 	mvn.w	r0, #16
    b7e2:	e7fb      	b.n	b7dc <_wdt_init+0x50>
    b7e4:	0000e03d 	.word	0x0000e03d
    b7e8:	000160fd 	.word	0x000160fd

0000b7ec <usb_find_desc>:
#define _param_error_check(cond) ASSERT(cond)
#define _desc_len_check() ASSERT(usb_desc_len(desc) >= 2)
#endif

uint8_t *usb_find_desc(uint8_t *desc, uint8_t *eof, uint8_t type)
{
    b7ec:	b510      	push	{r4, lr}
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    b7ee:	4288      	cmp	r0, r1
    b7f0:	d301      	bcc.n	b7f6 <usb_find_desc+0xa>
		_desc_len_check();
    b7f2:	2000      	movs	r0, #0
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
}
    b7f4:	bd10      	pop	{r4, pc}
		_desc_len_check();
    b7f6:	7803      	ldrb	r3, [r0, #0]
    b7f8:	2b01      	cmp	r3, #1
    b7fa:	d9fa      	bls.n	b7f2 <usb_find_desc+0x6>
		if (type == usb_desc_type(desc)) {
    b7fc:	7844      	ldrb	r4, [r0, #1]
    b7fe:	4294      	cmp	r4, r2
    b800:	d0f8      	beq.n	b7f4 <usb_find_desc+0x8>
    b802:	4418      	add	r0, r3
    b804:	e7f3      	b.n	b7ee <usb_find_desc+0x2>

0000b806 <usb_find_ep_desc>:

uint8_t *usb_find_ep_desc(uint8_t *desc, uint8_t *eof)
{
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    b806:	4288      	cmp	r0, r1
    b808:	d301      	bcc.n	b80e <usb_find_ep_desc+0x8>
		_desc_len_check();
    b80a:	2000      	movs	r0, #0
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
}
    b80c:	4770      	bx	lr
		_desc_len_check();
    b80e:	7803      	ldrb	r3, [r0, #0]
    b810:	2b01      	cmp	r3, #1
    b812:	d9fa      	bls.n	b80a <usb_find_ep_desc+0x4>
	return desc[1];
    b814:	7842      	ldrb	r2, [r0, #1]
		if (USB_DT_INTERFACE == usb_desc_type(desc)) {
    b816:	2a04      	cmp	r2, #4
    b818:	d0f7      	beq.n	b80a <usb_find_ep_desc+0x4>
		if (USB_DT_ENDPOINT == usb_desc_type(desc)) {
    b81a:	2a05      	cmp	r2, #5
    b81c:	d0f6      	beq.n	b80c <usb_find_ep_desc+0x6>
	return (desc + usb_desc_len(desc));
    b81e:	4418      	add	r0, r3
    b820:	e7f1      	b.n	b806 <usb_find_ep_desc>
	...

0000b824 <usb_find_cfg_desc>:

uint8_t *usb_find_cfg_desc(uint8_t *desc, uint8_t *eof, uint8_t cfg_value)
{
    b824:	b538      	push	{r3, r4, r5, lr}
    b826:	4615      	mov	r5, r2
	_param_error_check(desc && eof && (desc < eof));

	desc = usb_find_desc(desc, eof, USB_DT_CONFIG);
    b828:	4b0c      	ldr	r3, [pc, #48]	; (b85c <usb_find_cfg_desc+0x38>)
    b82a:	2202      	movs	r2, #2
{
    b82c:	460c      	mov	r4, r1
	desc = usb_find_desc(desc, eof, USB_DT_CONFIG);
    b82e:	4798      	blx	r3
	if (!desc) {
    b830:	b978      	cbnz	r0, b852 <usb_find_cfg_desc+0x2e>
			return desc;
		}
		desc = usb_cfg_desc_next(desc);
	}
	return NULL;
}
    b832:	bd38      	pop	{r3, r4, r5, pc}
		_desc_len_check();
    b834:	7803      	ldrb	r3, [r0, #0]
    b836:	2b01      	cmp	r3, #1
    b838:	d90d      	bls.n	b856 <usb_find_cfg_desc+0x32>
		if (desc[1] != USB_DT_CONFIG) {
    b83a:	7843      	ldrb	r3, [r0, #1]
    b83c:	2b02      	cmp	r3, #2
    b83e:	d10a      	bne.n	b856 <usb_find_cfg_desc+0x32>
		if (desc[5] == cfg_value) {
    b840:	7943      	ldrb	r3, [r0, #5]
    b842:	42ab      	cmp	r3, r5
    b844:	d0f5      	beq.n	b832 <usb_find_cfg_desc+0xe>
	return (ptr[0] + (ptr[1] << 8));
    b846:	78c2      	ldrb	r2, [r0, #3]
    b848:	7883      	ldrb	r3, [r0, #2]
    b84a:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 *  \param[in] cfg_desc Byte pointer to the descriptor start address
 *  \return Byte pointer to descriptor after configuration end
 */
static inline uint8_t *usb_cfg_desc_next(uint8_t *cfg_desc)
{
	return (cfg_desc + usb_cfg_desc_total_len(cfg_desc));
    b84e:	fa10 f083 	uxtah	r0, r0, r3
	while (desc < eof) {
    b852:	42a0      	cmp	r0, r4
    b854:	d3ee      	bcc.n	b834 <usb_find_cfg_desc+0x10>
		return NULL;
    b856:	2000      	movs	r0, #0
    b858:	e7eb      	b.n	b832 <usb_find_cfg_desc+0xe>
    b85a:	bf00      	nop
    b85c:	0000b7ed 	.word	0x0000b7ed

0000b860 <usb_find_str_desc>:
	}
	return NULL;
}

uint8_t *usb_find_str_desc(uint8_t *desc, uint8_t *eof, uint8_t str_index)
{
    b860:	b570      	push	{r4, r5, r6, lr}
	uint8_t i;

	_param_error_check(desc && eof && (desc < eof));

	for (i = 0; desc < eof;) {
		desc = usb_find_desc(desc, eof, USB_DT_STRING);
    b862:	4e09      	ldr	r6, [pc, #36]	; (b888 <usb_find_str_desc+0x28>)
{
    b864:	4615      	mov	r5, r2
	for (i = 0; desc < eof;) {
    b866:	2400      	movs	r4, #0
    b868:	4288      	cmp	r0, r1
    b86a:	d301      	bcc.n	b870 <usb_find_str_desc+0x10>
				return desc;
			}
			i++;
			desc = usb_desc_next(desc);
		} else {
			return NULL;
    b86c:	2000      	movs	r0, #0
		}
	}
	return NULL;
}
    b86e:	bd70      	pop	{r4, r5, r6, pc}
		desc = usb_find_desc(desc, eof, USB_DT_STRING);
    b870:	2203      	movs	r2, #3
    b872:	47b0      	blx	r6
		if (desc) {
    b874:	2800      	cmp	r0, #0
    b876:	d0fa      	beq.n	b86e <usb_find_str_desc+0xe>
			_desc_len_check();
    b878:	7803      	ldrb	r3, [r0, #0]
    b87a:	2b01      	cmp	r3, #1
    b87c:	d9f6      	bls.n	b86c <usb_find_str_desc+0xc>
			if (i == str_index) {
    b87e:	42ac      	cmp	r4, r5
    b880:	d0f5      	beq.n	b86e <usb_find_str_desc+0xe>
	return (desc + usb_desc_len(desc));
    b882:	4418      	add	r0, r3
    b884:	3401      	adds	r4, #1
    b886:	e7ef      	b.n	b868 <usb_find_str_desc+0x8>
    b888:	0000b7ed 	.word	0x0000b7ed

0000b88c <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
    b88c:	b570      	push	{r4, r5, r6, lr}
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
    b88e:	4e07      	ldr	r6, [pc, #28]	; (b8ac <stdio_io_init+0x20>)
    b890:	4d07      	ldr	r5, [pc, #28]	; (b8b0 <stdio_io_init+0x24>)
    b892:	6833      	ldr	r3, [r6, #0]
{
    b894:	4604      	mov	r4, r0
	setbuf(stdout, NULL);
    b896:	2100      	movs	r1, #0
    b898:	6898      	ldr	r0, [r3, #8]
    b89a:	47a8      	blx	r5
	setbuf(stdin, NULL);
    b89c:	6833      	ldr	r3, [r6, #0]
    b89e:	2100      	movs	r1, #0
    b8a0:	6858      	ldr	r0, [r3, #4]
    b8a2:	47a8      	blx	r5
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
    b8a4:	4b03      	ldr	r3, [pc, #12]	; (b8b4 <stdio_io_init+0x28>)
    b8a6:	601c      	str	r4, [r3, #0]
}
    b8a8:	bd70      	pop	{r4, r5, r6, pc}
    b8aa:	bf00      	nop
    b8ac:	2000054c 	.word	0x2000054c
    b8b0:	0001458d 	.word	0x0001458d
    b8b4:	20008520 	.word	0x20008520

0000b8b8 <stdio_io_read>:
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
    b8b8:	4a04      	ldr	r2, [pc, #16]	; (b8cc <stdio_io_read+0x14>)
{
    b8ba:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
    b8bc:	6810      	ldr	r0, [r2, #0]
    b8be:	b118      	cbz	r0, b8c8 <stdio_io_read+0x10>
		return 0;
	}
	return io_read(stdio_io, buf, len);
    b8c0:	b28a      	uxth	r2, r1
    b8c2:	4619      	mov	r1, r3
    b8c4:	4b02      	ldr	r3, [pc, #8]	; (b8d0 <stdio_io_read+0x18>)
    b8c6:	4718      	bx	r3
}
    b8c8:	4770      	bx	lr
    b8ca:	bf00      	nop
    b8cc:	20008520 	.word	0x20008520
    b8d0:	0000b0d5 	.word	0x0000b0d5

0000b8d4 <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
    b8d4:	4a04      	ldr	r2, [pc, #16]	; (b8e8 <stdio_io_write+0x14>)
{
    b8d6:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
    b8d8:	6810      	ldr	r0, [r2, #0]
    b8da:	b118      	cbz	r0, b8e4 <stdio_io_write+0x10>
		return 0;
	}
	return io_write(stdio_io, buf, len);
    b8dc:	b28a      	uxth	r2, r1
    b8de:	4619      	mov	r1, r3
    b8e0:	4b02      	ldr	r3, [pc, #8]	; (b8ec <stdio_io_write+0x18>)
    b8e2:	4718      	bx	r3
}
    b8e4:	4770      	bx	lr
    b8e6:	bf00      	nop
    b8e8:	20008520 	.word	0x20008520
    b8ec:	0000b0a5 	.word	0x0000b0a5

0000b8f0 <_spi_m_dma_io_write>:
 *  \return ERR_NONE on success, or an error code on failure.
 *  \retval ERR_NONE Success, transfer started.
 *  \retval ERR_BUSY Busy.
 */
static int32_t _spi_m_dma_io_write(struct io_descriptor *io, const uint8_t *const buf, const uint16_t length)
{
    b8f0:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ASSERT(io);
    b8f2:	4604      	mov	r4, r0
    b8f4:	3800      	subs	r0, #0
{
    b8f6:	460d      	mov	r5, r1
    b8f8:	9201      	str	r2, [sp, #4]
	ASSERT(io);
    b8fa:	bf18      	it	ne
    b8fc:	2001      	movne	r0, #1
    b8fe:	4907      	ldr	r1, [pc, #28]	; (b91c <_spi_m_dma_io_write+0x2c>)
    b900:	4e07      	ldr	r6, [pc, #28]	; (b920 <_spi_m_dma_io_write+0x30>)
    b902:	2298      	movs	r2, #152	; 0x98
    b904:	47b0      	blx	r6

	struct spi_m_dma_descriptor *spi = CONTAINER_OF(io, struct spi_m_dma_descriptor, io);
	return _spi_m_dma_transfer(&spi->dev, buf, NULL, length);
    b906:	f1a4 001c 	sub.w	r0, r4, #28
    b90a:	4c06      	ldr	r4, [pc, #24]	; (b924 <_spi_m_dma_io_write+0x34>)
    b90c:	9b01      	ldr	r3, [sp, #4]
    b90e:	2200      	movs	r2, #0
    b910:	4629      	mov	r1, r5
    b912:	46a4      	mov	ip, r4
}
    b914:	b002      	add	sp, #8
    b916:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_dma_transfer(&spi->dev, buf, NULL, length);
    b91a:	4760      	bx	ip
    b91c:	00016112 	.word	0x00016112
    b920:	0000e03d 	.word	0x0000e03d
    b924:	000118f5 	.word	0x000118f5

0000b928 <_spi_m_dma_io_read>:
{
    b928:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ASSERT(io);
    b92a:	4604      	mov	r4, r0
    b92c:	3800      	subs	r0, #0
{
    b92e:	460d      	mov	r5, r1
    b930:	9201      	str	r2, [sp, #4]
	ASSERT(io);
    b932:	bf18      	it	ne
    b934:	2001      	movne	r0, #1
    b936:	4907      	ldr	r1, [pc, #28]	; (b954 <_spi_m_dma_io_read+0x2c>)
    b938:	4e07      	ldr	r6, [pc, #28]	; (b958 <_spi_m_dma_io_read+0x30>)
    b93a:	2281      	movs	r2, #129	; 0x81
    b93c:	47b0      	blx	r6
	return _spi_m_dma_transfer(&spi->dev, NULL, buf, length);
    b93e:	f1a4 001c 	sub.w	r0, r4, #28
    b942:	4c06      	ldr	r4, [pc, #24]	; (b95c <_spi_m_dma_io_read+0x34>)
    b944:	9b01      	ldr	r3, [sp, #4]
    b946:	462a      	mov	r2, r5
    b948:	2100      	movs	r1, #0
    b94a:	46a4      	mov	ip, r4
}
    b94c:	b002      	add	sp, #8
    b94e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_dma_transfer(&spi->dev, NULL, buf, length);
    b952:	4760      	bx	ip
    b954:	00016112 	.word	0x00016112
    b958:	0000e03d 	.word	0x0000e03d
    b95c:	000118f5 	.word	0x000118f5

0000b960 <spi_m_dma_init>:
{
    b960:	b538      	push	{r3, r4, r5, lr}
    b962:	460d      	mov	r5, r1
	ASSERT(spi && hw);
    b964:	4604      	mov	r4, r0
    b966:	b110      	cbz	r0, b96e <spi_m_dma_init+0xe>
    b968:	1e08      	subs	r0, r1, #0
    b96a:	bf18      	it	ne
    b96c:	2001      	movne	r0, #1
    b96e:	4908      	ldr	r1, [pc, #32]	; (b990 <spi_m_dma_init+0x30>)
    b970:	4b08      	ldr	r3, [pc, #32]	; (b994 <spi_m_dma_init+0x34>)
    b972:	223b      	movs	r2, #59	; 0x3b
    b974:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    b976:	4620      	mov	r0, r4
	rc            = _spi_m_dma_init(&spi->dev, hw);
    b978:	4b07      	ldr	r3, [pc, #28]	; (b998 <spi_m_dma_init+0x38>)
	spi->dev.prvt = (void *)hw;
    b97a:	f840 5f04 	str.w	r5, [r0, #4]!
	rc            = _spi_m_dma_init(&spi->dev, hw);
    b97e:	4629      	mov	r1, r5
    b980:	4798      	blx	r3
	if (rc) {
    b982:	b918      	cbnz	r0, b98c <spi_m_dma_init+0x2c>
	spi->io.read  = _spi_m_dma_io_read;
    b984:	4b05      	ldr	r3, [pc, #20]	; (b99c <spi_m_dma_init+0x3c>)
    b986:	6263      	str	r3, [r4, #36]	; 0x24
	spi->io.write = _spi_m_dma_io_write;
    b988:	4b05      	ldr	r3, [pc, #20]	; (b9a0 <spi_m_dma_init+0x40>)
    b98a:	6223      	str	r3, [r4, #32]
}
    b98c:	bd38      	pop	{r3, r4, r5, pc}
    b98e:	bf00      	nop
    b990:	00016112 	.word	0x00016112
    b994:	0000e03d 	.word	0x0000e03d
    b998:	0001176d 	.word	0x0001176d
    b99c:	0000b929 	.word	0x0000b929
    b9a0:	0000b8f1 	.word	0x0000b8f1

0000b9a4 <spi_m_dma_enable>:
{
    b9a4:	b510      	push	{r4, lr}
	ASSERT(spi);
    b9a6:	4604      	mov	r4, r0
    b9a8:	3800      	subs	r0, #0
    b9aa:	4b05      	ldr	r3, [pc, #20]	; (b9c0 <spi_m_dma_enable+0x1c>)
    b9ac:	4905      	ldr	r1, [pc, #20]	; (b9c4 <spi_m_dma_enable+0x20>)
    b9ae:	bf18      	it	ne
    b9b0:	2001      	movne	r0, #1
    b9b2:	2251      	movs	r2, #81	; 0x51
    b9b4:	4798      	blx	r3
	_spi_m_dma_enable(&spi->dev);
    b9b6:	1d20      	adds	r0, r4, #4
    b9b8:	4b03      	ldr	r3, [pc, #12]	; (b9c8 <spi_m_dma_enable+0x24>)
}
    b9ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_spi_m_dma_enable(&spi->dev);
    b9be:	4718      	bx	r3
    b9c0:	0000e03d 	.word	0x0000e03d
    b9c4:	00016112 	.word	0x00016112
    b9c8:	00011831 	.word	0x00011831

0000b9cc <spi_m_dma_register_callback>:
	return _spi_m_dma_transfer(&spi->dev, txbuf, rxbuf, length);
}

void spi_m_dma_register_callback(struct spi_m_dma_descriptor *spi, const enum spi_m_dma_cb_type type,
                                 spi_m_dma_cb_t func)
{
    b9cc:	b570      	push	{r4, r5, r6, lr}
	ASSERT(spi);
    b9ce:	4604      	mov	r4, r0
    b9d0:	3800      	subs	r0, #0
{
    b9d2:	460d      	mov	r5, r1
    b9d4:	4616      	mov	r6, r2
	ASSERT(spi);
    b9d6:	4907      	ldr	r1, [pc, #28]	; (b9f4 <spi_m_dma_register_callback+0x28>)
    b9d8:	4b07      	ldr	r3, [pc, #28]	; (b9f8 <spi_m_dma_register_callback+0x2c>)
    b9da:	f04f 02a8 	mov.w	r2, #168	; 0xa8
    b9de:	bf18      	it	ne
    b9e0:	2001      	movne	r0, #1
    b9e2:	4798      	blx	r3
	_spi_m_dma_register_callback(&spi->dev, (enum _spi_dma_dev_cb_type)type, func);
    b9e4:	4632      	mov	r2, r6
    b9e6:	4629      	mov	r1, r5
    b9e8:	1d20      	adds	r0, r4, #4
    b9ea:	4b04      	ldr	r3, [pc, #16]	; (b9fc <spi_m_dma_register_callback+0x30>)
}
    b9ec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	_spi_m_dma_register_callback(&spi->dev, (enum _spi_dma_dev_cb_type)type, func);
    b9f0:	4718      	bx	r3
    b9f2:	bf00      	nop
    b9f4:	00016112 	.word	0x00016112
    b9f8:	0000e03d 	.word	0x0000e03d
    b9fc:	00011861 	.word	0x00011861

0000ba00 <spi_m_dma_get_io_descriptor>:

int32_t spi_m_dma_get_io_descriptor(struct spi_m_dma_descriptor *const spi, struct io_descriptor **io)
{
    ba00:	b538      	push	{r3, r4, r5, lr}
    ba02:	460d      	mov	r5, r1
	ASSERT(spi && io);
    ba04:	4604      	mov	r4, r0
    ba06:	b110      	cbz	r0, ba0e <spi_m_dma_get_io_descriptor+0xe>
    ba08:	1e08      	subs	r0, r1, #0
    ba0a:	bf18      	it	ne
    ba0c:	2001      	movne	r0, #1
    ba0e:	4904      	ldr	r1, [pc, #16]	; (ba20 <spi_m_dma_get_io_descriptor+0x20>)
    ba10:	4b04      	ldr	r3, [pc, #16]	; (ba24 <spi_m_dma_get_io_descriptor+0x24>)
    ba12:	22ae      	movs	r2, #174	; 0xae
	*io = &spi->io;
    ba14:	3420      	adds	r4, #32
	ASSERT(spi && io);
    ba16:	4798      	blx	r3
	*io = &spi->io;
    ba18:	602c      	str	r4, [r5, #0]

	return 0;
}
    ba1a:	2000      	movs	r0, #0
    ba1c:	bd38      	pop	{r3, r4, r5, pc}
    ba1e:	bf00      	nop
    ba20:	00016112 	.word	0x00016112
    ba24:	0000e03d 	.word	0x0000e03d

0000ba28 <_write>:

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
    ba28:	3801      	subs	r0, #1
    ba2a:	2802      	cmp	r0, #2
{
    ba2c:	b508      	push	{r3, lr}
    ba2e:	460b      	mov	r3, r1
    ba30:	4611      	mov	r1, r2
	if ((file != 1) && (file != 2) && (file != 3)) {
    ba32:	d805      	bhi.n	ba40 <_write+0x18>
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
    ba34:	4618      	mov	r0, r3
    ba36:	4b04      	ldr	r3, [pc, #16]	; (ba48 <_write+0x20>)
    ba38:	4798      	blx	r3
	if (n < 0) {
    ba3a:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
    ba3e:	bd08      	pop	{r3, pc}
		return -1;
    ba40:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    ba44:	e7fb      	b.n	ba3e <_write+0x16>
    ba46:	bf00      	nop
    ba48:	0000b8d5 	.word	0x0000b8d5

0000ba4c <_event_system_init>:

/**
 * \brief Initialize event system
 */
int32_t _event_system_init(void)
{
    ba4c:	b510      	push	{r4, lr}
    ba4e:	4a13      	ldr	r2, [pc, #76]	; (ba9c <_event_system_init+0x50>)
}

static inline void hri_evsys_write_USER_reg(const void *const hw, uint8_t index, hri_evsys_user_reg_t data)
{
	EVSYS_CRITICAL_SECTION_ENTER();
	((Evsys *)hw)->USER[index].reg = data;
    ba50:	4913      	ldr	r1, [pc, #76]	; (baa0 <_event_system_init+0x54>)
    ba52:	2300      	movs	r3, #0
    ba54:	f103 0048 	add.w	r0, r3, #72	; 0x48
    ba58:	3301      	adds	r3, #1
	uint8_t i;
	/* configure user multiplexers */
	for (i = 0; i < EVSYS_USERS; i++) {
		hri_evsys_write_USER_reg(EVSYS, i, user_mux_confs[i]);
    ba5a:	f812 4b01 	ldrb.w	r4, [r2], #1
    ba5e:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
	for (i = 0; i < EVSYS_USERS; i++) {
    ba62:	2b43      	cmp	r3, #67	; 0x43
    ba64:	d1f6      	bne.n	ba54 <_event_system_init+0x8>
    ba66:	480f      	ldr	r0, [pc, #60]	; (baa4 <_event_system_init+0x58>)
    ba68:	2100      	movs	r1, #0
    ba6a:	f100 0440 	add.w	r4, r0, #64	; 0x40
	}

	/* configure channels */
	for (i = 0; i < EVSYS_CHANNELS; i++) {
		hri_evsys_write_CHANNEL_reg(EVSYS, i, channel_confs[i]);
    ba6e:	00ca      	lsls	r2, r1, #3
    ba70:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    ba74:	f502 4260 	add.w	r2, r2, #57344	; 0xe000
    ba78:	f830 3b02 	ldrh.w	r3, [r0], #2

static inline void hri_evsys_write_CHANNEL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_evsys_channel_reg_t data)
{
	EVSYS_CRITICAL_SECTION_ENTER();
	((Evsys *)hw)->Channel[submodule_index].CHANNEL.reg = data;
    ba7c:	6213      	str	r3, [r2, #32]
		hri_evsys_write_CHINTEN_reg(EVSYS, i, interrupt_cfg[i]);
    ba7e:	f854 3b04 	ldr.w	r3, [r4], #4
    ba82:	b2db      	uxtb	r3, r3
	((Evsys *)hw)->Channel[submodule_index].CHINTENSET.reg = data;
    ba84:	f882 3025 	strb.w	r3, [r2, #37]	; 0x25
	((Evsys *)hw)->Channel[submodule_index].CHINTENCLR.reg = ~data;
    ba88:	3101      	adds	r1, #1
    ba8a:	43db      	mvns	r3, r3
    ba8c:	b2db      	uxtb	r3, r3
	for (i = 0; i < EVSYS_CHANNELS; i++) {
    ba8e:	2920      	cmp	r1, #32
    ba90:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
    ba94:	d1eb      	bne.n	ba6e <_event_system_init+0x22>
	}

	return ERR_NONE;
}
    ba96:	2000      	movs	r0, #0
    ba98:	bd10      	pop	{r4, pc}
    ba9a:	bf00      	nop
    ba9c:	00016130 	.word	0x00016130
    baa0:	4100e000 	.word	0x4100e000
    baa4:	00016174 	.word	0x00016174

0000baa8 <_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    baa8:	0943      	lsrs	r3, r0, #5
    baaa:	2201      	movs	r2, #1
    baac:	f000 001f 	and.w	r0, r0, #31
    bab0:	fa02 f000 	lsl.w	r0, r2, r0
    bab4:	3340      	adds	r3, #64	; 0x40
    bab6:	4a02      	ldr	r2, [pc, #8]	; (bac0 <_irq_set+0x18>)
    bab8:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 * \brief Set the given IRQ
 */
void _irq_set(uint8_t n)
{
	NVIC_SetPendingIRQ((IRQn_Type)n);
}
    babc:	4770      	bx	lr
    babe:	bf00      	nop
    bac0:	e000e100 	.word	0xe000e100

0000bac4 <_get_cycles_for_ms>:
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
    bac4:	4b01      	ldr	r3, [pc, #4]	; (bacc <_get_cycles_for_ms+0x8>)
    bac6:	4358      	muls	r0, r3
    bac8:	4770      	bx	lr
    baca:	bf00      	nop
    bacc:	0001d4c0 	.word	0x0001d4c0

0000bad0 <cdcdf_acm_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t cdcdf_acm_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    bad0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    bad4:	4615      	mov	r5, r2
	if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    bad6:	780a      	ldrb	r2, [r1, #0]
    bad8:	f3c2 1341 	ubfx	r3, r2, #5, #2
    badc:	2b01      	cmp	r3, #1
{
    bade:	4606      	mov	r6, r0
    bae0:	460c      	mov	r4, r1
	if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    bae2:	d155      	bne.n	bb90 <cdcdf_acm_req+0xc0>
		return ERR_NOT_FOUND;
	}
	if ((req->wIndex == _cdcdf_acm_funcd.func_iface[0]) || (req->wIndex == _cdcdf_acm_funcd.func_iface[1])) {
    bae4:	4b2d      	ldr	r3, [pc, #180]	; (bb9c <cdcdf_acm_req+0xcc>)
    bae6:	8889      	ldrh	r1, [r1, #4]
    bae8:	7818      	ldrb	r0, [r3, #0]
    baea:	4288      	cmp	r0, r1
    baec:	4698      	mov	r8, r3
    baee:	d002      	beq.n	baf6 <cdcdf_acm_req+0x26>
    baf0:	785b      	ldrb	r3, [r3, #1]
    baf2:	428b      	cmp	r3, r1
    baf4:	d14c      	bne.n	bb90 <cdcdf_acm_req+0xc0>
		if (req->bmRequestType & USB_EP_DIR_IN) {
    baf6:	0613      	lsls	r3, r2, #24
    baf8:	88e7      	ldrh	r7, [r4, #6]
    bafa:	d50f      	bpl.n	bb1c <cdcdf_acm_req+0x4c>
	if (USB_DATA_STAGE == stage) {
    bafc:	2d01      	cmp	r5, #1
    bafe:	d033      	beq.n	bb68 <cdcdf_acm_req+0x98>
	switch (req->bRequest) {
    bb00:	7863      	ldrb	r3, [r4, #1]
    bb02:	2b21      	cmp	r3, #33	; 0x21
    bb04:	d112      	bne.n	bb2c <cdcdf_acm_req+0x5c>
		if (sizeof(struct usb_cdc_line_coding) != len) {
    bb06:	2f07      	cmp	r7, #7
    bb08:	d145      	bne.n	bb96 <cdcdf_acm_req+0xc6>
		return usbdc_xfer(ep, (uint8_t *)&usbd_cdc_line_coding, len, false);
    bb0a:	4925      	ldr	r1, [pc, #148]	; (bba0 <cdcdf_acm_req+0xd0>)
    bb0c:	2300      	movs	r3, #0
    bb0e:	463a      	mov	r2, r7
			return usbdc_xfer(ep, ctrl_buf, len, false);
    bb10:	4c24      	ldr	r4, [pc, #144]	; (bba4 <cdcdf_acm_req+0xd4>)
    bb12:	4630      	mov	r0, r6
    bb14:	47a0      	blx	r4
			return cdcdf_acm_set_req(ep, req, stage);
		}
	} else {
		return ERR_NOT_FOUND;
	}
}
    bb16:	b002      	add	sp, #8
    bb18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint8_t *                  ctrl_buf = usbdc_get_ctrl_buffer();
    bb1c:	4b22      	ldr	r3, [pc, #136]	; (bba8 <cdcdf_acm_req+0xd8>)
    bb1e:	4798      	blx	r3
	switch (req->bRequest) {
    bb20:	7863      	ldrb	r3, [r4, #1]
    bb22:	2b20      	cmp	r3, #32
	uint8_t *                  ctrl_buf = usbdc_get_ctrl_buffer();
    bb24:	4601      	mov	r1, r0
	switch (req->bRequest) {
    bb26:	d004      	beq.n	bb32 <cdcdf_acm_req+0x62>
    bb28:	2b22      	cmp	r3, #34	; 0x22
    bb2a:	d024      	beq.n	bb76 <cdcdf_acm_req+0xa6>
		return ERR_INVALID_ARG;
    bb2c:	f06f 000c 	mvn.w	r0, #12
    bb30:	e7f1      	b.n	bb16 <cdcdf_acm_req+0x46>
		if (sizeof(struct usb_cdc_line_coding) != len) {
    bb32:	2f07      	cmp	r7, #7
    bb34:	d12f      	bne.n	bb96 <cdcdf_acm_req+0xc6>
		if (USB_SETUP_STAGE == stage) {
    bb36:	b915      	cbnz	r5, bb3e <cdcdf_acm_req+0x6e>
			return usbdc_xfer(ep, ctrl_buf, len, false);
    bb38:	462b      	mov	r3, r5
    bb3a:	463a      	mov	r2, r7
    bb3c:	e7e8      	b.n	bb10 <cdcdf_acm_req+0x40>
			memcpy(&line_coding_tmp, ctrl_buf, sizeof(struct usb_cdc_line_coding));
    bb3e:	6800      	ldr	r0, [r0, #0]
    bb40:	9000      	str	r0, [sp, #0]
    bb42:	798b      	ldrb	r3, [r1, #6]
    bb44:	888a      	ldrh	r2, [r1, #4]
    bb46:	f88d 3006 	strb.w	r3, [sp, #6]
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    bb4a:	f8d8 3010 	ldr.w	r3, [r8, #16]
			memcpy(&line_coding_tmp, ctrl_buf, sizeof(struct usb_cdc_line_coding));
    bb4e:	f8ad 2004 	strh.w	r2, [sp, #4]
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    bb52:	b95b      	cbnz	r3, bb6c <cdcdf_acm_req+0x9c>
				usbd_cdc_line_coding = line_coding_tmp;
    bb54:	4b12      	ldr	r3, [pc, #72]	; (bba0 <cdcdf_acm_req+0xd0>)
    bb56:	9800      	ldr	r0, [sp, #0]
    bb58:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    bb5c:	f89d 2006 	ldrb.w	r2, [sp, #6]
    bb60:	f8c8 0006 	str.w	r0, [r8, #6]
    bb64:	8099      	strh	r1, [r3, #4]
    bb66:	719a      	strb	r2, [r3, #6]
		return ERR_NONE;
    bb68:	2000      	movs	r0, #0
    bb6a:	e7d4      	b.n	bb16 <cdcdf_acm_req+0x46>
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    bb6c:	4668      	mov	r0, sp
    bb6e:	4798      	blx	r3
    bb70:	2800      	cmp	r0, #0
    bb72:	d1ef      	bne.n	bb54 <cdcdf_acm_req+0x84>
    bb74:	e7f8      	b.n	bb68 <cdcdf_acm_req+0x98>
		usbdc_xfer(0, NULL, 0, 0);
    bb76:	2300      	movs	r3, #0
    bb78:	461a      	mov	r2, r3
    bb7a:	4619      	mov	r1, r3
    bb7c:	4618      	mov	r0, r3
    bb7e:	4d09      	ldr	r5, [pc, #36]	; (bba4 <cdcdf_acm_req+0xd4>)
    bb80:	47a8      	blx	r5
		if (NULL != cdcdf_acm_notify_state) {
    bb82:	f8d8 3014 	ldr.w	r3, [r8, #20]
    bb86:	2b00      	cmp	r3, #0
    bb88:	d0ee      	beq.n	bb68 <cdcdf_acm_req+0x98>
			cdcdf_acm_notify_state(req->wValue);
    bb8a:	8860      	ldrh	r0, [r4, #2]
    bb8c:	4798      	blx	r3
    bb8e:	e7eb      	b.n	bb68 <cdcdf_acm_req+0x98>
		return ERR_NOT_FOUND;
    bb90:	f06f 0009 	mvn.w	r0, #9
    bb94:	e7bf      	b.n	bb16 <cdcdf_acm_req+0x46>
			return ERR_INVALID_DATA;
    bb96:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    bb9a:	e7bc      	b.n	bb16 <cdcdf_acm_req+0x46>
    bb9c:	20008524 	.word	0x20008524
    bba0:	2000852a 	.word	0x2000852a
    bba4:	0001323d 	.word	0x0001323d
    bba8:	00013669 	.word	0x00013669

0000bbac <cdcdf_acm_ctrl>:
	switch (ctrl) {
    bbac:	2901      	cmp	r1, #1
{
    bbae:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bbb2:	4615      	mov	r5, r2
	switch (ctrl) {
    bbb4:	d04f      	beq.n	bc56 <cdcdf_acm_ctrl+0xaa>
    bbb6:	2902      	cmp	r1, #2
    bbb8:	d076      	beq.n	bca8 <cdcdf_acm_ctrl+0xfc>
    bbba:	2900      	cmp	r1, #0
    bbbc:	d177      	bne.n	bcae <cdcdf_acm_ctrl+0x102>
		return cdcdf_acm_enable(drv, (struct usbd_descriptors *)param);
    bbbe:	6887      	ldr	r7, [r0, #8]
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    bbc0:	f8df 8114 	ldr.w	r8, [pc, #276]	; bcd8 <cdcdf_acm_ctrl+0x12c>
	ifc = desc->sod;
    bbc4:	6810      	ldr	r0, [r2, #0]
	for (i = 0; i < 2; i++) {
    bbc6:	1e7e      	subs	r6, r7, #1
		if (NULL == ifc) {
    bbc8:	b928      	cbnz	r0, bbd6 <cdcdf_acm_ctrl+0x2a>
			return ERR_NOT_FOUND;
    bbca:	f06f 0009 	mvn.w	r0, #9
}
    bbce:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bbd2:	464e      	mov	r6, r9
    bbd4:	e7f8      	b.n	bbc8 <cdcdf_acm_ctrl+0x1c>
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
    bbd6:	7943      	ldrb	r3, [r0, #5]
		ifc_desc.bInterfaceNumber = ifc[2];
    bbd8:	7882      	ldrb	r2, [r0, #2]
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
    bbda:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    bbde:	2b02      	cmp	r3, #2
    bbe0:	d1f3      	bne.n	bbca <cdcdf_acm_ctrl+0x1e>
			if (func_data->func_iface[i] == ifc_desc.bInterfaceNumber) { // Initialized
    bbe2:	7873      	ldrb	r3, [r6, #1]
    bbe4:	429a      	cmp	r2, r3
    bbe6:	d065      	beq.n	bcb4 <cdcdf_acm_ctrl+0x108>
			} else if (func_data->func_iface[i] != 0xFF) { // Occupied
    bbe8:	2bff      	cmp	r3, #255	; 0xff
    bbea:	d166      	bne.n	bcba <cdcdf_acm_ctrl+0x10e>
				func_data->func_iface[i] = ifc_desc.bInterfaceNumber;
    bbec:	7072      	strb	r2, [r6, #1]
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    bbee:	6869      	ldr	r1, [r5, #4]
    bbf0:	f8df a0e8 	ldr.w	sl, [pc, #232]	; bcdc <cdcdf_acm_ctrl+0x130>
    bbf4:	2205      	movs	r2, #5
    bbf6:	47c0      	blx	r8
    bbf8:	f106 0901 	add.w	r9, r6, #1
    bbfc:	4604      	mov	r4, r0
		while (NULL != ep) {
    bbfe:	b964      	cbnz	r4, bc1a <cdcdf_acm_ctrl+0x6e>
		ifc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_INTERFACE);
    bc00:	682b      	ldr	r3, [r5, #0]
    bc02:	6869      	ldr	r1, [r5, #4]
    bc04:	7818      	ldrb	r0, [r3, #0]
    bc06:	2204      	movs	r2, #4
    bc08:	4418      	add	r0, r3
    bc0a:	47c0      	blx	r8
	for (i = 0; i < 2; i++) {
    bc0c:	42be      	cmp	r6, r7
    bc0e:	d1e0      	bne.n	bbd2 <cdcdf_acm_ctrl+0x26>
	_cdcdf_acm_funcd.enabled = true;
    bc10:	4b2d      	ldr	r3, [pc, #180]	; (bcc8 <cdcdf_acm_ctrl+0x11c>)
    bc12:	2201      	movs	r2, #1
    bc14:	715a      	strb	r2, [r3, #5]
	return ERR_NONE;
    bc16:	4620      	mov	r0, r4
    bc18:	e7d9      	b.n	bbce <cdcdf_acm_ctrl+0x22>
	return (ptr[0] + (ptr[1] << 8));
    bc1a:	7961      	ldrb	r1, [r4, #5]
    bc1c:	7922      	ldrb	r2, [r4, #4]
			ep_desc.bEndpointAddress = ep[2];
    bc1e:	f894 b002 	ldrb.w	fp, [r4, #2]
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    bc22:	4b2a      	ldr	r3, [pc, #168]	; (bccc <cdcdf_acm_ctrl+0x120>)
    bc24:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    bc28:	b292      	uxth	r2, r2
    bc2a:	78e1      	ldrb	r1, [r4, #3]
    bc2c:	4658      	mov	r0, fp
    bc2e:	4798      	blx	r3
    bc30:	2800      	cmp	r0, #0
    bc32:	d145      	bne.n	bcc0 <cdcdf_acm_ctrl+0x114>
			if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    bc34:	f01b 0f80 	tst.w	fp, #128	; 0x80
				func_data->func_ep_in[i] = ep_desc.bEndpointAddress;
    bc38:	bf14      	ite	ne
    bc3a:	f889 b002 	strbne.w	fp, [r9, #2]
				func_data->func_ep_out = ep_desc.bEndpointAddress;
    bc3e:	f887 b004 	strbeq.w	fp, [r7, #4]
				usb_d_ep_enable(func_data->func_ep_out);
    bc42:	4658      	mov	r0, fp
    bc44:	47d0      	blx	sl
			desc->sod = ep;
    bc46:	602c      	str	r4, [r5, #0]
	return (desc + usb_desc_len(desc));
    bc48:	7820      	ldrb	r0, [r4, #0]
			ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    bc4a:	6869      	ldr	r1, [r5, #4]
    bc4c:	4b20      	ldr	r3, [pc, #128]	; (bcd0 <cdcdf_acm_ctrl+0x124>)
    bc4e:	4420      	add	r0, r4
    bc50:	4798      	blx	r3
    bc52:	4604      	mov	r4, r0
    bc54:	e7d3      	b.n	bbfe <cdcdf_acm_ctrl+0x52>
		return cdcdf_acm_disable(drv, (struct usbd_descriptors *)param);
    bc56:	6884      	ldr	r4, [r0, #8]
	if (desc) {
    bc58:	b12a      	cbz	r2, bc66 <cdcdf_acm_ctrl+0xba>
		ifc_desc.bInterfaceClass = desc->sod[5];
    bc5a:	6813      	ldr	r3, [r2, #0]
		if ((ifc_desc.bInterfaceClass != CDC_CLASS_COMM) && (ifc_desc.bInterfaceClass != CDC_CLASS_DATA)) {
    bc5c:	795b      	ldrb	r3, [r3, #5]
    bc5e:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    bc62:	2b02      	cmp	r3, #2
    bc64:	d1b1      	bne.n	bbca <cdcdf_acm_ctrl+0x1e>
		if (func_data->func_iface[i] == 0xFF) {
    bc66:	7823      	ldrb	r3, [r4, #0]
    bc68:	2bff      	cmp	r3, #255	; 0xff
    bc6a:	d007      	beq.n	bc7c <cdcdf_acm_ctrl+0xd0>
			if (func_data->func_ep_in[i] != 0xFF) {
    bc6c:	78a0      	ldrb	r0, [r4, #2]
			func_data->func_iface[i] = 0xFF;
    bc6e:	25ff      	movs	r5, #255	; 0xff
			if (func_data->func_ep_in[i] != 0xFF) {
    bc70:	42a8      	cmp	r0, r5
			func_data->func_iface[i] = 0xFF;
    bc72:	7025      	strb	r5, [r4, #0]
			if (func_data->func_ep_in[i] != 0xFF) {
    bc74:	d002      	beq.n	bc7c <cdcdf_acm_ctrl+0xd0>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
    bc76:	4b17      	ldr	r3, [pc, #92]	; (bcd4 <cdcdf_acm_ctrl+0x128>)
    bc78:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
    bc7a:	70a5      	strb	r5, [r4, #2]
		if (func_data->func_iface[i] == 0xFF) {
    bc7c:	7863      	ldrb	r3, [r4, #1]
    bc7e:	2bff      	cmp	r3, #255	; 0xff
    bc80:	d007      	beq.n	bc92 <cdcdf_acm_ctrl+0xe6>
			if (func_data->func_ep_in[i] != 0xFF) {
    bc82:	78e0      	ldrb	r0, [r4, #3]
			func_data->func_iface[i] = 0xFF;
    bc84:	25ff      	movs	r5, #255	; 0xff
			if (func_data->func_ep_in[i] != 0xFF) {
    bc86:	42a8      	cmp	r0, r5
			func_data->func_iface[i] = 0xFF;
    bc88:	7065      	strb	r5, [r4, #1]
			if (func_data->func_ep_in[i] != 0xFF) {
    bc8a:	d002      	beq.n	bc92 <cdcdf_acm_ctrl+0xe6>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
    bc8c:	4b11      	ldr	r3, [pc, #68]	; (bcd4 <cdcdf_acm_ctrl+0x128>)
    bc8e:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
    bc90:	70e5      	strb	r5, [r4, #3]
	if (func_data->func_ep_out != 0xFF) {
    bc92:	7920      	ldrb	r0, [r4, #4]
    bc94:	28ff      	cmp	r0, #255	; 0xff
    bc96:	d003      	beq.n	bca0 <cdcdf_acm_ctrl+0xf4>
		usb_d_ep_deinit(func_data->func_ep_out);
    bc98:	4b0e      	ldr	r3, [pc, #56]	; (bcd4 <cdcdf_acm_ctrl+0x128>)
    bc9a:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    bc9c:	23ff      	movs	r3, #255	; 0xff
    bc9e:	7123      	strb	r3, [r4, #4]
	_cdcdf_acm_funcd.enabled = false;
    bca0:	4b09      	ldr	r3, [pc, #36]	; (bcc8 <cdcdf_acm_ctrl+0x11c>)
    bca2:	2000      	movs	r0, #0
    bca4:	7158      	strb	r0, [r3, #5]
	return ERR_NONE;
    bca6:	e792      	b.n	bbce <cdcdf_acm_ctrl+0x22>
		return ERR_UNSUPPORTED_OP;
    bca8:	f06f 001a 	mvn.w	r0, #26
    bcac:	e78f      	b.n	bbce <cdcdf_acm_ctrl+0x22>
	switch (ctrl) {
    bcae:	f06f 000c 	mvn.w	r0, #12
    bcb2:	e78c      	b.n	bbce <cdcdf_acm_ctrl+0x22>
				return ERR_ALREADY_INITIALIZED;
    bcb4:	f06f 0011 	mvn.w	r0, #17
    bcb8:	e789      	b.n	bbce <cdcdf_acm_ctrl+0x22>
				return ERR_NO_RESOURCE;
    bcba:	f06f 001b 	mvn.w	r0, #27
    bcbe:	e786      	b.n	bbce <cdcdf_acm_ctrl+0x22>
				return ERR_NOT_INITIALIZED;
    bcc0:	f06f 0013 	mvn.w	r0, #19
    bcc4:	e783      	b.n	bbce <cdcdf_acm_ctrl+0x22>
    bcc6:	bf00      	nop
    bcc8:	20008524 	.word	0x20008524
    bccc:	0000f521 	.word	0x0000f521
    bcd0:	0000b807 	.word	0x0000b807
    bcd4:	0000f585 	.word	0x0000f585
    bcd8:	0000b7ed 	.word	0x0000b7ed
    bcdc:	0000f5b1 	.word	0x0000f5b1

0000bce0 <cdcdf_acm_init>:

/**
 * \brief Initialize the USB CDC ACM Function Driver
 */
int32_t cdcdf_acm_init(void)
{
    bce0:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    bce2:	4b0a      	ldr	r3, [pc, #40]	; (bd0c <cdcdf_acm_init+0x2c>)
    bce4:	4798      	blx	r3
    bce6:	2801      	cmp	r0, #1
    bce8:	d80c      	bhi.n	bd04 <cdcdf_acm_init+0x24>
		return ERR_DENIED;
	}

	_cdcdf_acm.ctrl      = cdcdf_acm_ctrl;
    bcea:	4809      	ldr	r0, [pc, #36]	; (bd10 <cdcdf_acm_init+0x30>)
    bcec:	4b09      	ldr	r3, [pc, #36]	; (bd14 <cdcdf_acm_init+0x34>)
	_cdcdf_acm.func_data = &_cdcdf_acm_funcd;
    bcee:	e9c0 3007 	strd	r3, r0, [r0, #28]

	usbdc_register_function(&_cdcdf_acm);
    bcf2:	4b09      	ldr	r3, [pc, #36]	; (bd18 <cdcdf_acm_init+0x38>)
    bcf4:	3018      	adds	r0, #24
    bcf6:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &cdcdf_acm_req_h);
    bcf8:	2001      	movs	r0, #1
    bcfa:	4908      	ldr	r1, [pc, #32]	; (bd1c <cdcdf_acm_init+0x3c>)
    bcfc:	4b08      	ldr	r3, [pc, #32]	; (bd20 <cdcdf_acm_init+0x40>)
    bcfe:	4798      	blx	r3
	return ERR_NONE;
    bd00:	2000      	movs	r0, #0
}
    bd02:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    bd04:	f06f 0010 	mvn.w	r0, #16
    bd08:	e7fb      	b.n	bd02 <cdcdf_acm_init+0x22>
    bd0a:	bf00      	nop
    bd0c:	00013675 	.word	0x00013675
    bd10:	20008524 	.word	0x20008524
    bd14:	0000bbad 	.word	0x0000bbad
    bd18:	0001361d 	.word	0x0001361d
    bd1c:	20000354 	.word	0x20000354
    bd20:	00013595 	.word	0x00013595

0000bd24 <cdcdf_acm_read>:

/**
 * \brief USB CDC ACM Function Read Data
 */
int32_t cdcdf_acm_read(uint8_t *buf, uint32_t size)
{
    bd24:	b410      	push	{r4}
/**
 * \brief Check whether CDC ACM Function is enabled
 */
bool cdcdf_acm_is_enabled(void)
{
	return _cdcdf_acm_funcd.enabled;
    bd26:	4c08      	ldr	r4, [pc, #32]	; (bd48 <cdcdf_acm_read+0x24>)
	if (!cdcdf_acm_is_enabled()) {
    bd28:	7963      	ldrb	r3, [r4, #5]
{
    bd2a:	460a      	mov	r2, r1
	if (!cdcdf_acm_is_enabled()) {
    bd2c:	b13b      	cbz	r3, bd3e <cdcdf_acm_read+0x1a>
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_out, buf, size, false);
    bd2e:	4601      	mov	r1, r0
    bd30:	7920      	ldrb	r0, [r4, #4]
    bd32:	4c06      	ldr	r4, [pc, #24]	; (bd4c <cdcdf_acm_read+0x28>)
    bd34:	2300      	movs	r3, #0
    bd36:	46a4      	mov	ip, r4
}
    bd38:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_out, buf, size, false);
    bd3c:	4760      	bx	ip
}
    bd3e:	f06f 0010 	mvn.w	r0, #16
    bd42:	f85d 4b04 	ldr.w	r4, [sp], #4
    bd46:	4770      	bx	lr
    bd48:	20008524 	.word	0x20008524
    bd4c:	0001323d 	.word	0x0001323d

0000bd50 <cdcdf_acm_write>:
{
    bd50:	b410      	push	{r4}
	return _cdcdf_acm_funcd.enabled;
    bd52:	4c08      	ldr	r4, [pc, #32]	; (bd74 <cdcdf_acm_write+0x24>)
	if (!cdcdf_acm_is_enabled()) {
    bd54:	7963      	ldrb	r3, [r4, #5]
{
    bd56:	460a      	mov	r2, r1
	if (!cdcdf_acm_is_enabled()) {
    bd58:	b13b      	cbz	r3, bd6a <cdcdf_acm_write+0x1a>
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], buf, size, true);
    bd5a:	4601      	mov	r1, r0
    bd5c:	78e0      	ldrb	r0, [r4, #3]
    bd5e:	4c06      	ldr	r4, [pc, #24]	; (bd78 <cdcdf_acm_write+0x28>)
    bd60:	2301      	movs	r3, #1
    bd62:	46a4      	mov	ip, r4
}
    bd64:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], buf, size, true);
    bd68:	4760      	bx	ip
}
    bd6a:	f06f 0010 	mvn.w	r0, #16
    bd6e:	f85d 4b04 	ldr.w	r4, [sp], #4
    bd72:	4770      	bx	lr
    bd74:	20008524 	.word	0x20008524
    bd78:	0001323d 	.word	0x0001323d

0000bd7c <cdcdf_acm_register_callback>:
{
    bd7c:	b508      	push	{r3, lr}
    bd7e:	460a      	mov	r2, r1
    bd80:	2803      	cmp	r0, #3
    bd82:	d814      	bhi.n	bdae <cdcdf_acm_register_callback+0x32>
    bd84:	e8df f000 	tbb	[pc, r0]
    bd88:	100d0902 	.word	0x100d0902
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_out, USB_D_EP_CB_XFER, func);
    bd8c:	4b09      	ldr	r3, [pc, #36]	; (bdb4 <cdcdf_acm_register_callback+0x38>)
    bd8e:	7918      	ldrb	r0, [r3, #4]
    bd90:	2102      	movs	r1, #2
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], USB_D_EP_CB_XFER, func);
    bd92:	4b09      	ldr	r3, [pc, #36]	; (bdb8 <cdcdf_acm_register_callback+0x3c>)
    bd94:	4798      	blx	r3
	return ERR_NONE;
    bd96:	2000      	movs	r0, #0
}
    bd98:	bd08      	pop	{r3, pc}
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], USB_D_EP_CB_XFER, func);
    bd9a:	4b06      	ldr	r3, [pc, #24]	; (bdb4 <cdcdf_acm_register_callback+0x38>)
    bd9c:	2102      	movs	r1, #2
    bd9e:	78d8      	ldrb	r0, [r3, #3]
    bda0:	e7f7      	b.n	bd92 <cdcdf_acm_register_callback+0x16>
		cdcdf_acm_set_line_coding = (cdcdf_acm_set_line_coding_t)func;
    bda2:	4b04      	ldr	r3, [pc, #16]	; (bdb4 <cdcdf_acm_register_callback+0x38>)
    bda4:	6119      	str	r1, [r3, #16]
		break;
    bda6:	e7f6      	b.n	bd96 <cdcdf_acm_register_callback+0x1a>
		cdcdf_acm_notify_state = (cdcdf_acm_notify_state_t)func;
    bda8:	4b02      	ldr	r3, [pc, #8]	; (bdb4 <cdcdf_acm_register_callback+0x38>)
    bdaa:	6159      	str	r1, [r3, #20]
    bdac:	e7f3      	b.n	bd96 <cdcdf_acm_register_callback+0x1a>
	return ERR_NONE;
    bdae:	f06f 000c 	mvn.w	r0, #12
    bdb2:	e7f1      	b.n	bd98 <cdcdf_acm_register_callback+0x1c>
    bdb4:	20008524 	.word	0x20008524
    bdb8:	0000f799 	.word	0x0000f799

0000bdbc <_sbrk>:
extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    bdbc:	4b04      	ldr	r3, [pc, #16]	; (bdd0 <_sbrk+0x14>)
    bdbe:	6819      	ldr	r1, [r3, #0]
{
    bdc0:	4602      	mov	r2, r0
	if (heap == NULL) {
    bdc2:	b909      	cbnz	r1, bdc8 <_sbrk+0xc>
		heap = (unsigned char *)&_end;
    bdc4:	4903      	ldr	r1, [pc, #12]	; (bdd4 <_sbrk+0x18>)
    bdc6:	6019      	str	r1, [r3, #0]
	}
	prev_heap = heap;
    bdc8:	6818      	ldr	r0, [r3, #0]

	heap += incr;
    bdca:	4402      	add	r2, r0
    bdcc:	601a      	str	r2, [r3, #0]

	return (caddr_t)prev_heap;
}
    bdce:	4770      	bx	lr
    bdd0:	20008548 	.word	0x20008548
    bdd4:	2002cfe8 	.word	0x2002cfe8

0000bdd8 <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
    bdd8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    bddc:	4770      	bx	lr

0000bdde <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
    bdde:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    bde2:	604b      	str	r3, [r1, #4]

	return 0;
}
    bde4:	2000      	movs	r0, #0
    bde6:	4770      	bx	lr

0000bde8 <_isatty>:
 */
extern int _isatty(int file)
{
	(void)file;
	return 1;
}
    bde8:	2001      	movs	r0, #1
    bdea:	4770      	bx	lr

0000bdec <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
    bdec:	2000      	movs	r0, #0
    bdee:	4770      	bx	lr

0000bdf0 <_qspi_dma_rx_complete>:
 *  \brief Callback for RX
 *  \param[in, out] dev Pointer to the DMA resource.
 */
static void _qspi_dma_rx_complete(struct _dma_resource *resource)
{
	struct _qspi_dma_dev *dev = (struct _qspi_dma_dev *)resource->back;
    bdf0:	6883      	ldr	r3, [r0, #8]
}

static inline void hri_qspi_write_CTRLA_reg(const void *const hw, hri_qspi_ctrla_reg_t data)
{
	QSPI_CRITICAL_SECTION_ENTER();
	((Qspi *)hw)->CTRLA.reg = data;
    bdf2:	4903      	ldr	r1, [pc, #12]	; (be00 <_qspi_dma_rx_complete+0x10>)

	_qspi_end_transfer(dev->prvt);
    bdf4:	681a      	ldr	r2, [r3, #0]

	if (dev->cb.xfer_done) {
    bdf6:	685b      	ldr	r3, [r3, #4]
    bdf8:	6011      	str	r1, [r2, #0]
    bdfa:	b103      	cbz	r3, bdfe <_qspi_dma_rx_complete+0xe>
		dev->cb.xfer_done(resource);
    bdfc:	4718      	bx	r3
	}
}
    bdfe:	4770      	bx	lr
    be00:	01000002 	.word	0x01000002

0000be04 <_qspi_dma_tx_complete>:
    be04:	4b00      	ldr	r3, [pc, #0]	; (be08 <_qspi_dma_tx_complete+0x4>)
    be06:	4718      	bx	r3
    be08:	0000bdf1 	.word	0x0000bdf1

0000be0c <_qspi_dma_error_occured>:
 */
static void _qspi_dma_error_occured(struct _dma_resource *resource)
{
	struct _qspi_dma_dev *dev = (struct _qspi_dma_dev *)resource->back;

	if (dev->cb.error) {
    be0c:	6883      	ldr	r3, [r0, #8]
    be0e:	689b      	ldr	r3, [r3, #8]
    be10:	b103      	cbz	r3, be14 <_qspi_dma_error_occured+0x8>
		dev->cb.error(resource);
    be12:	4718      	bx	r3
	}
}
    be14:	4770      	bx	lr
	...

0000be18 <_qspi_dma_init>:

int32_t _qspi_dma_init(struct _qspi_dma_dev *dev, void *const hw)
{
    be18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    be1a:	460d      	mov	r5, r1
	ASSERT(dev && hw);
    be1c:	4604      	mov	r4, r0
    be1e:	b110      	cbz	r0, be26 <_qspi_dma_init+0xe>
    be20:	1e08      	subs	r0, r1, #0
    be22:	bf18      	it	ne
    be24:	2001      	movne	r0, #1
	dev->prvt = hw;
    be26:	4626      	mov	r6, r4
	ASSERT(dev && hw);
    be28:	22cb      	movs	r2, #203	; 0xcb
    be2a:	490f      	ldr	r1, [pc, #60]	; (be68 <_qspi_dma_init+0x50>)
    be2c:	4b0f      	ldr	r3, [pc, #60]	; (be6c <_qspi_dma_init+0x54>)
	hri_qspi_write_BAUD_reg(hw,
	                        CONF_QSPI_CPOL << QSPI_BAUD_CPOL_Pos | CONF_QSPI_CPHA << QSPI_BAUD_CPHA_Pos
	                            | QSPI_BAUD_BAUD(CONF_QSPI_BAUD_RATE) | QSPI_BAUD_DLYBS(CONF_QSPI_DLYBS));

	/* Initialize DMA rx channel */
	_dma_get_channel_resource(&dev->resource, CONF_QSPI_DMA_RX_CHANNEL);
    be2e:	4f10      	ldr	r7, [pc, #64]	; (be70 <_qspi_dma_init+0x58>)
	ASSERT(dev && hw);
    be30:	4798      	blx	r3
    be32:	2301      	movs	r3, #1
	dev->prvt = hw;
    be34:	f846 5b0c 	str.w	r5, [r6], #12
    be38:	602b      	str	r3, [r5, #0]
}

static inline void hri_qspi_write_CTRLB_reg(const void *const hw, hri_qspi_ctrlb_reg_t data)
{
	QSPI_CRITICAL_SECTION_ENTER();
	((Qspi *)hw)->CTRLB.reg = data;
    be3a:	4b0e      	ldr	r3, [pc, #56]	; (be74 <_qspi_dma_init+0x5c>)
    be3c:	606b      	str	r3, [r5, #4]
}

static inline void hri_qspi_write_BAUD_reg(const void *const hw, hri_qspi_baud_reg_t data)
{
	QSPI_CRITICAL_SECTION_ENTER();
	((Qspi *)hw)->BAUD.reg = data;
    be3e:	4b0e      	ldr	r3, [pc, #56]	; (be78 <_qspi_dma_init+0x60>)
    be40:	60ab      	str	r3, [r5, #8]
	_dma_get_channel_resource(&dev->resource, CONF_QSPI_DMA_RX_CHANNEL);
    be42:	211f      	movs	r1, #31
    be44:	4630      	mov	r0, r6
    be46:	47b8      	blx	r7
	dev->resource->back                 = dev;
    be48:	68e3      	ldr	r3, [r4, #12]
	dev->resource->dma_cb.transfer_done = _qspi_dma_rx_complete;
    be4a:	4a0c      	ldr	r2, [pc, #48]	; (be7c <_qspi_dma_init+0x64>)
	dev->resource->dma_cb.error         = _qspi_dma_error_occured;
    be4c:	4d0c      	ldr	r5, [pc, #48]	; (be80 <_qspi_dma_init+0x68>)
	dev->resource->back                 = dev;
    be4e:	609c      	str	r4, [r3, #8]
	dev->resource->dma_cb.transfer_done = _qspi_dma_rx_complete;
    be50:	601a      	str	r2, [r3, #0]
	dev->resource->dma_cb.error         = _qspi_dma_error_occured;
    be52:	605d      	str	r5, [r3, #4]
	/* Initialize DMA tx channel */
	_dma_get_channel_resource(&dev->resource, CONF_QSPI_DMA_TX_CHANNEL);
    be54:	211e      	movs	r1, #30
    be56:	4630      	mov	r0, r6
    be58:	47b8      	blx	r7
	dev->resource->back                 = dev;
    be5a:	68e3      	ldr	r3, [r4, #12]
	dev->resource->dma_cb.transfer_done = _qspi_dma_tx_complete;
    be5c:	4a09      	ldr	r2, [pc, #36]	; (be84 <_qspi_dma_init+0x6c>)
	dev->resource->back                 = dev;
    be5e:	609c      	str	r4, [r3, #8]
	dev->resource->dma_cb.error         = _qspi_dma_error_occured;
    be60:	e9c3 2500 	strd	r2, r5, [r3]

	return ERR_NONE;
}
    be64:	2000      	movs	r0, #0
    be66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    be68:	00016234 	.word	0x00016234
    be6c:	0000e03d 	.word	0x0000e03d
    be70:	0000e281 	.word	0x0000e281
    be74:	06000011 	.word	0x06000011
    be78:	00243b00 	.word	0x00243b00
    be7c:	0000bdf1 	.word	0x0000bdf1
    be80:	0000be0d 	.word	0x0000be0d
    be84:	0000be05 	.word	0x0000be05

0000be88 <_flash_program>:
 * \param[in]  buffer        Pointer to buffer where the data to
 *                           write is stored
 * \param[in] size           The size of data to write to a page
 */
static void _flash_program(void *const hw, const uint32_t dst_addr, const uint8_t *buffer, const uint16_t size)
{
    be88:	b570      	push	{r4, r5, r6, lr}
	uint32_t *ptr_read    = (uint32_t *)buffer;
	uint32_t  nvm_address = dst_addr / 4;
    be8a:	088d      	lsrs	r5, r1, #2
	return ((Nvmctrl *)hw)->PARAM.reg;
}

static inline bool hri_nvmctrl_get_STATUS_READY_bit(const void *const hw)
{
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    be8c:	8a44      	ldrh	r4, [r0, #18]
	uint16_t  i;

	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    be8e:	07e6      	lsls	r6, r4, #31
    be90:	d5fc      	bpl.n	be8c <_flash_program+0x4>
}

static inline void hri_nvmctrl_write_CTRLB_reg(const void *const hw, hri_nvmctrl_ctrlb_reg_t data)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg = data;
    be92:	f24a 5415 	movw	r4, #42261	; 0xa515
    be96:	8084      	strh	r4, [r0, #4]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    be98:	8a44      	ldrh	r4, [r0, #18]
		/* Wait until this module isn't busy */
	}

	hri_nvmctrl_write_CTRLB_reg(hw, NVMCTRL_CTRLB_CMD_PBC | NVMCTRL_CTRLB_CMDEX_KEY);

	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    be9a:	07e4      	lsls	r4, r4, #31
    be9c:	d5fc      	bpl.n	be98 <_flash_program+0x10>
    be9e:	00ad      	lsls	r5, r5, #2
    bea0:	2400      	movs	r4, #0
		/* Wait until this module isn't busy */
	}

	/* Writes to the page buffer must be 32 bits, perform manual copy
	 * to ensure alignment */
	for (i = 0; i < size; i += 4) {
    bea2:	b2a6      	uxth	r6, r4
    bea4:	429e      	cmp	r6, r3
    bea6:	d307      	bcc.n	beb8 <_flash_program+0x30>
    bea8:	8a43      	ldrh	r3, [r0, #18]
		NVM_MEMORY[nvm_address++] = *ptr_read;
		ptr_read++;
	}

	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    beaa:	07db      	lsls	r3, r3, #31
    beac:	d5fc      	bpl.n	bea8 <_flash_program+0x20>
	((Nvmctrl *)hw)->CTRLB.reg = data;
    beae:	f24a 5303 	movw	r3, #42243	; 0xa503
	((Nvmctrl *)hw)->ADDR.reg = data;
    beb2:	6141      	str	r1, [r0, #20]
	((Nvmctrl *)hw)->CTRLB.reg = data;
    beb4:	8083      	strh	r3, [r0, #4]
		/* Wait until this module isn't busy */
	}

	hri_nvmctrl_write_ADDR_reg(hw, dst_addr);
	hri_nvmctrl_write_CTRLB_reg(hw, NVMCTRL_CTRLB_CMD_WP | NVMCTRL_CTRLB_CMDEX_KEY);
}
    beb6:	bd70      	pop	{r4, r5, r6, pc}
		NVM_MEMORY[nvm_address++] = *ptr_read;
    beb8:	5916      	ldr	r6, [r2, r4]
    beba:	5166      	str	r6, [r4, r5]
	for (i = 0; i < size; i += 4) {
    bebc:	3404      	adds	r4, #4
    bebe:	e7f0      	b.n	bea2 <_flash_program+0x1a>

0000bec0 <_flash_init>:
{
    bec0:	b538      	push	{r3, r4, r5, lr}
    bec2:	460d      	mov	r5, r1
	ASSERT(device && (hw == NVMCTRL));
    bec4:	4604      	mov	r4, r0
    bec6:	b118      	cbz	r0, bed0 <_flash_init+0x10>
    bec8:	4814      	ldr	r0, [pc, #80]	; (bf1c <_flash_init+0x5c>)
    beca:	1a0b      	subs	r3, r1, r0
    becc:	4258      	negs	r0, r3
    bece:	4158      	adcs	r0, r3
    bed0:	4913      	ldr	r1, [pc, #76]	; (bf20 <_flash_init+0x60>)
    bed2:	4b14      	ldr	r3, [pc, #80]	; (bf24 <_flash_init+0x64>)
    bed4:	224b      	movs	r2, #75	; 0x4b
    bed6:	4798      	blx	r3
	return ((Nvmctrl *)hw)->CTRLA.reg;
    bed8:	882b      	ldrh	r3, [r5, #0]
	device->hw = hw;
    beda:	6125      	str	r5, [r4, #16]
	hri_nvmctrl_write_CTRLA_reg(hw, ctrla);
    bedc:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    bee0:	049b      	lsls	r3, r3, #18
    bee2:	0c9b      	lsrs	r3, r3, #18
	((Nvmctrl *)hw)->CTRLA.reg = data;
    bee4:	802b      	strh	r3, [r5, #0]
	_nvm_dev = device;
    bee6:	4b10      	ldr	r3, [pc, #64]	; (bf28 <_flash_init+0x68>)
    bee8:	601c      	str	r4, [r3, #0]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    beea:	4b10      	ldr	r3, [pc, #64]	; (bf2c <_flash_init+0x6c>)
    beec:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
    bef0:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
    bef4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    bef8:	f3bf 8f6f 	isb	sy
    befc:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    bf00:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    bf04:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    bf08:	f3bf 8f6f 	isb	sy
}
    bf0c:	2000      	movs	r0, #0
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    bf0e:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
    bf12:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    bf16:	6019      	str	r1, [r3, #0]
    bf18:	601a      	str	r2, [r3, #0]
    bf1a:	bd38      	pop	{r3, r4, r5, pc}
    bf1c:	41004000 	.word	0x41004000
    bf20:	0001624b 	.word	0x0001624b
    bf24:	0000e03d 	.word	0x0000e03d
    bf28:	2000854c 	.word	0x2000854c
    bf2c:	e000e100 	.word	0xe000e100

0000bf30 <_flash_get_page_size>:
}
    bf30:	f44f 7000 	mov.w	r0, #512	; 0x200
    bf34:	4770      	bx	lr

0000bf36 <_flash_get_total_pages>:
	return (uint32_t)hri_nvmctrl_read_PARAM_NVMP_bf(device->hw);
    bf36:	6903      	ldr	r3, [r0, #16]
	return (((Nvmctrl *)hw)->PARAM.reg & NVMCTRL_PARAM_NVMP_Msk) >> NVMCTRL_PARAM_NVMP_Pos;
    bf38:	6898      	ldr	r0, [r3, #8]
}
    bf3a:	b280      	uxth	r0, r0
    bf3c:	4770      	bx	lr

0000bf3e <_flash_read>:
{
    bf3e:	b510      	push	{r4, lr}
	while (!hri_nvmctrl_get_STATUS_READY_bit(device->hw)) {
    bf40:	6904      	ldr	r4, [r0, #16]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    bf42:	8a60      	ldrh	r0, [r4, #18]
    bf44:	07c0      	lsls	r0, r0, #31
    bf46:	d5fc      	bpl.n	bf42 <_flash_read+0x4>
	for (i = 0; i < length; i++) {
    bf48:	2000      	movs	r0, #0
    bf4a:	e002      	b.n	bf52 <_flash_read+0x14>
		buffer[i] = nvm_addr[src_addr + i];
    bf4c:	5c44      	ldrb	r4, [r0, r1]
    bf4e:	5414      	strb	r4, [r2, r0]
	for (i = 0; i < length; i++) {
    bf50:	3001      	adds	r0, #1
    bf52:	4298      	cmp	r0, r3
    bf54:	d1fa      	bne.n	bf4c <_flash_read+0xe>
}
    bf56:	bd10      	pop	{r4, pc}

0000bf58 <_flash_write>:
{
    bf58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bf5c:	f5ad 5d00 	sub.w	sp, sp, #8192	; 0x2000
    bf60:	b083      	sub	sp, #12
    bf62:	4606      	mov	r6, r0
    bf64:	460c      	mov	r4, r1
    bf66:	4617      	mov	r7, r2
    bf68:	9301      	str	r3, [sp, #4]
		block_start_addr = wr_start_addr & ~(NVMCTRL_BLOCK_SIZE - 1);
    bf6a:	f424 59ff 	bic.w	r9, r4, #8160	; 0x1fe0
    bf6e:	f029 091f 	bic.w	r9, r9, #31
		block_end_addr   = block_start_addr + NVMCTRL_BLOCK_SIZE - 1;
    bf72:	f509 5aff 	add.w	sl, r9, #8160	; 0x1fe0
    bf76:	f10a 0a1f 	add.w	sl, sl, #31
    bf7a:	f04f 0800 	mov.w	r8, #0
			_flash_read(device, block_start_addr + i * NVMCTRL_PAGE_SIZE, tmp_buffer[i], NVMCTRL_PAGE_SIZE);
    bf7e:	aa02      	add	r2, sp, #8
    bf80:	4442      	add	r2, r8
    bf82:	eb09 0108 	add.w	r1, r9, r8
    bf86:	4d24      	ldr	r5, [pc, #144]	; (c018 <_flash_write+0xc0>)
    bf88:	f44f 7300 	mov.w	r3, #512	; 0x200
    bf8c:	4630      	mov	r0, r6
    bf8e:	f508 7800 	add.w	r8, r8, #512	; 0x200
    bf92:	47a8      	blx	r5
		for (i = 0; i < NVMCTRL_BLOCK_PAGES; i++) {
    bf94:	f5b8 5f00 	cmp.w	r8, #8192	; 0x2000
    bf98:	d1f1      	bne.n	bf7e <_flash_write+0x26>
		j = (wr_start_addr - block_start_addr) / NVMCTRL_PAGE_SIZE;
    bf9a:	eba4 0309 	sub.w	r3, r4, r9
    bf9e:	0a5a      	lsrs	r2, r3, #9
		k = wr_start_addr - block_start_addr - j * NVMCTRL_PAGE_SIZE;
    bfa0:	4639      	mov	r1, r7
    bfa2:	f3c3 0308 	ubfx	r3, r3, #0, #9
		while ((wr_start_addr <= block_end_addr) && (length > 0)) {
    bfa6:	4554      	cmp	r4, sl
    bfa8:	460f      	mov	r7, r1
    bfaa:	d801      	bhi.n	bfb0 <_flash_write+0x58>
    bfac:	9801      	ldr	r0, [sp, #4]
    bfae:	bb18      	cbnz	r0, bff8 <_flash_write+0xa0>
		_flash_erase_block(device->hw, block_start_addr);
    bfb0:	6933      	ldr	r3, [r6, #16]
    bfb2:	8a5a      	ldrh	r2, [r3, #18]
	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    bfb4:	07d2      	lsls	r2, r2, #31
    bfb6:	d5fc      	bpl.n	bfb2 <_flash_write+0x5a>
	((Nvmctrl *)hw)->CTRLB.reg = data;
    bfb8:	f24a 5201 	movw	r2, #42241	; 0xa501
			_flash_program(device->hw, block_start_addr + i * NVMCTRL_PAGE_SIZE, tmp_buffer[i], NVMCTRL_PAGE_SIZE);
    bfbc:	f8df b05c 	ldr.w	fp, [pc, #92]	; c01c <_flash_write+0xc4>
	((Nvmctrl *)hw)->ADDR.reg = data;
    bfc0:	f8c3 9014 	str.w	r9, [r3, #20]
	((Nvmctrl *)hw)->CTRLB.reg = data;
    bfc4:	f04f 0800 	mov.w	r8, #0
    bfc8:	809a      	strh	r2, [r3, #4]
    bfca:	aa02      	add	r2, sp, #8
    bfcc:	4442      	add	r2, r8
    bfce:	eb09 0108 	add.w	r1, r9, r8
    bfd2:	6930      	ldr	r0, [r6, #16]
    bfd4:	f44f 7300 	mov.w	r3, #512	; 0x200
    bfd8:	f508 7800 	add.w	r8, r8, #512	; 0x200
    bfdc:	47d8      	blx	fp
		for (i = 0; i < NVMCTRL_BLOCK_PAGES; i++) {
    bfde:	f5b8 5f00 	cmp.w	r8, #8192	; 0x2000
    bfe2:	d1f2      	bne.n	bfca <_flash_write+0x72>
	} while (block_end_addr < (wr_start_addr + length - 1));
    bfe4:	9b01      	ldr	r3, [sp, #4]
    bfe6:	4423      	add	r3, r4
    bfe8:	3b01      	subs	r3, #1
    bfea:	4553      	cmp	r3, sl
    bfec:	d8bd      	bhi.n	bf6a <_flash_write+0x12>
}
    bfee:	f50d 5d00 	add.w	sp, sp, #8192	; 0x2000
    bff2:	b003      	add	sp, #12
    bff4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			tmp_buffer[j][k] = *buffer;
    bff8:	a802      	add	r0, sp, #8
    bffa:	eb00 2042 	add.w	r0, r0, r2, lsl #9
    bffe:	783f      	ldrb	r7, [r7, #0]
    c000:	54c7      	strb	r7, [r0, r3]
			k                = (k + 1) % NVMCTRL_PAGE_SIZE;
    c002:	3301      	adds	r3, #1
    c004:	f3c3 0308 	ubfx	r3, r3, #0, #9
			if (0 == k) {
    c008:	3101      	adds	r1, #1
    c00a:	b903      	cbnz	r3, c00e <_flash_write+0xb6>
				j++;
    c00c:	3201      	adds	r2, #1
			length--;
    c00e:	9801      	ldr	r0, [sp, #4]
    c010:	3801      	subs	r0, #1
			wr_start_addr++;
    c012:	3401      	adds	r4, #1
			length--;
    c014:	9001      	str	r0, [sp, #4]
    c016:	e7c6      	b.n	bfa6 <_flash_write+0x4e>
    c018:	0000bf3f 	.word	0x0000bf3f
    c01c:	0000be89 	.word	0x0000be89

0000c020 <_flash_erase>:
{
    c020:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	block_start_addr = dst_addr & ~(NVMCTRL_BLOCK_SIZE - 1);
    c024:	f421 54ff 	bic.w	r4, r1, #8160	; 0x1fe0
{
    c028:	f5ad 7d01 	sub.w	sp, sp, #516	; 0x204
    c02c:	460e      	mov	r6, r1
	memset(tmp_buffer, 0xFF, NVMCTRL_PAGE_SIZE);
    c02e:	4b25      	ldr	r3, [pc, #148]	; (c0c4 <_flash_erase+0xa4>)
{
    c030:	4607      	mov	r7, r0
    c032:	4615      	mov	r5, r2
	block_start_addr = dst_addr & ~(NVMCTRL_BLOCK_SIZE - 1);
    c034:	f024 041f 	bic.w	r4, r4, #31
	memset(tmp_buffer, 0xFF, NVMCTRL_PAGE_SIZE);
    c038:	f44f 7200 	mov.w	r2, #512	; 0x200
    c03c:	21ff      	movs	r1, #255	; 0xff
    c03e:	4668      	mov	r0, sp
    c040:	4798      	blx	r3
	if (dst_addr != block_start_addr) {
    c042:	42a6      	cmp	r6, r4
    c044:	d11e      	bne.n	c084 <_flash_erase+0x64>
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    c046:	4622      	mov	r2, r4
    c048:	462b      	mov	r3, r5
    c04a:	f24a 5001 	movw	r0, #42241	; 0xa501
	while (page_nums >= NVMCTRL_BLOCK_PAGES) {
    c04e:	2b0f      	cmp	r3, #15
    c050:	d82e      	bhi.n	c0b0 <_flash_erase+0x90>
    c052:	0929      	lsrs	r1, r5, #4
    c054:	f06f 020f 	mvn.w	r2, #15
    c058:	fb02 5501 	mla	r5, r2, r1, r5
    c05c:	eb04 3441 	add.w	r4, r4, r1, lsl #13
	if (page_nums != 0) {
    c060:	b165      	cbz	r5, c07c <_flash_erase+0x5c>
			_flash_write(device, block_start_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    c062:	4e19      	ldr	r6, [pc, #100]	; (c0c8 <_flash_erase+0xa8>)
    c064:	eb04 2545 	add.w	r5, r4, r5, lsl #9
    c068:	4621      	mov	r1, r4
    c06a:	f44f 7300 	mov.w	r3, #512	; 0x200
    c06e:	466a      	mov	r2, sp
    c070:	4638      	mov	r0, r7
			block_start_addr += NVMCTRL_PAGE_SIZE;
    c072:	f504 7400 	add.w	r4, r4, #512	; 0x200
			_flash_write(device, block_start_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    c076:	47b0      	blx	r6
		for (i = 0; i < page_nums; i++) {
    c078:	42a5      	cmp	r5, r4
    c07a:	d1f5      	bne.n	c068 <_flash_erase+0x48>
}
    c07c:	f50d 7d01 	add.w	sp, sp, #516	; 0x204
    c080:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    c084:	f504 5800 	add.w	r8, r4, #8192	; 0x2000
		for (i = 0; i < NVMCTRL_BLOCK_PAGES - 1; i++) {
    c088:	f506 59f0 	add.w	r9, r6, #7680	; 0x1e00
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    c08c:	4634      	mov	r4, r6
			_flash_write(device, dst_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    c08e:	4e0e      	ldr	r6, [pc, #56]	; (c0c8 <_flash_erase+0xa8>)
    c090:	f44f 7300 	mov.w	r3, #512	; 0x200
    c094:	466a      	mov	r2, sp
    c096:	4621      	mov	r1, r4
    c098:	4638      	mov	r0, r7
    c09a:	47b0      	blx	r6
			if (--page_nums == 0) {
    c09c:	3d01      	subs	r5, #1
    c09e:	d0ed      	beq.n	c07c <_flash_erase+0x5c>
			dst_addr += NVMCTRL_PAGE_SIZE;
    c0a0:	f504 7400 	add.w	r4, r4, #512	; 0x200
			if (dst_addr == block_start_addr) {
    c0a4:	45a0      	cmp	r8, r4
    c0a6:	d0ce      	beq.n	c046 <_flash_erase+0x26>
		for (i = 0; i < NVMCTRL_BLOCK_PAGES - 1; i++) {
    c0a8:	45a1      	cmp	r9, r4
    c0aa:	d1f1      	bne.n	c090 <_flash_erase+0x70>
    c0ac:	4644      	mov	r4, r8
    c0ae:	e7ca      	b.n	c046 <_flash_erase+0x26>
		_flash_erase_block(device->hw, block_start_addr);
    c0b0:	6939      	ldr	r1, [r7, #16]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    c0b2:	8a4e      	ldrh	r6, [r1, #18]
	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    c0b4:	07f6      	lsls	r6, r6, #31
    c0b6:	d5fc      	bpl.n	c0b2 <_flash_erase+0x92>
	((Nvmctrl *)hw)->ADDR.reg = data;
    c0b8:	614a      	str	r2, [r1, #20]
		page_nums -= NVMCTRL_BLOCK_PAGES;
    c0ba:	3b10      	subs	r3, #16
	((Nvmctrl *)hw)->CTRLB.reg = data;
    c0bc:	8088      	strh	r0, [r1, #4]
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    c0be:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
		page_nums -= NVMCTRL_BLOCK_PAGES;
    c0c2:	e7c4      	b.n	c04e <_flash_erase+0x2e>
    c0c4:	000142f1 	.word	0x000142f1
    c0c8:	0000bf59 	.word	0x0000bf59

0000c0cc <_flash_is_locked>:
	return !(hri_nvmctrl_get_RUNLOCK_reg(device->hw, 1 << region_id));
    c0cc:	6903      	ldr	r3, [r0, #16]
    c0ce:	f3c1 31cf 	ubfx	r1, r1, #15, #16
	tmp = ((Nvmctrl *)hw)->RUNLOCK.reg;
    c0d2:	699a      	ldr	r2, [r3, #24]
    c0d4:	2301      	movs	r3, #1
    c0d6:	fa03 f101 	lsl.w	r1, r3, r1
    c0da:	4211      	tst	r1, r2
}
    c0dc:	bf0c      	ite	eq
    c0de:	4618      	moveq	r0, r3
    c0e0:	2000      	movne	r0, #0
    c0e2:	4770      	bx	lr

0000c0e4 <NVMCTRL_0_Handler>:
/**
 * \internal NVM 0 interrupt handler
 */
void NVMCTRL_0_Handler(void)
{
	_nvm_interrupt_handler(_nvm_dev);
    c0e4:	4b09      	ldr	r3, [pc, #36]	; (c10c <NVMCTRL_0_Handler+0x28>)
    c0e6:	6818      	ldr	r0, [r3, #0]
	void *const hw = device->hw;
    c0e8:	6903      	ldr	r3, [r0, #16]
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_DONE) >> NVMCTRL_INTFLAG_DONE_Pos;
    c0ea:	8a1a      	ldrh	r2, [r3, #16]
	if (hri_nvmctrl_get_INTFLAG_DONE_bit(hw)) {
    c0ec:	07d2      	lsls	r2, r2, #31
    c0ee:	d504      	bpl.n	c0fa <NVMCTRL_0_Handler+0x16>
	((Nvmctrl *)hw)->INTFLAG.reg = NVMCTRL_INTFLAG_DONE;
    c0f0:	2201      	movs	r2, #1
    c0f2:	821a      	strh	r2, [r3, #16]
		if (NULL != device->flash_cb.ready_cb) {
    c0f4:	6803      	ldr	r3, [r0, #0]
		if (NULL != device->flash_cb.error_cb) {
    c0f6:	b143      	cbz	r3, c10a <NVMCTRL_0_Handler+0x26>
			device->flash_cb.error_cb(device);
    c0f8:	4718      	bx	r3
	return ((Nvmctrl *)hw)->INTFLAG.reg;
    c0fa:	8a1a      	ldrh	r2, [r3, #16]
    c0fc:	b292      	uxth	r2, r2
	} else if (hri_nvmctrl_read_INTFLAG_reg(hw) && ~NVMCTRL_INTFLAG_ERR) {
    c0fe:	b122      	cbz	r2, c10a <NVMCTRL_0_Handler+0x26>
	((Nvmctrl *)hw)->INTFLAG.reg = mask;
    c100:	f240 225e 	movw	r2, #606	; 0x25e
    c104:	821a      	strh	r2, [r3, #16]
		if (NULL != device->flash_cb.error_cb) {
    c106:	6843      	ldr	r3, [r0, #4]
    c108:	e7f5      	b.n	c0f6 <NVMCTRL_0_Handler+0x12>
}
    c10a:	4770      	bx	lr
    c10c:	2000854c 	.word	0x2000854c

0000c110 <NVMCTRL_1_Handler>:
    c110:	4b00      	ldr	r3, [pc, #0]	; (c114 <NVMCTRL_1_Handler+0x4>)
    c112:	4718      	bx	r3
    c114:	0000c0e5 	.word	0x0000c0e5

0000c118 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty(const Queue_t *pxQueue)
{
    c118:	b510      	push	{r4, lr}
    c11a:	4604      	mov	r4, r0
	BaseType_t xReturn;

	taskENTER_CRITICAL();
    c11c:	4b04      	ldr	r3, [pc, #16]	; (c130 <prvIsQueueEmpty+0x18>)
    c11e:	4798      	blx	r3
	{
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
    c120:	6ba4      	ldr	r4, [r4, #56]	; 0x38
			xReturn = pdTRUE;
		} else {
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    c122:	4b04      	ldr	r3, [pc, #16]	; (c134 <prvIsQueueEmpty+0x1c>)
    c124:	4798      	blx	r3

	return xReturn;
}
    c126:	fab4 f084 	clz	r0, r4
    c12a:	0940      	lsrs	r0, r0, #5
    c12c:	bd10      	pop	{r4, pc}
    c12e:	bf00      	nop
    c130:	0000b255 	.word	0x0000b255
    c134:	0000b299 	.word	0x0000b299

0000c138 <prvCopyDataToQueue>:
{
    c138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c13a:	4615      	mov	r5, r2
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
    c13c:	6c02      	ldr	r2, [r0, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c13e:	6b86      	ldr	r6, [r0, #56]	; 0x38
{
    c140:	4604      	mov	r4, r0
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
    c142:	b952      	cbnz	r2, c15a <prvCopyDataToQueue+0x22>
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    c144:	6807      	ldr	r7, [r0, #0]
    c146:	bb3f      	cbnz	r7, c198 <prvCopyDataToQueue+0x60>
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
    c148:	6840      	ldr	r0, [r0, #4]
    c14a:	4b15      	ldr	r3, [pc, #84]	; (c1a0 <prvCopyDataToQueue+0x68>)
    c14c:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
    c14e:	6067      	str	r7, [r4, #4]
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
    c150:	4605      	mov	r5, r0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + (UBaseType_t)1;
    c152:	3601      	adds	r6, #1
    c154:	63a6      	str	r6, [r4, #56]	; 0x38
}
    c156:	4628      	mov	r0, r5
    c158:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
    c15a:	4b12      	ldr	r3, [pc, #72]	; (c1a4 <prvCopyDataToQueue+0x6c>)
    c15c:	b95d      	cbnz	r5, c176 <prvCopyDataToQueue+0x3e>
		(void)memcpy((void *)pxQueue->pcWriteTo,
    c15e:	6880      	ldr	r0, [r0, #8]
    c160:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c162:	68a3      	ldr	r3, [r4, #8]
    c164:	6c22      	ldr	r2, [r4, #64]	; 0x40
    c166:	4413      	add	r3, r2
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
    c168:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c16a:	60a3      	str	r3, [r4, #8]
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
    c16c:	4293      	cmp	r3, r2
    c16e:	d3f0      	bcc.n	c152 <prvCopyDataToQueue+0x1a>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    c170:	6823      	ldr	r3, [r4, #0]
    c172:	60a3      	str	r3, [r4, #8]
    c174:	e7ed      	b.n	c152 <prvCopyDataToQueue+0x1a>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
    c176:	68c0      	ldr	r0, [r0, #12]
    c178:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c17a:	6c22      	ldr	r2, [r4, #64]	; 0x40
    c17c:	68e3      	ldr	r3, [r4, #12]
    c17e:	4251      	negs	r1, r2
    c180:	1a9b      	subs	r3, r3, r2
		if (pxQueue->u.pcReadFrom
    c182:	6822      	ldr	r2, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c184:	60e3      	str	r3, [r4, #12]
		if (pxQueue->u.pcReadFrom
    c186:	4293      	cmp	r3, r2
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
    c188:	bf3e      	ittt	cc
    c18a:	6863      	ldrcc	r3, [r4, #4]
    c18c:	185b      	addcc	r3, r3, r1
    c18e:	60e3      	strcc	r3, [r4, #12]
		if (xPosition == queueOVERWRITE) {
    c190:	2d02      	cmp	r5, #2
    c192:	d101      	bne.n	c198 <prvCopyDataToQueue+0x60>
			if (uxMessagesWaiting > (UBaseType_t)0) {
    c194:	b116      	cbz	r6, c19c <prvCopyDataToQueue+0x64>
				--uxMessagesWaiting;
    c196:	3e01      	subs	r6, #1
	BaseType_t  xReturn = pdFALSE;
    c198:	2500      	movs	r5, #0
    c19a:	e7da      	b.n	c152 <prvCopyDataToQueue+0x1a>
    c19c:	4635      	mov	r5, r6
    c19e:	e7d8      	b.n	c152 <prvCopyDataToQueue+0x1a>
    c1a0:	00012c4d 	.word	0x00012c4d
    c1a4:	000142d5 	.word	0x000142d5

0000c1a8 <prvCopyDataFromQueue>:
{
    c1a8:	4603      	mov	r3, r0
    c1aa:	b410      	push	{r4}
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
    c1ac:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
    c1ae:	4608      	mov	r0, r1
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
    c1b0:	b16a      	cbz	r2, c1ce <prvCopyDataFromQueue+0x26>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    c1b2:	68dc      	ldr	r4, [r3, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
    c1b4:	6859      	ldr	r1, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    c1b6:	4414      	add	r4, r2
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
    c1b8:	428c      	cmp	r4, r1
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    c1ba:	bf28      	it	cs
    c1bc:	6819      	ldrcs	r1, [r3, #0]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    c1be:	60dc      	str	r4, [r3, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    c1c0:	bf28      	it	cs
    c1c2:	60d9      	strcs	r1, [r3, #12]
		(void)memcpy((void *)pvBuffer,
    c1c4:	68d9      	ldr	r1, [r3, #12]
}
    c1c6:	f85d 4b04 	ldr.w	r4, [sp], #4
		(void)memcpy((void *)pvBuffer,
    c1ca:	4b02      	ldr	r3, [pc, #8]	; (c1d4 <prvCopyDataFromQueue+0x2c>)
    c1cc:	4718      	bx	r3
}
    c1ce:	f85d 4b04 	ldr.w	r4, [sp], #4
    c1d2:	4770      	bx	lr
    c1d4:	000142d5 	.word	0x000142d5

0000c1d8 <prvNotifyQueueSetContainer.part.0>:
    c1d8:	f04f 0380 	mov.w	r3, #128	; 0x80
    c1dc:	f383 8811 	msr	BASEPRI, r3
    c1e0:	f3bf 8f6f 	isb	sy
    c1e4:	f3bf 8f4f 	dsb	sy
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
    c1e8:	e7fe      	b.n	c1e8 <prvNotifyQueueSetContainer.part.0+0x10>
	...

0000c1ec <prvNotifyQueueSetContainer>:
{
    c1ec:	b573      	push	{r0, r1, r4, r5, r6, lr}
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    c1ee:	6c84      	ldr	r4, [r0, #72]	; 0x48
{
    c1f0:	9001      	str	r0, [sp, #4]
    c1f2:	460a      	mov	r2, r1
	configASSERT(pxQueueSetContainer);
    c1f4:	b90c      	cbnz	r4, c1fa <prvNotifyQueueSetContainer+0xe>
    c1f6:	4b17      	ldr	r3, [pc, #92]	; (c254 <prvNotifyQueueSetContainer+0x68>)
    c1f8:	4798      	blx	r3
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
    c1fa:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    c1fc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c1fe:	4299      	cmp	r1, r3
    c200:	d308      	bcc.n	c214 <prvNotifyQueueSetContainer+0x28>
    c202:	f04f 0380 	mov.w	r3, #128	; 0x80
    c206:	f383 8811 	msr	BASEPRI, r3
    c20a:	f3bf 8f6f 	isb	sy
    c20e:	f3bf 8f4f 	dsb	sy
    c212:	e7fe      	b.n	c212 <prvNotifyQueueSetContainer+0x26>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
    c214:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    c216:	428b      	cmp	r3, r1
    c218:	d91a      	bls.n	c250 <prvNotifyQueueSetContainer+0x64>
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    c21a:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45

		traceQUEUE_SEND(pxQueueSetContainer);

		/* The data copied is the handle of the queue that contains data. */
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
    c21e:	4b0e      	ldr	r3, [pc, #56]	; (c258 <prvNotifyQueueSetContainer+0x6c>)
    c220:	a901      	add	r1, sp, #4
    c222:	4620      	mov	r0, r4
    c224:	4798      	blx	r3
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    c226:	b26d      	sxtb	r5, r5

		if (cTxLock == queueUNLOCKED) {
    c228:	1c6b      	adds	r3, r5, #1
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
    c22a:	4606      	mov	r6, r0
		if (cTxLock == queueUNLOCKED) {
    c22c:	d10b      	bne.n	c246 <prvNotifyQueueSetContainer+0x5a>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
    c22e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c230:	b133      	cbz	r3, c240 <prvNotifyQueueSetContainer+0x54>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
    c232:	4b0a      	ldr	r3, [pc, #40]	; (c25c <prvNotifyQueueSetContainer+0x70>)
    c234:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c238:	4798      	blx	r3
					/* The task waiting has a higher priority. */
					xReturn = pdTRUE;
    c23a:	2800      	cmp	r0, #0
    c23c:	bf18      	it	ne
    c23e:	2601      	movne	r6, #1
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    c240:	4630      	mov	r0, r6
    c242:	b002      	add	sp, #8
    c244:	bd70      	pop	{r4, r5, r6, pc}
			pxQueueSetContainer->cTxLock = (int8_t)(cTxLock + 1);
    c246:	3501      	adds	r5, #1
    c248:	b26d      	sxtb	r5, r5
    c24a:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
    c24e:	e7f7      	b.n	c240 <prvNotifyQueueSetContainer+0x54>
	BaseType_t xReturn             = pdFALSE;
    c250:	2600      	movs	r6, #0
	return xReturn;
    c252:	e7f5      	b.n	c240 <prvNotifyQueueSetContainer+0x54>
    c254:	0000c1d9 	.word	0x0000c1d9
    c258:	0000c139 	.word	0x0000c139
    c25c:	00012b05 	.word	0x00012b05

0000c260 <prvUnlockQueue>:
{
    c260:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c264:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
    c266:	4f1f      	ldr	r7, [pc, #124]	; (c2e4 <prvUnlockQueue+0x84>)
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    c268:	4e1f      	ldr	r6, [pc, #124]	; (c2e8 <prvUnlockQueue+0x88>)
						vTaskMissedYield();
    c26a:	f8df 8084 	ldr.w	r8, [pc, #132]	; c2f0 <prvUnlockQueue+0x90>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    c26e:	f8df 9084 	ldr.w	r9, [pc, #132]	; c2f4 <prvUnlockQueue+0x94>
	taskENTER_CRITICAL();
    c272:	47b8      	blx	r7
		int8_t cTxLock = pxQueue->cTxLock;
    c274:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    c278:	b26d      	sxtb	r5, r5
		while (cTxLock > queueLOCKED_UNMODIFIED) {
    c27a:	2d00      	cmp	r5, #0
    c27c:	dc17      	bgt.n	c2ae <prvUnlockQueue+0x4e>
		pxQueue->cTxLock = queueUNLOCKED;
    c27e:	23ff      	movs	r3, #255	; 0xff
    c280:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    c284:	4e19      	ldr	r6, [pc, #100]	; (c2ec <prvUnlockQueue+0x8c>)
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c286:	f8df 8060 	ldr.w	r8, [pc, #96]	; c2e8 <prvUnlockQueue+0x88>
					vTaskMissedYield();
    c28a:	f8df 9064 	ldr.w	r9, [pc, #100]	; c2f0 <prvUnlockQueue+0x90>
	taskEXIT_CRITICAL();
    c28e:	47b0      	blx	r6
	taskENTER_CRITICAL();
    c290:	47b8      	blx	r7
		int8_t cRxLock = pxQueue->cRxLock;
    c292:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c296:	f104 0710 	add.w	r7, r4, #16
		int8_t cRxLock = pxQueue->cRxLock;
    c29a:	b26d      	sxtb	r5, r5
		while (cRxLock > queueLOCKED_UNMODIFIED) {
    c29c:	2d00      	cmp	r5, #0
    c29e:	dc17      	bgt.n	c2d0 <prvUnlockQueue+0x70>
		pxQueue->cRxLock = queueUNLOCKED;
    c2a0:	23ff      	movs	r3, #255	; 0xff
    c2a2:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    c2a6:	4633      	mov	r3, r6
}
    c2a8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	taskEXIT_CRITICAL();
    c2ac:	4718      	bx	r3
				if (pxQueue->pxQueueSetContainer != NULL) {
    c2ae:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    c2b0:	b13b      	cbz	r3, c2c2 <prvUnlockQueue+0x62>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    c2b2:	2100      	movs	r1, #0
    c2b4:	4620      	mov	r0, r4
    c2b6:	47c8      	blx	r9
    c2b8:	b100      	cbz	r0, c2bc <prvUnlockQueue+0x5c>
						vTaskMissedYield();
    c2ba:	47c0      	blx	r8
			--cTxLock;
    c2bc:	3d01      	subs	r5, #1
    c2be:	b26d      	sxtb	r5, r5
    c2c0:	e7db      	b.n	c27a <prvUnlockQueue+0x1a>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    c2c2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c2c4:	2b00      	cmp	r3, #0
    c2c6:	d0da      	beq.n	c27e <prvUnlockQueue+0x1e>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    c2c8:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c2cc:	47b0      	blx	r6
    c2ce:	e7f3      	b.n	c2b8 <prvUnlockQueue+0x58>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    c2d0:	6923      	ldr	r3, [r4, #16]
    c2d2:	2b00      	cmp	r3, #0
    c2d4:	d0e4      	beq.n	c2a0 <prvUnlockQueue+0x40>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c2d6:	4638      	mov	r0, r7
    c2d8:	47c0      	blx	r8
    c2da:	b100      	cbz	r0, c2de <prvUnlockQueue+0x7e>
					vTaskMissedYield();
    c2dc:	47c8      	blx	r9
				--cRxLock;
    c2de:	3d01      	subs	r5, #1
    c2e0:	b26d      	sxtb	r5, r5
    c2e2:	e7db      	b.n	c29c <prvUnlockQueue+0x3c>
    c2e4:	0000b255 	.word	0x0000b255
    c2e8:	00012b05 	.word	0x00012b05
    c2ec:	0000b299 	.word	0x0000b299
    c2f0:	00012c1d 	.word	0x00012c1d
    c2f4:	0000c1ed 	.word	0x0000c1ed

0000c2f8 <xQueueGenericReset>:
{
    c2f8:	b538      	push	{r3, r4, r5, lr}
    c2fa:	460d      	mov	r5, r1
	configASSERT(pxQueue);
    c2fc:	4604      	mov	r4, r0
    c2fe:	b908      	cbnz	r0, c304 <xQueueGenericReset+0xc>
    c300:	4b18      	ldr	r3, [pc, #96]	; (c364 <xQueueGenericReset+0x6c>)
    c302:	4798      	blx	r3
	taskENTER_CRITICAL();
    c304:	4b18      	ldr	r3, [pc, #96]	; (c368 <xQueueGenericReset+0x70>)
    c306:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    c308:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
    c30c:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo         = pxQueue->pcHead;
    c30e:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    c310:	434b      	muls	r3, r1
    c312:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    c314:	1a5b      	subs	r3, r3, r1
    c316:	4413      	add	r3, r2
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    c318:	6060      	str	r0, [r4, #4]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    c31a:	60e3      	str	r3, [r4, #12]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    c31c:	2000      	movs	r0, #0
		pxQueue->cRxLock           = queueUNLOCKED;
    c31e:	23ff      	movs	r3, #255	; 0xff
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    c320:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock           = queueUNLOCKED;
    c322:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock           = queueUNLOCKED;
    c326:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if (xNewQueue == pdFALSE) {
    c32a:	b995      	cbnz	r5, c352 <xQueueGenericReset+0x5a>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    c32c:	6923      	ldr	r3, [r4, #16]
    c32e:	b163      	cbz	r3, c34a <xQueueGenericReset+0x52>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c330:	4b0e      	ldr	r3, [pc, #56]	; (c36c <xQueueGenericReset+0x74>)
    c332:	f104 0010 	add.w	r0, r4, #16
    c336:	4798      	blx	r3
    c338:	b138      	cbz	r0, c34a <xQueueGenericReset+0x52>
					queueYIELD_IF_USING_PREEMPTION();
    c33a:	4b0d      	ldr	r3, [pc, #52]	; (c370 <xQueueGenericReset+0x78>)
    c33c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c340:	601a      	str	r2, [r3, #0]
    c342:	f3bf 8f4f 	dsb	sy
    c346:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
    c34a:	4b0a      	ldr	r3, [pc, #40]	; (c374 <xQueueGenericReset+0x7c>)
    c34c:	4798      	blx	r3
}
    c34e:	2001      	movs	r0, #1
    c350:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
    c352:	f104 0010 	add.w	r0, r4, #16
    c356:	4d08      	ldr	r5, [pc, #32]	; (c378 <xQueueGenericReset+0x80>)
    c358:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
    c35a:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c35e:	47a8      	blx	r5
    c360:	e7f3      	b.n	c34a <xQueueGenericReset+0x52>
    c362:	bf00      	nop
    c364:	0000c1d9 	.word	0x0000c1d9
    c368:	0000b255 	.word	0x0000b255
    c36c:	00012b05 	.word	0x00012b05
    c370:	e000ed04 	.word	0xe000ed04
    c374:	0000b299 	.word	0x0000b299
    c378:	0000b105 	.word	0x0000b105

0000c37c <xQueueGenericCreate>:
{
    c37c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c37e:	460d      	mov	r5, r1
    c380:	4617      	mov	r7, r2
	configASSERT(uxQueueLength > (UBaseType_t)0);
    c382:	4606      	mov	r6, r0
    c384:	b940      	cbnz	r0, c398 <xQueueGenericCreate+0x1c>
    c386:	f04f 0380 	mov.w	r3, #128	; 0x80
    c38a:	f383 8811 	msr	BASEPRI, r3
    c38e:	f3bf 8f6f 	isb	sy
    c392:	f3bf 8f4f 	dsb	sy
    c396:	e7fe      	b.n	c396 <xQueueGenericCreate+0x1a>
		xQueueSizeInBytes = (size_t)(
    c398:	4348      	muls	r0, r1
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
    c39a:	4b0b      	ldr	r3, [pc, #44]	; (c3c8 <xQueueGenericCreate+0x4c>)
    c39c:	3054      	adds	r0, #84	; 0x54
    c39e:	4798      	blx	r3
	if (pxNewQueue != NULL) {
    c3a0:	4604      	mov	r4, r0
    c3a2:	b168      	cbz	r0, c3c0 <xQueueGenericCreate+0x44>
	if (uxItemSize == (UBaseType_t)0) {
    c3a4:	b175      	cbz	r5, c3c4 <xQueueGenericCreate+0x48>
		pucQueueStorage = ((uint8_t *)pxNewQueue) + sizeof(Queue_t);
    c3a6:	f100 0354 	add.w	r3, r0, #84	; 0x54
		pxNewQueue->pcHead = (int8_t *)pucQueueStorage;
    c3aa:	6023      	str	r3, [r4, #0]
	pxNewQueue->uxItemSize = uxItemSize;
    c3ac:	e9c4 650f 	strd	r6, r5, [r4, #60]	; 0x3c
	(void)xQueueGenericReset(pxNewQueue, pdTRUE);
    c3b0:	4b06      	ldr	r3, [pc, #24]	; (c3cc <xQueueGenericCreate+0x50>)
    c3b2:	2101      	movs	r1, #1
    c3b4:	4620      	mov	r0, r4
    c3b6:	4798      	blx	r3
		pxNewQueue->pxQueueSetContainer = NULL;
    c3b8:	2300      	movs	r3, #0
		pxNewQueue->ucQueueType = ucQueueType;
    c3ba:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
		pxNewQueue->pxQueueSetContainer = NULL;
    c3be:	64a3      	str	r3, [r4, #72]	; 0x48
}
    c3c0:	4620      	mov	r0, r4
    c3c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c3c4:	4603      	mov	r3, r0
    c3c6:	e7f0      	b.n	c3aa <xQueueGenericCreate+0x2e>
    c3c8:	0000b615 	.word	0x0000b615
    c3cc:	0000c2f9 	.word	0x0000c2f9

0000c3d0 <xQueueGenericSend>:
{
    c3d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c3d4:	b085      	sub	sp, #20
    c3d6:	460e      	mov	r6, r1
    c3d8:	9201      	str	r2, [sp, #4]
    c3da:	461c      	mov	r4, r3
	configASSERT(pxQueue);
    c3dc:	4683      	mov	fp, r0
    c3de:	b940      	cbnz	r0, c3f2 <xQueueGenericSend+0x22>
    c3e0:	f04f 0380 	mov.w	r3, #128	; 0x80
    c3e4:	f383 8811 	msr	BASEPRI, r3
    c3e8:	f3bf 8f6f 	isb	sy
    c3ec:	f3bf 8f4f 	dsb	sy
    c3f0:	e7fe      	b.n	c3f0 <xQueueGenericSend+0x20>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    c3f2:	b951      	cbnz	r1, c40a <xQueueGenericSend+0x3a>
    c3f4:	6c02      	ldr	r2, [r0, #64]	; 0x40
    c3f6:	b142      	cbz	r2, c40a <xQueueGenericSend+0x3a>
    c3f8:	f04f 0380 	mov.w	r3, #128	; 0x80
    c3fc:	f383 8811 	msr	BASEPRI, r3
    c400:	f3bf 8f6f 	isb	sy
    c404:	f3bf 8f4f 	dsb	sy
    c408:	e7fe      	b.n	c408 <xQueueGenericSend+0x38>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    c40a:	2c02      	cmp	r4, #2
    c40c:	d10c      	bne.n	c428 <xQueueGenericSend+0x58>
    c40e:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
    c412:	2a01      	cmp	r2, #1
    c414:	d008      	beq.n	c428 <xQueueGenericSend+0x58>
    c416:	f04f 0380 	mov.w	r3, #128	; 0x80
    c41a:	f383 8811 	msr	BASEPRI, r3
    c41e:	f3bf 8f6f 	isb	sy
    c422:	f3bf 8f4f 	dsb	sy
    c426:	e7fe      	b.n	c426 <xQueueGenericSend+0x56>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    c428:	4a47      	ldr	r2, [pc, #284]	; (c548 <xQueueGenericSend+0x178>)
    c42a:	4790      	blx	r2
    c42c:	4680      	mov	r8, r0
    c42e:	b950      	cbnz	r0, c446 <xQueueGenericSend+0x76>
    c430:	9a01      	ldr	r2, [sp, #4]
    c432:	b152      	cbz	r2, c44a <xQueueGenericSend+0x7a>
    c434:	f04f 0380 	mov.w	r3, #128	; 0x80
    c438:	f383 8811 	msr	BASEPRI, r3
    c43c:	f3bf 8f6f 	isb	sy
    c440:	f3bf 8f4f 	dsb	sy
    c444:	e7fe      	b.n	c444 <xQueueGenericSend+0x74>
    c446:	f04f 0800 	mov.w	r8, #0
		taskENTER_CRITICAL();
    c44a:	f8df 9128 	ldr.w	r9, [pc, #296]	; c574 <xQueueGenericSend+0x1a4>
    c44e:	46ca      	mov	sl, r9
    c450:	e042      	b.n	c4d8 <xQueueGenericSend+0x108>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    c452:	f8db 2024 	ldr.w	r2, [fp, #36]	; 0x24
    c456:	2a00      	cmp	r2, #0
    c458:	d055      	beq.n	c506 <xQueueGenericSend+0x136>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    c45a:	4b3c      	ldr	r3, [pc, #240]	; (c54c <xQueueGenericSend+0x17c>)
    c45c:	f10b 0024 	add.w	r0, fp, #36	; 0x24
    c460:	4798      	blx	r3
    c462:	e050      	b.n	c506 <xQueueGenericSend+0x136>
				if (xTicksToWait == (TickType_t)0) {
    c464:	9f01      	ldr	r7, [sp, #4]
    c466:	b917      	cbnz	r7, c46e <xQueueGenericSend+0x9e>
					taskEXIT_CRITICAL();
    c468:	47a8      	blx	r5
			return errQUEUE_FULL;
    c46a:	2000      	movs	r0, #0
    c46c:	e056      	b.n	c51c <xQueueGenericSend+0x14c>
				} else if (xEntryTimeSet == pdFALSE) {
    c46e:	f1b8 0f00 	cmp.w	r8, #0
    c472:	d102      	bne.n	c47a <xQueueGenericSend+0xaa>
					vTaskInternalSetTimeOutState(&xTimeOut);
    c474:	4a36      	ldr	r2, [pc, #216]	; (c550 <xQueueGenericSend+0x180>)
    c476:	a802      	add	r0, sp, #8
    c478:	4790      	blx	r2
		taskEXIT_CRITICAL();
    c47a:	47a8      	blx	r5
		vTaskSuspendAll();
    c47c:	4a35      	ldr	r2, [pc, #212]	; (c554 <xQueueGenericSend+0x184>)
    c47e:	f8df 80f8 	ldr.w	r8, [pc, #248]	; c578 <xQueueGenericSend+0x1a8>
    c482:	4f35      	ldr	r7, [pc, #212]	; (c558 <xQueueGenericSend+0x188>)
    c484:	4790      	blx	r2
		prvLockQueue(pxQueue);
    c486:	47d0      	blx	sl
    c488:	f89b 2044 	ldrb.w	r2, [fp, #68]	; 0x44
    c48c:	2aff      	cmp	r2, #255	; 0xff
    c48e:	bf04      	itt	eq
    c490:	2200      	moveq	r2, #0
    c492:	f88b 2044 	strbeq.w	r2, [fp, #68]	; 0x44
    c496:	f89b 2045 	ldrb.w	r2, [fp, #69]	; 0x45
    c49a:	2aff      	cmp	r2, #255	; 0xff
    c49c:	bf04      	itt	eq
    c49e:	2200      	moveq	r2, #0
    c4a0:	f88b 2045 	strbeq.w	r2, [fp, #69]	; 0x45
    c4a4:	47a8      	blx	r5
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    c4a6:	4a2d      	ldr	r2, [pc, #180]	; (c55c <xQueueGenericSend+0x18c>)
    c4a8:	a901      	add	r1, sp, #4
    c4aa:	a802      	add	r0, sp, #8
    c4ac:	4790      	blx	r2
    c4ae:	2800      	cmp	r0, #0
    c4b0:	d145      	bne.n	c53e <xQueueGenericSend+0x16e>
	taskENTER_CRITICAL();
    c4b2:	47d0      	blx	sl
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
    c4b4:	f8db 1038 	ldr.w	r1, [fp, #56]	; 0x38
    c4b8:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
    c4bc:	4291      	cmp	r1, r2
    c4be:	d130      	bne.n	c522 <xQueueGenericSend+0x152>
	taskEXIT_CRITICAL();
    c4c0:	47a8      	blx	r5
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
    c4c2:	9901      	ldr	r1, [sp, #4]
    c4c4:	4a26      	ldr	r2, [pc, #152]	; (c560 <xQueueGenericSend+0x190>)
    c4c6:	f10b 0010 	add.w	r0, fp, #16
    c4ca:	4790      	blx	r2
				prvUnlockQueue(pxQueue);
    c4cc:	4658      	mov	r0, fp
    c4ce:	47c0      	blx	r8
				if (xTaskResumeAll() == pdFALSE) {
    c4d0:	47b8      	blx	r7
    c4d2:	b358      	cbz	r0, c52c <xQueueGenericSend+0x15c>
    c4d4:	f04f 0801 	mov.w	r8, #1
		taskENTER_CRITICAL();
    c4d8:	47c8      	blx	r9
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    c4da:	f8db 1038 	ldr.w	r1, [fp, #56]	; 0x38
    c4de:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
    c4e2:	4d20      	ldr	r5, [pc, #128]	; (c564 <xQueueGenericSend+0x194>)
    c4e4:	4291      	cmp	r1, r2
    c4e6:	d301      	bcc.n	c4ec <xQueueGenericSend+0x11c>
    c4e8:	2c02      	cmp	r4, #2
    c4ea:	d1bb      	bne.n	c464 <xQueueGenericSend+0x94>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    c4ec:	4622      	mov	r2, r4
    c4ee:	4631      	mov	r1, r6
    c4f0:	4658      	mov	r0, fp
    c4f2:	4e1d      	ldr	r6, [pc, #116]	; (c568 <xQueueGenericSend+0x198>)
    c4f4:	47b0      	blx	r6
					if (pxQueue->pxQueueSetContainer != NULL) {
    c4f6:	f8db 2048 	ldr.w	r2, [fp, #72]	; 0x48
    c4fa:	2a00      	cmp	r2, #0
    c4fc:	d0a9      	beq.n	c452 <xQueueGenericSend+0x82>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    c4fe:	4b1b      	ldr	r3, [pc, #108]	; (c56c <xQueueGenericSend+0x19c>)
    c500:	4621      	mov	r1, r4
    c502:	4658      	mov	r0, fp
    c504:	4798      	blx	r3
						} else if (xYieldRequired != pdFALSE) {
    c506:	b138      	cbz	r0, c518 <xQueueGenericSend+0x148>
							queueYIELD_IF_USING_PREEMPTION();
    c508:	4b19      	ldr	r3, [pc, #100]	; (c570 <xQueueGenericSend+0x1a0>)
    c50a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c50e:	601a      	str	r2, [r3, #0]
    c510:	f3bf 8f4f 	dsb	sy
    c514:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    c518:	47a8      	blx	r5
				return pdPASS;
    c51a:	2001      	movs	r0, #1
}
    c51c:	b005      	add	sp, #20
    c51e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	taskEXIT_CRITICAL();
    c522:	47a8      	blx	r5
				prvUnlockQueue(pxQueue);
    c524:	4658      	mov	r0, fp
    c526:	47c0      	blx	r8
				(void)xTaskResumeAll();
    c528:	47b8      	blx	r7
    c52a:	e7d3      	b.n	c4d4 <xQueueGenericSend+0x104>
					portYIELD_WITHIN_API();
    c52c:	4b10      	ldr	r3, [pc, #64]	; (c570 <xQueueGenericSend+0x1a0>)
    c52e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c532:	601a      	str	r2, [r3, #0]
    c534:	f3bf 8f4f 	dsb	sy
    c538:	f3bf 8f6f 	isb	sy
    c53c:	e7ca      	b.n	c4d4 <xQueueGenericSend+0x104>
			prvUnlockQueue(pxQueue);
    c53e:	4658      	mov	r0, fp
    c540:	47c0      	blx	r8
			(void)xTaskResumeAll();
    c542:	47b8      	blx	r7
    c544:	e791      	b.n	c46a <xQueueGenericSend+0x9a>
    c546:	bf00      	nop
    c548:	00012c2d 	.word	0x00012c2d
    c54c:	00012b05 	.word	0x00012b05
    c550:	00012b85 	.word	0x00012b85
    c554:	00012761 	.word	0x00012761
    c558:	000128a9 	.word	0x000128a9
    c55c:	00012b99 	.word	0x00012b99
    c560:	00012a81 	.word	0x00012a81
    c564:	0000b299 	.word	0x0000b299
    c568:	0000c139 	.word	0x0000c139
    c56c:	0000c1ed 	.word	0x0000c1ed
    c570:	e000ed04 	.word	0xe000ed04
    c574:	0000b255 	.word	0x0000b255
    c578:	0000c261 	.word	0x0000c261

0000c57c <xQueueGenericSendFromISR>:
{
    c57c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    c580:	4689      	mov	r9, r1
    c582:	4690      	mov	r8, r2
    c584:	461f      	mov	r7, r3
	configASSERT(pxQueue);
    c586:	4604      	mov	r4, r0
    c588:	b940      	cbnz	r0, c59c <xQueueGenericSendFromISR+0x20>
    c58a:	f04f 0380 	mov.w	r3, #128	; 0x80
    c58e:	f383 8811 	msr	BASEPRI, r3
    c592:	f3bf 8f6f 	isb	sy
    c596:	f3bf 8f4f 	dsb	sy
    c59a:	e7fe      	b.n	c59a <xQueueGenericSendFromISR+0x1e>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    c59c:	b951      	cbnz	r1, c5b4 <xQueueGenericSendFromISR+0x38>
    c59e:	6c03      	ldr	r3, [r0, #64]	; 0x40
    c5a0:	b143      	cbz	r3, c5b4 <xQueueGenericSendFromISR+0x38>
    c5a2:	f04f 0380 	mov.w	r3, #128	; 0x80
    c5a6:	f383 8811 	msr	BASEPRI, r3
    c5aa:	f3bf 8f6f 	isb	sy
    c5ae:	f3bf 8f4f 	dsb	sy
    c5b2:	e7fe      	b.n	c5b2 <xQueueGenericSendFromISR+0x36>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    c5b4:	2f02      	cmp	r7, #2
    c5b6:	d10b      	bne.n	c5d0 <xQueueGenericSendFromISR+0x54>
    c5b8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c5ba:	2b01      	cmp	r3, #1
    c5bc:	d008      	beq.n	c5d0 <xQueueGenericSendFromISR+0x54>
    c5be:	f04f 0380 	mov.w	r3, #128	; 0x80
    c5c2:	f383 8811 	msr	BASEPRI, r3
    c5c6:	f3bf 8f6f 	isb	sy
    c5ca:	f3bf 8f4f 	dsb	sy
    c5ce:	e7fe      	b.n	c5ce <xQueueGenericSendFromISR+0x52>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    c5d0:	4b1e      	ldr	r3, [pc, #120]	; (c64c <xQueueGenericSendFromISR+0xd0>)
    c5d2:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
    c5d4:	f3ef 8611 	mrs	r6, BASEPRI
    c5d8:	f04f 0380 	mov.w	r3, #128	; 0x80
    c5dc:	f383 8811 	msr	BASEPRI, r3
    c5e0:	f3bf 8f6f 	isb	sy
    c5e4:	f3bf 8f4f 	dsb	sy
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    c5e8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    c5ea:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c5ec:	429a      	cmp	r2, r3
    c5ee:	d301      	bcc.n	c5f4 <xQueueGenericSendFromISR+0x78>
    c5f0:	2f02      	cmp	r7, #2
    c5f2:	d129      	bne.n	c648 <xQueueGenericSendFromISR+0xcc>
			const int8_t cTxLock = pxQueue->cTxLock;
    c5f4:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    c5f8:	4b15      	ldr	r3, [pc, #84]	; (c650 <xQueueGenericSendFromISR+0xd4>)
			const int8_t cTxLock = pxQueue->cTxLock;
    c5fa:	b26d      	sxtb	r5, r5
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    c5fc:	463a      	mov	r2, r7
    c5fe:	4649      	mov	r1, r9
    c600:	4620      	mov	r0, r4
    c602:	4798      	blx	r3
			if (cTxLock == queueUNLOCKED) {
    c604:	1c6b      	adds	r3, r5, #1
    c606:	d11a      	bne.n	c63e <xQueueGenericSendFromISR+0xc2>
					if (pxQueue->pxQueueSetContainer != NULL) {
    c608:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    c60a:	b183      	cbz	r3, c62e <xQueueGenericSendFromISR+0xb2>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    c60c:	4b11      	ldr	r3, [pc, #68]	; (c654 <xQueueGenericSendFromISR+0xd8>)
    c60e:	4639      	mov	r1, r7
    c610:	4620      	mov	r0, r4
    c612:	4798      	blx	r3
    c614:	b908      	cbnz	r0, c61a <xQueueGenericSendFromISR+0x9e>
			xReturn = pdPASS;
    c616:	2001      	movs	r0, #1
    c618:	e005      	b.n	c626 <xQueueGenericSendFromISR+0xaa>
							if (pxHigherPriorityTaskWoken != NULL) {
    c61a:	f1b8 0f00 	cmp.w	r8, #0
    c61e:	d0fa      	beq.n	c616 <xQueueGenericSendFromISR+0x9a>
								*pxHigherPriorityTaskWoken = pdTRUE;
    c620:	2001      	movs	r0, #1
    c622:	f8c8 0000 	str.w	r0, [r8]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    c626:	f386 8811 	msr	BASEPRI, r6
}
    c62a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    c62e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c630:	2b00      	cmp	r3, #0
    c632:	d0f0      	beq.n	c616 <xQueueGenericSendFromISR+0x9a>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    c634:	4b08      	ldr	r3, [pc, #32]	; (c658 <xQueueGenericSendFromISR+0xdc>)
    c636:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c63a:	4798      	blx	r3
    c63c:	e7ea      	b.n	c614 <xQueueGenericSendFromISR+0x98>
				pxQueue->cTxLock = (int8_t)(cTxLock + 1);
    c63e:	3501      	adds	r5, #1
    c640:	b26d      	sxtb	r5, r5
    c642:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
    c646:	e7e6      	b.n	c616 <xQueueGenericSendFromISR+0x9a>
			xReturn = errQUEUE_FULL;
    c648:	2000      	movs	r0, #0
    c64a:	e7ec      	b.n	c626 <xQueueGenericSendFromISR+0xaa>
    c64c:	0000b48d 	.word	0x0000b48d
    c650:	0000c139 	.word	0x0000c139
    c654:	0000c1ed 	.word	0x0000c1ed
    c658:	00012b05 	.word	0x00012b05

0000c65c <xQueueReceive>:
{
    c65c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c660:	b085      	sub	sp, #20
    c662:	460f      	mov	r7, r1
    c664:	9201      	str	r2, [sp, #4]
	configASSERT((pxQueue));
    c666:	4604      	mov	r4, r0
    c668:	b940      	cbnz	r0, c67c <xQueueReceive+0x20>
	__asm volatile("	mov %0, %1												\n"
    c66a:	f04f 0380 	mov.w	r3, #128	; 0x80
    c66e:	f383 8811 	msr	BASEPRI, r3
    c672:	f3bf 8f6f 	isb	sy
    c676:	f3bf 8f4f 	dsb	sy
    c67a:	e7fe      	b.n	c67a <xQueueReceive+0x1e>
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
    c67c:	b951      	cbnz	r1, c694 <xQueueReceive+0x38>
    c67e:	6c03      	ldr	r3, [r0, #64]	; 0x40
    c680:	b143      	cbz	r3, c694 <xQueueReceive+0x38>
    c682:	f04f 0380 	mov.w	r3, #128	; 0x80
    c686:	f383 8811 	msr	BASEPRI, r3
    c68a:	f3bf 8f6f 	isb	sy
    c68e:	f3bf 8f4f 	dsb	sy
    c692:	e7fe      	b.n	c692 <xQueueReceive+0x36>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    c694:	4b3e      	ldr	r3, [pc, #248]	; (c790 <xQueueReceive+0x134>)
    c696:	4798      	blx	r3
    c698:	4606      	mov	r6, r0
    c69a:	b950      	cbnz	r0, c6b2 <xQueueReceive+0x56>
    c69c:	9b01      	ldr	r3, [sp, #4]
    c69e:	b14b      	cbz	r3, c6b4 <xQueueReceive+0x58>
    c6a0:	f04f 0380 	mov.w	r3, #128	; 0x80
    c6a4:	f383 8811 	msr	BASEPRI, r3
    c6a8:	f3bf 8f6f 	isb	sy
    c6ac:	f3bf 8f4f 	dsb	sy
    c6b0:	e7fe      	b.n	c6b0 <xQueueReceive+0x54>
    c6b2:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    c6b4:	f8df 9100 	ldr.w	r9, [pc, #256]	; c7b8 <xQueueReceive+0x15c>
					portYIELD_WITHIN_API();
    c6b8:	f8df b0f8 	ldr.w	fp, [pc, #248]	; c7b4 <xQueueReceive+0x158>
    c6bc:	46ca      	mov	sl, r9
    c6be:	e03b      	b.n	c738 <xQueueReceive+0xdc>
				if (xTicksToWait == (TickType_t)0) {
    c6c0:	9d01      	ldr	r5, [sp, #4]
    c6c2:	b915      	cbnz	r5, c6ca <xQueueReceive+0x6e>
					taskEXIT_CRITICAL();
    c6c4:	47c0      	blx	r8
				return errQUEUE_EMPTY;
    c6c6:	2000      	movs	r0, #0
    c6c8:	e053      	b.n	c772 <xQueueReceive+0x116>
				} else if (xEntryTimeSet == pdFALSE) {
    c6ca:	b916      	cbnz	r6, c6d2 <xQueueReceive+0x76>
					vTaskInternalSetTimeOutState(&xTimeOut);
    c6cc:	4b31      	ldr	r3, [pc, #196]	; (c794 <xQueueReceive+0x138>)
    c6ce:	a802      	add	r0, sp, #8
    c6d0:	4798      	blx	r3
		taskEXIT_CRITICAL();
    c6d2:	47c0      	blx	r8
		vTaskSuspendAll();
    c6d4:	4b30      	ldr	r3, [pc, #192]	; (c798 <xQueueReceive+0x13c>)
    c6d6:	4e31      	ldr	r6, [pc, #196]	; (c79c <xQueueReceive+0x140>)
    c6d8:	4d31      	ldr	r5, [pc, #196]	; (c7a0 <xQueueReceive+0x144>)
    c6da:	4798      	blx	r3
		prvLockQueue(pxQueue);
    c6dc:	47d0      	blx	sl
    c6de:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    c6e2:	2bff      	cmp	r3, #255	; 0xff
    c6e4:	bf04      	itt	eq
    c6e6:	2300      	moveq	r3, #0
    c6e8:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
    c6ec:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    c6f0:	2bff      	cmp	r3, #255	; 0xff
    c6f2:	bf04      	itt	eq
    c6f4:	2300      	moveq	r3, #0
    c6f6:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
    c6fa:	47c0      	blx	r8
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    c6fc:	4b29      	ldr	r3, [pc, #164]	; (c7a4 <xQueueReceive+0x148>)
    c6fe:	f8df 80bc 	ldr.w	r8, [pc, #188]	; c7bc <xQueueReceive+0x160>
    c702:	a901      	add	r1, sp, #4
    c704:	a802      	add	r0, sp, #8
    c706:	4798      	blx	r3
    c708:	2800      	cmp	r0, #0
    c70a:	d139      	bne.n	c780 <xQueueReceive+0x124>
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    c70c:	4620      	mov	r0, r4
    c70e:	47c0      	blx	r8
    c710:	2800      	cmp	r0, #0
    c712:	d031      	beq.n	c778 <xQueueReceive+0x11c>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
    c714:	9901      	ldr	r1, [sp, #4]
    c716:	4b24      	ldr	r3, [pc, #144]	; (c7a8 <xQueueReceive+0x14c>)
    c718:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c71c:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    c71e:	4620      	mov	r0, r4
    c720:	47b0      	blx	r6
				if (xTaskResumeAll() == pdFALSE) {
    c722:	47a8      	blx	r5
    c724:	b938      	cbnz	r0, c736 <xQueueReceive+0xda>
					portYIELD_WITHIN_API();
    c726:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    c72a:	f8cb 3000 	str.w	r3, [fp]
    c72e:	f3bf 8f4f 	dsb	sy
    c732:	f3bf 8f6f 	isb	sy
    c736:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    c738:	47c8      	blx	r9
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c73a:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if (uxMessagesWaiting > (UBaseType_t)0) {
    c73c:	f8df 8080 	ldr.w	r8, [pc, #128]	; c7c0 <xQueueReceive+0x164>
    c740:	2d00      	cmp	r5, #0
    c742:	d0bd      	beq.n	c6c0 <xQueueReceive+0x64>
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    c744:	4b19      	ldr	r3, [pc, #100]	; (c7ac <xQueueReceive+0x150>)
    c746:	4639      	mov	r1, r7
    c748:	4620      	mov	r0, r4
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    c74a:	3d01      	subs	r5, #1
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    c74c:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    c74e:	63a5      	str	r5, [r4, #56]	; 0x38
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    c750:	6923      	ldr	r3, [r4, #16]
    c752:	b163      	cbz	r3, c76e <xQueueReceive+0x112>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c754:	4b16      	ldr	r3, [pc, #88]	; (c7b0 <xQueueReceive+0x154>)
    c756:	f104 0010 	add.w	r0, r4, #16
    c75a:	4798      	blx	r3
    c75c:	b138      	cbz	r0, c76e <xQueueReceive+0x112>
						queueYIELD_IF_USING_PREEMPTION();
    c75e:	4b15      	ldr	r3, [pc, #84]	; (c7b4 <xQueueReceive+0x158>)
    c760:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c764:	601a      	str	r2, [r3, #0]
    c766:	f3bf 8f4f 	dsb	sy
    c76a:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    c76e:	47c0      	blx	r8
				return pdPASS;
    c770:	2001      	movs	r0, #1
}
    c772:	b005      	add	sp, #20
    c774:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				prvUnlockQueue(pxQueue);
    c778:	4620      	mov	r0, r4
    c77a:	47b0      	blx	r6
				(void)xTaskResumeAll();
    c77c:	47a8      	blx	r5
    c77e:	e7da      	b.n	c736 <xQueueReceive+0xda>
			prvUnlockQueue(pxQueue);
    c780:	4620      	mov	r0, r4
    c782:	47b0      	blx	r6
			(void)xTaskResumeAll();
    c784:	47a8      	blx	r5
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    c786:	4620      	mov	r0, r4
    c788:	47c0      	blx	r8
    c78a:	2800      	cmp	r0, #0
    c78c:	d0d3      	beq.n	c736 <xQueueReceive+0xda>
    c78e:	e79a      	b.n	c6c6 <xQueueReceive+0x6a>
    c790:	00012c2d 	.word	0x00012c2d
    c794:	00012b85 	.word	0x00012b85
    c798:	00012761 	.word	0x00012761
    c79c:	0000c261 	.word	0x0000c261
    c7a0:	000128a9 	.word	0x000128a9
    c7a4:	00012b99 	.word	0x00012b99
    c7a8:	00012a81 	.word	0x00012a81
    c7ac:	0000c1a9 	.word	0x0000c1a9
    c7b0:	00012b05 	.word	0x00012b05
    c7b4:	e000ed04 	.word	0xe000ed04
    c7b8:	0000b255 	.word	0x0000b255
    c7bc:	0000c119 	.word	0x0000c119
    c7c0:	0000b299 	.word	0x0000b299

0000c7c4 <vQueueWaitForMessageRestricted>:
{
    c7c4:	b570      	push	{r4, r5, r6, lr}
    c7c6:	4604      	mov	r4, r0
	prvLockQueue(pxQueue);
    c7c8:	4b10      	ldr	r3, [pc, #64]	; (c80c <vQueueWaitForMessageRestricted+0x48>)
{
    c7ca:	460d      	mov	r5, r1
    c7cc:	4616      	mov	r6, r2
	prvLockQueue(pxQueue);
    c7ce:	4798      	blx	r3
    c7d0:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    c7d4:	2bff      	cmp	r3, #255	; 0xff
    c7d6:	bf04      	itt	eq
    c7d8:	2300      	moveq	r3, #0
    c7da:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
    c7de:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    c7e2:	2bff      	cmp	r3, #255	; 0xff
    c7e4:	bf04      	itt	eq
    c7e6:	2300      	moveq	r3, #0
    c7e8:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
    c7ec:	4b08      	ldr	r3, [pc, #32]	; (c810 <vQueueWaitForMessageRestricted+0x4c>)
    c7ee:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
    c7f0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    c7f2:	b92b      	cbnz	r3, c800 <vQueueWaitForMessageRestricted+0x3c>
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
    c7f4:	4b07      	ldr	r3, [pc, #28]	; (c814 <vQueueWaitForMessageRestricted+0x50>)
    c7f6:	4632      	mov	r2, r6
    c7f8:	4629      	mov	r1, r5
    c7fa:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c7fe:	4798      	blx	r3
	prvUnlockQueue(pxQueue);
    c800:	4620      	mov	r0, r4
    c802:	4b05      	ldr	r3, [pc, #20]	; (c818 <vQueueWaitForMessageRestricted+0x54>)
}
    c804:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	prvUnlockQueue(pxQueue);
    c808:	4718      	bx	r3
    c80a:	bf00      	nop
    c80c:	0000b255 	.word	0x0000b255
    c810:	0000b299 	.word	0x0000b299
    c814:	00012abd 	.word	0x00012abd
    c818:	0000c261 	.word	0x0000c261

0000c81c <gpio_get_pin_level>:
 * Reads the level on pins connected to a port
 *
 * \param[in] pin       The pin number for device
 */
static inline bool gpio_get_pin_level(const uint8_t pin)
{
    c81c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	CRITICAL_SECTION_ENTER();
    c81e:	4b0e      	ldr	r3, [pc, #56]	; (c858 <gpio_get_pin_level+0x3c>)
    c820:	4605      	mov	r5, r0
    c822:	a801      	add	r0, sp, #4
    c824:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    c826:	4a0d      	ldr	r2, [pc, #52]	; (c85c <gpio_get_pin_level+0x40>)
    c828:	096b      	lsrs	r3, r5, #5
    c82a:	01d9      	lsls	r1, r3, #7
    c82c:	eb02 13c3 	add.w	r3, r2, r3, lsl #7
    c830:	5851      	ldr	r1, [r2, r1]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    c832:	6a1a      	ldr	r2, [r3, #32]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    c834:	691c      	ldr	r4, [r3, #16]
	CRITICAL_SECTION_LEAVE();
    c836:	4b0a      	ldr	r3, [pc, #40]	; (c860 <gpio_get_pin_level+0x44>)
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    c838:	4054      	eors	r4, r2
    c83a:	400c      	ands	r4, r1
	CRITICAL_SECTION_LEAVE();
    c83c:	a801      	add	r0, sp, #4
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    c83e:	4054      	eors	r4, r2
	return (bool)(_gpio_get_level((enum gpio_port)GPIO_PORT(pin)) & (0x01U << GPIO_PIN(pin)));
    c840:	f005 051f 	and.w	r5, r5, #31
	CRITICAL_SECTION_LEAVE();
    c844:	4798      	blx	r3
    c846:	2001      	movs	r0, #1
    c848:	fa00 f505 	lsl.w	r5, r0, r5
    c84c:	4225      	tst	r5, r4
}
    c84e:	bf08      	it	eq
    c850:	2000      	moveq	r0, #0
    c852:	b003      	add	sp, #12
    c854:	bd30      	pop	{r4, r5, pc}
    c856:	bf00      	nop
    c858:	00011b09 	.word	0x00011b09
    c85c:	41008000 	.word	0x41008000
    c860:	00011b17 	.word	0x00011b17

0000c864 <hiddf_demo_sof_event>:
#endif /* CONF_USB_COMPOSITE_CDC_ECHO_DEMO */

#if CONF_USB_COMPOSITE_HID_MOUSE_DEMO || CONF_USB_COMPOSITE_HID_KEYBOARD_DEMO
static uint32_t pin_btn1, pin_btn2, pin_btn3;
static void     hiddf_demo_sof_event(void)
{
    c864:	b570      	push	{r4, r5, r6, lr}
        {HID_CAPS_LOCK, false, HID_KB_KEY_UP},
    };
	uint8_t b_btn_state;
#endif

	if (interval++ > 10) {
    c866:	4a15      	ldr	r2, [pc, #84]	; (c8bc <hiddf_demo_sof_event+0x58>)
    c868:	7913      	ldrb	r3, [r2, #4]
    c86a:	2b0a      	cmp	r3, #10
    c86c:	4614      	mov	r4, r2
    c86e:	d802      	bhi.n	c876 <hiddf_demo_sof_event+0x12>
    c870:	3301      	adds	r3, #1
    c872:	7113      	strb	r3, [r2, #4]
#endif
	}
	(void)pin_btn1;
	(void)pin_btn2;
	(void)pin_btn3;
}
    c874:	bd70      	pop	{r4, r5, r6, pc}
		interval = 0;
    c876:	2300      	movs	r3, #0
		if (!gpio_get_pin_level(pin_btn1)) {
    c878:	7a10      	ldrb	r0, [r2, #8]
    c87a:	4d11      	ldr	r5, [pc, #68]	; (c8c0 <hiddf_demo_sof_event+0x5c>)
		interval = 0;
    c87c:	7113      	strb	r3, [r2, #4]
		if (!gpio_get_pin_level(pin_btn1)) {
    c87e:	47a8      	blx	r5
    c880:	b920      	cbnz	r0, c88c <hiddf_demo_sof_event+0x28>
			hiddf_mouse_move(-5, HID_MOUSE_X_AXIS_MV);
    c882:	4b10      	ldr	r3, [pc, #64]	; (c8c4 <hiddf_demo_sof_event+0x60>)
    c884:	2101      	movs	r1, #1
    c886:	f06f 0004 	mvn.w	r0, #4
    c88a:	4798      	blx	r3
		if (!gpio_get_pin_level(pin_btn3)) {
    c88c:	7b20      	ldrb	r0, [r4, #12]
    c88e:	47a8      	blx	r5
    c890:	b918      	cbnz	r0, c89a <hiddf_demo_sof_event+0x36>
			hiddf_mouse_move(5, HID_MOUSE_X_AXIS_MV);
    c892:	4b0c      	ldr	r3, [pc, #48]	; (c8c4 <hiddf_demo_sof_event+0x60>)
    c894:	2101      	movs	r1, #1
    c896:	2005      	movs	r0, #5
    c898:	4798      	blx	r3
		if (b_btn_last_state != (b_btn_state = !gpio_get_pin_level(pin_btn2))) {
    c89a:	7c20      	ldrb	r0, [r4, #16]
    c89c:	47a8      	blx	r5
    c89e:	7d22      	ldrb	r2, [r4, #20]
    c8a0:	f080 0001 	eor.w	r0, r0, #1
    c8a4:	b2c3      	uxtb	r3, r0
    c8a6:	429a      	cmp	r2, r3
    c8a8:	d0e4      	beq.n	c874 <hiddf_demo_sof_event+0x10>
			b_btn_last_state = b_btn_state;
    c8aa:	4807      	ldr	r0, [pc, #28]	; (c8c8 <hiddf_demo_sof_event+0x64>)
    c8ac:	7523      	strb	r3, [r4, #20]
			if (1 == b_btn_last_state) {
    c8ae:	7083      	strb	r3, [r0, #2]
}
    c8b0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			hiddf_keyboard_keys_state_change(key_array, 1);
    c8b4:	4b05      	ldr	r3, [pc, #20]	; (c8cc <hiddf_demo_sof_event+0x68>)
    c8b6:	2101      	movs	r1, #1
    c8b8:	4718      	bx	r3
    c8ba:	bf00      	nop
    c8bc:	20008550 	.word	0x20008550
    c8c0:	0000c81d 	.word	0x0000c81d
    c8c4:	0000dff5 	.word	0x0000dff5
    c8c8:	2000035c 	.word	0x2000035c
    c8cc:	0000ea81 	.word	0x0000ea81

0000c8d0 <composite_device_init>:
	usbdc_register_handler(USBDC_HDL_SOF, &hiddf_demo_sof_event_h);
}
#endif /* #if CONF_USB_COMPOSITE_HID_MOUSE_DEMO || CONF_USB_COMPOSITE_HID_KEYBOARD_DEMO */

void composite_device_init(void)
{
    c8d0:	b510      	push	{r4, lr}
	/* usb stack init */
	usbdc_init(ctrl_buffer);
    c8d2:	4b05      	ldr	r3, [pc, #20]	; (c8e8 <composite_device_init+0x18>)
    c8d4:	4805      	ldr	r0, [pc, #20]	; (c8ec <composite_device_init+0x1c>)
    c8d6:	4798      	blx	r3

	/* usbdc_register_funcion inside */
#if CONF_USB_COMPOSITE_CDC_ACM_EN
	cdcdf_acm_init();
    c8d8:	4b05      	ldr	r3, [pc, #20]	; (c8f0 <composite_device_init+0x20>)
    c8da:	4798      	blx	r3
#endif
#if CONF_USB_COMPOSITE_HID_MOUSE_EN
	hiddf_mouse_init();
    c8dc:	4b05      	ldr	r3, [pc, #20]	; (c8f4 <composite_device_init+0x24>)
    c8de:	4798      	blx	r3
	hiddf_keyboard_init();
#endif
#if CONF_USB_COMPOSITE_MSC_EN
	mscdf_init(CONF_USB_MSC_MAX_LUN);
#endif
}
    c8e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hiddf_keyboard_init();
    c8e4:	4b04      	ldr	r3, [pc, #16]	; (c8f8 <composite_device_init+0x28>)
    c8e6:	4718      	bx	r3
    c8e8:	000135c1 	.word	0x000135c1
    c8ec:	20008565 	.word	0x20008565
    c8f0:	0000bce1 	.word	0x0000bce1
    c8f4:	0000dfb1 	.word	0x0000dfb1
    c8f8:	0000ea3d 	.word	0x0000ea3d

0000c8fc <composite_device_start>:

void composite_device_start(void)
{
    c8fc:	b510      	push	{r4, lr}
	usbdc_start(multi_desc);
    c8fe:	4b03      	ldr	r3, [pc, #12]	; (c90c <composite_device_start+0x10>)
    c900:	4803      	ldr	r0, [pc, #12]	; (c910 <composite_device_start+0x14>)
    c902:	4798      	blx	r3
	usbdc_attach();
}
    c904:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	usbdc_attach();
    c908:	4b02      	ldr	r3, [pc, #8]	; (c914 <composite_device_start+0x18>)
    c90a:	4718      	bx	r3
    c90c:	0001362d 	.word	0x0001362d
    c910:	20000368 	.word	0x20000368
    c914:	00013661 	.word	0x00013661

0000c918 <usb_init>:
}

void usb_init(void)
{

	composite_device_init();
    c918:	4b00      	ldr	r3, [pc, #0]	; (c91c <usb_init+0x4>)
    c91a:	4718      	bx	r3
    c91c:	0000c8d1 	.word	0x0000c8d1

0000c920 <timer_add_timer_task>:
 * \param[in] head The pointer to the head of timer task list
 * \param[in] task The pointer to task to add
 * \param[in] time Current timer time
 */
static void timer_add_timer_task(struct list_descriptor *list, struct timer_task *const new_task, const uint32_t time)
{
    c920:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);
    c922:	6805      	ldr	r5, [r0, #0]

	if (!head) {
    c924:	b91d      	cbnz	r5, c92e <timer_add_timer_task+0xe>
		list_insert_as_head(list, new_task);
    c926:	4b0f      	ldr	r3, [pc, #60]	; (c964 <timer_add_timer_task+0x44>)
	if (it == head) {
		list_insert_as_head(list, new_task);
	} else {
		list_insert_after(prev, new_task);
	}
}
    c928:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		list_insert_after(prev, new_task);
    c92c:	4718      	bx	r3
		if (time_left >= new_task->interval)
    c92e:	f8d1 c008 	ldr.w	ip, [r1, #8]
    c932:	462c      	mov	r4, r5
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);
    c934:	2600      	movs	r6, #0
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    c936:	f1c2 0e01 	rsb	lr, r2, #1
		if (it->time_label <= time) {
    c93a:	e9d4 3701 	ldrd	r3, r7, [r4, #4]
    c93e:	4293      	cmp	r3, r2
			time_left = it->interval - (time - it->time_label);
    c940:	bf95      	itete	ls
    c942:	19db      	addls	r3, r3, r7
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    c944:	4473      	addhi	r3, lr
			time_left = it->interval - (time - it->time_label);
    c946:	1a9b      	subls	r3, r3, r2
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    c948:	19db      	addhi	r3, r3, r7
		if (time_left >= new_task->interval)
    c94a:	459c      	cmp	ip, r3
    c94c:	d907      	bls.n	c95e <timer_add_timer_task+0x3e>
 * \return A pointer to the next list element or NULL if there is not next
 * element
 */
static inline void *list_get_next_element(const void *const element)
{
	return element ? ((struct list_element *)element)->next : NULL;
    c94e:	6823      	ldr	r3, [r4, #0]
	for (it = head; it; it = (struct timer_task *)list_get_next_element(it)) {
    c950:	4626      	mov	r6, r4
    c952:	b913      	cbnz	r3, c95a <timer_add_timer_task+0x3a>
		list_insert_after(prev, new_task);
    c954:	4b04      	ldr	r3, [pc, #16]	; (c968 <timer_add_timer_task+0x48>)
    c956:	4630      	mov	r0, r6
    c958:	e7e6      	b.n	c928 <timer_add_timer_task+0x8>
    c95a:	461c      	mov	r4, r3
    c95c:	e7ed      	b.n	c93a <timer_add_timer_task+0x1a>
	if (it == head) {
    c95e:	42a5      	cmp	r5, r4
    c960:	d0e1      	beq.n	c926 <timer_add_timer_task+0x6>
    c962:	e7f7      	b.n	c954 <timer_add_timer_task+0x34>
    c964:	0000f7f5 	.word	0x0000f7f5
    c968:	0000f821 	.word	0x0000f821

0000c96c <timer_process_counted>:

/**
 * \internal Process interrupts
 */
static void timer_process_counted(struct _timer_device *device)
{
    c96c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct timer_descriptor *timer = CONTAINER_OF(device, struct timer_descriptor, device);
	struct timer_task *      it    = (struct timer_task *)list_get_head(&timer->tasks);
	uint32_t                 time  = ++timer->time;
    c970:	e9d0 6504 	ldrd	r6, r5, [r0, #16]

	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    c974:	7e03      	ldrb	r3, [r0, #24]
	uint32_t                 time  = ++timer->time;
    c976:	3601      	adds	r6, #1
	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    c978:	07da      	lsls	r2, r3, #31
{
    c97a:	4604      	mov	r4, r0
	uint32_t                 time  = ++timer->time;
    c97c:	6106      	str	r6, [r0, #16]
	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    c97e:	d41f      	bmi.n	c9c0 <timer_process_counted+0x54>
    c980:	7e03      	ldrb	r3, [r0, #24]
    c982:	079b      	lsls	r3, r3, #30
    c984:	d41c      	bmi.n	c9c0 <timer_process_counted+0x54>
	}

	while (it && ((time - it->time_label) >= it->interval)) {
		struct timer_task *tmp = it;

		list_remove_head(&timer->tasks);
    c986:	f8df 8044 	ldr.w	r8, [pc, #68]	; c9cc <timer_process_counted+0x60>
		if (TIMER_TASK_REPEAT == tmp->mode) {
			tmp->time_label = time;
			timer_add_timer_task(&timer->tasks, tmp, time);
    c98a:	f8df 9044 	ldr.w	r9, [pc, #68]	; c9d0 <timer_process_counted+0x64>
		list_remove_head(&timer->tasks);
    c98e:	f100 0714 	add.w	r7, r0, #20
	while (it && ((time - it->time_label) >= it->interval)) {
    c992:	b1cd      	cbz	r5, c9c8 <timer_process_counted+0x5c>
    c994:	686b      	ldr	r3, [r5, #4]
    c996:	68aa      	ldr	r2, [r5, #8]
    c998:	1af3      	subs	r3, r6, r3
    c99a:	4293      	cmp	r3, r2
    c99c:	d314      	bcc.n	c9c8 <timer_process_counted+0x5c>
		list_remove_head(&timer->tasks);
    c99e:	4638      	mov	r0, r7
    c9a0:	47c0      	blx	r8
		if (TIMER_TASK_REPEAT == tmp->mode) {
    c9a2:	7c2b      	ldrb	r3, [r5, #16]
    c9a4:	2b01      	cmp	r3, #1
    c9a6:	d104      	bne.n	c9b2 <timer_process_counted+0x46>
			tmp->time_label = time;
    c9a8:	606e      	str	r6, [r5, #4]
			timer_add_timer_task(&timer->tasks, tmp, time);
    c9aa:	4632      	mov	r2, r6
    c9ac:	4629      	mov	r1, r5
    c9ae:	4638      	mov	r0, r7
    c9b0:	47c8      	blx	r9
		}
		it = (struct timer_task *)list_get_head(&timer->tasks);
    c9b2:	f8d4 a014 	ldr.w	sl, [r4, #20]

		tmp->cb(tmp);
    c9b6:	68eb      	ldr	r3, [r5, #12]
    c9b8:	4628      	mov	r0, r5
    c9ba:	4798      	blx	r3
		it = (struct timer_task *)list_get_head(&timer->tasks);
    c9bc:	4655      	mov	r5, sl
    c9be:	e7e8      	b.n	c992 <timer_process_counted+0x26>
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
    c9c0:	7e23      	ldrb	r3, [r4, #24]
    c9c2:	f043 0302 	orr.w	r3, r3, #2
    c9c6:	7623      	strb	r3, [r4, #24]
	}
}
    c9c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c9cc:	0000f869 	.word	0x0000f869
    c9d0:	0000c921 	.word	0x0000c921

0000c9d4 <timer_init>:
{
    c9d4:	b570      	push	{r4, r5, r6, lr}
    c9d6:	460d      	mov	r5, r1
    c9d8:	4616      	mov	r6, r2
	ASSERT(descr && hw && func);
    c9da:	4604      	mov	r4, r0
    c9dc:	b118      	cbz	r0, c9e6 <timer_init+0x12>
    c9de:	b189      	cbz	r1, ca04 <timer_init+0x30>
    c9e0:	1e10      	subs	r0, r2, #0
    c9e2:	bf18      	it	ne
    c9e4:	2001      	movne	r0, #1
    c9e6:	223b      	movs	r2, #59	; 0x3b
    c9e8:	4907      	ldr	r1, [pc, #28]	; (ca08 <timer_init+0x34>)
    c9ea:	4b08      	ldr	r3, [pc, #32]	; (ca0c <timer_init+0x38>)
    c9ec:	4798      	blx	r3
	descr->func = func;
    c9ee:	4620      	mov	r0, r4
	descr->func->init(&descr->device, hw);
    c9f0:	6833      	ldr	r3, [r6, #0]
	descr->func = func;
    c9f2:	f840 6b04 	str.w	r6, [r0], #4
	descr->func->init(&descr->device, hw);
    c9f6:	4629      	mov	r1, r5
    c9f8:	4798      	blx	r3
	descr->device.timer_cb.period_expired = timer_process_counted;
    c9fa:	4b05      	ldr	r3, [pc, #20]	; (ca10 <timer_init+0x3c>)
    c9fc:	6063      	str	r3, [r4, #4]
	descr->time                           = 0;
    c9fe:	2000      	movs	r0, #0
    ca00:	6160      	str	r0, [r4, #20]
}
    ca02:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw && func);
    ca04:	4608      	mov	r0, r1
    ca06:	e7ee      	b.n	c9e6 <timer_init+0x12>
    ca08:	00016268 	.word	0x00016268
    ca0c:	0000e03d 	.word	0x0000e03d
    ca10:	0000c96d 	.word	0x0000c96d

0000ca14 <timer_start>:
{
    ca14:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr && descr->func);
    ca16:	4605      	mov	r5, r0
    ca18:	b118      	cbz	r0, ca22 <timer_start+0xe>
    ca1a:	6800      	ldr	r0, [r0, #0]
    ca1c:	3800      	subs	r0, #0
    ca1e:	bf18      	it	ne
    ca20:	2001      	movne	r0, #1
	if (descr->func->is_timer_started(&descr->device)) {
    ca22:	462e      	mov	r6, r5
	ASSERT(descr && descr->func);
    ca24:	4909      	ldr	r1, [pc, #36]	; (ca4c <timer_start+0x38>)
    ca26:	4b0a      	ldr	r3, [pc, #40]	; (ca50 <timer_start+0x3c>)
    ca28:	2254      	movs	r2, #84	; 0x54
    ca2a:	4798      	blx	r3
	if (descr->func->is_timer_started(&descr->device)) {
    ca2c:	f856 3b04 	ldr.w	r3, [r6], #4
    ca30:	699b      	ldr	r3, [r3, #24]
    ca32:	4630      	mov	r0, r6
    ca34:	4798      	blx	r3
    ca36:	4604      	mov	r4, r0
    ca38:	b928      	cbnz	r0, ca46 <timer_start+0x32>
	descr->func->start_timer(&descr->device);
    ca3a:	682b      	ldr	r3, [r5, #0]
    ca3c:	4630      	mov	r0, r6
    ca3e:	689b      	ldr	r3, [r3, #8]
    ca40:	4798      	blx	r3
	return ERR_NONE;
    ca42:	4620      	mov	r0, r4
}
    ca44:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_DENIED;
    ca46:	f06f 0010 	mvn.w	r0, #16
    ca4a:	e7fb      	b.n	ca44 <timer_start+0x30>
    ca4c:	00016268 	.word	0x00016268
    ca50:	0000e03d 	.word	0x0000e03d

0000ca54 <timer_add_task>:
{
    ca54:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    ca58:	460d      	mov	r5, r1
	ASSERT(descr && task && descr->func);
    ca5a:	4604      	mov	r4, r0
    ca5c:	b120      	cbz	r0, ca68 <timer_add_task+0x14>
    ca5e:	b309      	cbz	r1, caa4 <timer_add_task+0x50>
    ca60:	6800      	ldr	r0, [r0, #0]
    ca62:	3800      	subs	r0, #0
    ca64:	bf18      	it	ne
    ca66:	2001      	movne	r0, #1
    ca68:	4920      	ldr	r1, [pc, #128]	; (caec <timer_add_task+0x98>)
    ca6a:	f8df 8094 	ldr.w	r8, [pc, #148]	; cb00 <timer_add_task+0xac>
    ca6e:	227b      	movs	r2, #123	; 0x7b
    ca70:	47c0      	blx	r8
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
    ca72:	7f23      	ldrb	r3, [r4, #28]
	if (is_list_element(&descr->tasks, task)) {
    ca74:	f104 0718 	add.w	r7, r4, #24
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
    ca78:	f043 0301 	orr.w	r3, r3, #1
    ca7c:	7723      	strb	r3, [r4, #28]
	if (is_list_element(&descr->tasks, task)) {
    ca7e:	4629      	mov	r1, r5
    ca80:	4b1b      	ldr	r3, [pc, #108]	; (caf0 <timer_add_task+0x9c>)
    ca82:	4638      	mov	r0, r7
    ca84:	4798      	blx	r3
    ca86:	4606      	mov	r6, r0
    ca88:	b170      	cbz	r0, caa8 <timer_add_task+0x54>
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    ca8a:	7f23      	ldrb	r3, [r4, #28]
		ASSERT(false);
    ca8c:	4917      	ldr	r1, [pc, #92]	; (caec <timer_add_task+0x98>)
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    ca8e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
		ASSERT(false);
    ca92:	2000      	movs	r0, #0
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    ca94:	7723      	strb	r3, [r4, #28]
		ASSERT(false);
    ca96:	2280      	movs	r2, #128	; 0x80
    ca98:	47c0      	blx	r8
		return ERR_ALREADY_INITIALIZED;
    ca9a:	f06f 0011 	mvn.w	r0, #17
}
    ca9e:	b002      	add	sp, #8
    caa0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(descr && task && descr->func);
    caa4:	4608      	mov	r0, r1
    caa6:	e7df      	b.n	ca68 <timer_add_task+0x14>
	task->time_label = descr->time;
    caa8:	6962      	ldr	r2, [r4, #20]
	timer_add_timer_task(&descr->tasks, task, descr->time);
    caaa:	4b12      	ldr	r3, [pc, #72]	; (caf4 <timer_add_task+0xa0>)
	task->time_label = descr->time;
    caac:	606a      	str	r2, [r5, #4]
	timer_add_timer_task(&descr->tasks, task, descr->time);
    caae:	4629      	mov	r1, r5
    cab0:	4638      	mov	r0, r7
    cab2:	4798      	blx	r3
	descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    cab4:	7f23      	ldrb	r3, [r4, #28]
    cab6:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    caba:	7723      	strb	r3, [r4, #28]
	if (descr->flags & TIMER_FLAG_INTERRUPT_TRIGERRED) {
    cabc:	7f23      	ldrb	r3, [r4, #28]
    cabe:	f013 0302 	ands.w	r3, r3, #2
    cac2:	d010      	beq.n	cae6 <timer_add_task+0x92>
		CRITICAL_SECTION_ENTER()
    cac4:	4b0c      	ldr	r3, [pc, #48]	; (caf8 <timer_add_task+0xa4>)
    cac6:	a801      	add	r0, sp, #4
    cac8:	4798      	blx	r3
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
    caca:	7f23      	ldrb	r3, [r4, #28]
		descr->func->set_timer_irq(&descr->device);
    cacc:	4620      	mov	r0, r4
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
    cace:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    cad2:	7723      	strb	r3, [r4, #28]
		descr->func->set_timer_irq(&descr->device);
    cad4:	f850 3b04 	ldr.w	r3, [r0], #4
    cad8:	69db      	ldr	r3, [r3, #28]
    cada:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
    cadc:	a801      	add	r0, sp, #4
    cade:	4b07      	ldr	r3, [pc, #28]	; (cafc <timer_add_task+0xa8>)
    cae0:	4798      	blx	r3
	return ERR_NONE;
    cae2:	4630      	mov	r0, r6
    cae4:	e7db      	b.n	ca9e <timer_add_task+0x4a>
    cae6:	4618      	mov	r0, r3
    cae8:	e7d9      	b.n	ca9e <timer_add_task+0x4a>
    caea:	bf00      	nop
    caec:	00016268 	.word	0x00016268
    caf0:	0000f7e5 	.word	0x0000f7e5
    caf4:	0000c921 	.word	0x0000c921
    caf8:	00011b09 	.word	0x00011b09
    cafc:	00011b17 	.word	0x00011b17
    cb00:	0000e03d 	.word	0x0000e03d

0000cb04 <_dummy_func_no_return>:
static bool _dummy_func_no_return(uint32_t unused0, uint32_t unused1)
{
	(void)unused0;
	(void)unused1;
	return false;
}
    cb04:	2000      	movs	r0, #0
    cb06:	4770      	bx	lr

0000cb08 <_usb_d_dev_wait_dfll_rdy>:
}

static inline bool hri_oscctrl_get_DFLLCTRLB_MODE_bit(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    cb08:	4b07      	ldr	r3, [pc, #28]	; (cb28 <_usb_d_dev_wait_dfll_rdy+0x20>)
    cb0a:	f893 2020 	ldrb.w	r2, [r3, #32]
/**
 * \brief Wait DFLL clock to be ready
 */
static inline void _usb_d_dev_wait_dfll_rdy(void)
{
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(OSCCTRL)) {
    cb0e:	07d1      	lsls	r1, r2, #31
    cb10:	d506      	bpl.n	cb20 <_usb_d_dev_wait_dfll_rdy+0x18>
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    cb12:	691a      	ldr	r2, [r3, #16]
	tmp &= mask;
    cb14:	f402 6210 	and.w	r2, r2, #2304	; 0x900
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, (OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC))
    cb18:	f5b2 6f10 	cmp.w	r2, #2304	; 0x900
    cb1c:	d1f9      	bne.n	cb12 <_usb_d_dev_wait_dfll_rdy+0xa>
    cb1e:	4770      	bx	lr
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    cb20:	691a      	ldr	r2, [r3, #16]
		       != (OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC))
			;
	} else {
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, OSCCTRL_STATUS_DFLLRDY) != OSCCTRL_STATUS_DFLLRDY)
    cb22:	05d2      	lsls	r2, r2, #23
    cb24:	d5fc      	bpl.n	cb20 <_usb_d_dev_wait_dfll_rdy+0x18>
			;
	}
}
    cb26:	4770      	bx	lr
    cb28:	40001000 	.word	0x40001000

0000cb2c <_usb_d_dev_ept>:
 * \param[in] epn Endpoint number.
 * \param[in] dir Endpoint direction.
 */
static inline struct _usb_d_dev_ep *_usb_d_dev_ept(uint8_t epn, bool dir)
{
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    cb2c:	b110      	cbz	r0, cb34 <_usb_d_dev_ept+0x8>
    cb2e:	b109      	cbz	r1, cb34 <_usb_d_dev_ept+0x8>
    cb30:	3005      	adds	r0, #5
    cb32:	b2c0      	uxtb	r0, r0
	return &dev_inst.ep[ep_index];
    cb34:	2314      	movs	r3, #20
    cb36:	fb00 3003 	mla	r0, r0, r3, r3
}
    cb3a:	4b01      	ldr	r3, [pc, #4]	; (cb40 <_usb_d_dev_ept+0x14>)
    cb3c:	4418      	add	r0, r3
    cb3e:	4770      	bx	lr
    cb40:	200085a8 	.word	0x200085a8

0000cb44 <_usb_d_dev_handle_setup>:
/**
 * \brief Handles setup received interrupt
 * \param[in] ept Pointer to endpoint information.
 */
static void _usb_d_dev_handle_setup(struct _usb_d_dev_ep *ept)
{
    cb44:	b430      	push	{r4, r5}
	uint8_t epn     = USB_EP_GET_N(ept->ep);
	bool    is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    cb46:	7cc1      	ldrb	r1, [r0, #19]
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    cb48:	7c85      	ldrb	r5, [r0, #18]

	if (!is_ctrl) {
    cb4a:	f001 0307 	and.w	r3, r1, #7
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    cb4e:	f005 020f 	and.w	r2, r5, #15
	if (!is_ctrl) {
    cb52:	2b01      	cmp	r3, #1
    cb54:	ea4f 1442 	mov.w	r4, r2, lsl #5
    cb58:	f102 0308 	add.w	r3, r2, #8
    cb5c:	d00a      	beq.n	cb74 <_usb_d_dev_handle_setup+0x30>
}

static inline void hri_usbendpoint_clear_EPINTFLAG_reg(const void *const hw, uint8_t submodule_index,
                                                       hri_usbendpoint_epintflag_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cb5e:	015a      	lsls	r2, r3, #5
    cb60:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	}
}

static inline void hri_usbendpoint_clear_EPINTEN_RXSTP_bit(const void *const hw, uint8_t submodule_index)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    cb64:	f104 4382 	add.w	r3, r4, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cb68:	2110      	movs	r1, #16
    cb6a:	71d1      	strb	r1, [r2, #7]
	_usbd_ep_clear_bank_status(epn, 1);
	_usbd_ep_int_ack(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	_usbd_ep_int_dis(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	/* Invoke callback. */
	dev_inst.ep_callbacks.setup(ept->ep);
}
    cb6c:	bc30      	pop	{r4, r5}
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    cb6e:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
    cb72:	4770      	bx	lr
	if (_usb_d_dev_ep_is_busy(ept)) {
    cb74:	f011 0f40 	tst.w	r1, #64	; 0x40
    cb78:	d00b      	beq.n	cb92 <_usb_d_dev_handle_setup+0x4e>
		ept->flags.bits.is_busy = 0;
    cb7a:	0152      	lsls	r2, r2, #5
    cb7c:	f36f 1186 	bfc	r1, #6, #1
    cb80:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    cb84:	74c1      	strb	r1, [r0, #19]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    cb86:	2180      	movs	r1, #128	; 0x80
    cb88:	f882 1104 	strb.w	r1, [r2, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    cb8c:	2140      	movs	r1, #64	; 0x40
    cb8e:	f882 1105 	strb.w	r1, [r2, #261]	; 0x105
	ept->flags.bits.is_stalled = 0;
    cb92:	7cc2      	ldrb	r2, [r0, #19]
    cb94:	f36f 02c3 	bfc	r2, #3, #1
    cb98:	74c2      	strb	r2, [r0, #19]
	bank->STATUS_BK.reg     = 0;
    cb9a:	4a0a      	ldr	r2, [pc, #40]	; (cbc4 <_usb_d_dev_handle_setup+0x80>)
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cb9c:	015b      	lsls	r3, r3, #5
    cb9e:	1911      	adds	r1, r2, r4
    cba0:	2000      	movs	r0, #0
    cba2:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    cba6:	f881 023a 	strb.w	r0, [r1, #570]	; 0x23a
    cbaa:	f881 024a 	strb.w	r0, [r1, #586]	; 0x24a
    cbae:	216f      	movs	r1, #111	; 0x6f
    cbb0:	71d9      	strb	r1, [r3, #7]
}

static inline void hri_usbendpoint_clear_EPINTEN_reg(const void *const hw, uint8_t submodule_index,
                                                     hri_usbendpoint_epintenset_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cbb2:	f104 4382 	add.w	r3, r4, #1090519040	; 0x41000000
	dev_inst.ep_callbacks.setup(ept->ep);
    cbb6:	4628      	mov	r0, r5
    cbb8:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
}
    cbbc:	bc30      	pop	{r4, r5}
	dev_inst.ep_callbacks.setup(ept->ep);
    cbbe:	6893      	ldr	r3, [r2, #8]
    cbc0:	4718      	bx	r3
    cbc2:	bf00      	nop
    cbc4:	200085a8 	.word	0x200085a8

0000cbc8 <_usb_d_dev_handle_stall>:
 * \brief Handles stall sent interrupt
 * \param[in] ept Pointer to endpoint information.
 * \param[in] bank_n Bank number.
 */
static void _usb_d_dev_handle_stall(struct _usb_d_dev_ep *ept, const uint8_t bank_n)
{
    cbc8:	b410      	push	{r4}
	uint8_t epn = USB_EP_GET_N(ept->ep);
    cbca:	7c84      	ldrb	r4, [r0, #18]
	/* Clear interrupt enable. Leave status there for status check. */
	_usbd_ep_int_stall_en(epn, bank_n, false);
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    cbcc:	6882      	ldr	r2, [r0, #8]
		_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << bank_n);
    cbce:	2320      	movs	r3, #32
    cbd0:	fa03 f101 	lsl.w	r1, r3, r1
    cbd4:	f004 030f 	and.w	r3, r4, #15
    cbd8:	015b      	lsls	r3, r3, #5
    cbda:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    cbde:	b2c9      	uxtb	r1, r1
    cbe0:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    cbe4:	4b03      	ldr	r3, [pc, #12]	; (cbf4 <_usb_d_dev_handle_stall+0x2c>)
    cbe6:	4620      	mov	r0, r4
    cbe8:	691b      	ldr	r3, [r3, #16]
}
    cbea:	f85d 4b04 	ldr.w	r4, [sp], #4
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    cbee:	2101      	movs	r1, #1
    cbf0:	4718      	bx	r3
    cbf2:	bf00      	nop
    cbf4:	200085a8 	.word	0x200085a8

0000cbf8 <_usb_d_dev_trans_done>:
 *  \brief Finish the transaction and invoke callback
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_done(struct _usb_d_dev_ep *ept, const int32_t code)
{
    cbf8:	b410      	push	{r4}
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    cbfa:	7c84      	ldrb	r4, [r0, #18]
    cbfc:	2cff      	cmp	r4, #255	; 0xff
    cbfe:	d00c      	beq.n	cc1a <_usb_d_dev_trans_done+0x22>
    cc00:	7cc3      	ldrb	r3, [r0, #19]
    cc02:	065a      	lsls	r2, r3, #25
    cc04:	d509      	bpl.n	cc1a <_usb_d_dev_trans_done+0x22>
		return;
	}
	ept->flags.bits.is_busy = 0;
    cc06:	f36f 1386 	bfc	r3, #6, #1
    cc0a:	74c3      	strb	r3, [r0, #19]
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
    cc0c:	4b04      	ldr	r3, [pc, #16]	; (cc20 <_usb_d_dev_trans_done+0x28>)
    cc0e:	6882      	ldr	r2, [r0, #8]
    cc10:	691b      	ldr	r3, [r3, #16]
    cc12:	4620      	mov	r0, r4
}
    cc14:	f85d 4b04 	ldr.w	r4, [sp], #4
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
    cc18:	4718      	bx	r3
}
    cc1a:	f85d 4b04 	ldr.w	r4, [sp], #4
    cc1e:	4770      	bx	lr
    cc20:	200085a8 	.word	0x200085a8

0000cc24 <_usb_d_dev_trans_stop>:
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] dir Endpoint direction.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_stop(struct _usb_d_dev_ep *ept, bool dir, const int32_t code)
{
    cc24:	b477      	push	{r0, r1, r2, r4, r5, r6}
	uint8_t epn = USB_EP_GET_N(ept->ep);
    cc26:	7c83      	ldrb	r3, [r0, #18]
{
    cc28:	460d      	mov	r5, r1
	;
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    cc2a:	2bff      	cmp	r3, #255	; 0xff
{
    cc2c:	4611      	mov	r1, r2
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
    cc2e:	f644 2225 	movw	r2, #18981	; 0x4a25
    cc32:	f8ad 2004 	strh.w	r2, [sp, #4]
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    cc36:	d020      	beq.n	cc7a <_usb_d_dev_trans_stop+0x56>
    cc38:	7cc2      	ldrb	r2, [r0, #19]
    cc3a:	0652      	lsls	r2, r2, #25
    cc3c:	d51d      	bpl.n	cc7a <_usb_d_dev_trans_stop+0x56>
		return;
	}
	/* Stop transfer */
	if (dir) {
    cc3e:	f003 030f 	and.w	r3, r3, #15
    cc42:	f103 0408 	add.w	r4, r3, #8
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    cc46:	0162      	lsls	r2, r4, #5
    cc48:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    cc4c:	b195      	cbz	r5, cc74 <_usb_d_dev_trans_stop+0x50>
    cc4e:	2680      	movs	r6, #128	; 0x80
    cc50:	7116      	strb	r6, [r2, #4]
		_usbd_ep_set_in_rdy(epn, 1, false);
	} else {
		/* NAK OUT */
		_usbd_ep_set_out_rdy(epn, 0, false);
	}
	_usbd_ep_int_ack(epn, intflags[dir]);
    cc52:	aa02      	add	r2, sp, #8
    cc54:	4415      	add	r5, r2
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cc56:	0164      	lsls	r4, r4, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cc58:	015b      	lsls	r3, r3, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cc5a:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cc5e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    cc62:	f815 2c04 	ldrb.w	r2, [r5, #-4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cc66:	71e2      	strb	r2, [r4, #7]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cc68:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
	_usbd_ep_int_dis(epn, intflags[dir]);
	_usb_d_dev_trans_done(ept, code);
    cc6c:	4b04      	ldr	r3, [pc, #16]	; (cc80 <_usb_d_dev_trans_stop+0x5c>)
}
    cc6e:	b003      	add	sp, #12
    cc70:	bc70      	pop	{r4, r5, r6}
	_usb_d_dev_trans_done(ept, code);
    cc72:	4718      	bx	r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    cc74:	2640      	movs	r6, #64	; 0x40
    cc76:	7156      	strb	r6, [r2, #5]
}
    cc78:	e7eb      	b.n	cc52 <_usb_d_dev_trans_stop+0x2e>
}
    cc7a:	b003      	add	sp, #12
    cc7c:	bc70      	pop	{r4, r5, r6}
    cc7e:	4770      	bx	lr
    cc80:	0000cbf9 	.word	0x0000cbf9

0000cc84 <_usb_d_dev_handle_trfail>:
{
    cc84:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint8_t            epn     = USB_EP_GET_N(ept->ep);
    cc86:	7c83      	ldrb	r3, [r0, #18]
    cc88:	f003 0c0f 	and.w	ip, r3, #15
	const uint8_t      fail[2] = {USB_DEVICE_EPINTFLAG_TRFAIL0, USB_DEVICE_EPINTFLAG_TRFAIL1};
    cc8c:	f640 0204 	movw	r2, #2052	; 0x804
    cc90:	4663      	mov	r3, ip
    cc92:	f8ad 2004 	strh.w	r2, [sp, #4]
	UsbDeviceDescBank *bank    = prvt_inst.desc_table[epn].DeviceDescBank;
    cc96:	015a      	lsls	r2, r3, #5
	uint8_t            eptype
    cc98:	f10c 0308 	add.w	r3, ip, #8
    cc9c:	460c      	mov	r4, r1

static inline hri_usbendpoint_epcfg_reg_t hri_usbendpoint_read_EPCFG_EPTYPE1_bf(const void *const hw,
                                                                                uint8_t           submodule_index)
{
	uint8_t tmp;
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    cc9e:	0159      	lsls	r1, r3, #5
    cca0:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
    cca4:	780f      	ldrb	r7, [r1, #0]
    cca6:	b334      	cbz	r4, ccf6 <_usb_d_dev_handle_trfail+0x72>
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE1_Msk) >> USB_DEVICE_EPCFG_EPTYPE1_Pos;
    cca8:	f3c7 1702 	ubfx	r7, r7, #4, #3
	st.reg = bank[bank_n].STATUS_BK.reg;
    ccac:	4e2c      	ldr	r6, [pc, #176]	; (cd60 <_usb_d_dev_handle_trfail+0xdc>)
    ccae:	eb02 1204 	add.w	r2, r2, r4, lsl #4
    ccb2:	4416      	add	r6, r2
    ccb4:	aa02      	add	r2, sp, #8
    ccb6:	4422      	add	r2, r4
    ccb8:	7ab5      	ldrb	r5, [r6, #10]
    ccba:	f812 ec04 	ldrb.w	lr, [r2, #-4]
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    ccbe:	2f02      	cmp	r7, #2
	st.reg = bank[bank_n].STATUS_BK.reg;
    ccc0:	b2ed      	uxtb	r5, r5
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    ccc2:	ea4f 124c 	mov.w	r2, ip, lsl #5
    ccc6:	d119      	bne.n	ccfc <_usb_d_dev_handle_trfail+0x78>
    ccc8:	07e9      	lsls	r1, r5, #31
    ccca:	d517      	bpl.n	ccfc <_usb_d_dev_handle_trfail+0x78>
		bank[bank_n].STATUS_BK.bit.CRCERR = 0;
    cccc:	7ab1      	ldrb	r1, [r6, #10]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    ccce:	015b      	lsls	r3, r3, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    ccd0:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    ccd4:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    ccd8:	f36f 0100 	bfc	r1, #0, #1
    ccdc:	72b1      	strb	r1, [r6, #10]
    ccde:	f883 e007 	strb.w	lr, [r3, #7]
		_usb_d_dev_trans_stop(ept, bank_n, USB_TRANS_ERROR);
    cce2:	f004 0101 	and.w	r1, r4, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cce6:	f882 e108 	strb.w	lr, [r2, #264]	; 0x108
    ccea:	2204      	movs	r2, #4
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    ccec:	4b1d      	ldr	r3, [pc, #116]	; (cd64 <_usb_d_dev_handle_trfail+0xe0>)
}
    ccee:	b003      	add	sp, #12
    ccf0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    ccf4:	4718      	bx	r3
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE0_Msk) >> USB_DEVICE_EPCFG_EPTYPE0_Pos;
    ccf6:	f007 0707 	and.w	r7, r7, #7
	return tmp;
    ccfa:	e7d7      	b.n	ccac <_usb_d_dev_handle_trfail+0x28>
	} else if (st.bit.ERRORFLOW) {
    ccfc:	f015 0502 	ands.w	r5, r5, #2
    cd00:	d01b      	beq.n	cd3a <_usb_d_dev_handle_trfail+0xb6>
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    cd02:	7ab1      	ldrb	r1, [r6, #10]
	bool                      is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    cd04:	7cc5      	ldrb	r5, [r0, #19]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cd06:	015b      	lsls	r3, r3, #5
    cd08:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    cd0c:	f36f 0141 	bfc	r1, #1, #1
    cd10:	72b1      	strb	r1, [r6, #10]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cd12:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cd16:	f883 e007 	strb.w	lr, [r3, #7]
		if (is_ctrl && _usb_d_dev_ep_is_busy(ept)) {
    cd1a:	f005 0307 	and.w	r3, r5, #7
    cd1e:	2b01      	cmp	r3, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cd20:	f882 e108 	strb.w	lr, [r2, #264]	; 0x108
    cd24:	d119      	bne.n	cd5a <_usb_d_dev_handle_trfail+0xd6>
    cd26:	066b      	lsls	r3, r5, #25
    cd28:	d517      	bpl.n	cd5a <_usb_d_dev_handle_trfail+0xd6>
			if (bank_n != _usb_d_dev_ep_is_in(ept)) {
    cd2a:	7cc3      	ldrb	r3, [r0, #19]
    cd2c:	ebb4 1fd3 	cmp.w	r4, r3, lsr #7
    cd30:	ea4f 11d3 	mov.w	r1, r3, lsr #7
    cd34:	d011      	beq.n	cd5a <_usb_d_dev_handle_trfail+0xd6>
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    cd36:	2200      	movs	r2, #0
    cd38:	e7d8      	b.n	ccec <_usb_d_dev_handle_trfail+0x68>
	bank->STATUS_BK.reg     = 0;
    cd3a:	490b      	ldr	r1, [pc, #44]	; (cd68 <_usb_d_dev_handle_trfail+0xe4>)
    cd3c:	eb04 044c 	add.w	r4, r4, ip, lsl #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cd40:	015b      	lsls	r3, r3, #5
    cd42:	eb01 1404 	add.w	r4, r1, r4, lsl #4
    cd46:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cd4a:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    cd4e:	f884 523a 	strb.w	r5, [r4, #570]	; 0x23a
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cd52:	f883 e007 	strb.w	lr, [r3, #7]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cd56:	f882 e108 	strb.w	lr, [r2, #264]	; 0x108
}
    cd5a:	b003      	add	sp, #12
    cd5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cd5e:	bf00      	nop
    cd60:	200087d8 	.word	0x200087d8
    cd64:	0000cc25 	.word	0x0000cc25
    cd68:	200085a8 	.word	0x200085a8

0000cd6c <_usb_d_dev_reset_epts>:
{
    cd6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    cd70:	4c0a      	ldr	r4, [pc, #40]	; (cd9c <_usb_d_dev_reset_epts+0x30>)
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    cd72:	4f0b      	ldr	r7, [pc, #44]	; (cda0 <_usb_d_dev_reset_epts+0x34>)
{
    cd74:	2501      	movs	r5, #1
		dev_inst.ep[i].ep       = 0xFF;
    cd76:	26ff      	movs	r6, #255	; 0xff
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    cd78:	2103      	movs	r1, #3
    cd7a:	4620      	mov	r0, r4
    cd7c:	3501      	adds	r5, #1
    cd7e:	47b8      	blx	r7
		dev_inst.ep[i].flags.u8 = 0;
    cd80:	2100      	movs	r1, #0
	for (i = 0; i < USB_D_N_EP; i++) {
    cd82:	2d1c      	cmp	r5, #28
		dev_inst.ep[i].ep       = 0xFF;
    cd84:	74a6      	strb	r6, [r4, #18]
		dev_inst.ep[i].flags.u8 = 0;
    cd86:	74e1      	strb	r1, [r4, #19]
	for (i = 0; i < USB_D_N_EP; i++) {
    cd88:	f104 0414 	add.w	r4, r4, #20
    cd8c:	d1f4      	bne.n	cd78 <_usb_d_dev_reset_epts+0xc>
}
    cd8e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	memset(prvt_inst.desc_table, 0, sizeof(UsbDeviceDescriptor) * (CONF_USB_D_MAX_EP_N + 1));
    cd92:	4804      	ldr	r0, [pc, #16]	; (cda4 <_usb_d_dev_reset_epts+0x38>)
    cd94:	4b04      	ldr	r3, [pc, #16]	; (cda8 <_usb_d_dev_reset_epts+0x3c>)
    cd96:	22c0      	movs	r2, #192	; 0xc0
    cd98:	4718      	bx	r3
    cd9a:	bf00      	nop
    cd9c:	200085bc 	.word	0x200085bc
    cda0:	0000cbf9 	.word	0x0000cbf9
    cda4:	200087d8 	.word	0x200087d8
    cda8:	000142f1 	.word	0x000142f1

0000cdac <_usb_d_dev_in_next>:
{
    cdac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    cdb0:	4604      	mov	r4, r0
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    cdb2:	7c80      	ldrb	r0, [r0, #18]
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    cdb4:	4688      	mov	r8, r1
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    cdb6:	f000 070f 	and.w	r7, r0, #15
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    cdba:	2900      	cmp	r1, #0
    cdbc:	d05b      	beq.n	ce76 <_usb_d_dev_in_next+0xca>
	UsbDeviceDescBank *bank        = &prvt_inst.desc_table[epn].DeviceDescBank[0];
    cdbe:	4b4d      	ldr	r3, [pc, #308]	; (cef4 <_usb_d_dev_in_next+0x148>)
    cdc0:	eb03 1347 	add.w	r3, r3, r7, lsl #5
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    cdc4:	695e      	ldr	r6, [r3, #20]
    cdc6:	f3c6 060d 	ubfx	r6, r6, #0, #14
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    cdca:	8a22      	ldrh	r2, [r4, #16]
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    cdcc:	f894 e013 	ldrb.w	lr, [r4, #19]
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    cdd0:	f240 33ff 	movw	r3, #1023	; 0x3ff
    cdd4:	429a      	cmp	r2, r3
    cdd6:	bf1a      	itte	ne
    cdd8:	f102 3cff 	addne.w	ip, r2, #4294967295	; 0xffffffff
    cddc:	fa0f fc8c 	sxthne.w	ip, ip
    cde0:	4694      	moveq	ip, r2
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    cde2:	f00e 0907 	and.w	r9, lr, #7
	if (isr) {
    cde6:	f1b8 0f00 	cmp.w	r8, #0
    cdea:	d005      	beq.n	cdf8 <_usb_d_dev_in_next+0x4c>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cdec:	017b      	lsls	r3, r7, #5
    cdee:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    cdf2:	2102      	movs	r1, #2
    cdf4:	f883 1107 	strb.w	r1, [r3, #263]	; 0x107
	ept->trans_count += trans_count;
    cdf8:	68a1      	ldr	r1, [r4, #8]
	if (ept->trans_count < ept->trans_size) {
    cdfa:	6863      	ldr	r3, [r4, #4]
	ept->trans_count += trans_count;
    cdfc:	4431      	add	r1, r6
	if (ept->trans_count < ept->trans_size) {
    cdfe:	4299      	cmp	r1, r3
	ept->trans_count += trans_count;
    ce00:	60a1      	str	r1, [r4, #8]
	if (ept->trans_count < ept->trans_size) {
    ce02:	ea4f 1547 	mov.w	r5, r7, lsl #5
    ce06:	d242      	bcs.n	ce8e <_usb_d_dev_in_next+0xe2>
		trans_next = ept->trans_size - ept->trans_count;
    ce08:	1a5b      	subs	r3, r3, r1
    ce0a:	b29e      	uxth	r6, r3
		if (ept->flags.bits.use_cache) {
    ce0c:	6823      	ldr	r3, [r4, #0]
    ce0e:	f8df a0f0 	ldr.w	sl, [pc, #240]	; cf00 <_usb_d_dev_in_next+0x154>
    ce12:	f01e 0f20 	tst.w	lr, #32
    ce16:	4419      	add	r1, r3
    ce18:	d02f      	beq.n	ce7a <_usb_d_dev_in_next+0xce>
			if (trans_next > ept->size) {
    ce1a:	4296      	cmp	r6, r2
    ce1c:	bf28      	it	cs
    ce1e:	4616      	movcs	r6, r2
			memcpy(ept->cache, &ept->trans_buf[ept->trans_count], trans_next);
    ce20:	4b35      	ldr	r3, [pc, #212]	; (cef8 <_usb_d_dev_in_next+0x14c>)
    ce22:	68e0      	ldr	r0, [r4, #12]
    ce24:	4632      	mov	r2, r6
    ce26:	4798      	blx	r3
	bank->ADDR.reg          = addr;
    ce28:	eb0a 0305 	add.w	r3, sl, r5
			_usbd_ep_set_buf(epn, 1, (uint32_t)ept->cache);
    ce2c:	68e2      	ldr	r2, [r4, #12]
	bank->ADDR.reg          = addr;
    ce2e:	f8c3 2240 	str.w	r2, [r3, #576]	; 0x240
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    ce32:	eb0a 0205 	add.w	r2, sl, r5
    ce36:	f8d2 3244 	ldr.w	r3, [r2, #580]	; 0x244
    ce3a:	f366 030d 	bfi	r3, r6, #0, #14
    ce3e:	f8c2 3244 	str.w	r3, [r2, #580]	; 0x244
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    ce42:	f8d2 3244 	ldr.w	r3, [r2, #580]	; 0x244
    ce46:	f36f 339b 	bfc	r3, #14, #14
    ce4a:	f8c2 3244 	str.w	r3, [r2, #580]	; 0x244
	if (!isr) {
    ce4e:	f1b8 0f00 	cmp.w	r8, #0
    ce52:	d108      	bne.n	ce66 <_usb_d_dev_in_next+0xba>
			inten = USB_D_BANK1_INT_FLAGS;
    ce54:	f1b9 0f01 	cmp.w	r9, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    ce58:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    ce5c:	bf0c      	ite	eq
    ce5e:	234e      	moveq	r3, #78	; 0x4e
    ce60:	234a      	movne	r3, #74	; 0x4a
    ce62:	f885 3109 	strb.w	r3, [r5, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    ce66:	017b      	lsls	r3, r7, #5
    ce68:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    ce6c:	2280      	movs	r2, #128	; 0x80
    ce6e:	f883 2105 	strb.w	r2, [r3, #261]	; 0x105
}
    ce72:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    ce76:	460e      	mov	r6, r1
    ce78:	e7a7      	b.n	cdca <_usb_d_dev_in_next+0x1e>
	bank->ADDR.reg          = addr;
    ce7a:	eb0a 0305 	add.w	r3, sl, r5
    ce7e:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
    ce82:	bf28      	it	cs
    ce84:	f44f 5600 	movcs.w	r6, #8192	; 0x2000
    ce88:	f8c3 1240 	str.w	r1, [r3, #576]	; 0x240
}
    ce8c:	e7d1      	b.n	ce32 <_usb_d_dev_in_next+0x86>
	} else if (ept->flags.bits.need_zlp) {
    ce8e:	f01e 0f10 	tst.w	lr, #16
    ce92:	d00e      	beq.n	ceb2 <_usb_d_dev_in_next+0x106>
		ept->flags.bits.need_zlp = 0;
    ce94:	7ce3      	ldrb	r3, [r4, #19]
    ce96:	f36f 1304 	bfc	r3, #4, #1
    ce9a:	74e3      	strb	r3, [r4, #19]
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    ce9c:	4b17      	ldr	r3, [pc, #92]	; (cefc <_usb_d_dev_in_next+0x150>)
    ce9e:	442b      	add	r3, r5
    cea0:	685a      	ldr	r2, [r3, #4]
    cea2:	f36f 020d 	bfc	r2, #0, #14
    cea6:	605a      	str	r2, [r3, #4]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    cea8:	685a      	ldr	r2, [r3, #4]
    ceaa:	f36f 329b 	bfc	r2, #14, #14
    ceae:	605a      	str	r2, [r3, #4]
		goto _in_tx_exec;
    ceb0:	e7cd      	b.n	ce4e <_usb_d_dev_in_next+0xa2>
	if (is_ctrl) {
    ceb2:	f1b9 0f01 	cmp.w	r9, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    ceb6:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
	if (last_pkt == ept->size) {
    ceba:	ea0c 0c06 	and.w	ip, ip, r6
    cebe:	bf0c      	ite	eq
    cec0:	234b      	moveq	r3, #75	; 0x4b
    cec2:	234a      	movne	r3, #74	; 0x4a
    cec4:	4562      	cmp	r2, ip
    cec6:	f885 3108 	strb.w	r3, [r5, #264]	; 0x108
    ceca:	d10c      	bne.n	cee6 <_usb_d_dev_in_next+0x13a>
		ept->flags.bits.is_busy = 0;
    cecc:	7ce3      	ldrb	r3, [r4, #19]
    cece:	f36f 1386 	bfc	r3, #6, #1
    ced2:	74e3      	strb	r3, [r4, #19]
		if (dev_inst.ep_callbacks.more(ept->ep, ept->trans_count)) {
    ced4:	4b0a      	ldr	r3, [pc, #40]	; (cf00 <_usb_d_dev_in_next+0x154>)
    ced6:	68db      	ldr	r3, [r3, #12]
    ced8:	4798      	blx	r3
    ceda:	2800      	cmp	r0, #0
    cedc:	d1c9      	bne.n	ce72 <_usb_d_dev_in_next+0xc6>
		ept->flags.bits.is_busy = 1;
    cede:	7ce3      	ldrb	r3, [r4, #19]
    cee0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    cee4:	74e3      	strb	r3, [r4, #19]
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    cee6:	4620      	mov	r0, r4
    cee8:	4b06      	ldr	r3, [pc, #24]	; (cf04 <_usb_d_dev_in_next+0x158>)
}
    ceea:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    ceee:	2100      	movs	r1, #0
    cef0:	4718      	bx	r3
    cef2:	bf00      	nop
    cef4:	200087d8 	.word	0x200087d8
    cef8:	000142d5 	.word	0x000142d5
    cefc:	200087e8 	.word	0x200087e8
    cf00:	200085a8 	.word	0x200085a8
    cf04:	0000cbf9 	.word	0x0000cbf9

0000cf08 <_usb_d_dev_out_next>:
{
    cf08:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t            epn        = USB_EP_GET_N(ept->ep);
    cf0c:	7c86      	ldrb	r6, [r0, #18]
    cf0e:	f006 060f 	and.w	r6, r6, #15
{
    cf12:	4604      	mov	r4, r0
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    cf14:	460f      	mov	r7, r1
    cf16:	0175      	lsls	r5, r6, #5
    cf18:	2900      	cmp	r1, #0
    cf1a:	d060      	beq.n	cfde <_usb_d_dev_out_next+0xd6>
    cf1c:	4b5d      	ldr	r3, [pc, #372]	; (d094 <_usb_d_dev_out_next+0x18c>)
    cf1e:	442b      	add	r3, r5
    cf20:	685a      	ldr	r2, [r3, #4]
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    cf22:	685b      	ldr	r3, [r3, #4]
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    cf24:	f3c2 3a8d 	ubfx	sl, r2, #14, #14
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    cf28:	f3c3 090d 	ubfx	r9, r3, #0, #14
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    cf2c:	f8b4 8010 	ldrh.w	r8, [r4, #16]
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    cf30:	7ce2      	ldrb	r2, [r4, #19]
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    cf32:	f240 33ff 	movw	r3, #1023	; 0x3ff
    cf36:	4598      	cmp	r8, r3
    cf38:	bf1c      	itt	ne
    cf3a:	f108 38ff 	addne.w	r8, r8, #4294967295	; 0xffffffff
    cf3e:	fa1f f888 	uxthne.w	r8, r8
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    cf42:	f002 0307 	and.w	r3, r2, #7
	uint16_t           last_pkt   = last_trans & size_mask;
    cf46:	ea09 0b08 	and.w	fp, r9, r8
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    cf4a:	9301      	str	r3, [sp, #4]
	if (isr) {
    cf4c:	b12f      	cbz	r7, cf5a <_usb_d_dev_out_next+0x52>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cf4e:	0173      	lsls	r3, r6, #5
    cf50:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    cf54:	2101      	movs	r1, #1
    cf56:	f883 1107 	strb.w	r1, [r3, #263]	; 0x107
	if (ept->flags.bits.use_cache && ept->trans_size) {
    cf5a:	0690      	lsls	r0, r2, #26
    cf5c:	d50c      	bpl.n	cf78 <_usb_d_dev_out_next+0x70>
    cf5e:	6862      	ldr	r2, [r4, #4]
    cf60:	b152      	cbz	r2, cf78 <_usb_d_dev_out_next+0x70>
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    cf62:	68a0      	ldr	r0, [r4, #8]
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    cf64:	6823      	ldr	r3, [r4, #0]
    cf66:	68e1      	ldr	r1, [r4, #12]
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    cf68:	1a12      	subs	r2, r2, r0
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    cf6a:	b292      	uxth	r2, r2
    cf6c:	455a      	cmp	r2, fp
    cf6e:	4418      	add	r0, r3
    cf70:	bf28      	it	cs
    cf72:	465a      	movcs	r2, fp
    cf74:	4b48      	ldr	r3, [pc, #288]	; (d098 <_usb_d_dev_out_next+0x190>)
    cf76:	4798      	blx	r3
	if (ept->trans_size == 0 && ept->flags.bits.need_zlp) {
    cf78:	6863      	ldr	r3, [r4, #4]
    cf7a:	2b00      	cmp	r3, #0
    cf7c:	d132      	bne.n	cfe4 <_usb_d_dev_out_next+0xdc>
    cf7e:	7ce2      	ldrb	r2, [r4, #19]
    cf80:	06d1      	lsls	r1, r2, #27
    cf82:	d52f      	bpl.n	cfe4 <_usb_d_dev_out_next+0xdc>
	bank->ADDR.reg          = addr;
    cf84:	4845      	ldr	r0, [pc, #276]	; (d09c <_usb_d_dev_out_next+0x194>)
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    cf86:	68e1      	ldr	r1, [r4, #12]
		ept->flags.bits.need_zlp  = 0;
    cf88:	f022 0230 	bic.w	r2, r2, #48	; 0x30
	bank->ADDR.reg          = addr;
    cf8c:	4428      	add	r0, r5
		ept->flags.bits.need_zlp  = 0;
    cf8e:	f042 0220 	orr.w	r2, r2, #32
    cf92:	74e2      	strb	r2, [r4, #19]
	bank->ADDR.reg          = addr;
    cf94:	f500 720c 	add.w	r2, r0, #560	; 0x230
    cf98:	f8c0 1230 	str.w	r1, [r0, #560]	; 0x230
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    cf9c:	6851      	ldr	r1, [r2, #4]
    cf9e:	8a20      	ldrh	r0, [r4, #16]
    cfa0:	f360 319b 	bfi	r1, r0, #14, #14
    cfa4:	6051      	str	r1, [r2, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    cfa6:	6851      	ldr	r1, [r2, #4]
    cfa8:	f363 010d 	bfi	r1, r3, #0, #14
    cfac:	6051      	str	r1, [r2, #4]
	if (!isr) {
    cfae:	b96f      	cbnz	r7, cfcc <_usb_d_dev_out_next+0xc4>
		if (is_ctrl) {
    cfb0:	9b01      	ldr	r3, [sp, #4]
    cfb2:	2b01      	cmp	r3, #1
	bank->STATUS_BK.reg     = 0;
    cfb4:	bf04      	itt	eq
    cfb6:	4b39      	ldreq	r3, [pc, #228]	; (d09c <_usb_d_dev_out_next+0x194>)
    cfb8:	195b      	addeq	r3, r3, r5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    cfba:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    cfbe:	bf0a      	itet	eq
    cfc0:	f883 724a 	strbeq.w	r7, [r3, #586]	; 0x24a
			inten = USB_D_BANK0_INT_FLAGS;
    cfc4:	2325      	movne	r3, #37	; 0x25
			inten = USB_D_BANK0_INT_FLAGS | USB_DEVICE_EPINTFLAG_TRFAIL1;
    cfc6:	232d      	moveq	r3, #45	; 0x2d
    cfc8:	f885 3109 	strb.w	r3, [r5, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    cfcc:	0176      	lsls	r6, r6, #5
    cfce:	f106 4682 	add.w	r6, r6, #1090519040	; 0x41000000
    cfd2:	2340      	movs	r3, #64	; 0x40
    cfd4:	f886 3104 	strb.w	r3, [r6, #260]	; 0x104
}
    cfd8:	b003      	add	sp, #12
    cfda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    cfde:	468a      	mov	sl, r1
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    cfe0:	4689      	mov	r9, r1
    cfe2:	e7a3      	b.n	cf2c <_usb_d_dev_out_next+0x24>
	} else if (isr && last_pkt < ept->size) {
    cfe4:	68a1      	ldr	r1, [r4, #8]
    cfe6:	b1ef      	cbz	r7, d024 <_usb_d_dev_out_next+0x11c>
    cfe8:	8a22      	ldrh	r2, [r4, #16]
    cfea:	455a      	cmp	r2, fp
    cfec:	d91a      	bls.n	d024 <_usb_d_dev_out_next+0x11c>
		ept->flags.bits.need_zlp = 0;
    cfee:	7ce3      	ldrb	r3, [r4, #19]
		ept->trans_count += last_trans;
    cff0:	4449      	add	r1, r9
		ept->flags.bits.need_zlp = 0;
    cff2:	f36f 1304 	bfc	r3, #4, #1
    cff6:	74e3      	strb	r3, [r4, #19]
		ept->trans_count += last_trans;
    cff8:	60a1      	str	r1, [r4, #8]
	if (is_ctrl) {
    cffa:	9b01      	ldr	r3, [sp, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cffc:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    d000:	2b01      	cmp	r3, #1
    d002:	bf0c      	ite	eq
    d004:	232d      	moveq	r3, #45	; 0x2d
    d006:	2325      	movne	r3, #37	; 0x25
    d008:	f885 3108 	strb.w	r3, [r5, #264]	; 0x108
	if (0 == epn) {
    d00c:	b91e      	cbnz	r6, d016 <_usb_d_dev_out_next+0x10e>
	bank->ADDR.reg          = addr;
    d00e:	4b23      	ldr	r3, [pc, #140]	; (d09c <_usb_d_dev_out_next+0x194>)
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    d010:	68e2      	ldr	r2, [r4, #12]
	bank->ADDR.reg          = addr;
    d012:	f8c3 2230 	str.w	r2, [r3, #560]	; 0x230
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    d016:	4b22      	ldr	r3, [pc, #136]	; (d0a0 <_usb_d_dev_out_next+0x198>)
    d018:	2100      	movs	r1, #0
    d01a:	4620      	mov	r0, r4
}
    d01c:	b003      	add	sp, #12
    d01e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    d022:	4718      	bx	r3
		ept->trans_count += trans_size;
    d024:	4451      	add	r1, sl
		if (ept->trans_count < ept->trans_size) {
    d026:	428b      	cmp	r3, r1
		ept->trans_count += trans_size;
    d028:	60a1      	str	r1, [r4, #8]
		if (ept->trans_count < ept->trans_size) {
    d02a:	d9e6      	bls.n	cffa <_usb_d_dev_out_next+0xf2>
			if (ept->flags.bits.use_cache) {
    d02c:	7ce0      	ldrb	r0, [r4, #19]
    d02e:	f8b4 c010 	ldrh.w	ip, [r4, #16]
    d032:	4a1a      	ldr	r2, [pc, #104]	; (d09c <_usb_d_dev_out_next+0x194>)
			trans_next = ept->trans_size - ept->trans_count;
    d034:	1a5b      	subs	r3, r3, r1
			if (ept->flags.bits.use_cache) {
    d036:	f010 0f20 	tst.w	r0, #32
			trans_next = ept->trans_size - ept->trans_count;
    d03a:	b29b      	uxth	r3, r3
			if (ept->flags.bits.use_cache) {
    d03c:	d014      	beq.n	d068 <_usb_d_dev_out_next+0x160>
	bank->ADDR.reg          = addr;
    d03e:	1951      	adds	r1, r2, r5
				_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    d040:	68e0      	ldr	r0, [r4, #12]
	bank->ADDR.reg          = addr;
    d042:	f8c1 0230 	str.w	r0, [r1, #560]	; 0x230
    d046:	4563      	cmp	r3, ip
    d048:	bf28      	it	cs
    d04a:	4663      	movcs	r3, ip
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    d04c:	442a      	add	r2, r5
    d04e:	f8d2 1234 	ldr.w	r1, [r2, #564]	; 0x234
    d052:	f363 319b 	bfi	r1, r3, #14, #14
    d056:	f8c2 1234 	str.w	r1, [r2, #564]	; 0x234
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    d05a:	f8d2 3234 	ldr.w	r3, [r2, #564]	; 0x234
    d05e:	f36f 030d 	bfc	r3, #0, #14
    d062:	f8c2 3234 	str.w	r3, [r2, #564]	; 0x234
			goto _out_rx_exec;
    d066:	e7a2      	b.n	cfae <_usb_d_dev_out_next+0xa6>
				if (trans_next > ept->size) {
    d068:	4563      	cmp	r3, ip
    d06a:	d90a      	bls.n	d082 <_usb_d_dev_out_next+0x17a>
					if (trans_next > USB_D_DEV_TRANS_MAX) {
    d06c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    d070:	d80c      	bhi.n	d08c <_usb_d_dev_out_next+0x184>
						trans_next -= trans_next & size_mask;
    d072:	ea23 0308 	bic.w	r3, r3, r8
				_usbd_ep_set_buf(epn, 0, (uint32_t)&ept->trans_buf[ept->trans_count]);
    d076:	6820      	ldr	r0, [r4, #0]
    d078:	4401      	add	r1, r0
	bank->ADDR.reg          = addr;
    d07a:	1950      	adds	r0, r2, r5
    d07c:	f8c0 1230 	str.w	r1, [r0, #560]	; 0x230
}
    d080:	e7e4      	b.n	d04c <_usb_d_dev_out_next+0x144>
				} else if (trans_next < ept->size) {
    d082:	d2f8      	bcs.n	d076 <_usb_d_dev_out_next+0x16e>
					ept->flags.bits.use_cache = 1;
    d084:	f040 0020 	orr.w	r0, r0, #32
    d088:	74e0      	strb	r0, [r4, #19]
    d08a:	e7f4      	b.n	d076 <_usb_d_dev_out_next+0x16e>
						trans_next = USB_D_DEV_TRANS_MAX;
    d08c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    d090:	e7f1      	b.n	d076 <_usb_d_dev_out_next+0x16e>
    d092:	bf00      	nop
    d094:	200087d8 	.word	0x200087d8
    d098:	000142d5 	.word	0x000142d5
    d09c:	200085a8 	.word	0x200085a8
    d0a0:	0000cbf9 	.word	0x0000cbf9

0000d0a4 <_usb_d_dev_handler>:
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    d0a4:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
{
    d0a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    d0ac:	8c1f      	ldrh	r7, [r3, #32]
    d0ae:	4d69      	ldr	r5, [pc, #420]	; (d254 <_usb_d_dev_handler+0x1b0>)
    d0b0:	b2bf      	uxth	r7, r7
	if (0 == epint) {
    d0b2:	2f00      	cmp	r7, #0
    d0b4:	d163      	bne.n	d17e <_usb_d_dev_handler+0xda>
	return tmp;
}

static inline hri_usbdevice_intflag_reg_t hri_usbdevice_read_INTFLAG_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTFLAG.reg;
    d0b6:	8b99      	ldrh	r1, [r3, #28]
	return tmp;
}

static inline hri_usbdevice_intenset_reg_t hri_usbdevice_read_INTEN_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTENSET.reg;
    d0b8:	8b1a      	ldrh	r2, [r3, #24]
    d0ba:	b292      	uxth	r2, r2
	flags &= hri_usbdevice_read_INTEN_reg(USB);
    d0bc:	400a      	ands	r2, r1
	if (flags & USB_DEVICE_INTFLAG_SOF) {
    d0be:	f012 0004 	ands.w	r0, r2, #4
    d0c2:	d005      	beq.n	d0d0 <_usb_d_dev_handler+0x2c>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d0c4:	2204      	movs	r2, #4
    d0c6:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.sof();
    d0c8:	682b      	ldr	r3, [r5, #0]
}
    d0ca:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	dev_inst.callbacks.sof();
    d0ce:	4718      	bx	r3
	if (flags & USB_DEVICE_INTFLAG_LPMSUSP) {
    d0d0:	f412 7100 	ands.w	r1, r2, #512	; 0x200
    d0d4:	d01f      	beq.n	d116 <_usb_d_dev_handler+0x72>
    d0d6:	f240 2201 	movw	r2, #513	; 0x201
    d0da:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = ~data;
}

static inline void hri_usbdevice_clear_INTEN_reg(const void *const hw, hri_usbdevice_intenset_reg_t mask)
{
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    d0dc:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d0de:	2270      	movs	r2, #112	; 0x70
    d0e0:	831a      	strh	r2, [r3, #24]
    d0e2:	4603      	mov	r3, r0
		if (bank->EXTREG.bit.SUBPID == 0x3) {
    d0e4:	eb05 1243 	add.w	r2, r5, r3, lsl #5
    d0e8:	f502 700e 	add.w	r0, r2, #568	; 0x238
    d0ec:	f8b2 2238 	ldrh.w	r2, [r2, #568]	; 0x238
    d0f0:	f002 020f 	and.w	r2, r2, #15
    d0f4:	2a03      	cmp	r2, #3
    d0f6:	d109      	bne.n	d10c <_usb_d_dev_handler+0x68>
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    d0f8:	8801      	ldrh	r1, [r0, #0]
			bank->EXTREG.reg = 0;
    d0fa:	2300      	movs	r3, #0
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    d0fc:	f3c1 110a 	ubfx	r1, r1, #4, #11
			bank->EXTREG.reg = 0;
    d100:	8003      	strh	r3, [r0, #0]
	dev_inst.callbacks.event(USB_EV_LPM_SUSPEND, lpm_variable);
    d102:	686b      	ldr	r3, [r5, #4]
    d104:	2003      	movs	r0, #3
}
    d106:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    d10a:	4718      	bx	r3
	for (i = 0; i < CONF_USB_D_MAX_EP_N; i++) {
    d10c:	3301      	adds	r3, #1
    d10e:	2b05      	cmp	r3, #5
    d110:	d1e8      	bne.n	d0e4 <_usb_d_dev_handler+0x40>
	uint32_t lpm_variable = 0;
    d112:	2100      	movs	r1, #0
    d114:	e7f5      	b.n	d102 <_usb_d_dev_handler+0x5e>
	} else if (flags & USB_DEVICE_INTFLAG_RAMACER) {
    d116:	f012 0080 	ands.w	r0, r2, #128	; 0x80
    d11a:	d004      	beq.n	d126 <_usb_d_dev_handler+0x82>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d11c:	2280      	movs	r2, #128	; 0x80
    d11e:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.event(USB_EV_ERROR, 0);
    d120:	2005      	movs	r0, #5
    d122:	686b      	ldr	r3, [r5, #4]
    d124:	e7ef      	b.n	d106 <_usb_d_dev_handler+0x62>
	} else if (flags & USB_D_WAKEUP_INT_FLAGS) {
    d126:	f012 0470 	ands.w	r4, r2, #112	; 0x70
    d12a:	d00b      	beq.n	d144 <_usb_d_dev_handler+0xa0>
    d12c:	2270      	movs	r2, #112	; 0x70
    d12e:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    d130:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d132:	f240 2201 	movw	r2, #513	; 0x201
    d136:	831a      	strh	r2, [r3, #24]
		_usb_d_dev_wait_dfll_rdy();
    d138:	4b47      	ldr	r3, [pc, #284]	; (d258 <_usb_d_dev_handler+0x1b4>)
    d13a:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_WAKEUP, 0);
    d13c:	686b      	ldr	r3, [r5, #4]
    d13e:	4601      	mov	r1, r0
    d140:	2002      	movs	r0, #2
    d142:	e7e0      	b.n	d106 <_usb_d_dev_handler+0x62>
	} else if (flags & USB_DEVICE_INTFLAG_EORST) {
    d144:	f012 0108 	ands.w	r1, r2, #8
    d148:	d00e      	beq.n	d168 <_usb_d_dev_handler+0xc4>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d14a:	2208      	movs	r2, #8
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    d14c:	f883 4100 	strb.w	r4, [r3, #256]	; 0x100
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d150:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    d152:	2270      	movs	r2, #112	; 0x70
    d154:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d156:	f240 2201 	movw	r2, #513	; 0x201
    d15a:	831a      	strh	r2, [r3, #24]
	_usb_d_dev_reset_epts();
    d15c:	4b3f      	ldr	r3, [pc, #252]	; (d25c <_usb_d_dev_handler+0x1b8>)
    d15e:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_RESET, 0);
    d160:	686b      	ldr	r3, [r5, #4]
    d162:	4621      	mov	r1, r4
    d164:	2001      	movs	r0, #1
    d166:	e7ce      	b.n	d106 <_usb_d_dev_handler+0x62>
	} else if (flags & USB_DEVICE_INTFLAG_SUSPEND) {
    d168:	07d0      	lsls	r0, r2, #31
    d16a:	d508      	bpl.n	d17e <_usb_d_dev_handler+0xda>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d16c:	f240 2201 	movw	r2, #513	; 0x201
    d170:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    d172:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d174:	2270      	movs	r2, #112	; 0x70
    d176:	831a      	strh	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    d178:	2004      	movs	r0, #4
    d17a:	686b      	ldr	r3, [r5, #4]
    d17c:	e7c3      	b.n	d106 <_usb_d_dev_handler+0x62>
    d17e:	4c35      	ldr	r4, [pc, #212]	; (d254 <_usb_d_dev_handler+0x1b0>)
			_usb_d_dev_handle_setup(ept);
    d180:	f8df 90e4 	ldr.w	r9, [pc, #228]	; d268 <_usb_d_dev_handler+0x1c4>
			_usb_d_dev_handle_trfail(ept, 1);
    d184:	f8df 80e4 	ldr.w	r8, [pc, #228]	; d26c <_usb_d_dev_handler+0x1c8>
		_usb_d_dev_out_next(ept, true);
    d188:	f8df a0e4 	ldr.w	sl, [pc, #228]	; d270 <_usb_d_dev_handler+0x1cc>
	uint32_t lpm_variable = 0;
    d18c:	2600      	movs	r6, #0
		if (ept->ep == 0xFF) {
    d18e:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
    d192:	2aff      	cmp	r2, #255	; 0xff
    d194:	f104 0414 	add.w	r4, r4, #20
    d198:	d029      	beq.n	d1ee <_usb_d_dev_handler+0x14a>
	if (!(epint & (1u << epn))) {
    d19a:	f002 020f 	and.w	r2, r2, #15
    d19e:	2101      	movs	r1, #1
    d1a0:	fa01 f302 	lsl.w	r3, r1, r2
    d1a4:	423b      	tst	r3, r7
    d1a6:	d022      	beq.n	d1ee <_usb_d_dev_handler+0x14a>
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    d1a8:	0153      	lsls	r3, r2, #5
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    d1aa:	0152      	lsls	r2, r2, #5
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    d1ac:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    d1b0:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    d1b4:	f893 0107 	ldrb.w	r0, [r3, #263]	; 0x107
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    d1b8:	f892 3109 	ldrb.w	r3, [r2, #265]	; 0x109
	if (flags) {
    d1bc:	4003      	ands	r3, r0
    d1be:	d016      	beq.n	d1ee <_usb_d_dev_handler+0x14a>
		if ((ept->flags.bits.eptype == 0x1) && !_usb_d_dev_ep_is_busy(ept)) {
    d1c0:	2214      	movs	r2, #20
    d1c2:	fb02 5206 	mla	r2, r2, r6, r5
    d1c6:	f892 2027 	ldrb.w	r2, [r2, #39]	; 0x27
    d1ca:	f002 0047 	and.w	r0, r2, #71	; 0x47
    d1ce:	4288      	cmp	r0, r1
    d1d0:	d112      	bne.n	d1f8 <_usb_d_dev_handler+0x154>
	if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    d1d2:	06da      	lsls	r2, r3, #27
    d1d4:	d502      	bpl.n	d1dc <_usb_d_dev_handler+0x138>
			_usb_d_dev_handle_setup(ept);
    d1d6:	4620      	mov	r0, r4
    d1d8:	47c8      	blx	r9
    d1da:	e008      	b.n	d1ee <_usb_d_dev_handler+0x14a>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    d1dc:	f013 0140 	ands.w	r1, r3, #64	; 0x40
    d1e0:	d003      	beq.n	d1ea <_usb_d_dev_handler+0x146>
		_usb_d_dev_handle_stall(ept, 1);
    d1e2:	4601      	mov	r1, r0
		_usb_d_dev_handle_stall(ept, 0);
    d1e4:	4b1e      	ldr	r3, [pc, #120]	; (d260 <_usb_d_dev_handler+0x1bc>)
    d1e6:	4620      	mov	r0, r4
    d1e8:	e013      	b.n	d212 <_usb_d_dev_handler+0x16e>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    d1ea:	069b      	lsls	r3, r3, #26
    d1ec:	d4fa      	bmi.n	d1e4 <_usb_d_dev_handler+0x140>
	for (i = 0; i < USB_D_N_EP; i++) {
    d1ee:	3601      	adds	r6, #1
    d1f0:	2e1b      	cmp	r6, #27
    d1f2:	d1cc      	bne.n	d18e <_usb_d_dev_handler+0xea>
}
    d1f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		} else if (_usb_d_dev_ep_is_in(ept)) {
    d1f8:	0610      	lsls	r0, r2, #24
    d1fa:	d514      	bpl.n	d226 <_usb_d_dev_handler+0x182>
	if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    d1fc:	0658      	lsls	r0, r3, #25
    d1fe:	d4f1      	bmi.n	d1e4 <_usb_d_dev_handler+0x140>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    d200:	0718      	lsls	r0, r3, #28
    d202:	d502      	bpl.n	d20a <_usb_d_dev_handler+0x166>
			_usb_d_dev_handle_trfail(ept, 1);
    d204:	4620      	mov	r0, r4
    d206:	47c0      	blx	r8
    d208:	e7f1      	b.n	d1ee <_usb_d_dev_handler+0x14a>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT1) {
    d20a:	0798      	lsls	r0, r3, #30
    d20c:	d503      	bpl.n	d216 <_usb_d_dev_handler+0x172>
		_usb_d_dev_in_next(ept, true);
    d20e:	4b15      	ldr	r3, [pc, #84]	; (d264 <_usb_d_dev_handler+0x1c0>)
    d210:	4620      	mov	r0, r4
		_usb_d_dev_handle_stall(ept, 0);
    d212:	4798      	blx	r3
    d214:	e7eb      	b.n	d1ee <_usb_d_dev_handler+0x14a>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    d216:	f002 0207 	and.w	r2, r2, #7
    d21a:	2a01      	cmp	r2, #1
    d21c:	d1e7      	bne.n	d1ee <_usb_d_dev_handler+0x14a>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    d21e:	075a      	lsls	r2, r3, #29
    d220:	d515      	bpl.n	d24e <_usb_d_dev_handler+0x1aa>
			_usb_d_dev_handle_trfail(ept, 0);
    d222:	2100      	movs	r1, #0
    d224:	e7ee      	b.n	d204 <_usb_d_dev_handler+0x160>
	if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    d226:	f013 0020 	ands.w	r0, r3, #32
    d22a:	d001      	beq.n	d230 <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_stall(ept, 0);
    d22c:	2100      	movs	r1, #0
    d22e:	e7d9      	b.n	d1e4 <_usb_d_dev_handler+0x140>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    d230:	0758      	lsls	r0, r3, #29
    d232:	d4f6      	bmi.n	d222 <_usb_d_dev_handler+0x17e>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT0) {
    d234:	07d8      	lsls	r0, r3, #31
    d236:	d502      	bpl.n	d23e <_usb_d_dev_handler+0x19a>
		_usb_d_dev_out_next(ept, true);
    d238:	4620      	mov	r0, r4
    d23a:	47d0      	blx	sl
    d23c:	e7d7      	b.n	d1ee <_usb_d_dev_handler+0x14a>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    d23e:	f002 0207 	and.w	r2, r2, #7
    d242:	2a01      	cmp	r2, #1
    d244:	d1d3      	bne.n	d1ee <_usb_d_dev_handler+0x14a>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    d246:	071a      	lsls	r2, r3, #28
    d248:	d501      	bpl.n	d24e <_usb_d_dev_handler+0x1aa>
			_usb_d_dev_handle_trfail(ept, 1);
    d24a:	2101      	movs	r1, #1
    d24c:	e7da      	b.n	d204 <_usb_d_dev_handler+0x160>
		} else if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    d24e:	06db      	lsls	r3, r3, #27
    d250:	d5cd      	bpl.n	d1ee <_usb_d_dev_handler+0x14a>
    d252:	e7c0      	b.n	d1d6 <_usb_d_dev_handler+0x132>
    d254:	200085a8 	.word	0x200085a8
    d258:	0000cb09 	.word	0x0000cb09
    d25c:	0000cd6d 	.word	0x0000cd6d
    d260:	0000cbc9 	.word	0x0000cbc9
    d264:	0000cdad 	.word	0x0000cdad
    d268:	0000cb45 	.word	0x0000cb45
    d26c:	0000cc85 	.word	0x0000cc85
    d270:	0000cf09 	.word	0x0000cf09

0000d274 <_usbd_ep_pcksize_size>:
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    d274:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    d278:	d80f      	bhi.n	d29a <_usbd_ep_pcksize_size+0x26>
    d27a:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    d27e:	d80e      	bhi.n	d29e <_usbd_ep_pcksize_size+0x2a>
    d280:	2880      	cmp	r0, #128	; 0x80
    d282:	d80e      	bhi.n	d2a2 <_usbd_ep_pcksize_size+0x2e>
    d284:	2840      	cmp	r0, #64	; 0x40
    d286:	d80e      	bhi.n	d2a6 <_usbd_ep_pcksize_size+0x32>
    d288:	2820      	cmp	r0, #32
    d28a:	d80e      	bhi.n	d2aa <_usbd_ep_pcksize_size+0x36>
    d28c:	2810      	cmp	r0, #16
    d28e:	d80e      	bhi.n	d2ae <_usbd_ep_pcksize_size+0x3a>
    d290:	2808      	cmp	r0, #8
    d292:	bf94      	ite	ls
    d294:	2000      	movls	r0, #0
    d296:	2001      	movhi	r0, #1
    d298:	4770      	bx	lr
    d29a:	2007      	movs	r0, #7
    d29c:	4770      	bx	lr
    d29e:	2006      	movs	r0, #6
    d2a0:	4770      	bx	lr
    d2a2:	2005      	movs	r0, #5
    d2a4:	4770      	bx	lr
    d2a6:	2004      	movs	r0, #4
    d2a8:	4770      	bx	lr
    d2aa:	2003      	movs	r0, #3
    d2ac:	4770      	bx	lr
    d2ae:	2002      	movs	r0, #2
}
    d2b0:	4770      	bx	lr
	...

0000d2b4 <_usb_d_dev_init>:
{
    d2b4:	b508      	push	{r3, lr}
	return ((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg;
    d2b6:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d2ba:	789a      	ldrb	r2, [r3, #2]
	if (!hri_usbdevice_is_syncing(hw, USB_SYNCBUSY_SWRST)) {
    d2bc:	07d0      	lsls	r0, r2, #31
    d2be:	d41a      	bmi.n	d2f6 <_usb_d_dev_init+0x42>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d2c0:	789a      	ldrb	r2, [r3, #2]
    d2c2:	0791      	lsls	r1, r2, #30
    d2c4:	d1fc      	bne.n	d2c0 <_usb_d_dev_init+0xc>

static inline hri_usb_ctrla_reg_t hri_usb_get_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t mask)
{
	uint8_t tmp;
	hri_usb_wait_for_sync(hw, USB_SYNCBUSY_MASK);
	tmp = ((Usb *)hw)->HOST.CTRLA.reg;
    d2c6:	781a      	ldrb	r2, [r3, #0]
		if (hri_usbdevice_get_CTRLA_reg(hw, USB_CTRLA_ENABLE)) {
    d2c8:	0792      	lsls	r2, r2, #30
    d2ca:	d50d      	bpl.n	d2e8 <_usb_d_dev_init+0x34>
	((Usb *)hw)->HOST.CTRLA.reg &= ~USB_CTRLA_ENABLE;
    d2cc:	781a      	ldrb	r2, [r3, #0]
    d2ce:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
    d2d2:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d2d4:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d2d8:	7893      	ldrb	r3, [r2, #2]
    d2da:	0798      	lsls	r0, r3, #30
    d2dc:	d1fc      	bne.n	d2d8 <_usb_d_dev_init+0x24>
    d2de:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d2e2:	7893      	ldrb	r3, [r2, #2]
    d2e4:	0799      	lsls	r1, r3, #30
    d2e6:	d4fc      	bmi.n	d2e2 <_usb_d_dev_init+0x2e>
}

static inline void hri_usb_write_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.CTRLA.reg = data;
    d2e8:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d2ec:	2201      	movs	r2, #1
    d2ee:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d2f0:	789a      	ldrb	r2, [r3, #2]
    d2f2:	0792      	lsls	r2, r2, #30
    d2f4:	d1fc      	bne.n	d2f0 <_usb_d_dev_init+0x3c>
    d2f6:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d2fa:	7893      	ldrb	r3, [r2, #2]
    d2fc:	07db      	lsls	r3, r3, #31
    d2fe:	d4fc      	bmi.n	d2fa <_usb_d_dev_init+0x46>
	dev_inst.callbacks.sof   = (_usb_d_dev_sof_cb_t)_dummy_func_no_return;
    d300:	4a1e      	ldr	r2, [pc, #120]	; (d37c <_usb_d_dev_init+0xc8>)
    d302:	4b1f      	ldr	r3, [pc, #124]	; (d380 <_usb_d_dev_init+0xcc>)
	dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)_dummy_func_no_return;
    d304:	e9c3 2200 	strd	r2, r2, [r3]
	dev_inst.ep_callbacks.more  = (_usb_d_dev_ep_cb_more_t)_dummy_func_no_return;
    d308:	e9c3 2202 	strd	r2, r2, [r3, #8]
	dev_inst.ep_callbacks.done  = (_usb_d_dev_ep_cb_done_t)_dummy_func_no_return;
    d30c:	611a      	str	r2, [r3, #16]
	_usb_d_dev_reset_epts();
    d30e:	4b1d      	ldr	r3, [pc, #116]	; (d384 <_usb_d_dev_init+0xd0>)
    d310:	4798      	blx	r3
	    = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRANSN_POS / 32)) >> (NVM_USB_PAD_TRANSN_POS % 32))
    d312:	4b1d      	ldr	r3, [pc, #116]	; (d388 <_usb_d_dev_init+0xd4>)
    d314:	681a      	ldr	r2, [r3, #0]
	uint32_t pad_transp
    d316:	f3c2 1344 	ubfx	r3, r2, #5, #5
	uint32_t pad_trim = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRIM_POS / 32)) >> (NVM_USB_PAD_TRIM_POS % 32))
    d31a:	f3c2 2182 	ubfx	r1, r2, #10, #3
	if (pad_transn == 0 || pad_transn == 0x1F) {
    d31e:	f012 021f 	ands.w	r2, r2, #31
    d322:	d025      	beq.n	d370 <_usb_d_dev_init+0xbc>
		pad_transn = 9;
    d324:	2a1f      	cmp	r2, #31
    d326:	bf08      	it	eq
    d328:	2209      	moveq	r2, #9
	if (pad_transp == 0 || pad_transp == 0x1F) {
    d32a:	b31b      	cbz	r3, d374 <_usb_d_dev_init+0xc0>
		pad_transp = 25;
    d32c:	2b1f      	cmp	r3, #31
    d32e:	bf08      	it	eq
    d330:	2319      	moveq	r3, #25
	if (pad_trim == 0 || pad_trim == 0x7) {
    d332:	b309      	cbz	r1, d378 <_usb_d_dev_init+0xc4>
		pad_trim = 6;
    d334:	2907      	cmp	r1, #7
    d336:	bf08      	it	eq
    d338:	2106      	moveq	r1, #6
	hw->DEVICE.PADCAL.reg = USB_PADCAL_TRANSN(pad_transn) | USB_PADCAL_TRANSP(pad_transp) | USB_PADCAL_TRIM(pad_trim);
    d33a:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
    d33e:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
    d342:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d346:	b29b      	uxth	r3, r3
    d348:	8513      	strh	r3, [r2, #40]	; 0x28
	hw->DEVICE.QOSCTRL.bit.CQOS = 3;
    d34a:	78d3      	ldrb	r3, [r2, #3]
    d34c:	f043 0303 	orr.w	r3, r3, #3
    d350:	70d3      	strb	r3, [r2, #3]
	hw->DEVICE.QOSCTRL.bit.DQOS = 3;
    d352:	78d3      	ldrb	r3, [r2, #3]
    d354:	f043 030c 	orr.w	r3, r3, #12
    d358:	70d3      	strb	r3, [r2, #3]
	((Usb *)hw)->HOST.CTRLA.reg = data;
    d35a:	2304      	movs	r3, #4
    d35c:	7013      	strb	r3, [r2, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d35e:	7890      	ldrb	r0, [r2, #2]
    d360:	f010 0003 	ands.w	r0, r0, #3
    d364:	d1fb      	bne.n	d35e <_usb_d_dev_init+0xaa>
	hri_usbdevice_write_DESCADD_reg(hw, (uint32_t)prvt_inst.desc_table);
    d366:	4b09      	ldr	r3, [pc, #36]	; (d38c <_usb_d_dev_init+0xd8>)
}

static inline void hri_usb_write_DESCADD_reg(const void *const hw, hri_usb_descadd_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.DESCADD.reg = data;
    d368:	6253      	str	r3, [r2, #36]	; 0x24
	((Usb *)hw)->DEVICE.CTRLB.reg = data;
    d36a:	2301      	movs	r3, #1
    d36c:	8113      	strh	r3, [r2, #8]
}
    d36e:	bd08      	pop	{r3, pc}
		pad_transn = 9;
    d370:	2209      	movs	r2, #9
    d372:	e7da      	b.n	d32a <_usb_d_dev_init+0x76>
		pad_transp = 25;
    d374:	2319      	movs	r3, #25
    d376:	e7dc      	b.n	d332 <_usb_d_dev_init+0x7e>
		pad_trim = 6;
    d378:	2106      	movs	r1, #6
    d37a:	e7de      	b.n	d33a <_usb_d_dev_init+0x86>
    d37c:	0000cb05 	.word	0x0000cb05
    d380:	200085a8 	.word	0x200085a8
    d384:	0000cd6d 	.word	0x0000cd6d
    d388:	00800084 	.word	0x00800084
    d38c:	200087d8 	.word	0x200087d8

0000d390 <_usb_d_dev_enable>:
	tmp = ((Usb *)hw)->HOST.SYNCBUSY.reg;
    d390:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d394:	789a      	ldrb	r2, [r3, #2]
	if (hri_usbdevice_get_SYNCBUSY_reg(hw, (USB_SYNCBUSY_ENABLE | USB_SYNCBUSY_SWRST))) {
    d396:	0792      	lsls	r2, r2, #30
    d398:	d122      	bne.n	d3e0 <_usb_d_dev_enable+0x50>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d39a:	789a      	ldrb	r2, [r3, #2]
    d39c:	0790      	lsls	r0, r2, #30
    d39e:	d1fc      	bne.n	d39a <_usb_d_dev_enable+0xa>
	return ((Usb *)hw)->HOST.CTRLA.reg;
    d3a0:	7819      	ldrb	r1, [r3, #0]
    d3a2:	b2ca      	uxtb	r2, r1
	if ((ctrla & USB_CTRLA_ENABLE) == 0) {
    d3a4:	0789      	lsls	r1, r1, #30
    d3a6:	d407      	bmi.n	d3b8 <_usb_d_dev_enable+0x28>
		hri_usbdevice_write_CTRLA_reg(hw, ctrla | USB_CTRLA_ENABLE);
    d3a8:	f042 0202 	orr.w	r2, r2, #2
	((Usb *)hw)->HOST.CTRLA.reg = data;
    d3ac:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d3ae:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d3b2:	7893      	ldrb	r3, [r2, #2]
    d3b4:	079b      	lsls	r3, r3, #30
    d3b6:	d1fc      	bne.n	d3b2 <_usb_d_dev_enable+0x22>
    d3b8:	4b0b      	ldr	r3, [pc, #44]	; (d3e8 <_usb_d_dev_enable+0x58>)
    d3ba:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    d3be:	609a      	str	r2, [r3, #8]
    d3c0:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    d3c4:	609a      	str	r2, [r3, #8]
    d3c6:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    d3ca:	609a      	str	r2, [r3, #8]
    d3cc:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    d3d0:	609a      	str	r2, [r3, #8]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d3d2:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d3d6:	f240 228d 	movw	r2, #653	; 0x28d
    d3da:	831a      	strh	r2, [r3, #24]
	return ERR_NONE;
    d3dc:	2000      	movs	r0, #0
    d3de:	4770      	bx	lr
		return -USB_ERR_DENIED;
    d3e0:	f06f 0010 	mvn.w	r0, #16
}
    d3e4:	4770      	bx	lr
    d3e6:	bf00      	nop
    d3e8:	e000e100 	.word	0xe000e100

0000d3ec <_usb_d_dev_attach>:
	((Usb *)hw)->DEVICE.CTRLB.reg &= ~USB_DEVICE_CTRLB_DETACH;
    d3ec:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d3f0:	8913      	ldrh	r3, [r2, #8]
    d3f2:	f023 0301 	bic.w	r3, r3, #1
    d3f6:	041b      	lsls	r3, r3, #16
    d3f8:	0c1b      	lsrs	r3, r3, #16
    d3fa:	8113      	strh	r3, [r2, #8]
}
    d3fc:	4770      	bx	lr

0000d3fe <_usb_d_dev_set_address>:
	((Usb *)hw)->DEVICE.DADD.reg = data;
    d3fe:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
	hri_usbdevice_write_DADD_reg(USB, USB_DEVICE_DADD_ADDEN | USB_DEVICE_DADD_DADD(addr));
    d402:	f040 0080 	orr.w	r0, r0, #128	; 0x80
    d406:	7298      	strb	r0, [r3, #10]
}
    d408:	4770      	bx	lr

0000d40a <_usb_d_dev_get_frame_n>:
	return (((Usb *)hw)->DEVICE.FNUM.reg & USB_DEVICE_FNUM_FNUM_Msk) >> USB_DEVICE_FNUM_FNUM_Pos;
    d40a:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d40e:	8a18      	ldrh	r0, [r3, #16]
}
    d410:	f3c0 00ca 	ubfx	r0, r0, #3, #11
    d414:	4770      	bx	lr
	...

0000d418 <_usb_d_dev_ep_init>:
{
    d418:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    d41c:	f000 040f 	and.w	r4, r0, #15
{
    d420:	460d      	mov	r5, r1
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d422:	f8df 90b0 	ldr.w	r9, [pc, #176]	; d4d4 <_usb_d_dev_ep_init+0xbc>
    d426:	09c1      	lsrs	r1, r0, #7
{
    d428:	4607      	mov	r7, r0
    d42a:	fa4f f880 	sxtb.w	r8, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d42e:	4620      	mov	r0, r4
    d430:	47c8      	blx	r9
	if (epn > CONF_USB_D_MAX_EP_N) {
    d432:	2c05      	cmp	r4, #5
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d434:	4606      	mov	r6, r0
	uint8_t                        ep_type = attr & USB_EP_XTYPE_MASK;
    d436:	f005 0503 	and.w	r5, r5, #3
	if (epn > CONF_USB_D_MAX_EP_N) {
    d43a:	d83f      	bhi.n	d4bc <_usb_d_dev_ep_init+0xa4>
	if (ept->ep != 0xFF) {
    d43c:	7c83      	ldrb	r3, [r0, #18]
    d43e:	2bff      	cmp	r3, #255	; 0xff
    d440:	d13f      	bne.n	d4c2 <_usb_d_dev_ep_init+0xaa>
	if (ep_type == USB_EP_XTYPE_CTRL) {
    d442:	b985      	cbnz	r5, d466 <_usb_d_dev_ep_init+0x4e>
		struct _usb_d_dev_ep *ept_in = _usb_d_dev_ept(epn, !dir);
    d444:	ea6f 0108 	mvn.w	r1, r8
    d448:	0fc9      	lsrs	r1, r1, #31
    d44a:	4620      	mov	r0, r4
    d44c:	47c8      	blx	r9
		if (ept_in->ep != 0xFF) {
    d44e:	7c83      	ldrb	r3, [r0, #18]
    d450:	2bff      	cmp	r3, #255	; 0xff
    d452:	d136      	bne.n	d4c2 <_usb_d_dev_ep_init+0xaa>
		if (pcfg->cache == NULL) {
    d454:	230c      	movs	r3, #12
    d456:	491e      	ldr	r1, [pc, #120]	; (d4d0 <_usb_d_dev_ep_init+0xb8>)
    d458:	4363      	muls	r3, r4
    d45a:	58cb      	ldr	r3, [r1, r3]
    d45c:	2b00      	cmp	r3, #0
    d45e:	d133      	bne.n	d4c8 <_usb_d_dev_ep_init+0xb0>
			return -USB_ERR_FUNC;
    d460:	f06f 0012 	mvn.w	r0, #18
    d464:	e018      	b.n	d498 <_usb_d_dev_ep_init+0x80>
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    d466:	f1b8 0f00 	cmp.w	r8, #0
    d46a:	da17      	bge.n	d49c <_usb_d_dev_ep_init+0x84>
    d46c:	4918      	ldr	r1, [pc, #96]	; (d4d0 <_usb_d_dev_ep_init+0xb8>)
    d46e:	230c      	movs	r3, #12
    d470:	fb03 1304 	mla	r3, r3, r4, r1
    d474:	6859      	ldr	r1, [r3, #4]
    d476:	b9e9      	cbnz	r1, d4b4 <_usb_d_dev_ep_init+0x9c>
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d478:	4915      	ldr	r1, [pc, #84]	; (d4d0 <_usb_d_dev_ep_init+0xb8>)
	ept->size     = max_pkt_siz;
    d47a:	8232      	strh	r2, [r6, #16]
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d47c:	230c      	movs	r3, #12
    d47e:	435c      	muls	r4, r3
    d480:	190b      	adds	r3, r1, r4
    d482:	5909      	ldr	r1, [r1, r4]
    d484:	685b      	ldr	r3, [r3, #4]
	ept->ep       = ep;
    d486:	74b7      	strb	r7, [r6, #18]
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d488:	ea13 0328 	ands.w	r3, r3, r8, asr #32
    d48c:	bf38      	it	cc
    d48e:	460b      	movcc	r3, r1
	ept->flags.u8 = (ep_type + 1);
    d490:	3501      	adds	r5, #1
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d492:	60f3      	str	r3, [r6, #12]
	ept->flags.u8 = (ep_type + 1);
    d494:	74f5      	strb	r5, [r6, #19]
	return USB_OK;
    d496:	2000      	movs	r0, #0
}
    d498:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    d49c:	230c      	movs	r3, #12
    d49e:	490c      	ldr	r1, [pc, #48]	; (d4d0 <_usb_d_dev_ep_init+0xb8>)
    d4a0:	4363      	muls	r3, r4
    d4a2:	58cb      	ldr	r3, [r1, r3]
    d4a4:	2b00      	cmp	r3, #0
    d4a6:	d0e7      	beq.n	d478 <_usb_d_dev_ep_init+0x60>
    d4a8:	4909      	ldr	r1, [pc, #36]	; (d4d0 <_usb_d_dev_ep_init+0xb8>)
    d4aa:	230c      	movs	r3, #12
    d4ac:	fb03 1304 	mla	r3, r3, r4, r1
    d4b0:	891b      	ldrh	r3, [r3, #8]
    d4b2:	e000      	b.n	d4b6 <_usb_d_dev_ep_init+0x9e>
    d4b4:	895b      	ldrh	r3, [r3, #10]
    d4b6:	429a      	cmp	r2, r3
    d4b8:	ddde      	ble.n	d478 <_usb_d_dev_ep_init+0x60>
    d4ba:	e7d1      	b.n	d460 <_usb_d_dev_ep_init+0x48>
		return -USB_ERR_PARAM;
    d4bc:	f06f 0011 	mvn.w	r0, #17
    d4c0:	e7ea      	b.n	d498 <_usb_d_dev_ep_init+0x80>
		return -USB_ERR_REDO;
    d4c2:	f06f 0013 	mvn.w	r0, #19
    d4c6:	e7e7      	b.n	d498 <_usb_d_dev_ep_init+0x80>
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    d4c8:	f1b8 0f00 	cmp.w	r8, #0
    d4cc:	daec      	bge.n	d4a8 <_usb_d_dev_ep_init+0x90>
    d4ce:	e7cd      	b.n	d46c <_usb_d_dev_ep_init+0x54>
    d4d0:	00016280 	.word	0x00016280
    d4d4:	0000cb2d 	.word	0x0000cb2d

0000d4d8 <_usb_d_dev_ep_deinit>:
{
    d4d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    d4da:	f000 050f 	and.w	r5, r0, #15
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d4de:	2d05      	cmp	r5, #5
{
    d4e0:	4604      	mov	r4, r0
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d4e2:	d818      	bhi.n	d516 <_usb_d_dev_ep_deinit+0x3e>
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d4e4:	4b17      	ldr	r3, [pc, #92]	; (d544 <_usb_d_dev_ep_deinit+0x6c>)
	bool                  dir = USB_EP_GET_DIR(ep);
    d4e6:	09c1      	lsrs	r1, r0, #7
    d4e8:	b247      	sxtb	r7, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d4ea:	4628      	mov	r0, r5
    d4ec:	4798      	blx	r3
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d4ee:	7c83      	ldrb	r3, [r0, #18]
    d4f0:	2bff      	cmp	r3, #255	; 0xff
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d4f2:	4606      	mov	r6, r0
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d4f4:	d00f      	beq.n	d516 <_usb_d_dev_ep_deinit+0x3e>
	_usb_d_dev_trans_stop(ept, dir, USB_TRANS_RESET);
    d4f6:	4b14      	ldr	r3, [pc, #80]	; (d548 <_usb_d_dev_ep_deinit+0x70>)
    d4f8:	2203      	movs	r2, #3
    d4fa:	4798      	blx	r3
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    d4fc:	7cf3      	ldrb	r3, [r6, #19]
    d4fe:	f003 0307 	and.w	r3, r3, #7
    d502:	2b01      	cmp	r3, #1
    d504:	d108      	bne.n	d518 <_usb_d_dev_ep_deinit+0x40>
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg = 0;
    d506:	0164      	lsls	r4, r4, #5
    d508:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
    d50c:	2300      	movs	r3, #0
    d50e:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
	ept->ep       = 0xFF;
    d512:	23ff      	movs	r3, #255	; 0xff
    d514:	8273      	strh	r3, [r6, #18]
}
    d516:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (USB_EP_GET_DIR(ep)) {
    d518:	2f00      	cmp	r7, #0
    d51a:	da09      	bge.n	d530 <_usb_d_dev_ep_deinit+0x58>
		hw->DEVICE.DeviceEndpoint[USB_EP_GET_N(ep)].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE1_Msk;
    d51c:	016b      	lsls	r3, r5, #5
    d51e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d522:	f893 2100 	ldrb.w	r2, [r3, #256]	; 0x100
    d526:	f002 028f 	and.w	r2, r2, #143	; 0x8f
    d52a:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
    d52e:	e7f0      	b.n	d512 <_usb_d_dev_ep_deinit+0x3a>
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE0_Msk;
    d530:	0164      	lsls	r4, r4, #5
    d532:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
    d536:	f894 3100 	ldrb.w	r3, [r4, #256]	; 0x100
    d53a:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
    d53e:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
    d542:	e7e6      	b.n	d512 <_usb_d_dev_ep_deinit+0x3a>
    d544:	0000cb2d 	.word	0x0000cb2d
    d548:	0000cc25 	.word	0x0000cc25

0000d54c <_usb_d_dev_ep_enable>:
{
    d54c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t               epn   = USB_EP_GET_N(ep);
    d550:	f000 050f 	and.w	r5, r0, #15
	struct _usb_d_dev_ep *ept   = _usb_d_dev_ept(epn, dir);
    d554:	09c1      	lsrs	r1, r0, #7
    d556:	4b55      	ldr	r3, [pc, #340]	; (d6ac <_usb_d_dev_ep_enable+0x160>)
    d558:	fa4f f980 	sxtb.w	r9, r0
    d55c:	4628      	mov	r0, r5
    d55e:	4798      	blx	r3
    d560:	ea4f 1c45 	mov.w	ip, r5, lsl #5
    d564:	f10c 4682 	add.w	r6, ip, #1090519040	; 0x41000000
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d568:	2d05      	cmp	r5, #5
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    d56a:	f896 1100 	ldrb.w	r1, [r6, #256]	; 0x100
	struct _usb_d_dev_ep *ept   = _usb_d_dev_ept(epn, dir);
    d56e:	4607      	mov	r7, r0
    d570:	b2c8      	uxtb	r0, r1
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d572:	f200 8094 	bhi.w	d69e <_usb_d_dev_ep_enable+0x152>
    d576:	7cba      	ldrb	r2, [r7, #18]
    d578:	2aff      	cmp	r2, #255	; 0xff
    d57a:	f000 8090 	beq.w	d69e <_usb_d_dev_ep_enable+0x152>
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d57e:	7cf9      	ldrb	r1, [r7, #19]
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    d580:	4c4b      	ldr	r4, [pc, #300]	; (d6b0 <_usb_d_dev_ep_enable+0x164>)
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d582:	f001 0307 	and.w	r3, r1, #7
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    d586:	f504 780c 	add.w	r8, r4, #560	; 0x230
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d58a:	2b01      	cmp	r3, #1
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    d58c:	44e0      	add	r8, ip
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d58e:	d147      	bne.n	d620 <_usb_d_dev_ep_enable+0xd4>
		if (epcfg & (USB_DEVICE_EPCFG_EPTYPE1_Msk | USB_DEVICE_EPCFG_EPTYPE0_Msk)) {
    d590:	f010 0377 	ands.w	r3, r0, #119	; 0x77
    d594:	f040 8086 	bne.w	d6a4 <_usb_d_dev_ep_enable+0x158>
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d598:	f8b7 9010 	ldrh.w	r9, [r7, #16]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    d59c:	2111      	movs	r1, #17
    d59e:	f886 1100 	strb.w	r1, [r6, #256]	; 0x100
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d5a2:	4648      	mov	r0, r9
    d5a4:	4943      	ldr	r1, [pc, #268]	; (d6b4 <_usb_d_dev_ep_enable+0x168>)
    d5a6:	4788      	blx	r1
    d5a8:	0700      	lsls	r0, r0, #28
    d5aa:	f000 41e0 	and.w	r1, r0, #1879048192	; 0x70000000
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d5ae:	4842      	ldr	r0, [pc, #264]	; (d6b8 <_usb_d_dev_ep_enable+0x16c>)
    d5b0:	ea00 3089 	and.w	r0, r0, r9, lsl #14
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d5b4:	f3c9 090d 	ubfx	r9, r9, #0, #14
	bank->STATUS_BK.reg     = 0;
    d5b8:	eb04 1545 	add.w	r5, r4, r5, lsl #5
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d5bc:	4308      	orrs	r0, r1
	uint8_t epn = USB_EP_GET_N(ept->ep);
    d5be:	f002 020f 	and.w	r2, r2, #15
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d5c2:	ea49 0101 	orr.w	r1, r9, r1
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d5c6:	f8c8 0004 	str.w	r0, [r8, #4]
	bank->ADDR.reg          = addr;
    d5ca:	eb04 1442 	add.w	r4, r4, r2, lsl #5
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d5ce:	f8c8 1014 	str.w	r1, [r8, #20]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d5d2:	f04f 0c40 	mov.w	ip, #64	; 0x40
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d5d6:	2180      	movs	r1, #128	; 0x80
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d5d8:	f886 c105 	strb.w	ip, [r6, #261]	; 0x105
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d5dc:	f886 1104 	strb.w	r1, [r6, #260]	; 0x104
	bank->STATUS_BK.reg     = 0;
    d5e0:	f885 323a 	strb.w	r3, [r5, #570]	; 0x23a
    d5e4:	f885 324a 	strb.w	r3, [r5, #586]	; 0x24a
	_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    d5e8:	68fd      	ldr	r5, [r7, #12]
	bank->ADDR.reg          = addr;
    d5ea:	f8c4 5230 	str.w	r5, [r4, #560]	; 0x230
    d5ee:	f504 710c 	add.w	r1, r4, #560	; 0x230
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    d5f2:	f8d4 4234 	ldr.w	r4, [r4, #564]	; 0x234
    d5f6:	f369 349b 	bfi	r4, r9, #14, #14
    d5fa:	604c      	str	r4, [r1, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    d5fc:	684c      	ldr	r4, [r1, #4]
	bank->ADDR.reg          = addr;
    d5fe:	0150      	lsls	r0, r2, #5
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    d600:	f100 4282 	add.w	r2, r0, #1090519040	; 0x41000000
    d604:	f363 040d 	bfi	r4, r3, #0, #14
    d608:	604c      	str	r4, [r1, #4]
    d60a:	21b0      	movs	r1, #176	; 0xb0
    d60c:	f882 1104 	strb.w	r1, [r2, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    d610:	2110      	movs	r1, #16
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d612:	f882 c105 	strb.w	ip, [r2, #261]	; 0x105
	return USB_OK;
    d616:	4618      	mov	r0, r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    d618:	f882 1109 	strb.w	r1, [r2, #265]	; 0x109
}
    d61c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if (dir) {
    d620:	f1b9 0f00 	cmp.w	r9, #0
    d624:	da1e      	bge.n	d664 <_usb_d_dev_ep_enable+0x118>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE1_Msk) {
    d626:	f010 0270 	ands.w	r2, r0, #112	; 0x70
    d62a:	d13b      	bne.n	d6a4 <_usb_d_dev_ep_enable+0x158>
		epcfg |= USB_DEVICE_EPCFG_EPTYPE1(ept->flags.bits.eptype);
    d62c:	f3c1 0102 	ubfx	r1, r1, #0, #3
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d630:	8a3b      	ldrh	r3, [r7, #16]
		epcfg |= USB_DEVICE_EPCFG_EPTYPE1(ept->flags.bits.eptype);
    d632:	ea40 1101 	orr.w	r1, r0, r1, lsl #4
    d636:	b2c9      	uxtb	r1, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    d638:	f886 1100 	strb.w	r1, [r6, #256]	; 0x100
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d63c:	4618      	mov	r0, r3
    d63e:	491d      	ldr	r1, [pc, #116]	; (d6b4 <_usb_d_dev_ep_enable+0x168>)
    d640:	4788      	blx	r1
    d642:	0700      	lsls	r0, r0, #28
    d644:	f3c3 030d 	ubfx	r3, r3, #0, #14
    d648:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
	bank->STATUS_BK.reg     = 0;
    d64c:	eb04 1445 	add.w	r4, r4, r5, lsl #5
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d650:	4318      	orrs	r0, r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d652:	2380      	movs	r3, #128	; 0x80
    d654:	f8c8 0014 	str.w	r0, [r8, #20]
    d658:	f886 3104 	strb.w	r3, [r6, #260]	; 0x104
	bank->STATUS_BK.reg     = 0;
    d65c:	f884 224a 	strb.w	r2, [r4, #586]	; 0x24a
	return USB_OK;
    d660:	4610      	mov	r0, r2
}
    d662:	e7db      	b.n	d61c <_usb_d_dev_ep_enable+0xd0>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE0_Msk) {
    d664:	f010 0207 	ands.w	r2, r0, #7
    d668:	d11c      	bne.n	d6a4 <_usb_d_dev_ep_enable+0x158>
		epcfg |= USB_DEVICE_EPCFG_EPTYPE0(ept->flags.bits.eptype);
    d66a:	f001 0107 	and.w	r1, r1, #7
    d66e:	4301      	orrs	r1, r0
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    d670:	f886 1100 	strb.w	r1, [r6, #256]	; 0x100
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d674:	8a39      	ldrh	r1, [r7, #16]
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d676:	4b0f      	ldr	r3, [pc, #60]	; (d6b4 <_usb_d_dev_ep_enable+0x168>)
    d678:	4608      	mov	r0, r1
    d67a:	4798      	blx	r3
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d67c:	4b0e      	ldr	r3, [pc, #56]	; (d6b8 <_usb_d_dev_ep_enable+0x16c>)
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d67e:	0700      	lsls	r0, r0, #28
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d680:	ea03 3381 	and.w	r3, r3, r1, lsl #14
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d684:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
    d688:	4303      	orrs	r3, r0
	bank->STATUS_BK.reg     = 0;
    d68a:	eb04 1445 	add.w	r4, r4, r5, lsl #5
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d68e:	f8c8 3004 	str.w	r3, [r8, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d692:	2340      	movs	r3, #64	; 0x40
    d694:	f886 3105 	strb.w	r3, [r6, #261]	; 0x105
	bank->STATUS_BK.reg     = 0;
    d698:	f884 223a 	strb.w	r2, [r4, #570]	; 0x23a
    d69c:	e7e0      	b.n	d660 <_usb_d_dev_ep_enable+0x114>
		return -USB_ERR_PARAM;
    d69e:	f06f 0011 	mvn.w	r0, #17
    d6a2:	e7bb      	b.n	d61c <_usb_d_dev_ep_enable+0xd0>
			return -USB_ERR_REDO;
    d6a4:	f06f 0013 	mvn.w	r0, #19
    d6a8:	e7b8      	b.n	d61c <_usb_d_dev_ep_enable+0xd0>
    d6aa:	bf00      	nop
    d6ac:	0000cb2d 	.word	0x0000cb2d
    d6b0:	200085a8 	.word	0x200085a8
    d6b4:	0000d275 	.word	0x0000d275
    d6b8:	0fffc000 	.word	0x0fffc000

0000d6bc <_usb_d_dev_ep_stall>:
{
    d6bc:	b538      	push	{r3, r4, r5, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    d6be:	f000 020f 	and.w	r2, r0, #15
	bool                  dir = USB_EP_GET_DIR(ep);
    d6c2:	09c4      	lsrs	r4, r0, #7
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d6c4:	4b2f      	ldr	r3, [pc, #188]	; (d784 <_usb_d_dev_ep_stall+0xc8>)
{
    d6c6:	460d      	mov	r5, r1
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d6c8:	4610      	mov	r0, r2
    d6ca:	4621      	mov	r1, r4
    d6cc:	4798      	blx	r3
	if (epn > CONF_USB_D_MAX_EP_N) {
    d6ce:	2a05      	cmp	r2, #5
    d6d0:	d855      	bhi.n	d77e <_usb_d_dev_ep_stall+0xc2>
	if (USB_EP_STALL_SET == ctrl) {
    d6d2:	7c83      	ldrb	r3, [r0, #18]
    d6d4:	2210      	movs	r2, #16
    d6d6:	2d01      	cmp	r5, #1
    d6d8:	f003 030f 	and.w	r3, r3, #15
    d6dc:	fa02 f204 	lsl.w	r2, r2, r4
    d6e0:	d113      	bne.n	d70a <_usb_d_dev_ep_stall+0x4e>
    d6e2:	0159      	lsls	r1, r3, #5
    d6e4:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
		hri_usbendpoint_set_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    d6e8:	b2d2      	uxtb	r2, r2
    d6ea:	f881 2105 	strb.w	r2, [r1, #261]	; 0x105
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    d6ee:	015b      	lsls	r3, r3, #5
	_usbd_ep_int_en(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    d6f0:	2120      	movs	r1, #32
    d6f2:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d6f6:	40a1      	lsls	r1, r4
	hri_usbendpoint_set_EPINTEN_reg(USB, epn, flags);
    d6f8:	b2c9      	uxtb	r1, r1
    d6fa:	f883 1109 	strb.w	r1, [r3, #265]	; 0x109
	ept->flags.bits.is_stalled = 1;
    d6fe:	7cc3      	ldrb	r3, [r0, #19]
    d700:	f043 0308 	orr.w	r3, r3, #8
    d704:	74c3      	strb	r3, [r0, #19]
		rc = _usb_d_dev_ep_stall_clr(ept, dir);
    d706:	2000      	movs	r0, #0
}
    d708:	bd38      	pop	{r3, r4, r5, pc}
	} else if (USB_EP_STALL_CLR == ctrl) {
    d70a:	bb6d      	cbnz	r5, d768 <_usb_d_dev_ep_stall+0xac>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    d70c:	015d      	lsls	r5, r3, #5
    d70e:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    d712:	f895 1106 	ldrb.w	r1, [r5, #262]	; 0x106
	if (!is_stalled) {
    d716:	4211      	tst	r1, r2
    d718:	d0f5      	beq.n	d706 <_usb_d_dev_ep_stall+0x4a>
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    d71a:	b2d2      	uxtb	r2, r2
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d71c:	f885 2104 	strb.w	r2, [r5, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d720:	015b      	lsls	r3, r3, #5
	_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    d722:	2220      	movs	r2, #32
    d724:	40a2      	lsls	r2, r4
    d726:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    d72a:	b2d1      	uxtb	r1, r2
    d72c:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    d730:	f895 3107 	ldrb.w	r3, [r5, #263]	; 0x107
	if (_usbd_ep_is_stall_sent(epn, dir)) {
    d734:	4213      	tst	r3, r2
    d736:	d006      	beq.n	d746 <_usb_d_dev_ep_stall+0x8a>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d738:	f885 1107 	strb.w	r1, [r5, #263]	; 0x107
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_DTGLOUT << bank_n));
    d73c:	2101      	movs	r1, #1
    d73e:	40a1      	lsls	r1, r4
    d740:	b2c9      	uxtb	r1, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d742:	f885 1104 	strb.w	r1, [r5, #260]	; 0x104
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    d746:	7cc2      	ldrb	r2, [r0, #19]
    d748:	f002 0307 	and.w	r3, r2, #7
    d74c:	2b01      	cmp	r3, #1
    d74e:	d108      	bne.n	d762 <_usb_d_dev_ep_stall+0xa6>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    d750:	f895 3106 	ldrb.w	r3, [r5, #262]	; 0x106
		if ((hri_usbendpoint_read_EPSTATUS_reg(USB, epn) & USB_DEVICE_EPSTATUS_STALLRQ_Msk) == 0) {
    d754:	f013 0330 	ands.w	r3, r3, #48	; 0x30
    d758:	d1d5      	bne.n	d706 <_usb_d_dev_ep_stall+0x4a>
			ept->flags.bits.is_stalled = 0;
    d75a:	f363 02c3 	bfi	r2, r3, #3, #1
		ept->flags.bits.is_stalled = 0;
    d75e:	74c2      	strb	r2, [r0, #19]
    d760:	e7d1      	b.n	d706 <_usb_d_dev_ep_stall+0x4a>
    d762:	f36f 02c3 	bfc	r2, #3, #1
    d766:	e7fa      	b.n	d75e <_usb_d_dev_ep_stall+0xa2>
    d768:	015b      	lsls	r3, r3, #5
    d76a:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d76e:	f503 7380 	add.w	r3, r3, #256	; 0x100
    d772:	799b      	ldrb	r3, [r3, #6]
	return (hri_usbendpoint_read_EPSTATUS_reg(hw, epn) & (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    d774:	4213      	tst	r3, r2
    d776:	bf14      	ite	ne
    d778:	2001      	movne	r0, #1
    d77a:	2000      	moveq	r0, #0
    d77c:	e7c4      	b.n	d708 <_usb_d_dev_ep_stall+0x4c>
		return -USB_ERR_PARAM;
    d77e:	f06f 0011 	mvn.w	r0, #17
    d782:	e7c1      	b.n	d708 <_usb_d_dev_ep_stall+0x4c>
    d784:	0000cb2d 	.word	0x0000cb2d

0000d788 <_usb_d_dev_ep_read_req>:

int32_t _usb_d_dev_ep_read_req(const uint8_t ep, uint8_t *req_buf)
{
    d788:	b570      	push	{r4, r5, r6, lr}
	uint8_t            epn   = USB_EP_GET_N(ep);
	UsbDeviceDescBank *bank  = prvt_inst.desc_table[epn].DeviceDescBank;
    d78a:	4b13      	ldr	r3, [pc, #76]	; (d7d8 <_usb_d_dev_ep_read_req+0x50>)
	uint8_t            epn   = USB_EP_GET_N(ep);
    d78c:	f000 060f 	and.w	r6, r0, #15
	UsbDeviceDescBank *bank  = prvt_inst.desc_table[epn].DeviceDescBank;
    d790:	0172      	lsls	r2, r6, #5
    d792:	eb03 1046 	add.w	r0, r3, r6, lsl #5
	uint32_t           addr  = bank[0].ADDR.reg;
    d796:	589d      	ldr	r5, [r3, r2]
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    d798:	6844      	ldr	r4, [r0, #4]

	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    d79a:	2e05      	cmp	r6, #5
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    d79c:	f3c4 040d 	ubfx	r4, r4, #0, #14
	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    d7a0:	d814      	bhi.n	d7cc <_usb_d_dev_ep_read_req+0x44>
    d7a2:	b199      	cbz	r1, d7cc <_usb_d_dev_ep_read_req+0x44>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    d7a4:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    d7a8:	f892 3100 	ldrb.w	r3, [r2, #256]	; 0x100
		return -USB_ERR_PARAM;
	}
	if (!_usbd_ep_is_ctrl(epn)) {
    d7ac:	2b11      	cmp	r3, #17
    d7ae:	d110      	bne.n	d7d2 <_usb_d_dev_ep_read_req+0x4a>
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    d7b0:	f892 3107 	ldrb.w	r3, [r2, #263]	; 0x107
		return -USB_ERR_FUNC;
	}
	if (!_usbd_ep_is_setup(epn)) {
    d7b4:	f013 0010 	ands.w	r0, r3, #16
    d7b8:	d007      	beq.n	d7ca <_usb_d_dev_ep_read_req+0x42>
		return ERR_NONE;
	}
	memcpy(req_buf, (void *)addr, 8);
    d7ba:	682b      	ldr	r3, [r5, #0]
    d7bc:	600b      	str	r3, [r1, #0]
    d7be:	686b      	ldr	r3, [r5, #4]
    d7c0:	604b      	str	r3, [r1, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d7c2:	2310      	movs	r3, #16
    d7c4:	f882 3107 	strb.w	r3, [r2, #263]	; 0x107
	_usbd_ep_ack_setup(epn);

	return bytes;
    d7c8:	4620      	mov	r0, r4
}
    d7ca:	bd70      	pop	{r4, r5, r6, pc}
		return -USB_ERR_PARAM;
    d7cc:	f06f 0011 	mvn.w	r0, #17
    d7d0:	e7fb      	b.n	d7ca <_usb_d_dev_ep_read_req+0x42>
		return -USB_ERR_FUNC;
    d7d2:	f06f 0012 	mvn.w	r0, #18
    d7d6:	e7f8      	b.n	d7ca <_usb_d_dev_ep_read_req+0x42>
    d7d8:	200087d8 	.word	0x200087d8

0000d7dc <_usb_d_dev_ep_trans>:

int32_t _usb_d_dev_ep_trans(const struct usb_d_transfer *trans)
{
    d7dc:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    d7e0:	f890 9008 	ldrb.w	r9, [r0, #8]
	bool                  dir = USB_EP_GET_DIR(trans->ep);
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d7e4:	4b39      	ldr	r3, [pc, #228]	; (d8cc <_usb_d_dev_ep_trans+0xf0>)
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    d7e6:	f009 050f 	and.w	r5, r9, #15
	bool                  dir = USB_EP_GET_DIR(trans->ep);
    d7ea:	fa4f f789 	sxtb.w	r7, r9
    d7ee:	ea4f 19d9 	mov.w	r9, r9, lsr #7
{
    d7f2:	4680      	mov	r8, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d7f4:	4649      	mov	r1, r9
    d7f6:	4628      	mov	r0, r5
    d7f8:	4798      	blx	r3

	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    d7fa:	8a02      	ldrh	r2, [r0, #16]
	bool     size_n_aligned = (trans->size & size_mask);
    d7fc:	f8d8 1004 	ldr.w	r1, [r8, #4]
	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    d800:	f240 33ff 	movw	r3, #1023	; 0x3ff
    d804:	429a      	cmp	r2, r3
    d806:	bf1a      	itte	ne
    d808:	f102 33ff 	addne.w	r3, r2, #4294967295	; 0xffffffff
    d80c:	b29b      	uxthne	r3, r3
    d80e:	4613      	moveq	r3, r2

	bool use_cache = false;

	volatile hal_atomic_t flags;

	if (epn > CONF_USB_D_MAX_EP_N) {
    d810:	2d05      	cmp	r5, #5
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d812:	4604      	mov	r4, r0
	bool     size_n_aligned = (trans->size & size_mask);
    d814:	ea03 0601 	and.w	r6, r3, r1
	if (epn > CONF_USB_D_MAX_EP_N) {
    d818:	d828      	bhi.n	d86c <_usb_d_dev_ep_trans+0x90>
	 * 1. Buffer not in RAM (cache all).
	 * 2. IN/OUT with unaligned buffer (cache all).
	 * 3. OUT with unaligned packet size (cache last packet).
	 * 4. OUT size < 8 (sub-case for 3).
	 */
	if (!_usb_is_addr4dma(trans->buf, trans->size) || (!_usb_is_aligned(trans->buf))
    d81a:	f8d8 5000 	ldr.w	r5, [r8]
    d81e:	f1b5 5f00 	cmp.w	r5, #536870912	; 0x20000000
    d822:	d30a      	bcc.n	d83a <_usb_d_dev_ep_trans+0x5e>
    d824:	4b2a      	ldr	r3, [pc, #168]	; (d8d0 <_usb_d_dev_ep_trans+0xf4>)
    d826:	1948      	adds	r0, r1, r5
    d828:	4298      	cmp	r0, r3
    d82a:	d206      	bcs.n	d83a <_usb_d_dev_ep_trans+0x5e>
    d82c:	f015 0503 	ands.w	r5, r5, #3
    d830:	d103      	bne.n	d83a <_usb_d_dev_ep_trans+0x5e>
	    || (!dir && (trans->size < ept->size))) {
    d832:	2f00      	cmp	r7, #0
    d834:	db05      	blt.n	d842 <_usb_d_dev_ep_trans+0x66>
    d836:	4291      	cmp	r1, r2
    d838:	d214      	bcs.n	d864 <_usb_d_dev_ep_trans+0x88>
		if (!ept->cache) {
    d83a:	68e3      	ldr	r3, [r4, #12]
    d83c:	2b00      	cmp	r3, #0
    d83e:	d03f      	beq.n	d8c0 <_usb_d_dev_ep_trans+0xe4>
			return -USB_ERR_FUNC;
		}
		/* Use cache all the time. */
		use_cache = true;
    d840:	2501      	movs	r5, #1
		}
		/* Set 'use_cache' on last packet. */
	}

	/* Check halt */
	if (ept->flags.bits.is_stalled) {
    d842:	7ce3      	ldrb	r3, [r4, #19]
    d844:	071b      	lsls	r3, r3, #28
    d846:	d43e      	bmi.n	d8c6 <_usb_d_dev_ep_trans+0xea>
		return USB_HALTED;
	}

	/* Try to start transactions. */

	atomic_enter_critical(&flags);
    d848:	4b22      	ldr	r3, [pc, #136]	; (d8d4 <_usb_d_dev_ep_trans+0xf8>)
    d84a:	a801      	add	r0, sp, #4
    d84c:	4798      	blx	r3
	if (_usb_d_dev_ep_is_busy(ept)) {
    d84e:	7ce3      	ldrb	r3, [r4, #19]
    d850:	4a21      	ldr	r2, [pc, #132]	; (d8d8 <_usb_d_dev_ep_trans+0xfc>)
    d852:	f013 0a40 	ands.w	sl, r3, #64	; 0x40
    d856:	d00e      	beq.n	d876 <_usb_d_dev_ep_trans+0x9a>
		atomic_leave_critical(&flags);
    d858:	a801      	add	r0, sp, #4
    d85a:	4790      	blx	r2
		return USB_BUSY;
    d85c:	2001      	movs	r0, #1
	} else {
		_usb_d_dev_out_next(ept, false);
	}

	return ERR_NONE;
}
    d85e:	b002      	add	sp, #8
    d860:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (!dir && size_n_aligned) {
    d864:	b12e      	cbz	r6, d872 <_usb_d_dev_ep_trans+0x96>
		if (!ept->cache) {
    d866:	68e3      	ldr	r3, [r4, #12]
    d868:	2b00      	cmp	r3, #0
    d86a:	d1ea      	bne.n	d842 <_usb_d_dev_ep_trans+0x66>
		return -USB_ERR_PARAM;
    d86c:	f06f 0011 	mvn.w	r0, #17
    d870:	e7f5      	b.n	d85e <_usb_d_dev_ep_trans+0x82>
	bool use_cache = false;
    d872:	4635      	mov	r5, r6
    d874:	e7e5      	b.n	d842 <_usb_d_dev_ep_trans+0x66>
	ept->flags.bits.is_busy = 1;
    d876:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d87a:	74e3      	strb	r3, [r4, #19]
	atomic_leave_critical(&flags);
    d87c:	a801      	add	r0, sp, #4
    d87e:	4790      	blx	r2
	ept->trans_buf   = trans->buf;
    d880:	f8d8 3000 	ldr.w	r3, [r8]
    d884:	6023      	str	r3, [r4, #0]
	ept->trans_size  = trans->size;
    d886:	f8d8 3004 	ldr.w	r3, [r8, #4]
	ept->trans_count = 0;
    d88a:	e9c4 3a01 	strd	r3, sl, [r4, #4]
	ept->flags.bits.dir       = dir;
    d88e:	7ce3      	ldrb	r3, [r4, #19]
    d890:	f369 13c7 	bfi	r3, r9, #7, #1
	ept->flags.bits.use_cache = use_cache;
    d894:	f365 1345 	bfi	r3, r5, #5, #1
    d898:	74e3      	strb	r3, [r4, #19]
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    d89a:	f898 3009 	ldrb.w	r3, [r8, #9]
    d89e:	b113      	cbz	r3, d8a6 <_usb_d_dev_ep_trans+0xca>
    d8a0:	fab6 f386 	clz	r3, r6
    d8a4:	095b      	lsrs	r3, r3, #5
    d8a6:	7ce2      	ldrb	r2, [r4, #19]
	if (dir) {
    d8a8:	2f00      	cmp	r7, #0
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    d8aa:	f363 1204 	bfi	r2, r3, #4, #1
		_usb_d_dev_in_next(ept, false);
    d8ae:	4620      	mov	r0, r4
    d8b0:	bfb4      	ite	lt
    d8b2:	4b0a      	ldrlt	r3, [pc, #40]	; (d8dc <_usb_d_dev_ep_trans+0x100>)
		_usb_d_dev_out_next(ept, false);
    d8b4:	4b0a      	ldrge	r3, [pc, #40]	; (d8e0 <_usb_d_dev_ep_trans+0x104>)
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    d8b6:	74e2      	strb	r2, [r4, #19]
		_usb_d_dev_in_next(ept, false);
    d8b8:	2100      	movs	r1, #0
		_usb_d_dev_out_next(ept, false);
    d8ba:	4798      	blx	r3
	return ERR_NONE;
    d8bc:	2000      	movs	r0, #0
    d8be:	e7ce      	b.n	d85e <_usb_d_dev_ep_trans+0x82>
			return -USB_ERR_FUNC;
    d8c0:	f06f 0012 	mvn.w	r0, #18
    d8c4:	e7cb      	b.n	d85e <_usb_d_dev_ep_trans+0x82>
		return USB_HALTED;
    d8c6:	2002      	movs	r0, #2
    d8c8:	e7c9      	b.n	d85e <_usb_d_dev_ep_trans+0x82>
    d8ca:	bf00      	nop
    d8cc:	0000cb2d 	.word	0x0000cb2d
    d8d0:	20042000 	.word	0x20042000
    d8d4:	00011b09 	.word	0x00011b09
    d8d8:	00011b17 	.word	0x00011b17
    d8dc:	0000cdad 	.word	0x0000cdad
    d8e0:	0000cf09 	.word	0x0000cf09

0000d8e4 <_usb_d_dev_ep_get_status>:
	}
	_usb_d_dev_trans_stop(ept, dir, USB_TRANS_ABORT);
}

int32_t _usb_d_dev_ep_get_status(const uint8_t ep, struct usb_d_trans_status *stat)
{
    d8e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    d8e6:	f000 040f 	and.w	r4, r0, #15
{
    d8ea:	460a      	mov	r2, r1
	bool                  dir = USB_EP_GET_DIR(ep);
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d8ec:	4b19      	ldr	r3, [pc, #100]	; (d954 <_usb_d_dev_ep_get_status+0x70>)
    d8ee:	09c1      	lsrs	r1, r0, #7
{
    d8f0:	4607      	mov	r7, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d8f2:	4620      	mov	r0, r4
    d8f4:	4798      	blx	r3
	bool                  busy, stall;

	if (epn > CONF_USB_D_MAX_EP_N) {
    d8f6:	2c05      	cmp	r4, #5
    d8f8:	d82a      	bhi.n	d950 <_usb_d_dev_ep_get_status+0x6c>
		return USB_ERR_PARAM;
	}
	busy  = ept->flags.bits.is_busy;
    d8fa:	7cc5      	ldrb	r5, [r0, #19]
    d8fc:	f3c5 1180 	ubfx	r1, r5, #6, #1
	stall = ept->flags.bits.is_stalled;
    d900:	f3c5 06c0 	ubfx	r6, r5, #3, #1
	if (stat) {
    d904:	b1fa      	cbz	r2, d946 <_usb_d_dev_ep_get_status+0x62>
		stat->stall = stall;
    d906:	7a53      	ldrb	r3, [r2, #9]
		stat->busy  = busy;
		stat->setup = USB->DEVICE.DeviceEndpoint[epn].EPINTFLAG.bit.RXSTP;
    d908:	0164      	lsls	r4, r4, #5
		stat->stall = stall;
    d90a:	f366 1304 	bfi	r3, r6, #4, #1
		stat->busy  = busy;
    d90e:	f361 0382 	bfi	r3, r1, #2, #1
		stat->setup = USB->DEVICE.DeviceEndpoint[epn].EPINTFLAG.bit.RXSTP;
    d912:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
		stat->busy  = busy;
    d916:	7253      	strb	r3, [r2, #9]
		stat->setup = USB->DEVICE.DeviceEndpoint[epn].EPINTFLAG.bit.RXSTP;
    d918:	f894 3107 	ldrb.w	r3, [r4, #263]	; 0x107
    d91c:	f3c3 1400 	ubfx	r4, r3, #4, #1
		stat->dir   = ept->flags.bits.dir;
		stat->size  = ept->trans_size;
    d920:	6843      	ldr	r3, [r0, #4]
    d922:	6013      	str	r3, [r2, #0]
		stat->count = ept->trans_count;
    d924:	6883      	ldr	r3, [r0, #8]
		stat->ep    = ep;
    d926:	7217      	strb	r7, [r2, #8]
		stat->count = ept->trans_count;
    d928:	6053      	str	r3, [r2, #4]
		stat->xtype = ept->flags.bits.eptype - 1;
    d92a:	7cc3      	ldrb	r3, [r0, #19]
    d92c:	7a50      	ldrb	r0, [r2, #9]
    d92e:	3303      	adds	r3, #3
    d930:	f003 0303 	and.w	r3, r3, #3
		stat->dir   = ept->flags.bits.dir;
    d934:	09ed      	lsrs	r5, r5, #7
		stat->xtype = ept->flags.bits.eptype - 1;
    d936:	ea43 03c4 	orr.w	r3, r3, r4, lsl #3
    d93a:	ea43 1345 	orr.w	r3, r3, r5, lsl #5
    d93e:	f020 002b 	bic.w	r0, r0, #43	; 0x2b
    d942:	4303      	orrs	r3, r0
    d944:	7253      	strb	r3, [r2, #9]
		return USB_ERR_PARAM;
    d946:	2e00      	cmp	r6, #0
    d948:	bf0c      	ite	eq
    d94a:	4608      	moveq	r0, r1
    d94c:	2002      	movne	r0, #2
	}
	if (busy) {
		return USB_BUSY;
	}
	return USB_OK;
}
    d94e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return USB_ERR_PARAM;
    d950:	2012      	movs	r0, #18
    d952:	e7fc      	b.n	d94e <_usb_d_dev_ep_get_status+0x6a>
    d954:	0000cb2d 	.word	0x0000cb2d

0000d958 <_usb_d_dev_register_callback>:

void _usb_d_dev_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    d958:	4b06      	ldr	r3, [pc, #24]	; (d974 <_usb_d_dev_register_callback+0x1c>)
    d95a:	2900      	cmp	r1, #0
    d95c:	bf08      	it	eq
    d95e:	4619      	moveq	r1, r3
	if (type == USB_D_CB_EVENT) {
    d960:	2801      	cmp	r0, #1
    d962:	d102      	bne.n	d96a <_usb_d_dev_register_callback+0x12>
		dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)f;
    d964:	4b04      	ldr	r3, [pc, #16]	; (d978 <_usb_d_dev_register_callback+0x20>)
    d966:	6059      	str	r1, [r3, #4]
    d968:	4770      	bx	lr
	} else if (type == USB_D_CB_SOF) {
    d96a:	b908      	cbnz	r0, d970 <_usb_d_dev_register_callback+0x18>
		dev_inst.callbacks.sof = (_usb_d_dev_sof_cb_t)f;
    d96c:	4b02      	ldr	r3, [pc, #8]	; (d978 <_usb_d_dev_register_callback+0x20>)
    d96e:	6019      	str	r1, [r3, #0]
	}
}
    d970:	4770      	bx	lr
    d972:	bf00      	nop
    d974:	0000cb05 	.word	0x0000cb05
    d978:	200085a8 	.word	0x200085a8

0000d97c <_usb_d_dev_register_ep_callback>:

void _usb_d_dev_register_ep_callback(const enum usb_d_dev_ep_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    d97c:	4b08      	ldr	r3, [pc, #32]	; (d9a0 <_usb_d_dev_register_ep_callback+0x24>)
    d97e:	2900      	cmp	r1, #0
    d980:	bf08      	it	eq
    d982:	4619      	moveq	r1, r3
	if (type == USB_D_DEV_EP_CB_SETUP) {
    d984:	b910      	cbnz	r0, d98c <_usb_d_dev_register_ep_callback+0x10>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
    d986:	4b07      	ldr	r3, [pc, #28]	; (d9a4 <_usb_d_dev_register_ep_callback+0x28>)
    d988:	6099      	str	r1, [r3, #8]
    d98a:	4770      	bx	lr
	} else if (type == USB_D_DEV_EP_CB_MORE) {
    d98c:	2801      	cmp	r0, #1
    d98e:	d102      	bne.n	d996 <_usb_d_dev_register_ep_callback+0x1a>
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
    d990:	4b04      	ldr	r3, [pc, #16]	; (d9a4 <_usb_d_dev_register_ep_callback+0x28>)
    d992:	60d9      	str	r1, [r3, #12]
    d994:	4770      	bx	lr
	} else if (type == USB_D_DEV_EP_CB_DONE) {
    d996:	2802      	cmp	r0, #2
		dev_inst.ep_callbacks.done = (_usb_d_dev_ep_cb_done_t)f;
    d998:	bf04      	itt	eq
    d99a:	4b02      	ldreq	r3, [pc, #8]	; (d9a4 <_usb_d_dev_register_ep_callback+0x28>)
    d99c:	6119      	streq	r1, [r3, #16]
	}
}
    d99e:	4770      	bx	lr
    d9a0:	0000cb05 	.word	0x0000cb05
    d9a4:	200085a8 	.word	0x200085a8

0000d9a8 <USB_0_Handler>:
 * \brief USB interrupt handler
 */
void USB_0_Handler(void)
{

	_usb_d_dev_handler();
    d9a8:	4b00      	ldr	r3, [pc, #0]	; (d9ac <USB_0_Handler+0x4>)
    d9aa:	4718      	bx	r3
    d9ac:	0000d0a5 	.word	0x0000d0a5

0000d9b0 <USB_1_Handler>:
    d9b0:	4b00      	ldr	r3, [pc, #0]	; (d9b4 <USB_1_Handler+0x4>)
    d9b2:	4718      	bx	r3
    d9b4:	0000d0a5 	.word	0x0000d0a5

0000d9b8 <USB_2_Handler>:
    d9b8:	4b00      	ldr	r3, [pc, #0]	; (d9bc <USB_2_Handler+0x4>)
    d9ba:	4718      	bx	r3
    d9bc:	0000d0a5 	.word	0x0000d0a5

0000d9c0 <USB_3_Handler>:
    d9c0:	4b00      	ldr	r3, [pc, #0]	; (d9c4 <USB_3_Handler+0x4>)
    d9c2:	4718      	bx	r3
    d9c4:	0000d0a5 	.word	0x0000d0a5

0000d9c8 <_read>:
#include <stdio.h>

int __attribute__((weak)) _read(int file, char *ptr, int len); /* Remove GCC compiler warning */

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
    d9c8:	b508      	push	{r3, lr}
    d9ca:	4603      	mov	r3, r0
    d9cc:	4608      	mov	r0, r1
    d9ce:	4611      	mov	r1, r2
	int n = 0;

	if (file != 0) {
    d9d0:	b923      	cbnz	r3, d9dc <_read+0x14>
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
    d9d2:	4b04      	ldr	r3, [pc, #16]	; (d9e4 <_read+0x1c>)
    d9d4:	4798      	blx	r3
	if (n < 0) {
    d9d6:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
    d9da:	bd08      	pop	{r3, pc}
		return -1;
    d9dc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    d9e0:	e7fb      	b.n	d9da <_read+0x12>
    d9e2:	bf00      	nop
    d9e4:	0000b8b9 	.word	0x0000b8b9

0000d9e8 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
    d9e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if (xTimerQueue == NULL) {
    d9ec:	4c0c      	ldr	r4, [pc, #48]	; (da20 <prvCheckForValidListAndQueue+0x38>)
	taskENTER_CRITICAL();
    d9ee:	4b0d      	ldr	r3, [pc, #52]	; (da24 <prvCheckForValidListAndQueue+0x3c>)
    d9f0:	4798      	blx	r3
		if (xTimerQueue == NULL) {
    d9f2:	6825      	ldr	r5, [r4, #0]
    d9f4:	b985      	cbnz	r5, da18 <prvCheckForValidListAndQueue+0x30>
			vListInitialise(&xActiveTimerList1);
    d9f6:	1d27      	adds	r7, r4, #4
    d9f8:	f8df 8034 	ldr.w	r8, [pc, #52]	; da30 <prvCheckForValidListAndQueue+0x48>
    d9fc:	4638      	mov	r0, r7
			vListInitialise(&xActiveTimerList2);
    d9fe:	f104 0618 	add.w	r6, r4, #24
			vListInitialise(&xActiveTimerList1);
    da02:	47c0      	blx	r8
			vListInitialise(&xActiveTimerList2);
    da04:	4630      	mov	r0, r6
    da06:	47c0      	blx	r8
				                                 &(ucStaticTimerQueueStorage[0]),
				                                 &xStaticTimerQueue);
			}
#else
			{
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    da08:	4b07      	ldr	r3, [pc, #28]	; (da28 <prvCheckForValidListAndQueue+0x40>)
    da0a:	462a      	mov	r2, r5
    da0c:	210c      	movs	r1, #12
    da0e:	2002      	movs	r0, #2
			pxOverflowTimerList = &xActiveTimerList2;
    da10:	e9c4 760b 	strd	r7, r6, [r4, #44]	; 0x2c
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    da14:	4798      	blx	r3
    da16:	6020      	str	r0, [r4, #0]
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
    da18:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	taskEXIT_CRITICAL();
    da1c:	4b03      	ldr	r3, [pc, #12]	; (da2c <prvCheckForValidListAndQueue+0x44>)
    da1e:	4718      	bx	r3
    da20:	20008968 	.word	0x20008968
    da24:	0000b255 	.word	0x0000b255
    da28:	0000c37d 	.word	0x0000c37d
    da2c:	0000b299 	.word	0x0000b299
    da30:	0000b105 	.word	0x0000b105

0000da34 <prvInsertTimerInActiveList>:
	if (xNextExpiryTime <= xTimeNow) {
    da34:	4291      	cmp	r1, r2
{
    da36:	b508      	push	{r3, lr}
	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
    da38:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    da3a:	6100      	str	r0, [r0, #16]
	if (xNextExpiryTime <= xTimeNow) {
    da3c:	d80a      	bhi.n	da54 <prvInsertTimerInActiveList+0x20>
		if (((TickType_t)(xTimeNow - xCommandTime))
    da3e:	1ad2      	subs	r2, r2, r3
    da40:	6983      	ldr	r3, [r0, #24]
    da42:	429a      	cmp	r2, r3
    da44:	d20e      	bcs.n	da64 <prvInsertTimerInActiveList+0x30>
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
    da46:	4b08      	ldr	r3, [pc, #32]	; (da68 <prvInsertTimerInActiveList+0x34>)
    da48:	1d01      	adds	r1, r0, #4
    da4a:	6b18      	ldr	r0, [r3, #48]	; 0x30
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    da4c:	4b07      	ldr	r3, [pc, #28]	; (da6c <prvInsertTimerInActiveList+0x38>)
    da4e:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    da50:	2000      	movs	r0, #0
}
    da52:	bd08      	pop	{r3, pc}
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    da54:	429a      	cmp	r2, r3
    da56:	d201      	bcs.n	da5c <prvInsertTimerInActiveList+0x28>
    da58:	4299      	cmp	r1, r3
    da5a:	d203      	bcs.n	da64 <prvInsertTimerInActiveList+0x30>
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    da5c:	4b02      	ldr	r3, [pc, #8]	; (da68 <prvInsertTimerInActiveList+0x34>)
    da5e:	1d01      	adds	r1, r0, #4
    da60:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    da62:	e7f3      	b.n	da4c <prvInsertTimerInActiveList+0x18>
			xProcessTimerNow = pdTRUE;
    da64:	2001      	movs	r0, #1
	return xProcessTimerNow;
    da66:	e7f4      	b.n	da52 <prvInsertTimerInActiveList+0x1e>
    da68:	20008968 	.word	0x20008968
    da6c:	0000b139 	.word	0x0000b139

0000da70 <xTimerCreateTimerTask>:
	prvCheckForValidListAndQueue();
    da70:	4b0e      	ldr	r3, [pc, #56]	; (daac <xTimerCreateTimerTask+0x3c>)
{
    da72:	b513      	push	{r0, r1, r4, lr}
	prvCheckForValidListAndQueue();
    da74:	4798      	blx	r3
	if (xTimerQueue != NULL) {
    da76:	4b0e      	ldr	r3, [pc, #56]	; (dab0 <xTimerCreateTimerTask+0x40>)
    da78:	681a      	ldr	r2, [r3, #0]
    da7a:	b942      	cbnz	r2, da8e <xTimerCreateTimerTask+0x1e>
    da7c:	f04f 0380 	mov.w	r3, #128	; 0x80
    da80:	f383 8811 	msr	BASEPRI, r3
    da84:	f3bf 8f6f 	isb	sy
    da88:	f3bf 8f4f 	dsb	sy
	configASSERT(xReturn);
    da8c:	e7fe      	b.n	da8c <xTimerCreateTimerTask+0x1c>
			xReturn = xTaskCreate(prvTimerTask,
    da8e:	3334      	adds	r3, #52	; 0x34
    da90:	9301      	str	r3, [sp, #4]
    da92:	2302      	movs	r3, #2
    da94:	9300      	str	r3, [sp, #0]
    da96:	4907      	ldr	r1, [pc, #28]	; (dab4 <xTimerCreateTimerTask+0x44>)
    da98:	4807      	ldr	r0, [pc, #28]	; (dab8 <xTimerCreateTimerTask+0x48>)
    da9a:	4c08      	ldr	r4, [pc, #32]	; (dabc <xTimerCreateTimerTask+0x4c>)
    da9c:	2300      	movs	r3, #0
    da9e:	2240      	movs	r2, #64	; 0x40
    daa0:	47a0      	blx	r4
	configASSERT(xReturn);
    daa2:	2800      	cmp	r0, #0
    daa4:	d0ea      	beq.n	da7c <xTimerCreateTimerTask+0xc>
}
    daa6:	b002      	add	sp, #8
    daa8:	bd10      	pop	{r4, pc}
    daaa:	bf00      	nop
    daac:	0000d9e9 	.word	0x0000d9e9
    dab0:	20008968 	.word	0x20008968
    dab4:	000162c8 	.word	0x000162c8
    dab8:	0000dba1 	.word	0x0000dba1
    dabc:	00012539 	.word	0x00012539

0000dac0 <xTimerGenericCommand>:
{
    dac0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    dac2:	4616      	mov	r6, r2
	configASSERT(xTimer);
    dac4:	4604      	mov	r4, r0
{
    dac6:	461a      	mov	r2, r3
	configASSERT(xTimer);
    dac8:	b940      	cbnz	r0, dadc <xTimerGenericCommand+0x1c>
    daca:	f04f 0380 	mov.w	r3, #128	; 0x80
    dace:	f383 8811 	msr	BASEPRI, r3
    dad2:	f3bf 8f6f 	isb	sy
    dad6:	f3bf 8f4f 	dsb	sy
    dada:	e7fe      	b.n	dada <xTimerGenericCommand+0x1a>
	if (xTimerQueue != NULL) {
    dadc:	4d0d      	ldr	r5, [pc, #52]	; (db14 <xTimerGenericCommand+0x54>)
    dade:	6828      	ldr	r0, [r5, #0]
    dae0:	b188      	cbz	r0, db06 <xTimerGenericCommand+0x46>
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    dae2:	2905      	cmp	r1, #5
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    dae4:	e9cd 1601 	strd	r1, r6, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
    dae8:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    daea:	dc0e      	bgt.n	db0a <xTimerGenericCommand+0x4a>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
    daec:	4b0a      	ldr	r3, [pc, #40]	; (db18 <xTimerGenericCommand+0x58>)
    daee:	4c0b      	ldr	r4, [pc, #44]	; (db1c <xTimerGenericCommand+0x5c>)
    daf0:	4798      	blx	r3
    daf2:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
    daf4:	f04f 0300 	mov.w	r3, #0
    daf8:	bf08      	it	eq
    dafa:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
    dafc:	6828      	ldr	r0, [r5, #0]
    dafe:	bf18      	it	ne
    db00:	461a      	movne	r2, r3
    db02:	a901      	add	r1, sp, #4
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    db04:	47a0      	blx	r4
}
    db06:	b004      	add	sp, #16
    db08:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    db0a:	4c05      	ldr	r4, [pc, #20]	; (db20 <xTimerGenericCommand+0x60>)
    db0c:	2300      	movs	r3, #0
    db0e:	a901      	add	r1, sp, #4
    db10:	e7f8      	b.n	db04 <xTimerGenericCommand+0x44>
    db12:	bf00      	nop
    db14:	20008968 	.word	0x20008968
    db18:	00012c2d 	.word	0x00012c2d
    db1c:	0000c3d1 	.word	0x0000c3d1
    db20:	0000c57d 	.word	0x0000c57d

0000db24 <prvSwitchTimerLists>:
{
    db24:	b5f0      	push	{r4, r5, r6, r7, lr}
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    db26:	4d1a      	ldr	r5, [pc, #104]	; (db90 <prvSwitchTimerLists+0x6c>)
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    db28:	4f1a      	ldr	r7, [pc, #104]	; (db94 <prvSwitchTimerLists+0x70>)
{
    db2a:	b085      	sub	sp, #20
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    db2c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    db2e:	681a      	ldr	r2, [r3, #0]
    db30:	b922      	cbnz	r2, db3c <prvSwitchTimerLists+0x18>
	pxCurrentTimerList  = pxOverflowTimerList;
    db32:	6b2a      	ldr	r2, [r5, #48]	; 0x30
	pxOverflowTimerList = pxTemp;
    db34:	e9c5 230b 	strd	r2, r3, [r5, #44]	; 0x2c
}
    db38:	b005      	add	sp, #20
    db3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    db3c:	68db      	ldr	r3, [r3, #12]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    db3e:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    db40:	681e      	ldr	r6, [r3, #0]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    db42:	1d21      	adds	r1, r4, #4
    db44:	4608      	mov	r0, r1
    db46:	9103      	str	r1, [sp, #12]
    db48:	47b8      	blx	r7
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    db4a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    db4c:	4620      	mov	r0, r4
    db4e:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    db50:	69e3      	ldr	r3, [r4, #28]
    db52:	9903      	ldr	r1, [sp, #12]
    db54:	2b01      	cmp	r3, #1
    db56:	d1e9      	bne.n	db2c <prvSwitchTimerLists+0x8>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
    db58:	69a3      	ldr	r3, [r4, #24]
    db5a:	4433      	add	r3, r6
			if (xReloadTime > xNextExpireTime) {
    db5c:	429e      	cmp	r6, r3
    db5e:	d205      	bcs.n	db6c <prvSwitchTimerLists+0x48>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
    db60:	6063      	str	r3, [r4, #4]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    db62:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    db64:	4b0c      	ldr	r3, [pc, #48]	; (db98 <prvSwitchTimerLists+0x74>)
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    db66:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    db68:	4798      	blx	r3
    db6a:	e7df      	b.n	db2c <prvSwitchTimerLists+0x8>
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    db6c:	2300      	movs	r3, #0
    db6e:	4620      	mov	r0, r4
    db70:	9300      	str	r3, [sp, #0]
    db72:	4c0a      	ldr	r4, [pc, #40]	; (db9c <prvSwitchTimerLists+0x78>)
    db74:	4632      	mov	r2, r6
    db76:	4619      	mov	r1, r3
    db78:	47a0      	blx	r4
				configASSERT(xResult);
    db7a:	2800      	cmp	r0, #0
    db7c:	d1d6      	bne.n	db2c <prvSwitchTimerLists+0x8>
    db7e:	f04f 0380 	mov.w	r3, #128	; 0x80
    db82:	f383 8811 	msr	BASEPRI, r3
    db86:	f3bf 8f6f 	isb	sy
    db8a:	f3bf 8f4f 	dsb	sy
    db8e:	e7fe      	b.n	db8e <prvSwitchTimerLists+0x6a>
    db90:	20008968 	.word	0x20008968
    db94:	0000b167 	.word	0x0000b167
    db98:	0000b139 	.word	0x0000b139
    db9c:	0000dac1 	.word	0x0000dac1

0000dba0 <prvTimerTask>:
{
    dba0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    dba4:	f8df 81c8 	ldr.w	r8, [pc, #456]	; dd70 <prvTimerTask+0x1d0>
{
    dba8:	b087      	sub	sp, #28
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    dbaa:	4c68      	ldr	r4, [pc, #416]	; (dd4c <prvTimerTask+0x1ac>)
    dbac:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    dbae:	f8d3 b000 	ldr.w	fp, [r3]
	if (*pxListWasEmpty == pdFALSE) {
    dbb2:	4627      	mov	r7, r4
    dbb4:	f1bb 0f00 	cmp.w	fp, #0
    dbb8:	d044      	beq.n	dc44 <prvTimerTask+0xa4>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    dbba:	68db      	ldr	r3, [r3, #12]
    dbbc:	f8d3 9000 	ldr.w	r9, [r3]
	vTaskSuspendAll();
    dbc0:	4b63      	ldr	r3, [pc, #396]	; (dd50 <prvTimerTask+0x1b0>)
	xTimeNow = xTaskGetTickCount();
    dbc2:	4e64      	ldr	r6, [pc, #400]	; (dd54 <prvTimerTask+0x1b4>)
    dbc4:	f8df a1ac 	ldr.w	sl, [pc, #428]	; dd74 <prvTimerTask+0x1d4>
	vTaskSuspendAll();
    dbc8:	4798      	blx	r3
	xTimeNow = xTaskGetTickCount();
    dbca:	47b0      	blx	r6
	if (xTimeNow < xLastTime) {
    dbcc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    dbce:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
    dbd0:	4605      	mov	r5, r0
	if (xTimeNow < xLastTime) {
    dbd2:	d239      	bcs.n	dc48 <prvTimerTask+0xa8>
		prvSwitchTimerLists();
    dbd4:	4b60      	ldr	r3, [pc, #384]	; (dd58 <prvTimerTask+0x1b8>)
    dbd6:	4798      	blx	r3
	xLastTime = xTimeNow;
    dbd8:	63a5      	str	r5, [r4, #56]	; 0x38
			(void)xTaskResumeAll();
    dbda:	47d0      	blx	sl
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    dbdc:	f8df 9198 	ldr.w	r9, [pc, #408]	; dd78 <prvTimerTask+0x1d8>
		prvSwitchTimerLists();
    dbe0:	f8df a174 	ldr.w	sl, [pc, #372]	; dd58 <prvTimerTask+0x1b8>
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    dbe4:	6838      	ldr	r0, [r7, #0]
    dbe6:	2200      	movs	r2, #0
    dbe8:	a903      	add	r1, sp, #12
    dbea:	47c8      	blx	r9
    dbec:	2800      	cmp	r0, #0
    dbee:	d0dc      	beq.n	dbaa <prvTimerTask+0xa>
		if (xMessage.xMessageID >= (BaseType_t)0) {
    dbf0:	9b03      	ldr	r3, [sp, #12]
    dbf2:	2b00      	cmp	r3, #0
    dbf4:	dbf6      	blt.n	dbe4 <prvTimerTask+0x44>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    dbf6:	9c05      	ldr	r4, [sp, #20]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem))
    dbf8:	6963      	ldr	r3, [r4, #20]
    dbfa:	b10b      	cbz	r3, dc00 <prvTimerTask+0x60>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    dbfc:	1d20      	adds	r0, r4, #4
    dbfe:	47c0      	blx	r8
	xTimeNow = xTaskGetTickCount();
    dc00:	47b0      	blx	r6
	if (xTimeNow < xLastTime) {
    dc02:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dc04:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
    dc06:	4605      	mov	r5, r0
	if (xTimeNow < xLastTime) {
    dc08:	d200      	bcs.n	dc0c <prvTimerTask+0x6c>
		prvSwitchTimerLists();
    dc0a:	47d0      	blx	sl
	xLastTime = xTimeNow;
    dc0c:	9b03      	ldr	r3, [sp, #12]
    dc0e:	63bd      	str	r5, [r7, #56]	; 0x38
			switch (xMessage.xMessageID) {
    dc10:	2b09      	cmp	r3, #9
    dc12:	d8e7      	bhi.n	dbe4 <prvTimerTask+0x44>
    dc14:	a201      	add	r2, pc, #4	; (adr r2, dc1c <prvTimerTask+0x7c>)
    dc16:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    dc1a:	bf00      	nop
    dc1c:	0000dcd1 	.word	0x0000dcd1
    dc20:	0000dcd1 	.word	0x0000dcd1
    dc24:	0000dcd1 	.word	0x0000dcd1
    dc28:	0000dbe5 	.word	0x0000dbe5
    dc2c:	0000dd1d 	.word	0x0000dd1d
    dc30:	0000dd43 	.word	0x0000dd43
    dc34:	0000dcd1 	.word	0x0000dcd1
    dc38:	0000dcd1 	.word	0x0000dcd1
    dc3c:	0000dbe5 	.word	0x0000dbe5
    dc40:	0000dd1d 	.word	0x0000dd1d
		xNextExpireTime = (TickType_t)0U;
    dc44:	46d9      	mov	r9, fp
    dc46:	e7bb      	b.n	dbc0 <prvTimerTask+0x20>
	xLastTime = xTimeNow;
    dc48:	63a0      	str	r0, [r4, #56]	; 0x38
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
    dc4a:	f1bb 0f00 	cmp.w	fp, #0
    dc4e:	d027      	beq.n	dca0 <prvTimerTask+0x100>
    dc50:	4581      	cmp	r9, r0
    dc52:	d83b      	bhi.n	dccc <prvTimerTask+0x12c>
				(void)xTaskResumeAll();
    dc54:	47d0      	blx	sl
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    dc56:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    dc58:	68db      	ldr	r3, [r3, #12]
    dc5a:	68dc      	ldr	r4, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    dc5c:	1d20      	adds	r0, r4, #4
    dc5e:	47c0      	blx	r8
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    dc60:	69e3      	ldr	r3, [r4, #28]
    dc62:	2b01      	cmp	r3, #1
    dc64:	d118      	bne.n	dc98 <prvTimerTask+0xf8>
		if (prvInsertTimerInActiveList(
    dc66:	69a1      	ldr	r1, [r4, #24]
    dc68:	462a      	mov	r2, r5
    dc6a:	464b      	mov	r3, r9
    dc6c:	4d3b      	ldr	r5, [pc, #236]	; (dd5c <prvTimerTask+0x1bc>)
    dc6e:	4449      	add	r1, r9
    dc70:	4620      	mov	r0, r4
    dc72:	47a8      	blx	r5
    dc74:	b180      	cbz	r0, dc98 <prvTimerTask+0xf8>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    dc76:	2300      	movs	r3, #0
    dc78:	4d39      	ldr	r5, [pc, #228]	; (dd60 <prvTimerTask+0x1c0>)
    dc7a:	9300      	str	r3, [sp, #0]
    dc7c:	464a      	mov	r2, r9
    dc7e:	4619      	mov	r1, r3
    dc80:	4620      	mov	r0, r4
    dc82:	47a8      	blx	r5
			configASSERT(xResult);
    dc84:	b940      	cbnz	r0, dc98 <prvTimerTask+0xf8>
    dc86:	f04f 0380 	mov.w	r3, #128	; 0x80
    dc8a:	f383 8811 	msr	BASEPRI, r3
    dc8e:	f3bf 8f6f 	isb	sy
    dc92:	f3bf 8f4f 	dsb	sy
    dc96:	e7fe      	b.n	dc96 <prvTimerTask+0xf6>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    dc98:	6a63      	ldr	r3, [r4, #36]	; 0x24
    dc9a:	4620      	mov	r0, r4
    dc9c:	4798      	blx	r3
}
    dc9e:	e79d      	b.n	dbdc <prvTimerTask+0x3c>
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
    dca0:	6b23      	ldr	r3, [r4, #48]	; 0x30
    dca2:	681a      	ldr	r2, [r3, #0]
    dca4:	fab2 f282 	clz	r2, r2
    dca8:	0952      	lsrs	r2, r2, #5
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
    dcaa:	6820      	ldr	r0, [r4, #0]
    dcac:	4b2d      	ldr	r3, [pc, #180]	; (dd64 <prvTimerTask+0x1c4>)
    dcae:	eba9 0105 	sub.w	r1, r9, r5
    dcb2:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    dcb4:	47d0      	blx	sl
    dcb6:	2800      	cmp	r0, #0
    dcb8:	d190      	bne.n	dbdc <prvTimerTask+0x3c>
					portYIELD_WITHIN_API();
    dcba:	4b2b      	ldr	r3, [pc, #172]	; (dd68 <prvTimerTask+0x1c8>)
    dcbc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    dcc0:	601a      	str	r2, [r3, #0]
    dcc2:	f3bf 8f4f 	dsb	sy
    dcc6:	f3bf 8f6f 	isb	sy
    dcca:	e787      	b.n	dbdc <prvTimerTask+0x3c>
    dccc:	2200      	movs	r2, #0
    dcce:	e7ec      	b.n	dcaa <prvTimerTask+0x10a>
				if (prvInsertTimerInActiveList(pxTimer,
    dcd0:	69a1      	ldr	r1, [r4, #24]
    dcd2:	9b04      	ldr	r3, [sp, #16]
    dcd4:	462a      	mov	r2, r5
    dcd6:	4419      	add	r1, r3
    dcd8:	4d20      	ldr	r5, [pc, #128]	; (dd5c <prvTimerTask+0x1bc>)
    dcda:	4620      	mov	r0, r4
    dcdc:	47a8      	blx	r5
    dcde:	2800      	cmp	r0, #0
    dce0:	f43f af7e 	beq.w	dbe0 <prvTimerTask+0x40>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    dce4:	6a63      	ldr	r3, [r4, #36]	; 0x24
    dce6:	4620      	mov	r0, r4
    dce8:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    dcea:	69e3      	ldr	r3, [r4, #28]
    dcec:	2b01      	cmp	r3, #1
    dcee:	f47f af77 	bne.w	dbe0 <prvTimerTask+0x40>
						xResult = xTimerGenericCommand(pxTimer,
    dcf2:	69a2      	ldr	r2, [r4, #24]
    dcf4:	9904      	ldr	r1, [sp, #16]
    dcf6:	2300      	movs	r3, #0
    dcf8:	440a      	add	r2, r1
    dcfa:	4620      	mov	r0, r4
    dcfc:	9300      	str	r3, [sp, #0]
    dcfe:	4c18      	ldr	r4, [pc, #96]	; (dd60 <prvTimerTask+0x1c0>)
    dd00:	4619      	mov	r1, r3
    dd02:	47a0      	blx	r4
						configASSERT(xResult);
    dd04:	2800      	cmp	r0, #0
    dd06:	f47f af6b 	bne.w	dbe0 <prvTimerTask+0x40>
    dd0a:	f04f 0380 	mov.w	r3, #128	; 0x80
    dd0e:	f383 8811 	msr	BASEPRI, r3
    dd12:	f3bf 8f6f 	isb	sy
    dd16:	f3bf 8f4f 	dsb	sy
    dd1a:	e7fe      	b.n	dd1a <prvTimerTask+0x17a>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    dd1c:	9904      	ldr	r1, [sp, #16]
    dd1e:	61a1      	str	r1, [r4, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    dd20:	b941      	cbnz	r1, dd34 <prvTimerTask+0x194>
    dd22:	f04f 0380 	mov.w	r3, #128	; 0x80
    dd26:	f383 8811 	msr	BASEPRI, r3
    dd2a:	f3bf 8f6f 	isb	sy
    dd2e:	f3bf 8f4f 	dsb	sy
    dd32:	e7fe      	b.n	dd32 <prvTimerTask+0x192>
				(void)prvInsertTimerInActiveList(
    dd34:	462b      	mov	r3, r5
    dd36:	462a      	mov	r2, r5
    dd38:	4429      	add	r1, r5
    dd3a:	4620      	mov	r0, r4
    dd3c:	4c07      	ldr	r4, [pc, #28]	; (dd5c <prvTimerTask+0x1bc>)
    dd3e:	47a0      	blx	r4
				break;
    dd40:	e74e      	b.n	dbe0 <prvTimerTask+0x40>
				vPortFree(pxTimer);
    dd42:	4b0a      	ldr	r3, [pc, #40]	; (dd6c <prvTimerTask+0x1cc>)
    dd44:	4620      	mov	r0, r4
    dd46:	4798      	blx	r3
			break;
    dd48:	e74a      	b.n	dbe0 <prvTimerTask+0x40>
    dd4a:	bf00      	nop
    dd4c:	20008968 	.word	0x20008968
    dd50:	00012761 	.word	0x00012761
    dd54:	00012775 	.word	0x00012775
    dd58:	0000db25 	.word	0x0000db25
    dd5c:	0000da35 	.word	0x0000da35
    dd60:	0000dac1 	.word	0x0000dac1
    dd64:	0000c7c5 	.word	0x0000c7c5
    dd68:	e000ed04 	.word	0xe000ed04
    dd6c:	0000b719 	.word	0x0000b719
    dd70:	0000b167 	.word	0x0000b167
    dd74:	000128a9 	.word	0x000128a9
    dd78:	0000c65d 	.word	0x0000c65d

0000dd7c <delay_init>:
/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
	_delay_init(hardware = hw);
    dd7c:	4b01      	ldr	r3, [pc, #4]	; (dd84 <delay_init+0x8>)
    dd7e:	6018      	str	r0, [r3, #0]
    dd80:	4b01      	ldr	r3, [pc, #4]	; (dd88 <delay_init+0xc>)
    dd82:	4718      	bx	r3
    dd84:	200089a4 	.word	0x200089a4
    dd88:	00013a4d 	.word	0x00013a4d

0000dd8c <delay_ms>:
/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    dd8c:	4b05      	ldr	r3, [pc, #20]	; (dda4 <delay_ms+0x18>)
{
    dd8e:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    dd90:	681c      	ldr	r4, [r3, #0]
    dd92:	4b05      	ldr	r3, [pc, #20]	; (dda8 <delay_ms+0x1c>)
    dd94:	4798      	blx	r3
    dd96:	4b05      	ldr	r3, [pc, #20]	; (ddac <delay_ms+0x20>)
    dd98:	4601      	mov	r1, r0
    dd9a:	4620      	mov	r0, r4
}
    dd9c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    dda0:	4718      	bx	r3
    dda2:	bf00      	nop
    dda4:	200089a4 	.word	0x200089a4
    dda8:	0000bac5 	.word	0x0000bac5
    ddac:	00013a61 	.word	0x00013a61

0000ddb0 <_init_chip>:
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    ddb0:	4a0e      	ldr	r2, [pc, #56]	; (ddec <_init_chip+0x3c>)
    ddb2:	8813      	ldrh	r3, [r2, #0]
    ddb4:	b29b      	uxth	r3, r3
    ddb6:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    ddba:	b510      	push	{r4, lr}
    ddbc:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    ddbe:	4b0c      	ldr	r3, [pc, #48]	; (ddf0 <_init_chip+0x40>)
	_oscctrl_init_sources();
	_mclk_init();
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    ddc0:	4c0c      	ldr	r4, [pc, #48]	; (ddf4 <_init_chip+0x44>)
	_osc32kctrl_init_sources();
    ddc2:	4798      	blx	r3
	_oscctrl_init_sources();
    ddc4:	4b0c      	ldr	r3, [pc, #48]	; (ddf8 <_init_chip+0x48>)
    ddc6:	4798      	blx	r3
	_mclk_init();
    ddc8:	4b0c      	ldr	r3, [pc, #48]	; (ddfc <_init_chip+0x4c>)
    ddca:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    ddcc:	2004      	movs	r0, #4
    ddce:	47a0      	blx	r4
#endif
	_oscctrl_init_referenced_generators();
    ddd0:	4b0b      	ldr	r3, [pc, #44]	; (de00 <_init_chip+0x50>)
    ddd2:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    ddd4:	f640 70fb 	movw	r0, #4091	; 0xffb
    ddd8:	47a0      	blx	r4
}

static inline void hri_mclk_set_AHBMASK_DMAC_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_DMAC;
    ddda:	4a0a      	ldr	r2, [pc, #40]	; (de04 <_init_chip+0x54>)
    dddc:	6913      	ldr	r3, [r2, #16]
    ddde:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    dde2:	6113      	str	r3, [r2, #16]
#endif

#if CONF_CMCC_ENABLE
	cache_init();
#endif
}
    dde4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_dma_init();
    dde8:	4b07      	ldr	r3, [pc, #28]	; (de08 <_init_chip+0x58>)
    ddea:	4718      	bx	r3
    ddec:	41004000 	.word	0x41004000
    ddf0:	0000f875 	.word	0x0000f875
    ddf4:	0000ec75 	.word	0x0000ec75
    ddf8:	0000e61d 	.word	0x0000e61d
    ddfc:	0000ec55 	.word	0x0000ec55
    de00:	0000e621 	.word	0x0000e621
    de04:	40000800 	.word	0x40000800
    de08:	0000e091 	.word	0x0000e091

0000de0c <RAMECC_Handler>:
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    de0c:	4a0b      	ldr	r2, [pc, #44]	; (de3c <RAMECC_Handler+0x30>)
    de0e:	7893      	ldrb	r3, [r2, #2]

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    de10:	b082      	sub	sp, #8
    de12:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    de14:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    de16:	9b01      	ldr	r3, [sp, #4]
    de18:	0799      	lsls	r1, r3, #30
    de1a:	d505      	bpl.n	de28 <RAMECC_Handler+0x1c>
    de1c:	4b08      	ldr	r3, [pc, #32]	; (de40 <RAMECC_Handler+0x34>)
    de1e:	681b      	ldr	r3, [r3, #0]
    de20:	b113      	cbz	r3, de28 <RAMECC_Handler+0x1c>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    de22:	6850      	ldr	r0, [r2, #4]
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
	} else {
		return;
	}
}
    de24:	b002      	add	sp, #8
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    de26:	4718      	bx	r3
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    de28:	9b01      	ldr	r3, [sp, #4]
    de2a:	07db      	lsls	r3, r3, #31
    de2c:	d504      	bpl.n	de38 <RAMECC_Handler+0x2c>
    de2e:	4b04      	ldr	r3, [pc, #16]	; (de40 <RAMECC_Handler+0x34>)
    de30:	685b      	ldr	r3, [r3, #4]
    de32:	b10b      	cbz	r3, de38 <RAMECC_Handler+0x2c>
    de34:	4a01      	ldr	r2, [pc, #4]	; (de3c <RAMECC_Handler+0x30>)
    de36:	e7f4      	b.n	de22 <RAMECC_Handler+0x16>
}
    de38:	b002      	add	sp, #8
    de3a:	4770      	bx	lr
    de3c:	41020000 	.word	0x41020000
    de40:	2001c858 	.word	0x2001c858

0000de44 <hid_mouse_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t hid_mouse_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    de44:	b430      	push	{r4, r5}
	if ((0x81 == req->bmRequestType) && (0x06 == req->bRequest) && (req->wIndex == _hiddf_mouse_funcd.func_iface)) {
    de46:	780a      	ldrb	r2, [r1, #0]
    de48:	2a81      	cmp	r2, #129	; 0x81
    de4a:	d11c      	bne.n	de86 <hid_mouse_req+0x42>
    de4c:	784b      	ldrb	r3, [r1, #1]
    de4e:	2b06      	cmp	r3, #6
    de50:	d131      	bne.n	deb6 <hid_mouse_req+0x72>
    de52:	4a1a      	ldr	r2, [pc, #104]	; (debc <hid_mouse_req+0x78>)
    de54:	888c      	ldrh	r4, [r1, #4]
    de56:	7a13      	ldrb	r3, [r2, #8]
    de58:	429c      	cmp	r4, r3
    de5a:	d12c      	bne.n	deb6 <hid_mouse_req+0x72>
	switch (req->wValue >> 8) {
    de5c:	884b      	ldrh	r3, [r1, #2]
    de5e:	0a1b      	lsrs	r3, r3, #8
    de60:	2b21      	cmp	r3, #33	; 0x21
    de62:	d005      	beq.n	de70 <hid_mouse_req+0x2c>
    de64:	2b22      	cmp	r3, #34	; 0x22
    de66:	d00a      	beq.n	de7e <hid_mouse_req+0x3a>
	} else {
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
			return ERR_NOT_FOUND;
		}
		if (req->wIndex == _hiddf_mouse_funcd.func_iface) {
			switch (req->bRequest) {
    de68:	f06f 000c 	mvn.w	r0, #12
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    de6c:	bc30      	pop	{r4, r5}
    de6e:	4770      	bx	lr
		return usbdc_xfer(ep, _hiddf_mouse_funcd.hid_desc, _hiddf_mouse_funcd.hid_desc[0], false);
    de70:	6811      	ldr	r1, [r2, #0]
    de72:	780a      	ldrb	r2, [r1, #0]
    de74:	2300      	movs	r3, #0
				return usbdc_xfer(ep, NULL, 0, 0);
    de76:	4c12      	ldr	r4, [pc, #72]	; (dec0 <hid_mouse_req+0x7c>)
    de78:	46a4      	mov	ip, r4
}
    de7a:	bc30      	pop	{r4, r5}
				return usbdc_xfer(ep, NULL, 0, 0);
    de7c:	4760      	bx	ip
		return usbdc_xfer(ep, (uint8_t *)mouse_report_desc, MOUSE_REPORT_DESC_LEN, false);
    de7e:	4911      	ldr	r1, [pc, #68]	; (dec4 <hid_mouse_req+0x80>)
    de80:	2300      	movs	r3, #0
    de82:	2234      	movs	r2, #52	; 0x34
    de84:	e7f7      	b.n	de76 <hid_mouse_req+0x32>
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    de86:	f3c2 1241 	ubfx	r2, r2, #5, #2
    de8a:	2a01      	cmp	r2, #1
    de8c:	d113      	bne.n	deb6 <hid_mouse_req+0x72>
		if (req->wIndex == _hiddf_mouse_funcd.func_iface) {
    de8e:	4c0b      	ldr	r4, [pc, #44]	; (debc <hid_mouse_req+0x78>)
    de90:	888d      	ldrh	r5, [r1, #4]
    de92:	7a23      	ldrb	r3, [r4, #8]
    de94:	429d      	cmp	r5, r3
    de96:	d10e      	bne.n	deb6 <hid_mouse_req+0x72>
			switch (req->bRequest) {
    de98:	784b      	ldrb	r3, [r1, #1]
    de9a:	2b03      	cmp	r3, #3
    de9c:	d007      	beq.n	deae <hid_mouse_req+0x6a>
    de9e:	2b0b      	cmp	r3, #11
    dea0:	d1e2      	bne.n	de68 <hid_mouse_req+0x24>
				_hiddf_mouse_funcd.protocol = req->wValue;
    dea2:	884b      	ldrh	r3, [r1, #2]
    dea4:	72a3      	strb	r3, [r4, #10]
				return usbdc_xfer(ep, NULL, 0, 0);
    dea6:	2300      	movs	r3, #0
    dea8:	461a      	mov	r2, r3
    deaa:	4619      	mov	r1, r3
    deac:	e7e3      	b.n	de76 <hid_mouse_req+0x32>
				return usbdc_xfer(ep, &_hiddf_mouse_funcd.protocol, 1, 0);
    deae:	2300      	movs	r3, #0
    deb0:	f104 010a 	add.w	r1, r4, #10
    deb4:	e7df      	b.n	de76 <hid_mouse_req+0x32>
			return ERR_NOT_FOUND;
    deb6:	f06f 0009 	mvn.w	r0, #9
	(void)stage;
    deba:	e7d7      	b.n	de6c <hid_mouse_req+0x28>
    debc:	200089a8 	.word	0x200089a8
    dec0:	0001323d 	.word	0x0001323d
    dec4:	000162d0 	.word	0x000162d0

0000dec8 <hid_mouse_ctrl>:
	switch (ctrl) {
    dec8:	2901      	cmp	r1, #1
{
    deca:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    decc:	4614      	mov	r4, r2
	switch (ctrl) {
    dece:	d03b      	beq.n	df48 <hid_mouse_ctrl+0x80>
    ded0:	2902      	cmp	r1, #2
    ded2:	d04f      	beq.n	df74 <hid_mouse_ctrl+0xac>
    ded4:	2900      	cmp	r1, #0
    ded6:	d150      	bne.n	df7a <hid_mouse_ctrl+0xb2>
	ifc = desc->sod;
    ded8:	6813      	ldr	r3, [r2, #0]
		return hid_mouse_enable(drv, (struct usbd_descriptors *)param);
    deda:	6886      	ldr	r6, [r0, #8]
	if (NULL == ifc) {
    dedc:	b91b      	cbnz	r3, dee6 <hid_mouse_ctrl+0x1e>
		return ERR_NOT_FOUND;
    dede:	f06f 0409 	mvn.w	r4, #9
}
    dee2:	4620      	mov	r0, r4
    dee4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    dee6:	7959      	ldrb	r1, [r3, #5]
	ifc_desc.bInterfaceNumber = ifc[2];
    dee8:	789a      	ldrb	r2, [r3, #2]
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    deea:	2903      	cmp	r1, #3
    deec:	d1f7      	bne.n	dede <hid_mouse_ctrl+0x16>
		if (func_data->func_iface == ifc_desc.bInterfaceNumber) { // Initialized
    deee:	7a31      	ldrb	r1, [r6, #8]
    def0:	428a      	cmp	r2, r1
    def2:	d045      	beq.n	df80 <hid_mouse_ctrl+0xb8>
		} else if (func_data->func_iface != 0xFF) { // Occupied
    def4:	29ff      	cmp	r1, #255	; 0xff
    def6:	d146      	bne.n	df86 <hid_mouse_ctrl+0xbe>
			func_data->func_iface = ifc_desc.bInterfaceNumber;
    def8:	7232      	strb	r2, [r6, #8]
    defa:	7818      	ldrb	r0, [r3, #0]
	_hiddf_mouse_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    defc:	6861      	ldr	r1, [r4, #4]
    defe:	4f26      	ldr	r7, [pc, #152]	; (df98 <hid_mouse_ctrl+0xd0>)
    df00:	2221      	movs	r2, #33	; 0x21
    df02:	4418      	add	r0, r3
    df04:	4b25      	ldr	r3, [pc, #148]	; (df9c <hid_mouse_ctrl+0xd4>)
    df06:	4798      	blx	r3
	ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    df08:	6823      	ldr	r3, [r4, #0]
	_hiddf_mouse_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    df0a:	6038      	str	r0, [r7, #0]
    df0c:	7818      	ldrb	r0, [r3, #0]
	ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    df0e:	6861      	ldr	r1, [r4, #4]
    df10:	4418      	add	r0, r3
    df12:	4b23      	ldr	r3, [pc, #140]	; (dfa0 <hid_mouse_ctrl+0xd8>)
    df14:	4798      	blx	r3
	desc->sod = ep;
    df16:	6020      	str	r0, [r4, #0]
	if (NULL != ep) {
    df18:	2800      	cmp	r0, #0
    df1a:	d0e0      	beq.n	dede <hid_mouse_ctrl+0x16>
	return (ptr[0] + (ptr[1] << 8));
    df1c:	7943      	ldrb	r3, [r0, #5]
    df1e:	7902      	ldrb	r2, [r0, #4]
		ep_desc.bEndpointAddress = ep[2];
    df20:	7885      	ldrb	r5, [r0, #2]
		if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    df22:	78c1      	ldrb	r1, [r0, #3]
    df24:	eb02 2203 	add.w	r2, r2, r3, lsl #8
    df28:	b292      	uxth	r2, r2
    df2a:	4b1e      	ldr	r3, [pc, #120]	; (dfa4 <hid_mouse_ctrl+0xdc>)
    df2c:	4628      	mov	r0, r5
    df2e:	4798      	blx	r3
    df30:	4604      	mov	r4, r0
    df32:	bb58      	cbnz	r0, df8c <hid_mouse_ctrl+0xc4>
		if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    df34:	062b      	lsls	r3, r5, #24
    df36:	d52c      	bpl.n	df92 <hid_mouse_ctrl+0xca>
			usb_d_ep_enable(func_data->func_ep_in);
    df38:	4b1b      	ldr	r3, [pc, #108]	; (dfa8 <hid_mouse_ctrl+0xe0>)
			func_data->func_ep_in = ep_desc.bEndpointAddress;
    df3a:	7275      	strb	r5, [r6, #9]
			usb_d_ep_enable(func_data->func_ep_in);
    df3c:	4628      	mov	r0, r5
    df3e:	4798      	blx	r3
	_hiddf_mouse_funcd.protocol = 1;
    df40:	f240 1301 	movw	r3, #257	; 0x101
    df44:	817b      	strh	r3, [r7, #10]
	return ERR_NONE;
    df46:	e7cc      	b.n	dee2 <hid_mouse_ctrl+0x1a>
		return hid_mouse_disable(drv, (struct usbd_descriptors *)param);
    df48:	6885      	ldr	r5, [r0, #8]
	if (desc) {
    df4a:	b11a      	cbz	r2, df54 <hid_mouse_ctrl+0x8c>
		ifc_desc.bInterfaceClass = desc->sod[5];
    df4c:	6813      	ldr	r3, [r2, #0]
		if (ifc_desc.bInterfaceClass != HID_CLASS) {
    df4e:	795b      	ldrb	r3, [r3, #5]
    df50:	2b03      	cmp	r3, #3
    df52:	d1c4      	bne.n	dede <hid_mouse_ctrl+0x16>
	if (func_data->func_iface != 0xFF) {
    df54:	7a2b      	ldrb	r3, [r5, #8]
	if (func_data->func_ep_in != 0xFF) {
    df56:	7a68      	ldrb	r0, [r5, #9]
	if (func_data->func_iface != 0xFF) {
    df58:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface = 0xFF;
    df5a:	bf1c      	itt	ne
    df5c:	23ff      	movne	r3, #255	; 0xff
    df5e:	722b      	strbne	r3, [r5, #8]
	if (func_data->func_ep_in != 0xFF) {
    df60:	28ff      	cmp	r0, #255	; 0xff
    df62:	d003      	beq.n	df6c <hid_mouse_ctrl+0xa4>
		usb_d_ep_deinit(func_data->func_ep_in);
    df64:	4b11      	ldr	r3, [pc, #68]	; (dfac <hid_mouse_ctrl+0xe4>)
    df66:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    df68:	23ff      	movs	r3, #255	; 0xff
    df6a:	726b      	strb	r3, [r5, #9]
	_hiddf_mouse_funcd.enabled = false;
    df6c:	4b0a      	ldr	r3, [pc, #40]	; (df98 <hid_mouse_ctrl+0xd0>)
    df6e:	2400      	movs	r4, #0
    df70:	72dc      	strb	r4, [r3, #11]
	return ERR_NONE;
    df72:	e7b6      	b.n	dee2 <hid_mouse_ctrl+0x1a>
		return ERR_UNSUPPORTED_OP;
    df74:	f06f 041a 	mvn.w	r4, #26
    df78:	e7b3      	b.n	dee2 <hid_mouse_ctrl+0x1a>
	switch (ctrl) {
    df7a:	f06f 040c 	mvn.w	r4, #12
    df7e:	e7b0      	b.n	dee2 <hid_mouse_ctrl+0x1a>
			return ERR_ALREADY_INITIALIZED;
    df80:	f06f 0411 	mvn.w	r4, #17
    df84:	e7ad      	b.n	dee2 <hid_mouse_ctrl+0x1a>
			return ERR_NO_RESOURCE;
    df86:	f06f 041b 	mvn.w	r4, #27
    df8a:	e7aa      	b.n	dee2 <hid_mouse_ctrl+0x1a>
			return ERR_NOT_INITIALIZED;
    df8c:	f06f 0413 	mvn.w	r4, #19
    df90:	e7a7      	b.n	dee2 <hid_mouse_ctrl+0x1a>
			return ERR_INVALID_DATA;
    df92:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    df96:	e7a4      	b.n	dee2 <hid_mouse_ctrl+0x1a>
    df98:	200089a8 	.word	0x200089a8
    df9c:	0000b7ed 	.word	0x0000b7ed
    dfa0:	0000b807 	.word	0x0000b807
    dfa4:	0000f521 	.word	0x0000f521
    dfa8:	0000f5b1 	.word	0x0000f5b1
    dfac:	0000f585 	.word	0x0000f585

0000dfb0 <hiddf_mouse_init>:

/**
 * \brief Initialize the USB HID Mouse Function Driver
 */
int32_t hiddf_mouse_init(void)
{
    dfb0:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    dfb2:	4b0a      	ldr	r3, [pc, #40]	; (dfdc <hiddf_mouse_init+0x2c>)
    dfb4:	4798      	blx	r3
    dfb6:	2801      	cmp	r0, #1
    dfb8:	d80c      	bhi.n	dfd4 <hiddf_mouse_init+0x24>
		return ERR_DENIED;
	}

	_hiddf_mouse.ctrl      = hid_mouse_ctrl;
    dfba:	4809      	ldr	r0, [pc, #36]	; (dfe0 <hiddf_mouse_init+0x30>)
    dfbc:	4b09      	ldr	r3, [pc, #36]	; (dfe4 <hiddf_mouse_init+0x34>)
	_hiddf_mouse.func_data = &_hiddf_mouse_funcd;
    dfbe:	e9c0 3004 	strd	r3, r0, [r0, #16]

	usbdc_register_function(&_hiddf_mouse);
    dfc2:	4b09      	ldr	r3, [pc, #36]	; (dfe8 <hiddf_mouse_init+0x38>)
    dfc4:	300c      	adds	r0, #12
    dfc6:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &hid_mouse_req_h);
    dfc8:	2001      	movs	r0, #1
    dfca:	4908      	ldr	r1, [pc, #32]	; (dfec <hiddf_mouse_init+0x3c>)
    dfcc:	4b08      	ldr	r3, [pc, #32]	; (dff0 <hiddf_mouse_init+0x40>)
    dfce:	4798      	blx	r3
	return ERR_NONE;
    dfd0:	2000      	movs	r0, #0
}
    dfd2:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    dfd4:	f06f 0010 	mvn.w	r0, #16
    dfd8:	e7fb      	b.n	dfd2 <hiddf_mouse_init+0x22>
    dfda:	bf00      	nop
    dfdc:	00013675 	.word	0x00013675
    dfe0:	200089a8 	.word	0x200089a8
    dfe4:	0000dec9 	.word	0x0000dec9
    dfe8:	0001361d 	.word	0x0001361d
    dfec:	200004fc 	.word	0x200004fc
    dff0:	00013595 	.word	0x00013595

0000dff4 <hiddf_mouse_move>:
 * \param pos     Signed value to move
 * \param type    HID mouse class pointer move type
 * \return Operation status.
 */
int32_t hiddf_mouse_move(int8_t pos, enum hiddf_mouse_move_type type)
{
    dff4:	b410      	push	{r4}

	_hiddf_mouse_funcd.mouse_report.u32 = 0;
    dff6:	4c0e      	ldr	r4, [pc, #56]	; (e030 <hiddf_mouse_move+0x3c>)
    dff8:	2300      	movs	r3, #0

	if (type == HID_MOUSE_X_AXIS_MV) {
    dffa:	2901      	cmp	r1, #1
	_hiddf_mouse_funcd.mouse_report.u32 = 0;
    dffc:	6063      	str	r3, [r4, #4]
	if (type == HID_MOUSE_X_AXIS_MV) {
    dffe:	d109      	bne.n	e014 <hiddf_mouse_move+0x20>
		_hiddf_mouse_funcd.mouse_report.bytes.x_axis_var = pos;
    e000:	7160      	strb	r0, [r4, #5]
		_hiddf_mouse_funcd.mouse_report.bytes.scroll_var = pos;
	} else {
		return ERR_INVALID_ARG;
	}

	return usbdc_xfer(_hiddf_mouse_funcd.func_ep_in, &_hiddf_mouse_funcd.mouse_report.bytes.button_state, 4, false);
    e002:	7a60      	ldrb	r0, [r4, #9]
    e004:	4c0b      	ldr	r4, [pc, #44]	; (e034 <hiddf_mouse_move+0x40>)
    e006:	490c      	ldr	r1, [pc, #48]	; (e038 <hiddf_mouse_move+0x44>)
    e008:	46a4      	mov	ip, r4
    e00a:	2300      	movs	r3, #0
}
    e00c:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_hiddf_mouse_funcd.func_ep_in, &_hiddf_mouse_funcd.mouse_report.bytes.button_state, 4, false);
    e010:	2204      	movs	r2, #4
    e012:	4760      	bx	ip
	} else if (type == HID_MOUSE_Y_AXIS_MV) {
    e014:	2902      	cmp	r1, #2
    e016:	d101      	bne.n	e01c <hiddf_mouse_move+0x28>
		_hiddf_mouse_funcd.mouse_report.bytes.y_axis_var = pos;
    e018:	71a0      	strb	r0, [r4, #6]
    e01a:	e7f2      	b.n	e002 <hiddf_mouse_move+0xe>
	} else if (type == HID_MOUSE_SCROLL_MV) {
    e01c:	2903      	cmp	r1, #3
    e01e:	d101      	bne.n	e024 <hiddf_mouse_move+0x30>
		_hiddf_mouse_funcd.mouse_report.bytes.scroll_var = pos;
    e020:	71e0      	strb	r0, [r4, #7]
    e022:	e7ee      	b.n	e002 <hiddf_mouse_move+0xe>
}
    e024:	f06f 000c 	mvn.w	r0, #12
    e028:	f85d 4b04 	ldr.w	r4, [sp], #4
    e02c:	4770      	bx	lr
    e02e:	bf00      	nop
    e030:	200089a8 	.word	0x200089a8
    e034:	0001323d 	.word	0x0001323d
    e038:	200089ac 	.word	0x200089ac

0000e03c <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    e03c:	b900      	cbnz	r0, e040 <assert+0x4>
		__asm("BKPT #0");
    e03e:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    e040:	4770      	bx	lr
	...

0000e044 <_dmac_handler>:
	tmp = ((Dmac *)hw)->INTPEND.reg;
    e044:	4b10      	ldr	r3, [pc, #64]	; (e088 <_dmac_handler+0x44>)
    e046:	8c1a      	ldrh	r2, [r3, #32]
}
/**
 * \internal DMAC interrupt handler
 */
static void _dmac_handler(void)
{
    e048:	b430      	push	{r4, r5}
	tmp = ((Dmac *)hw)->INTPEND.reg;
    e04a:	8c1d      	ldrh	r5, [r3, #32]
	uint8_t               channel      = hri_dmac_get_INTPEND_reg(DMAC, DMAC_INTPEND_ID_Msk);
	struct _dma_resource *tmp_resource = &_resources[channel];
    e04c:	4c0f      	ldr	r4, [pc, #60]	; (e08c <_dmac_handler+0x48>)
	tmp &= mask;
    e04e:	f002 021f 	and.w	r2, r2, #31
    e052:	210c      	movs	r1, #12
    e054:	4351      	muls	r1, r2

	if (hri_dmac_get_INTPEND_TERR_bit(DMAC)) {
    e056:	05ed      	lsls	r5, r5, #23
	struct _dma_resource *tmp_resource = &_resources[channel];
    e058:	eb04 0001 	add.w	r0, r4, r1
	if (hri_dmac_get_INTPEND_TERR_bit(DMAC)) {
    e05c:	d507      	bpl.n	e06e <_dmac_handler+0x2a>
	((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg = DMAC_CHINTFLAG_TERR;
    e05e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    e062:	2201      	movs	r2, #1
    e064:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
		hri_dmac_clear_CHINTFLAG_TERR_bit(DMAC, channel);
		tmp_resource->dma_cb.error(tmp_resource);
    e068:	6843      	ldr	r3, [r0, #4]
	} else if (hri_dmac_get_INTPEND_TCMPL_bit(DMAC)) {
		hri_dmac_clear_CHINTFLAG_TCMPL_bit(DMAC, channel);
		tmp_resource->dma_cb.transfer_done(tmp_resource);
	}
}
    e06a:	bc30      	pop	{r4, r5}
		tmp_resource->dma_cb.transfer_done(tmp_resource);
    e06c:	4718      	bx	r3
	tmp = ((Dmac *)hw)->INTPEND.reg;
    e06e:	8c1d      	ldrh	r5, [r3, #32]
	} else if (hri_dmac_get_INTPEND_TCMPL_bit(DMAC)) {
    e070:	05ad      	lsls	r5, r5, #22
    e072:	d506      	bpl.n	e082 <_dmac_handler+0x3e>
	((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg = DMAC_CHINTFLAG_TCMPL;
    e074:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    e078:	2202      	movs	r2, #2
    e07a:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
		tmp_resource->dma_cb.transfer_done(tmp_resource);
    e07e:	5863      	ldr	r3, [r4, r1]
    e080:	e7f3      	b.n	e06a <_dmac_handler+0x26>
}
    e082:	bc30      	pop	{r4, r5}
    e084:	4770      	bx	lr
    e086:	bf00      	nop
    e088:	4100a000 	.word	0x4100a000
    e08c:	200089c0 	.word	0x200089c0

0000e090 <_dma_init>:
	((Dmac *)hw)->CTRL.reg &= ~DMAC_CTRL_DMAENABLE;
    e090:	4b3d      	ldr	r3, [pc, #244]	; (e188 <_dma_init+0xf8>)
    e092:	881a      	ldrh	r2, [r3, #0]
    e094:	f022 0202 	bic.w	r2, r2, #2
    e098:	0412      	lsls	r2, r2, #16
    e09a:	0c12      	lsrs	r2, r2, #16
{
    e09c:	b570      	push	{r4, r5, r6, lr}
    e09e:	801a      	strh	r2, [r3, #0]
	((Dmac *)hw)->CRCCTRL.reg &= ~mask;
    e0a0:	885a      	ldrh	r2, [r3, #2]
    e0a2:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
    e0a6:	0412      	lsls	r2, r2, #16
    e0a8:	0c12      	lsrs	r2, r2, #16
    e0aa:	805a      	strh	r2, [r3, #2]
	((Dmac *)hw)->CTRL.reg |= DMAC_CTRL_SWRST;
    e0ac:	881a      	ldrh	r2, [r3, #0]
    e0ae:	b292      	uxth	r2, r2
    e0b0:	f042 0201 	orr.w	r2, r2, #1
    e0b4:	801a      	strh	r2, [r3, #0]
	tmp = ((Dmac *)hw)->CTRL.reg;
    e0b6:	881a      	ldrh	r2, [r3, #0]
	while (hri_dmac_get_CTRL_SWRST_bit(DMAC))
    e0b8:	f012 0201 	ands.w	r2, r2, #1
    e0bc:	d1fb      	bne.n	e0b6 <_dma_init+0x26>
	((Dmac *)hw)->CTRL.reg = data;
    e0be:	f44f 6170 	mov.w	r1, #3840	; 0xf00
    e0c2:	8019      	strh	r1, [r3, #0]
	tmp = ((Dmac *)hw)->DBGCTRL.reg;
    e0c4:	7b59      	ldrb	r1, [r3, #13]
	hri_dmac_write_BASEADDR_reg(DMAC, (uint32_t)_descriptor_section);
    e0c6:	4831      	ldr	r0, [pc, #196]	; (e18c <_dma_init+0xfc>)
	tmp &= ~DMAC_DBGCTRL_DBGRUN;
    e0c8:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	tmp |= value << DMAC_DBGCTRL_DBGRUN_Pos;
    e0cc:	f041 0101 	orr.w	r1, r1, #1
	((Dmac *)hw)->DBGCTRL.reg = tmp;
    e0d0:	7359      	strb	r1, [r3, #13]
	hri_dmac_write_WRBADDR_reg(DMAC, (uint32_t)_write_back_section);
    e0d2:	492f      	ldr	r1, [pc, #188]	; (e190 <_dma_init+0x100>)
	((Dmac *)hw)->PRICTRL0.reg = data;
    e0d4:	615a      	str	r2, [r3, #20]
	((Dmac *)hw)->BASEADDR.reg = data;
    e0d6:	6358      	str	r0, [r3, #52]	; 0x34
	((Dmac *)hw)->WRBADDR.reg = data;
    e0d8:	6399      	str	r1, [r3, #56]	; 0x38
    e0da:	4613      	mov	r3, r2
    e0dc:	492d      	ldr	r1, [pc, #180]	; (e194 <_dma_init+0x104>)
    e0de:	4602      	mov	r2, r0
	((DmacDescriptor *)hw)->DESCADDR.reg = data;
    e0e0:	461d      	mov	r5, r3
		hri_dmac_write_CHCTRLA_reg(DMAC, i, _cfgs[i].ctrla);
    e0e2:	011c      	lsls	r4, r3, #4
    e0e4:	f104 4082 	add.w	r0, r4, #1090519040	; 0x41000000
    e0e8:	f500 4020 	add.w	r0, r0, #40960	; 0xa000
    e0ec:	680e      	ldr	r6, [r1, #0]

static inline void hri_dmac_write_CHCTRLA_reg(const void *const hw, uint8_t submodule_index,
                                              hri_dmac_chctrla_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg = data;
    e0ee:	6406      	str	r6, [r0, #64]	; 0x40
		hri_dmac_write_CHPRILVL_reg(DMAC, i, _cfgs[i].prilvl);
    e0f0:	790e      	ldrb	r6, [r1, #4]

static inline void hri_dmac_write_CHPRILVL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_dmac_chprilvl_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHPRILVL.reg = data;
    e0f2:	f880 6045 	strb.w	r6, [r0, #69]	; 0x45
		hri_dmac_write_CHEVCTRL_reg(DMAC, i, _cfgs[i].evctrl);
    e0f6:	794e      	ldrb	r6, [r1, #5]

static inline void hri_dmac_write_CHEVCTRL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_dmac_chevctrl_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHEVCTRL.reg = data;
    e0f8:	f880 6046 	strb.w	r6, [r0, #70]	; 0x46
		hri_dmacdescriptor_write_BTCTRL_reg(&_descriptor_section[i], _cfgs[i].btctrl);
    e0fc:	3301      	adds	r3, #1
	((DmacDescriptor *)hw)->BTCTRL.reg = data;
    e0fe:	1910      	adds	r0, r2, r4
    e100:	88ce      	ldrh	r6, [r1, #6]
    e102:	5316      	strh	r6, [r2, r4]
	for (i = 0; i < DMAC_CH_NUM; i++) {
    e104:	2b20      	cmp	r3, #32
	((DmacDescriptor *)hw)->DESCADDR.reg = data;
    e106:	60c5      	str	r5, [r0, #12]
    e108:	f101 0108 	add.w	r1, r1, #8
    e10c:	d1e9      	bne.n	e0e2 <_dma_init+0x52>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e10e:	4b22      	ldr	r3, [pc, #136]	; (e198 <_dma_init+0x108>)
    e110:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    e114:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    e118:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e11c:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e120:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e124:	601a      	str	r2, [r3, #0]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e126:	2201      	movs	r2, #1
    e128:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e12c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e130:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e134:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e138:	605a      	str	r2, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e13a:	2202      	movs	r2, #2
    e13c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e140:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e144:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e148:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e14c:	605a      	str	r2, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e14e:	2204      	movs	r2, #4
    e150:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e154:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e158:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e15c:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e160:	605a      	str	r2, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e162:	2208      	movs	r2, #8
    e164:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e168:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e16c:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e170:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e174:	605a      	str	r2, [r3, #4]
	((Dmac *)hw)->CTRL.reg |= DMAC_CTRL_DMAENABLE;
    e176:	4a04      	ldr	r2, [pc, #16]	; (e188 <_dma_init+0xf8>)
    e178:	8813      	ldrh	r3, [r2, #0]
    e17a:	b29b      	uxth	r3, r3
    e17c:	f043 0302 	orr.w	r3, r3, #2
    e180:	8013      	strh	r3, [r2, #0]
}
    e182:	2000      	movs	r0, #0
    e184:	bd70      	pop	{r4, r5, r6, pc}
    e186:	bf00      	nop
    e188:	4100a000 	.word	0x4100a000
    e18c:	2001c870 	.word	0x2001c870
    e190:	2001ca70 	.word	0x2001ca70
    e194:	00016304 	.word	0x00016304
    e198:	e000e100 	.word	0xe000e100

0000e19c <_dma_set_irq_state>:
	if (DMA_TRANSFER_COMPLETE_CB == type) {
    e19c:	b939      	cbnz	r1, e1ae <_dma_set_irq_state+0x12>
	if (value == 0x0) {
    e19e:	4b08      	ldr	r3, [pc, #32]	; (e1c0 <_dma_set_irq_state+0x24>)
    e1a0:	0100      	lsls	r0, r0, #4
    e1a2:	2102      	movs	r1, #2
		((Dmac *)hw)->Channel[submodule_index].CHINTENCLR.reg = DMAC_CHINTENSET_TERR;
    e1a4:	4418      	add	r0, r3
	if (value == 0x0) {
    e1a6:	b93a      	cbnz	r2, e1b8 <_dma_set_irq_state+0x1c>
		((Dmac *)hw)->Channel[submodule_index].CHINTENCLR.reg = DMAC_CHINTENSET_TERR;
    e1a8:	f880 104c 	strb.w	r1, [r0, #76]	; 0x4c
    e1ac:	4770      	bx	lr
	} else if (DMA_TRANSFER_ERROR_CB == type) {
    e1ae:	2901      	cmp	r1, #1
    e1b0:	d104      	bne.n	e1bc <_dma_set_irq_state+0x20>
	if (value == 0x0) {
    e1b2:	4b03      	ldr	r3, [pc, #12]	; (e1c0 <_dma_set_irq_state+0x24>)
    e1b4:	0100      	lsls	r0, r0, #4
    e1b6:	e7f5      	b.n	e1a4 <_dma_set_irq_state+0x8>
		((Dmac *)hw)->Channel[submodule_index].CHINTENSET.reg = DMAC_CHINTENSET_TERR;
    e1b8:	f880 104d 	strb.w	r1, [r0, #77]	; 0x4d
}
    e1bc:	4770      	bx	lr
    e1be:	bf00      	nop
    e1c0:	4100a000 	.word	0x4100a000

0000e1c4 <_dma_set_destination_address>:
	((DmacDescriptor *)hw)->DSTADDR.reg = data;
    e1c4:	4b02      	ldr	r3, [pc, #8]	; (e1d0 <_dma_set_destination_address+0xc>)
    e1c6:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    e1ca:	6081      	str	r1, [r0, #8]
}
    e1cc:	2000      	movs	r0, #0
    e1ce:	4770      	bx	lr
    e1d0:	2001c870 	.word	0x2001c870

0000e1d4 <_dma_set_source_address>:
	((DmacDescriptor *)hw)->SRCADDR.reg = data;
    e1d4:	4b02      	ldr	r3, [pc, #8]	; (e1e0 <_dma_set_source_address+0xc>)
    e1d6:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    e1da:	6041      	str	r1, [r0, #4]
}
    e1dc:	2000      	movs	r0, #0
    e1de:	4770      	bx	lr
    e1e0:	2001c870 	.word	0x2001c870

0000e1e4 <_dma_srcinc_enable>:
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e1e4:	4a05      	ldr	r2, [pc, #20]	; (e1fc <_dma_srcinc_enable+0x18>)
    e1e6:	0100      	lsls	r0, r0, #4
    e1e8:	5a13      	ldrh	r3, [r2, r0]
    e1ea:	b29b      	uxth	r3, r3
	tmp &= ~DMAC_BTCTRL_SRCINC;
    e1ec:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
	tmp |= value << DMAC_BTCTRL_SRCINC_Pos;
    e1f0:	ea43 2181 	orr.w	r1, r3, r1, lsl #10
    e1f4:	b289      	uxth	r1, r1
	((DmacDescriptor *)hw)->BTCTRL.reg = tmp;
    e1f6:	5211      	strh	r1, [r2, r0]
}
    e1f8:	2000      	movs	r0, #0
    e1fa:	4770      	bx	lr
    e1fc:	2001c870 	.word	0x2001c870

0000e200 <_dma_set_data_amount>:
	return ((DmacDescriptor *)hw)->DSTADDR.reg;
    e200:	4b0f      	ldr	r3, [pc, #60]	; (e240 <_dma_set_data_amount+0x40>)
{
    e202:	b570      	push	{r4, r5, r6, lr}
    e204:	0104      	lsls	r4, r0, #4
    e206:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    e20a:	6886      	ldr	r6, [r0, #8]
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e20c:	5b1a      	ldrh	r2, [r3, r4]
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e20e:	5b1d      	ldrh	r5, [r3, r4]
	tmp = (tmp & DMAC_BTCTRL_BEATSIZE_Msk) >> DMAC_BTCTRL_BEATSIZE_Pos;
    e210:	f3c2 2201 	ubfx	r2, r2, #8, #2
	if (hri_dmacdescriptor_get_BTCTRL_DSTINC_bit(&_descriptor_section[channel])) {
    e214:	052d      	lsls	r5, r5, #20
		hri_dmacdescriptor_write_DSTADDR_reg(&_descriptor_section[channel], address + amount * (1 << beat_size));
    e216:	bf42      	ittt	mi
    e218:	fa01 f502 	lslmi.w	r5, r1, r2
    e21c:	19ad      	addmi	r5, r5, r6
	((DmacDescriptor *)hw)->DSTADDR.reg = data;
    e21e:	6085      	strmi	r5, [r0, #8]
	return ((DmacDescriptor *)hw)->SRCADDR.reg;
    e220:	1918      	adds	r0, r3, r4
    e222:	6845      	ldr	r5, [r0, #4]
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e224:	5b1e      	ldrh	r6, [r3, r4]
	if (hri_dmacdescriptor_get_BTCTRL_SRCINC_bit(&_descriptor_section[channel])) {
    e226:	0576      	lsls	r6, r6, #21
		hri_dmacdescriptor_write_SRCADDR_reg(&_descriptor_section[channel], address + amount * (1 << beat_size));
    e228:	bf48      	it	mi
    e22a:	fa01 f202 	lslmi.w	r2, r1, r2
	((DmacDescriptor *)hw)->BTCNT.reg = data;
    e22e:	4423      	add	r3, r4
    e230:	bf48      	it	mi
    e232:	1952      	addmi	r2, r2, r5
	hri_dmacdescriptor_write_BTCNT_reg(&_descriptor_section[channel], amount);
    e234:	b289      	uxth	r1, r1
	((DmacDescriptor *)hw)->SRCADDR.reg = data;
    e236:	bf48      	it	mi
    e238:	6042      	strmi	r2, [r0, #4]
	((DmacDescriptor *)hw)->BTCNT.reg = data;
    e23a:	8059      	strh	r1, [r3, #2]
}
    e23c:	2000      	movs	r0, #0
    e23e:	bd70      	pop	{r4, r5, r6, pc}
    e240:	2001c870 	.word	0x2001c870

0000e244 <_dma_enable_transaction>:
	((DmacDescriptor *)hw)->BTCTRL.reg |= DMAC_BTCTRL_VALID;
    e244:	0102      	lsls	r2, r0, #4
{
    e246:	b510      	push	{r4, lr}
    e248:	4c0b      	ldr	r4, [pc, #44]	; (e278 <_dma_enable_transaction+0x34>)
    e24a:	5aa3      	ldrh	r3, [r4, r2]
    e24c:	b29b      	uxth	r3, r3
    e24e:	f043 0301 	orr.w	r3, r3, #1
    e252:	52a3      	strh	r3, [r4, r2]
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg |= DMAC_CHCTRLA_ENABLE;
    e254:	f102 4382 	add.w	r3, r2, #1090519040	; 0x41000000
    e258:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
    e25c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    e25e:	f042 0202 	orr.w	r2, r2, #2
    e262:	641a      	str	r2, [r3, #64]	; 0x40
	if (software_trigger) {
    e264:	b131      	cbz	r1, e274 <_dma_enable_transaction+0x30>
	((Dmac *)hw)->SWTRIGCTRL.reg |= mask;
    e266:	4a05      	ldr	r2, [pc, #20]	; (e27c <_dma_enable_transaction+0x38>)
		hri_dmac_set_SWTRIGCTRL_reg(DMAC, 1 << channel);
    e268:	2301      	movs	r3, #1
    e26a:	6911      	ldr	r1, [r2, #16]
    e26c:	fa03 f000 	lsl.w	r0, r3, r0
    e270:	4308      	orrs	r0, r1
    e272:	6110      	str	r0, [r2, #16]
}
    e274:	2000      	movs	r0, #0
    e276:	bd10      	pop	{r4, pc}
    e278:	2001c870 	.word	0x2001c870
    e27c:	4100a000 	.word	0x4100a000

0000e280 <_dma_get_channel_resource>:
	*resource = &_resources[channel];
    e280:	4b03      	ldr	r3, [pc, #12]	; (e290 <_dma_get_channel_resource+0x10>)
    e282:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    e286:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    e28a:	6001      	str	r1, [r0, #0]
}
    e28c:	2000      	movs	r0, #0
    e28e:	4770      	bx	lr
    e290:	200089c0 	.word	0x200089c0

0000e294 <DMAC_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void DMAC_0_Handler(void)
{
	_dmac_handler();
    e294:	4b00      	ldr	r3, [pc, #0]	; (e298 <DMAC_0_Handler+0x4>)
    e296:	4718      	bx	r3
    e298:	0000e045 	.word	0x0000e045

0000e29c <DMAC_1_Handler>:
    e29c:	4b00      	ldr	r3, [pc, #0]	; (e2a0 <DMAC_1_Handler+0x4>)
    e29e:	4718      	bx	r3
    e2a0:	0000e045 	.word	0x0000e045

0000e2a4 <DMAC_2_Handler>:
    e2a4:	4b00      	ldr	r3, [pc, #0]	; (e2a8 <DMAC_2_Handler+0x4>)
    e2a6:	4718      	bx	r3
    e2a8:	0000e045 	.word	0x0000e045

0000e2ac <DMAC_3_Handler>:
    e2ac:	4b00      	ldr	r3, [pc, #0]	; (e2b0 <DMAC_3_Handler+0x4>)
    e2ae:	4718      	bx	r3
    e2b0:	0000e045 	.word	0x0000e045

0000e2b4 <DMAC_4_Handler>:
    e2b4:	4b00      	ldr	r3, [pc, #0]	; (e2b8 <DMAC_4_Handler+0x4>)
    e2b6:	4718      	bx	r3
    e2b8:	0000e045 	.word	0x0000e045

0000e2bc <adc_async_window_threshold_reached>:

static void adc_async_window_threshold_reached(struct _adc_async_device *device, const uint8_t channel)
{
	struct adc_async_descriptor *const descr = CONTAINER_OF(device, struct adc_async_descriptor, device);

	if (descr->adc_async_cb.monitor) {
    e2bc:	6983      	ldr	r3, [r0, #24]
    e2be:	b103      	cbz	r3, e2c2 <adc_async_window_threshold_reached+0x6>
		descr->adc_async_cb.monitor(descr, channel);
    e2c0:	4718      	bx	r3
	}
}
    e2c2:	4770      	bx	lr

0000e2c4 <adc_async_error_occured>:

static void adc_async_error_occured(struct _adc_async_device *device, const uint8_t channel)
{
	struct adc_async_descriptor *const descr = CONTAINER_OF(device, struct adc_async_descriptor, device);

	if (descr->adc_async_cb.error) {
    e2c4:	69c3      	ldr	r3, [r0, #28]
    e2c6:	b103      	cbz	r3, e2ca <adc_async_error_occured+0x6>
		descr->adc_async_cb.error(descr, channel);
    e2c8:	4718      	bx	r3
	}
}
    e2ca:	4770      	bx	lr

0000e2cc <adc_async_channel_conversion_done>:
{
    e2cc:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t                              index    = descr->channel_map[channel];
    e2d0:	6a03      	ldr	r3, [r0, #32]
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    e2d2:	f8d0 8028 	ldr.w	r8, [r0, #40]	; 0x28
    e2d6:	5c5c      	ldrb	r4, [r3, r1]
	ringbuffer_put(&descr_ch->convert, data);
    e2d8:	f8df a054 	ldr.w	sl, [pc, #84]	; e330 <adc_async_channel_conversion_done+0x64>
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    e2dc:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    e2e0:	ea4f 09c4 	mov.w	r9, r4, lsl #3
    e2e4:	eb08 04c4 	add.w	r4, r8, r4, lsl #3
	ringbuffer_put(&descr_ch->convert, data);
    e2e8:	f104 0b04 	add.w	fp, r4, #4
{
    e2ec:	4605      	mov	r5, r0
    e2ee:	460e      	mov	r6, r1
	ringbuffer_put(&descr_ch->convert, data);
    e2f0:	4658      	mov	r0, fp
    e2f2:	b2d1      	uxtb	r1, r2
{
    e2f4:	4617      	mov	r7, r2
	ringbuffer_put(&descr_ch->convert, data);
    e2f6:	47d0      	blx	sl
	if (1 < _adc_async_get_data_size(&descr->device)) {
    e2f8:	4b0c      	ldr	r3, [pc, #48]	; (e32c <adc_async_channel_conversion_done+0x60>)
    e2fa:	4628      	mov	r0, r5
    e2fc:	4798      	blx	r3
    e2fe:	2801      	cmp	r0, #1
    e300:	d905      	bls.n	e30e <adc_async_channel_conversion_done+0x42>
		ringbuffer_put(&descr_ch->convert, data >> 8);
    e302:	0a39      	lsrs	r1, r7, #8
    e304:	4658      	mov	r0, fp
    e306:	47d0      	blx	sl
		++descr_ch->bytes_in_buffer;
    e308:	8aa3      	ldrh	r3, [r4, #20]
    e30a:	3301      	adds	r3, #1
    e30c:	82a3      	strh	r3, [r4, #20]
	++descr_ch->bytes_in_buffer;
    e30e:	8aa3      	ldrh	r3, [r4, #20]
    e310:	3301      	adds	r3, #1
    e312:	82a3      	strh	r3, [r4, #20]
	if (descr_ch->adc_async_ch_cb.convert_done) {
    e314:	f858 3009 	ldr.w	r3, [r8, r9]
    e318:	b12b      	cbz	r3, e326 <adc_async_channel_conversion_done+0x5a>
		descr_ch->adc_async_ch_cb.convert_done(descr, channel);
    e31a:	4631      	mov	r1, r6
    e31c:	4628      	mov	r0, r5
}
    e31e:	b001      	add	sp, #4
    e320:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		descr_ch->adc_async_ch_cb.convert_done(descr, channel);
    e324:	4718      	bx	r3
}
    e326:	b001      	add	sp, #4
    e328:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e32c:	00012fbd 	.word	0x00012fbd
    e330:	00011aa1 	.word	0x00011aa1

0000e334 <adc_async_init>:
{
    e334:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e338:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    e33c:	f89d 8020 	ldrb.w	r8, [sp, #32]
    e340:	460e      	mov	r6, r1
    e342:	4615      	mov	r5, r2
    e344:	461f      	mov	r7, r3
	ASSERT(descr && hw && channel_map && channel_amount && descr_ch);
    e346:	4604      	mov	r4, r0
    e348:	b150      	cbz	r0, e360 <adc_async_init+0x2c>
    e34a:	2900      	cmp	r1, #0
    e34c:	d032      	beq.n	e3b4 <adc_async_init+0x80>
    e34e:	2a00      	cmp	r2, #0
    e350:	d032      	beq.n	e3b8 <adc_async_init+0x84>
    e352:	f1b8 0f00 	cmp.w	r8, #0
    e356:	d031      	beq.n	e3bc <adc_async_init+0x88>
    e358:	f1b9 0000 	subs.w	r0, r9, #0
    e35c:	bf18      	it	ne
    e35e:	2001      	movne	r0, #1
    e360:	4917      	ldr	r1, [pc, #92]	; (e3c0 <adc_async_init+0x8c>)
    e362:	f8df a070 	ldr.w	sl, [pc, #112]	; e3d4 <adc_async_init+0xa0>
    e366:	223f      	movs	r2, #63	; 0x3f
    e368:	47d0      	blx	sl
	ASSERT(channel_amount <= (channel_max + 1));
    e36a:	1c78      	adds	r0, r7, #1
    e36c:	4580      	cmp	r8, r0
    e36e:	4914      	ldr	r1, [pc, #80]	; (e3c0 <adc_async_init+0x8c>)
    e370:	f04f 0240 	mov.w	r2, #64	; 0x40
    e374:	bfcc      	ite	gt
    e376:	2000      	movgt	r0, #0
    e378:	2001      	movle	r0, #1
    e37a:	47d0      	blx	sl
	device = &descr->device;
    e37c:	2300      	movs	r3, #0
		channel_map[i] = 0xFF;
    e37e:	21ff      	movs	r1, #255	; 0xff
    e380:	b2da      	uxtb	r2, r3
    e382:	3301      	adds	r3, #1
    e384:	54a9      	strb	r1, [r5, r2]
	for (uint8_t i = 0; i <= channel_max; i++) {
    e386:	b2da      	uxtb	r2, r3
    e388:	4297      	cmp	r7, r2
    e38a:	d2f9      	bcs.n	e380 <adc_async_init+0x4c>
	init_status           = _adc_async_init(device, hw);
    e38c:	4b0d      	ldr	r3, [pc, #52]	; (e3c4 <adc_async_init+0x90>)
	descr->channel_map    = channel_map;
    e38e:	6225      	str	r5, [r4, #32]
	descr->channel_max    = channel_max;
    e390:	f884 7024 	strb.w	r7, [r4, #36]	; 0x24
	descr->channel_amount = channel_amount;
    e394:	f884 8025 	strb.w	r8, [r4, #37]	; 0x25
	descr->descr_ch       = descr_ch;
    e398:	f8c4 9028 	str.w	r9, [r4, #40]	; 0x28
	init_status           = _adc_async_init(device, hw);
    e39c:	4631      	mov	r1, r6
    e39e:	4620      	mov	r0, r4
    e3a0:	4798      	blx	r3
	if (init_status) {
    e3a2:	b928      	cbnz	r0, e3b0 <adc_async_init+0x7c>
	device->adc_async_ch_cb.convert_done = adc_async_channel_conversion_done;
    e3a4:	4b08      	ldr	r3, [pc, #32]	; (e3c8 <adc_async_init+0x94>)
    e3a6:	60a3      	str	r3, [r4, #8]
	device->adc_async_cb.window_cb       = adc_async_window_threshold_reached;
    e3a8:	4b08      	ldr	r3, [pc, #32]	; (e3cc <adc_async_init+0x98>)
    e3aa:	6023      	str	r3, [r4, #0]
	device->adc_async_cb.error_cb        = adc_async_error_occured;
    e3ac:	4b08      	ldr	r3, [pc, #32]	; (e3d0 <adc_async_init+0x9c>)
    e3ae:	6063      	str	r3, [r4, #4]
}
    e3b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ASSERT(descr && hw && channel_map && channel_amount && descr_ch);
    e3b4:	4608      	mov	r0, r1
    e3b6:	e7d3      	b.n	e360 <adc_async_init+0x2c>
    e3b8:	4610      	mov	r0, r2
    e3ba:	e7d1      	b.n	e360 <adc_async_init+0x2c>
    e3bc:	4640      	mov	r0, r8
    e3be:	e7cf      	b.n	e360 <adc_async_init+0x2c>
    e3c0:	00016404 	.word	0x00016404
    e3c4:	00012ee5 	.word	0x00012ee5
    e3c8:	0000e2cd 	.word	0x0000e2cd
    e3cc:	0000e2bd 	.word	0x0000e2bd
    e3d0:	0000e2c5 	.word	0x0000e2c5
    e3d4:	0000e03d 	.word	0x0000e03d

0000e3d8 <adc_async_register_channel_buffer>:
{
    e3d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    e3dc:	460e      	mov	r6, r1
    e3de:	4617      	mov	r7, r2
    e3e0:	4698      	mov	r8, r3
	ASSERT(descr && convert_buffer && convert_buffer_length);
    e3e2:	4604      	mov	r4, r0
    e3e4:	b118      	cbz	r0, e3ee <adc_async_register_channel_buffer+0x16>
    e3e6:	b1c2      	cbz	r2, e41a <adc_async_register_channel_buffer+0x42>
    e3e8:	1e18      	subs	r0, r3, #0
    e3ea:	bf18      	it	ne
    e3ec:	2001      	movne	r0, #1
    e3ee:	4921      	ldr	r1, [pc, #132]	; (e474 <adc_async_register_channel_buffer+0x9c>)
    e3f0:	4d21      	ldr	r5, [pc, #132]	; (e478 <adc_async_register_channel_buffer+0xa0>)
    e3f2:	2266      	movs	r2, #102	; 0x66
    e3f4:	47a8      	blx	r5
	ASSERT(descr->channel_max >= channel);
    e3f6:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e3fa:	491e      	ldr	r1, [pc, #120]	; (e474 <adc_async_register_channel_buffer+0x9c>)
    e3fc:	42b0      	cmp	r0, r6
    e3fe:	f04f 0267 	mov.w	r2, #103	; 0x67
    e402:	bf34      	ite	cc
    e404:	2000      	movcc	r0, #0
    e406:	2001      	movcs	r0, #1
    e408:	47a8      	blx	r5
	if (descr->channel_map[channel] != 0xFF) {
    e40a:	6a23      	ldr	r3, [r4, #32]
    e40c:	5d9a      	ldrb	r2, [r3, r6]
    e40e:	2aff      	cmp	r2, #255	; 0xff
    e410:	d005      	beq.n	e41e <adc_async_register_channel_buffer+0x46>
		return ERR_INVALID_ARG;
    e412:	f06f 000c 	mvn.w	r0, #12
}
    e416:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(descr && convert_buffer && convert_buffer_length);
    e41a:	4610      	mov	r0, r2
    e41c:	e7e7      	b.n	e3ee <adc_async_register_channel_buffer+0x16>
	for (i = 0; i <= descr->channel_max; i++) {
    e41e:	2200      	movs	r2, #0
    e420:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
	uint8_t i, index = 0;
    e424:	4615      	mov	r5, r2
		if (descr->channel_map[i] != 0xFF) {
    e426:	b2d1      	uxtb	r1, r2
    e428:	3201      	adds	r2, #1
    e42a:	5c59      	ldrb	r1, [r3, r1]
    e42c:	29ff      	cmp	r1, #255	; 0xff
			index++;
    e42e:	bf18      	it	ne
    e430:	3501      	addne	r5, #1
	for (i = 0; i <= descr->channel_max; i++) {
    e432:	b2d1      	uxtb	r1, r2
			index++;
    e434:	bf18      	it	ne
    e436:	b2ed      	uxtbne	r5, r5
	for (i = 0; i <= descr->channel_max; i++) {
    e438:	4288      	cmp	r0, r1
    e43a:	d2f4      	bcs.n	e426 <adc_async_register_channel_buffer+0x4e>
	if (index > descr->channel_amount) {
    e43c:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
    e440:	42ab      	cmp	r3, r5
    e442:	d313      	bcc.n	e46c <adc_async_register_channel_buffer+0x94>
	if (ERR_NONE != ringbuffer_init(&descr->descr_ch[index].convert, convert_buffer, convert_buffer_length)) {
    e444:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    e446:	eb05 0345 	add.w	r3, r5, r5, lsl #1
    e44a:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
    e44e:	ea4f 09c3 	mov.w	r9, r3, lsl #3
    e452:	4642      	mov	r2, r8
    e454:	4b09      	ldr	r3, [pc, #36]	; (e47c <adc_async_register_channel_buffer+0xa4>)
    e456:	4639      	mov	r1, r7
    e458:	3004      	adds	r0, #4
    e45a:	4798      	blx	r3
    e45c:	2800      	cmp	r0, #0
    e45e:	d1d8      	bne.n	e412 <adc_async_register_channel_buffer+0x3a>
	descr->channel_map[channel]            = index;
    e460:	6a23      	ldr	r3, [r4, #32]
    e462:	559d      	strb	r5, [r3, r6]
	descr->descr_ch[index].bytes_in_buffer = 0;
    e464:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e466:	444b      	add	r3, r9
    e468:	8298      	strh	r0, [r3, #20]
	return ERR_NONE;
    e46a:	e7d4      	b.n	e416 <adc_async_register_channel_buffer+0x3e>
		return ERR_NO_RESOURCE;
    e46c:	f06f 001b 	mvn.w	r0, #27
    e470:	e7d1      	b.n	e416 <adc_async_register_channel_buffer+0x3e>
    e472:	bf00      	nop
    e474:	00016404 	.word	0x00016404
    e478:	0000e03d 	.word	0x0000e03d
    e47c:	00011a25 	.word	0x00011a25

0000e480 <adc_async_enable_channel>:
{
    e480:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
    e482:	4604      	mov	r4, r0
    e484:	3800      	subs	r0, #0
{
    e486:	460d      	mov	r5, r1
	ASSERT(descr);
    e488:	bf18      	it	ne
    e48a:	2001      	movne	r0, #1
    e48c:	4e09      	ldr	r6, [pc, #36]	; (e4b4 <adc_async_enable_channel+0x34>)
    e48e:	490a      	ldr	r1, [pc, #40]	; (e4b8 <adc_async_enable_channel+0x38>)
    e490:	2283      	movs	r2, #131	; 0x83
    e492:	47b0      	blx	r6
	ASSERT(descr->channel_max >= channel);
    e494:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e498:	4907      	ldr	r1, [pc, #28]	; (e4b8 <adc_async_enable_channel+0x38>)
    e49a:	42a8      	cmp	r0, r5
    e49c:	bf34      	ite	cc
    e49e:	2000      	movcc	r0, #0
    e4a0:	2001      	movcs	r0, #1
    e4a2:	2284      	movs	r2, #132	; 0x84
    e4a4:	47b0      	blx	r6
	_adc_async_enable_channel(&descr->device, channel);
    e4a6:	4620      	mov	r0, r4
    e4a8:	4b04      	ldr	r3, [pc, #16]	; (e4bc <adc_async_enable_channel+0x3c>)
    e4aa:	4629      	mov	r1, r5
    e4ac:	4798      	blx	r3
}
    e4ae:	2000      	movs	r0, #0
    e4b0:	bd70      	pop	{r4, r5, r6, pc}
    e4b2:	bf00      	nop
    e4b4:	0000e03d 	.word	0x0000e03d
    e4b8:	00016404 	.word	0x00016404
    e4bc:	00012fb1 	.word	0x00012fb1

0000e4c0 <adc_async_register_callback>:
{
    e4c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	ASSERT(descr);
    e4c4:	4604      	mov	r4, r0
    e4c6:	3800      	subs	r0, #0
    e4c8:	bf18      	it	ne
    e4ca:	2001      	movne	r0, #1
    e4cc:	f8df 8064 	ldr.w	r8, [pc, #100]	; e534 <adc_async_register_callback+0x74>
{
    e4d0:	460f      	mov	r7, r1
    e4d2:	4615      	mov	r5, r2
	ASSERT(descr);
    e4d4:	4915      	ldr	r1, [pc, #84]	; (e52c <adc_async_register_callback+0x6c>)
    e4d6:	229c      	movs	r2, #156	; 0x9c
{
    e4d8:	461e      	mov	r6, r3
	ASSERT(descr);
    e4da:	47c0      	blx	r8
	ASSERT(descr->channel_max >= channel);
    e4dc:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e4e0:	4912      	ldr	r1, [pc, #72]	; (e52c <adc_async_register_callback+0x6c>)
    e4e2:	42b8      	cmp	r0, r7
    e4e4:	bf34      	ite	cc
    e4e6:	2000      	movcc	r0, #0
    e4e8:	2001      	movcs	r0, #1
    e4ea:	229d      	movs	r2, #157	; 0x9d
    e4ec:	47c0      	blx	r8
	switch (type) {
    e4ee:	2d01      	cmp	r5, #1
    e4f0:	d014      	beq.n	e51c <adc_async_register_callback+0x5c>
    e4f2:	2d02      	cmp	r5, #2
    e4f4:	d014      	beq.n	e520 <adc_async_register_callback+0x60>
    e4f6:	b9ad      	cbnz	r5, e524 <adc_async_register_callback+0x64>
	uint8_t index = descr->channel_map[channel];
    e4f8:	6a23      	ldr	r3, [r4, #32]
		descr->descr_ch[index].adc_async_ch_cb.convert_done = cb;
    e4fa:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    e4fc:	5ddb      	ldrb	r3, [r3, r7]
    e4fe:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    e502:	f842 6033 	str.w	r6, [r2, r3, lsl #3]
	_adc_async_set_irq_state(&descr->device, channel, (enum _adc_async_callback_type)type, cb != NULL);
    e506:	1e33      	subs	r3, r6, #0
    e508:	4620      	mov	r0, r4
    e50a:	bf18      	it	ne
    e50c:	2301      	movne	r3, #1
    e50e:	4c08      	ldr	r4, [pc, #32]	; (e530 <adc_async_register_callback+0x70>)
    e510:	462a      	mov	r2, r5
    e512:	4639      	mov	r1, r7
    e514:	47a0      	blx	r4
	return ERR_NONE;
    e516:	2000      	movs	r0, #0
}
    e518:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		descr->adc_async_cb.monitor = cb;
    e51c:	61a6      	str	r6, [r4, #24]
		break;
    e51e:	e7f2      	b.n	e506 <adc_async_register_callback+0x46>
		descr->adc_async_cb.error = cb;
    e520:	61e6      	str	r6, [r4, #28]
		break;
    e522:	e7f0      	b.n	e506 <adc_async_register_callback+0x46>
	switch (type) {
    e524:	f06f 000c 	mvn.w	r0, #12
    e528:	e7f6      	b.n	e518 <adc_async_register_callback+0x58>
    e52a:	bf00      	nop
    e52c:	00016404 	.word	0x00016404
    e530:	00012fe9 	.word	0x00012fe9
    e534:	0000e03d 	.word	0x0000e03d

0000e538 <adc_async_read_channel>:
{
    e538:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    e53c:	460e      	mov	r6, r1
    e53e:	4617      	mov	r7, r2
    e540:	461d      	mov	r5, r3
	ASSERT(descr && buffer && length);
    e542:	4604      	mov	r4, r0
    e544:	b120      	cbz	r0, e550 <adc_async_read_channel+0x18>
    e546:	2a00      	cmp	r2, #0
    e548:	d03f      	beq.n	e5ca <adc_async_read_channel+0x92>
    e54a:	1e18      	subs	r0, r3, #0
    e54c:	bf18      	it	ne
    e54e:	2001      	movne	r0, #1
    e550:	f8df 8098 	ldr.w	r8, [pc, #152]	; e5ec <adc_async_read_channel+0xb4>
    e554:	4920      	ldr	r1, [pc, #128]	; (e5d8 <adc_async_read_channel+0xa0>)
		ringbuffer_get(&descr_ch->convert, &buffer[was_read++]);
    e556:	f8df a098 	ldr.w	sl, [pc, #152]	; e5f0 <adc_async_read_channel+0xb8>
	ASSERT(descr && buffer && length);
    e55a:	22bc      	movs	r2, #188	; 0xbc
    e55c:	47c0      	blx	r8
	ASSERT(descr->channel_max >= channel);
    e55e:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e562:	491d      	ldr	r1, [pc, #116]	; (e5d8 <adc_async_read_channel+0xa0>)
    e564:	42b0      	cmp	r0, r6
    e566:	bf34      	ite	cc
    e568:	2000      	movcc	r0, #0
    e56a:	2001      	movcs	r0, #1
    e56c:	22bd      	movs	r2, #189	; 0xbd
    e56e:	47c0      	blx	r8
	data_size = _adc_async_get_data_size(&descr->device);
    e570:	4b1a      	ldr	r3, [pc, #104]	; (e5dc <adc_async_read_channel+0xa4>)
    e572:	4620      	mov	r0, r4
    e574:	4798      	blx	r3
	ASSERT(!(length % data_size));
    e576:	fbb5 f3f0 	udiv	r3, r5, r0
    e57a:	fb03 5010 	mls	r0, r3, r0, r5
    e57e:	fab0 f080 	clz	r0, r0
    e582:	4915      	ldr	r1, [pc, #84]	; (e5d8 <adc_async_read_channel+0xa0>)
    e584:	22bf      	movs	r2, #191	; 0xbf
    e586:	0940      	lsrs	r0, r0, #5
    e588:	47c0      	blx	r8
	index                                         = descr->channel_map[channel];
    e58a:	6a23      	ldr	r3, [r4, #32]
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    e58c:	5d9e      	ldrb	r6, [r3, r6]
    e58e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e590:	eb06 0646 	add.w	r6, r6, r6, lsl #1
    e594:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
	CRITICAL_SECTION_ENTER()
    e598:	a801      	add	r0, sp, #4
    e59a:	4b11      	ldr	r3, [pc, #68]	; (e5e0 <adc_async_read_channel+0xa8>)
	num = ringbuffer_num(&descr_ch->convert);
    e59c:	f106 0904 	add.w	r9, r6, #4
	CRITICAL_SECTION_ENTER()
    e5a0:	4798      	blx	r3
	num = ringbuffer_num(&descr_ch->convert);
    e5a2:	4b10      	ldr	r3, [pc, #64]	; (e5e4 <adc_async_read_channel+0xac>)
    e5a4:	4648      	mov	r0, r9
    e5a6:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
    e5a8:	4b0f      	ldr	r3, [pc, #60]	; (e5e8 <adc_async_read_channel+0xb0>)
	num = ringbuffer_num(&descr_ch->convert);
    e5aa:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
    e5ac:	a801      	add	r0, sp, #4
    e5ae:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
    e5b0:	2400      	movs	r4, #0
    e5b2:	45a0      	cmp	r8, r4
    e5b4:	b2a2      	uxth	r2, r4
    e5b6:	d001      	beq.n	e5bc <adc_async_read_channel+0x84>
    e5b8:	42a5      	cmp	r5, r4
    e5ba:	d108      	bne.n	e5ce <adc_async_read_channel+0x96>
	descr_ch->bytes_in_buffer -= was_read;
    e5bc:	8ab3      	ldrh	r3, [r6, #20]
}
    e5be:	4620      	mov	r0, r4
	descr_ch->bytes_in_buffer -= was_read;
    e5c0:	1a9b      	subs	r3, r3, r2
    e5c2:	82b3      	strh	r3, [r6, #20]
}
    e5c4:	b002      	add	sp, #8
    e5c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ASSERT(descr && buffer && length);
    e5ca:	4610      	mov	r0, r2
    e5cc:	e7c0      	b.n	e550 <adc_async_read_channel+0x18>
		ringbuffer_get(&descr_ch->convert, &buffer[was_read++]);
    e5ce:	1939      	adds	r1, r7, r4
    e5d0:	4648      	mov	r0, r9
    e5d2:	47d0      	blx	sl
    e5d4:	3401      	adds	r4, #1
    e5d6:	e7ec      	b.n	e5b2 <adc_async_read_channel+0x7a>
    e5d8:	00016404 	.word	0x00016404
    e5dc:	00012fbd 	.word	0x00012fbd
    e5e0:	00011b09 	.word	0x00011b09
    e5e4:	00011ae5 	.word	0x00011ae5
    e5e8:	00011b17 	.word	0x00011b17
    e5ec:	0000e03d 	.word	0x0000e03d
    e5f0:	00011a61 	.word	0x00011a61

0000e5f4 <adc_async_start_conversion>:
{
    e5f4:	b510      	push	{r4, lr}
	ASSERT(descr);
    e5f6:	4604      	mov	r4, r0
    e5f8:	3800      	subs	r0, #0
    e5fa:	bf18      	it	ne
    e5fc:	2001      	movne	r0, #1
    e5fe:	4904      	ldr	r1, [pc, #16]	; (e610 <adc_async_start_conversion+0x1c>)
    e600:	4b04      	ldr	r3, [pc, #16]	; (e614 <adc_async_start_conversion+0x20>)
    e602:	22d6      	movs	r2, #214	; 0xd6
    e604:	4798      	blx	r3
	_adc_async_convert(&descr->device);
    e606:	4620      	mov	r0, r4
    e608:	4b03      	ldr	r3, [pc, #12]	; (e618 <adc_async_start_conversion+0x24>)
    e60a:	4798      	blx	r3
}
    e60c:	2000      	movs	r0, #0
    e60e:	bd10      	pop	{r4, pc}
    e610:	00016404 	.word	0x00016404
    e614:	0000e03d 	.word	0x0000e03d
    e618:	00012fd1 	.word	0x00012fd1

0000e61c <_oscctrl_init_sources>:
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    e61c:	4770      	bx	lr
	...

0000e620 <_oscctrl_init_referenced_generators>:

static inline void hri_gclk_write_GENCTRL_SRC_bf(const void *const hw, uint8_t index, hri_gclk_genctrl_reg_t data)
{
	uint32_t tmp;
	GCLK_CRITICAL_SECTION_ENTER();
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    e620:	4b3b      	ldr	r3, [pc, #236]	; (e710 <_oscctrl_init_referenced_generators+0xf0>)
    e622:	6a1a      	ldr	r2, [r3, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    e624:	f022 020f 	bic.w	r2, r2, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    e628:	f042 0204 	orr.w	r2, r2, #4
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    e62c:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    e62e:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    e632:	6859      	ldr	r1, [r3, #4]
    e634:	4211      	tst	r1, r2
    e636:	d1fc      	bne.n	e632 <_oscctrl_init_referenced_generators+0x12>
	return (((Gclk *)hw)->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL0) >> GCLK_SYNCBUSY_GENCTRL0_Pos;
    e638:	685a      	ldr	r2, [r3, #4]
{
	void *hw = (void *)OSCCTRL;

#if CONF_DFLL_CONFIG == 1
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, GCLK_GENCTRL_SRC_OSCULP32K);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    e63a:	0750      	lsls	r0, r2, #29
    e63c:	f3c2 0180 	ubfx	r1, r2, #2, #1
    e640:	d4fa      	bmi.n	e638 <_oscctrl_init_referenced_generators+0x18>
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    e642:	4b34      	ldr	r3, [pc, #208]	; (e714 <_oscctrl_init_referenced_generators+0xf4>)
}

static inline void hri_oscctrl_write_DFLLMUL_reg(const void *const hw, hri_oscctrl_dfllmul_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->DFLLMUL.reg = data;
    e644:	4a34      	ldr	r2, [pc, #208]	; (e718 <_oscctrl_init_referenced_generators+0xf8>)
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    e646:	7719      	strb	r1, [r3, #28]
	((Oscctrl *)hw)->DFLLMUL.reg = data;
    e648:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline bool hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    e64a:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
#endif

	hri_oscctrl_write_DFLLMUL_reg(hw,
	                              OSCCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | OSCCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | OSCCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	while (hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(hw))
    e64e:	f3c2 1100 	ubfx	r1, r2, #4, #1
    e652:	06d2      	lsls	r2, r2, #27
    e654:	d4f9      	bmi.n	e64a <_oscctrl_init_referenced_generators+0x2a>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    e656:	f883 1020 	strb.w	r1, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    e65a:	4b2e      	ldr	r3, [pc, #184]	; (e714 <_oscctrl_init_referenced_generators+0xf4>)
    e65c:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
		;

	hri_oscctrl_write_DFLLCTRLB_reg(hw, 0);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    e660:	0750      	lsls	r0, r2, #29
    e662:	d4fb      	bmi.n	e65c <_oscctrl_init_referenced_generators+0x3c>
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    e664:	2202      	movs	r2, #2
    e666:	771a      	strb	r2, [r3, #28]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    e668:	4b2a      	ldr	r3, [pc, #168]	; (e714 <_oscctrl_init_referenced_generators+0xf4>)
    e66a:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
		;

	tmp = (CONF_DFLL_RUNSTDBY << OSCCTRL_DFLLCTRLA_RUNSTDBY_Pos) | OSCCTRL_DFLLCTRLA_ENABLE;
	hri_oscctrl_write_DFLLCTRLA_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_ENABLE_bit(hw))
    e66e:	0791      	lsls	r1, r2, #30
    e670:	d4fb      	bmi.n	e66a <_oscctrl_init_referenced_generators+0x4a>
	return ((Oscctrl *)hw)->DFLLVAL.reg;
    e672:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	((Oscctrl *)hw)->DFLLVAL.reg = data;
    e674:	625a      	str	r2, [r3, #36]	; 0x24
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    e676:	4b27      	ldr	r3, [pc, #156]	; (e714 <_oscctrl_init_referenced_generators+0xf4>)
    e678:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c

#if CONF_DFLL_OVERWRITE_CALIBRATION == 1
	hri_oscctrl_write_DFLLVAL_reg(hw, OSCCTRL_DFLLVAL_COARSE(CONF_DFLL_COARSE) | OSCCTRL_DFLLVAL_FINE(CONF_DFLL_FINE));
#endif
	hri_oscctrl_write_DFLLVAL_reg(hw, hri_oscctrl_read_DFLLVAL_reg(hw));
	while (hri_oscctrl_get_DFLLSYNC_DFLLVAL_bit(hw))
    e67c:	0712      	lsls	r2, r2, #28
    e67e:	d4fb      	bmi.n	e678 <_oscctrl_init_referenced_generators+0x58>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    e680:	2288      	movs	r2, #136	; 0x88
    e682:	f883 2020 	strb.w	r2, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    e686:	4a23      	ldr	r2, [pc, #140]	; (e714 <_oscctrl_init_referenced_generators+0xf4>)
    e688:	4613      	mov	r3, r2
    e68a:	f892 102c 	ldrb.w	r1, [r2, #44]	; 0x2c
	tmp = (CONF_DFLL_WAITLOCK << OSCCTRL_DFLLCTRLB_WAITLOCK_Pos) | (CONF_DFLL_BPLCKC << OSCCTRL_DFLLCTRLB_BPLCKC_Pos)
	      | (CONF_DFLL_QLDIS << OSCCTRL_DFLLCTRLB_QLDIS_Pos) | (CONF_DFLL_CCDIS << OSCCTRL_DFLLCTRLB_CCDIS_Pos)
	      | (CONF_DFLL_USBCRM << OSCCTRL_DFLLCTRLB_USBCRM_Pos) | (CONF_DFLL_LLAW << OSCCTRL_DFLLCTRLB_LLAW_Pos)
	      | (CONF_DFLL_STABLE << OSCCTRL_DFLLCTRLB_STABLE_Pos) | (CONF_DFLL_MODE << OSCCTRL_DFLLCTRLB_MODE_Pos) | 0;
	hri_oscctrl_write_DFLLCTRLB_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    e68e:	0748      	lsls	r0, r1, #29
    e690:	d4fb      	bmi.n	e68a <_oscctrl_init_referenced_generators+0x6a>
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    e692:	491f      	ldr	r1, [pc, #124]	; (e710 <_oscctrl_init_referenced_generators+0xf0>)
    e694:	2042      	movs	r0, #66	; 0x42
    e696:	f8c1 0088 	str.w	r0, [r1, #136]	; 0x88
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLRATIO.reg = data;
    e69a:	2127      	movs	r1, #39	; 0x27
    e69c:	6491      	str	r1, [r2, #72]	; 0x48
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    e69e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    e6a0:	f012 0f06 	tst.w	r2, #6
    e6a4:	d1fb      	bne.n	e69e <_oscctrl_init_referenced_generators+0x7e>
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLB.reg = data;
    e6a6:	f44f 6200 	mov.w	r2, #2048	; 0x800
    e6aa:	64da      	str	r2, [r3, #76]	; 0x4c
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLA.reg = data;
    e6ac:	2202      	movs	r2, #2
    e6ae:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    e6b2:	4b18      	ldr	r3, [pc, #96]	; (e714 <_oscctrl_init_referenced_generators+0xf4>)
    e6b4:	461a      	mov	r2, r3
    e6b6:	6d19      	ldr	r1, [r3, #80]	; 0x50
    e6b8:	0789      	lsls	r1, r1, #30
    e6ba:	d4fc      	bmi.n	e6b6 <_oscctrl_init_referenced_generators+0x96>
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    e6bc:	f893 3020 	ldrb.w	r3, [r3, #32]
	                                (CONF_FDPLL1_RUNSTDBY << OSCCTRL_DPLLCTRLA_RUNSTDBY_Pos)
	                                    | (CONF_FDPLL1_ENABLE << OSCCTRL_DPLLCTRLA_ENABLE_Pos));
#endif

#if CONF_DFLL_CONFIG == 1
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(hw)) {
    e6c0:	07db      	lsls	r3, r3, #31
    e6c2:	d521      	bpl.n	e708 <_oscctrl_init_referenced_generators+0xe8>
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    e6c4:	6913      	ldr	r3, [r2, #16]
	tmp &= mask;
    e6c6:	f403 6310 	and.w	r3, r3, #2304	; 0x900
		hri_oscctrl_status_reg_t status_mask = OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC;

		while (hri_oscctrl_get_STATUS_reg(hw, status_mask) != status_mask)
    e6ca:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    e6ce:	d1f9      	bne.n	e6c4 <_oscctrl_init_referenced_generators+0xa4>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_LOCK)
    e6d0:	4b10      	ldr	r3, [pc, #64]	; (e714 <_oscctrl_init_referenced_generators+0xf4>)
    e6d2:	6d5a      	ldr	r2, [r3, #84]	; 0x54
#endif
#endif

#if CONF_FDPLL1_CONFIG == 1
#if CONF_FDPLL1_ENABLE == 1
	while (!(hri_oscctrl_get_DPLLSTATUS_LOCK_bit(hw, 1) || hri_oscctrl_get_DPLLSTATUS_CLKRDY_bit(hw, 1)))
    e6d4:	07d1      	lsls	r1, r2, #31
    e6d6:	d402      	bmi.n	e6de <_oscctrl_init_referenced_generators+0xbe>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_CLKRDY)
    e6d8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    e6da:	0792      	lsls	r2, r2, #30
    e6dc:	d5f9      	bpl.n	e6d2 <_oscctrl_init_referenced_generators+0xb2>
	return ((Gclk *)hw)->SYNCBUSY.reg;
    e6de:	4a0c      	ldr	r2, [pc, #48]	; (e710 <_oscctrl_init_referenced_generators+0xf0>)
    e6e0:	4611      	mov	r1, r2
    e6e2:	6853      	ldr	r3, [r2, #4]
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw, 1);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_read_SYNCBUSY_reg(GCLK))
    e6e4:	2b00      	cmp	r3, #0
    e6e6:	d1fc      	bne.n	e6e2 <_oscctrl_init_referenced_generators+0xc2>
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    e6e8:	6a13      	ldr	r3, [r2, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    e6ea:	f023 030f 	bic.w	r3, r3, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    e6ee:	f043 0308 	orr.w	r3, r3, #8
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    e6f2:	6213      	str	r3, [r2, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    e6f4:	f643 73fd 	movw	r3, #16381	; 0x3ffd
    e6f8:	684a      	ldr	r2, [r1, #4]
    e6fa:	421a      	tst	r2, r3
    e6fc:	d1fc      	bne.n	e6f8 <_oscctrl_init_referenced_generators+0xd8>
	return (((Gclk *)hw)->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL0) >> GCLK_SYNCBUSY_GENCTRL0_Pos;
    e6fe:	4a04      	ldr	r2, [pc, #16]	; (e710 <_oscctrl_init_referenced_generators+0xf0>)
    e700:	6853      	ldr	r3, [r2, #4]
		;
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, CONF_GCLK_GEN_0_SOURCE);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    e702:	075b      	lsls	r3, r3, #29
    e704:	d4fc      	bmi.n	e700 <_oscctrl_init_referenced_generators+0xe0>
		;
#endif
	(void)hw;
}
    e706:	4770      	bx	lr
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_DFLLRDY) >> OSCCTRL_STATUS_DFLLRDY_Pos;
    e708:	6913      	ldr	r3, [r2, #16]
		while (!hri_oscctrl_get_STATUS_DFLLRDY_bit(hw))
    e70a:	05d8      	lsls	r0, r3, #23
    e70c:	d5fc      	bpl.n	e708 <_oscctrl_init_referenced_generators+0xe8>
    e70e:	e7df      	b.n	e6d0 <_oscctrl_init_referenced_generators+0xb0>
    e710:	40001c00 	.word	0x40001c00
    e714:	40001000 	.word	0x40001000
    e718:	04010000 	.word	0x04010000

0000e71c <_rand_sync_read_data>:

/**
 * \brief Read data bits
 */
static uint32_t _rand_sync_read_data(const struct _rand_sync_dev *dev, const uint8_t n_bits)
{
    e71c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t r_bits = (dev->n_bits < 1) ? 32 : dev->n_bits;
    e720:	f890 8004 	ldrb.w	r8, [r0, #4]
    e724:	f8df 9034 	ldr.w	r9, [pc, #52]	; e75c <_rand_sync_read_data+0x40>
{
    e728:	4605      	mov	r5, r0
    e72a:	460f      	mov	r7, r1
	uint8_t r_bits = (dev->n_bits < 1) ? 32 : dev->n_bits;
    e72c:	f1b8 0f00 	cmp.w	r8, #0
    e730:	d00f      	beq.n	e752 <_rand_sync_read_data+0x36>
	if (r_bits < n_bits) {
    e732:	4588      	cmp	r8, r1
    e734:	d20d      	bcs.n	e752 <_rand_sync_read_data+0x36>
		uint8_t  i;
		uint32_t d = 0;
    e736:	2600      	movs	r6, #0
		/* Join read bits */
		for (i = 0; i < n_bits; i += r_bits) {
    e738:	4634      	mov	r4, r6
			d |= (uint32_t)(_rand_sync_read_one(dev) << i);
    e73a:	4628      	mov	r0, r5
    e73c:	47c8      	blx	r9
    e73e:	40a0      	lsls	r0, r4
		for (i = 0; i < n_bits; i += r_bits) {
    e740:	4444      	add	r4, r8
    e742:	b2e4      	uxtb	r4, r4
    e744:	42a7      	cmp	r7, r4
			d |= (uint32_t)(_rand_sync_read_one(dev) << i);
    e746:	ea46 0600 	orr.w	r6, r6, r0
		for (i = 0; i < n_bits; i += r_bits) {
    e74a:	d8f6      	bhi.n	e73a <_rand_sync_read_data+0x1e>
		}
		return d;
	} else {
		return _rand_sync_read_one(dev);
	}
}
    e74c:	4630      	mov	r0, r6
    e74e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return _rand_sync_read_one(dev);
    e752:	4628      	mov	r0, r5
    e754:	464b      	mov	r3, r9
}
    e756:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		return _rand_sync_read_one(dev);
    e75a:	4718      	bx	r3
    e75c:	0000e861 	.word	0x0000e861

0000e760 <rand_sync_init>:
{
    e760:	b570      	push	{r4, r5, r6, lr}
	ASSERT(desc);
    e762:	4604      	mov	r4, r0
    e764:	3800      	subs	r0, #0
{
    e766:	460d      	mov	r5, r1
	ASSERT(desc);
    e768:	4b05      	ldr	r3, [pc, #20]	; (e780 <rand_sync_init+0x20>)
    e76a:	4906      	ldr	r1, [pc, #24]	; (e784 <rand_sync_init+0x24>)
    e76c:	bf18      	it	ne
    e76e:	2001      	movne	r0, #1
    e770:	2229      	movs	r2, #41	; 0x29
    e772:	4798      	blx	r3
	return _rand_sync_init(&desc->dev, hw);
    e774:	4629      	mov	r1, r5
    e776:	4620      	mov	r0, r4
    e778:	4b03      	ldr	r3, [pc, #12]	; (e788 <rand_sync_init+0x28>)
}
    e77a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _rand_sync_init(&desc->dev, hw);
    e77e:	4718      	bx	r3
    e780:	0000e03d 	.word	0x0000e03d
    e784:	0001641f 	.word	0x0001641f
    e788:	0000e7e1 	.word	0x0000e7e1

0000e78c <rand_sync_enable>:
{
    e78c:	b510      	push	{r4, lr}
	ASSERT(desc);
    e78e:	4604      	mov	r4, r0
    e790:	3800      	subs	r0, #0
    e792:	4b05      	ldr	r3, [pc, #20]	; (e7a8 <rand_sync_enable+0x1c>)
    e794:	4905      	ldr	r1, [pc, #20]	; (e7ac <rand_sync_enable+0x20>)
    e796:	bf18      	it	ne
    e798:	2001      	movne	r0, #1
    e79a:	2236      	movs	r2, #54	; 0x36
    e79c:	4798      	blx	r3
	return _rand_sync_enable(&desc->dev);
    e79e:	4620      	mov	r0, r4
    e7a0:	4b03      	ldr	r3, [pc, #12]	; (e7b0 <rand_sync_enable+0x24>)
}
    e7a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _rand_sync_enable(&desc->dev);
    e7a6:	4718      	bx	r3
    e7a8:	0000e03d 	.word	0x0000e03d
    e7ac:	0001641f 	.word	0x0001641f
    e7b0:	0000e829 	.word	0x0000e829

0000e7b4 <rand_sync_read8>:

uint8_t rand_sync_read8(const struct rand_sync_desc *const desc)
{
    e7b4:	b510      	push	{r4, lr}
	ASSERT(desc);
    e7b6:	4604      	mov	r4, r0
    e7b8:	3800      	subs	r0, #0
    e7ba:	bf18      	it	ne
    e7bc:	2001      	movne	r0, #1
    e7be:	225b      	movs	r2, #91	; 0x5b
    e7c0:	4904      	ldr	r1, [pc, #16]	; (e7d4 <rand_sync_read8+0x20>)
    e7c2:	4b05      	ldr	r3, [pc, #20]	; (e7d8 <rand_sync_read8+0x24>)
    e7c4:	4798      	blx	r3
	return (uint8_t)_rand_sync_read_data(&desc->dev, 8);
    e7c6:	4b05      	ldr	r3, [pc, #20]	; (e7dc <rand_sync_read8+0x28>)
    e7c8:	2108      	movs	r1, #8
    e7ca:	4620      	mov	r0, r4
    e7cc:	4798      	blx	r3
}
    e7ce:	b2c0      	uxtb	r0, r0
    e7d0:	bd10      	pop	{r4, pc}
    e7d2:	bf00      	nop
    e7d4:	0001641f 	.word	0x0001641f
    e7d8:	0000e03d 	.word	0x0000e03d
    e7dc:	0000e71d 	.word	0x0000e71d

0000e7e0 <_rand_sync_init>:
	}
	return ERR_NONE;
}

int32_t _rand_sync_init(struct _rand_sync_dev *const dev, void *const hw)
{
    e7e0:	b538      	push	{r3, r4, r5, lr}
    e7e2:	460c      	mov	r4, r1
	int32_t rc;

	ASSERT(dev && hw);
    e7e4:	4605      	mov	r5, r0
    e7e6:	b110      	cbz	r0, e7ee <_rand_sync_init+0xe>
    e7e8:	1e08      	subs	r0, r1, #0
    e7ea:	bf18      	it	ne
    e7ec:	2001      	movne	r0, #1
    e7ee:	4b0c      	ldr	r3, [pc, #48]	; (e820 <_rand_sync_init+0x40>)
    e7f0:	490c      	ldr	r1, [pc, #48]	; (e824 <_rand_sync_init+0x44>)
    e7f2:	223d      	movs	r2, #61	; 0x3d
    e7f4:	4798      	blx	r3
}

static inline hri_trng_ctrla_reg_t hri_trng_get_CTRLA_reg(const void *const hw, hri_trng_ctrla_reg_t mask)
{
	uint8_t tmp;
	tmp = ((Trng *)hw)->CTRLA.reg;
    e7f6:	7823      	ldrb	r3, [r4, #0]
	if (hri_trng_get_CTRLA_reg(hw, TRNG_CTRLA_ENABLE)) {
    e7f8:	f013 0302 	ands.w	r3, r3, #2
    e7fc:	d10c      	bne.n	e818 <_rand_sync_init+0x38>
	((Trng *)hw)->CTRLA.reg &= ~TRNG_CTRLA_RUNSTDBY;
    e7fe:	7822      	ldrb	r2, [r4, #0]
    e800:	f002 02bf 	and.w	r2, r2, #191	; 0xbf
    e804:	7022      	strb	r2, [r4, #0]
}

static inline void hri_trng_clear_EVCTRL_DATARDYEO_bit(const void *const hw)
{
	TRNG_CRITICAL_SECTION_ENTER();
	((Trng *)hw)->EVCTRL.reg &= ~TRNG_EVCTRL_DATARDYEO;
    e806:	7922      	ldrb	r2, [r4, #4]
    e808:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    e80c:	7122      	strb	r2, [r4, #4]

	rc = _trng_init(hw);
	if (rc == ERR_NONE) {
		dev->prvt   = hw;
		dev->n_bits = 32;
    e80e:	2220      	movs	r2, #32
		dev->prvt   = hw;
    e810:	602c      	str	r4, [r5, #0]
		dev->n_bits = 32;
    e812:	712a      	strb	r2, [r5, #4]
	return ERR_NONE;
    e814:	4618      	mov	r0, r3
	}
	return rc;
}
    e816:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_DENIED;
    e818:	f06f 0010 	mvn.w	r0, #16
	return rc;
    e81c:	e7fb      	b.n	e816 <_rand_sync_init+0x36>
    e81e:	bf00      	nop
    e820:	0000e03d 	.word	0x0000e03d
    e824:	0001643a 	.word	0x0001643a

0000e828 <_rand_sync_enable>:
{
	_rand_sync_disable(dev);
}

int32_t _rand_sync_enable(struct _rand_sync_dev *const dev)
{
    e828:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev);
    e82a:	4604      	mov	r4, r0
    e82c:	3800      	subs	r0, #0
    e82e:	bf18      	it	ne
    e830:	2001      	movne	r0, #1
    e832:	4d09      	ldr	r5, [pc, #36]	; (e858 <_rand_sync_enable+0x30>)
    e834:	4909      	ldr	r1, [pc, #36]	; (e85c <_rand_sync_enable+0x34>)
    e836:	224e      	movs	r2, #78	; 0x4e
    e838:	47a8      	blx	r5
	ASSERT(dev->prvt);
    e83a:	6820      	ldr	r0, [r4, #0]
    e83c:	4907      	ldr	r1, [pc, #28]	; (e85c <_rand_sync_enable+0x34>)
    e83e:	3800      	subs	r0, #0
    e840:	bf18      	it	ne
    e842:	2001      	movne	r0, #1
    e844:	224f      	movs	r2, #79	; 0x4f
    e846:	47a8      	blx	r5

	hri_trng_set_CTRLA_ENABLE_bit(dev->prvt);
    e848:	6822      	ldr	r2, [r4, #0]
	((Trng *)hw)->CTRLA.reg |= TRNG_CTRLA_ENABLE;
    e84a:	7813      	ldrb	r3, [r2, #0]
    e84c:	f043 0302 	orr.w	r3, r3, #2
    e850:	7013      	strb	r3, [r2, #0]
	return ERR_NONE;
}
    e852:	2000      	movs	r0, #0
    e854:	bd38      	pop	{r3, r4, r5, pc}
    e856:	bf00      	nop
    e858:	0000e03d 	.word	0x0000e03d
    e85c:	0001643a 	.word	0x0001643a

0000e860 <_rand_sync_read_one>:
	(void)seed;
	return ERR_UNSUPPORTED_OP;
}

uint32_t _rand_sync_read_one(const struct _rand_sync_dev *const dev)
{
    e860:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev);
    e862:	4604      	mov	r4, r0
    e864:	3800      	subs	r0, #0
    e866:	4d0d      	ldr	r5, [pc, #52]	; (e89c <_rand_sync_read_one+0x3c>)
    e868:	490d      	ldr	r1, [pc, #52]	; (e8a0 <_rand_sync_read_one+0x40>)
    e86a:	bf18      	it	ne
    e86c:	2001      	movne	r0, #1
    e86e:	2266      	movs	r2, #102	; 0x66
    e870:	47a8      	blx	r5
	ASSERT(dev->prvt);
    e872:	6820      	ldr	r0, [r4, #0]
    e874:	490a      	ldr	r1, [pc, #40]	; (e8a0 <_rand_sync_read_one+0x40>)
    e876:	3800      	subs	r0, #0
    e878:	bf18      	it	ne
    e87a:	2001      	movne	r0, #1
    e87c:	2267      	movs	r2, #103	; 0x67
    e87e:	47a8      	blx	r5
	ASSERT(hri_trng_get_CTRLA_reg(dev->prvt, TRNG_CTRLA_ENABLE));
    e880:	6823      	ldr	r3, [r4, #0]
    e882:	4907      	ldr	r1, [pc, #28]	; (e8a0 <_rand_sync_read_one+0x40>)
	tmp = ((Trng *)hw)->CTRLA.reg;
    e884:	7818      	ldrb	r0, [r3, #0]
    e886:	2268      	movs	r2, #104	; 0x68
    e888:	f3c0 0040 	ubfx	r0, r0, #1, #1
    e88c:	47a8      	blx	r5

	while (!hri_trng_get_INTFLAG_reg(dev->prvt, TRNG_INTFLAG_DATARDY)) {
    e88e:	6823      	ldr	r3, [r4, #0]
	tmp = ((Trng *)hw)->INTFLAG.reg;
    e890:	7a9a      	ldrb	r2, [r3, #10]
    e892:	07d2      	lsls	r2, r2, #31
    e894:	d5fc      	bpl.n	e890 <_rand_sync_read_one+0x30>
	return ((Trng *)hw)->DATA.reg;
    e896:	6a18      	ldr	r0, [r3, #32]
		/* Wait until data ready. */
	}
	return hri_trng_read_DATA_reg(dev->prvt);
}
    e898:	bd38      	pop	{r3, r4, r5, pc}
    e89a:	bf00      	nop
    e89c:	0000e03d 	.word	0x0000e03d
    e8a0:	0001643a 	.word	0x0001643a

0000e8a4 <hid_keyboard_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t hid_keyboard_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    e8a4:	b430      	push	{r4, r5}
	if ((0x81 == req->bmRequestType) && (0x06 == req->bRequest) && (req->wIndex == _hiddf_keyboard_funcd.func_iface)) {
    e8a6:	780a      	ldrb	r2, [r1, #0]
    e8a8:	2a81      	cmp	r2, #129	; 0x81
    e8aa:	d11c      	bne.n	e8e6 <hid_keyboard_req+0x42>
    e8ac:	784b      	ldrb	r3, [r1, #1]
    e8ae:	2b06      	cmp	r3, #6
    e8b0:	d131      	bne.n	e916 <hid_keyboard_req+0x72>
    e8b2:	4a1a      	ldr	r2, [pc, #104]	; (e91c <hid_keyboard_req+0x78>)
    e8b4:	888c      	ldrh	r4, [r1, #4]
    e8b6:	7b13      	ldrb	r3, [r2, #12]
    e8b8:	429c      	cmp	r4, r3
    e8ba:	d12c      	bne.n	e916 <hid_keyboard_req+0x72>
	switch (req->wValue >> 8) {
    e8bc:	884b      	ldrh	r3, [r1, #2]
    e8be:	0a1b      	lsrs	r3, r3, #8
    e8c0:	2b21      	cmp	r3, #33	; 0x21
    e8c2:	d005      	beq.n	e8d0 <hid_keyboard_req+0x2c>
    e8c4:	2b22      	cmp	r3, #34	; 0x22
    e8c6:	d00a      	beq.n	e8de <hid_keyboard_req+0x3a>
	} else {
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
			return ERR_NOT_FOUND;
		}
		if (req->wIndex == _hiddf_keyboard_funcd.func_iface) {
			switch (req->bRequest) {
    e8c8:	f06f 000c 	mvn.w	r0, #12
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    e8cc:	bc30      	pop	{r4, r5}
    e8ce:	4770      	bx	lr
		return usbdc_xfer(ep, _hiddf_keyboard_funcd.hid_desc, _hiddf_keyboard_funcd.hid_desc[0], false);
    e8d0:	6811      	ldr	r1, [r2, #0]
    e8d2:	780a      	ldrb	r2, [r1, #0]
    e8d4:	2300      	movs	r3, #0
				return usbdc_xfer(ep, NULL, 0, 0);
    e8d6:	4c12      	ldr	r4, [pc, #72]	; (e920 <hid_keyboard_req+0x7c>)
    e8d8:	46a4      	mov	ip, r4
}
    e8da:	bc30      	pop	{r4, r5}
				return usbdc_xfer(ep, NULL, 0, 0);
    e8dc:	4760      	bx	ip
		return usbdc_xfer(ep, (uint8_t *)keyboard_report_desc, KEYBOARD_REPORT_DESC_LEN, false);
    e8de:	4911      	ldr	r1, [pc, #68]	; (e924 <hid_keyboard_req+0x80>)
    e8e0:	2300      	movs	r3, #0
    e8e2:	223b      	movs	r2, #59	; 0x3b
    e8e4:	e7f7      	b.n	e8d6 <hid_keyboard_req+0x32>
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    e8e6:	f3c2 1241 	ubfx	r2, r2, #5, #2
    e8ea:	2a01      	cmp	r2, #1
    e8ec:	d113      	bne.n	e916 <hid_keyboard_req+0x72>
		if (req->wIndex == _hiddf_keyboard_funcd.func_iface) {
    e8ee:	4c0b      	ldr	r4, [pc, #44]	; (e91c <hid_keyboard_req+0x78>)
    e8f0:	888d      	ldrh	r5, [r1, #4]
    e8f2:	7b23      	ldrb	r3, [r4, #12]
    e8f4:	429d      	cmp	r5, r3
    e8f6:	d10e      	bne.n	e916 <hid_keyboard_req+0x72>
			switch (req->bRequest) {
    e8f8:	784b      	ldrb	r3, [r1, #1]
    e8fa:	2b03      	cmp	r3, #3
    e8fc:	d007      	beq.n	e90e <hid_keyboard_req+0x6a>
    e8fe:	2b0b      	cmp	r3, #11
    e900:	d1e2      	bne.n	e8c8 <hid_keyboard_req+0x24>
				_hiddf_keyboard_funcd.protocol = req->wValue;
    e902:	884b      	ldrh	r3, [r1, #2]
    e904:	73e3      	strb	r3, [r4, #15]
				return usbdc_xfer(ep, NULL, 0, 0);
    e906:	2300      	movs	r3, #0
    e908:	461a      	mov	r2, r3
    e90a:	4619      	mov	r1, r3
    e90c:	e7e3      	b.n	e8d6 <hid_keyboard_req+0x32>
				return usbdc_xfer(ep, &_hiddf_keyboard_funcd.protocol, 1, 0);
    e90e:	2300      	movs	r3, #0
    e910:	f104 010f 	add.w	r1, r4, #15
    e914:	e7df      	b.n	e8d6 <hid_keyboard_req+0x32>
			return ERR_NOT_FOUND;
    e916:	f06f 0009 	mvn.w	r0, #9
	(void)stage;
    e91a:	e7d7      	b.n	e8cc <hid_keyboard_req+0x28>
    e91c:	20008b40 	.word	0x20008b40
    e920:	0001323d 	.word	0x0001323d
    e924:	00016451 	.word	0x00016451

0000e928 <hid_keyboard_ctrl>:
	switch (ctrl) {
    e928:	2901      	cmp	r1, #1
{
    e92a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e92e:	4615      	mov	r5, r2
	switch (ctrl) {
    e930:	d04b      	beq.n	e9ca <hid_keyboard_ctrl+0xa2>
    e932:	2902      	cmp	r1, #2
    e934:	d066      	beq.n	ea04 <hid_keyboard_ctrl+0xdc>
    e936:	2900      	cmp	r1, #0
    e938:	d167      	bne.n	ea0a <hid_keyboard_ctrl+0xe2>
	ifc = desc->sod;
    e93a:	6813      	ldr	r3, [r2, #0]
		return hid_keyboard_enable(drv, (struct usbd_descriptors *)param);
    e93c:	f8d0 8008 	ldr.w	r8, [r0, #8]
	if (NULL == ifc) {
    e940:	b923      	cbnz	r3, e94c <hid_keyboard_ctrl+0x24>
		return ERR_NOT_FOUND;
    e942:	f06f 0409 	mvn.w	r4, #9
}
    e946:	4620      	mov	r0, r4
    e948:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    e94c:	7959      	ldrb	r1, [r3, #5]
	ifc_desc.bInterfaceNumber = ifc[2];
    e94e:	789a      	ldrb	r2, [r3, #2]
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    e950:	2903      	cmp	r1, #3
    e952:	d1f6      	bne.n	e942 <hid_keyboard_ctrl+0x1a>
		if (func_data->func_iface == ifc_desc.bInterfaceNumber) { // Initialized
    e954:	f898 100c 	ldrb.w	r1, [r8, #12]
    e958:	428a      	cmp	r2, r1
    e95a:	d059      	beq.n	ea10 <hid_keyboard_ctrl+0xe8>
		} else if (func_data->func_iface != 0xFF) { // Occupied
    e95c:	29ff      	cmp	r1, #255	; 0xff
    e95e:	d15a      	bne.n	ea16 <hid_keyboard_ctrl+0xee>
			func_data->func_iface = ifc_desc.bInterfaceNumber;
    e960:	f888 200c 	strb.w	r2, [r8, #12]
	return (desc + usb_desc_len(desc));
    e964:	7818      	ldrb	r0, [r3, #0]
	_hiddf_keyboard_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    e966:	6869      	ldr	r1, [r5, #4]
    e968:	4e2e      	ldr	r6, [pc, #184]	; (ea24 <hid_keyboard_ctrl+0xfc>)
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    e96a:	f8df b0c8 	ldr.w	fp, [pc, #200]	; ea34 <hid_keyboard_ctrl+0x10c>
    e96e:	f8df 90c8 	ldr.w	r9, [pc, #200]	; ea38 <hid_keyboard_ctrl+0x110>
	_hiddf_keyboard_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    e972:	4418      	add	r0, r3
    e974:	2221      	movs	r2, #33	; 0x21
    e976:	4b2c      	ldr	r3, [pc, #176]	; (ea28 <hid_keyboard_ctrl+0x100>)
    e978:	4798      	blx	r3
    e97a:	2702      	movs	r7, #2
    e97c:	6030      	str	r0, [r6, #0]
		ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    e97e:	682b      	ldr	r3, [r5, #0]
    e980:	6869      	ldr	r1, [r5, #4]
    e982:	7818      	ldrb	r0, [r3, #0]
    e984:	4418      	add	r0, r3
    e986:	4b29      	ldr	r3, [pc, #164]	; (ea2c <hid_keyboard_ctrl+0x104>)
    e988:	4798      	blx	r3
		desc->sod = ep;
    e98a:	6028      	str	r0, [r5, #0]
		if (NULL != ep) {
    e98c:	2800      	cmp	r0, #0
    e98e:	d0d8      	beq.n	e942 <hid_keyboard_ctrl+0x1a>
	return (ptr[0] + (ptr[1] << 8));
    e990:	7941      	ldrb	r1, [r0, #5]
    e992:	7902      	ldrb	r2, [r0, #4]
			ep_desc.bEndpointAddress = ep[2];
    e994:	f890 a002 	ldrb.w	sl, [r0, #2]
    e998:	eb02 2201 	add.w	r2, r2, r1, lsl #8
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    e99c:	b292      	uxth	r2, r2
    e99e:	78c1      	ldrb	r1, [r0, #3]
    e9a0:	4650      	mov	r0, sl
    e9a2:	47d8      	blx	fp
    e9a4:	4604      	mov	r4, r0
    e9a6:	2800      	cmp	r0, #0
    e9a8:	d138      	bne.n	ea1c <hid_keyboard_ctrl+0xf4>
			if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    e9aa:	f01a 0f80 	tst.w	sl, #128	; 0x80
				func_data->func_ep_in = ep_desc.bEndpointAddress;
    e9ae:	bf14      	ite	ne
    e9b0:	f888 a00d 	strbne.w	sl, [r8, #13]
				func_data->func_ep_out = ep_desc.bEndpointAddress;
    e9b4:	f888 a00e 	strbeq.w	sl, [r8, #14]
				usb_d_ep_enable(func_data->func_ep_out);
    e9b8:	4650      	mov	r0, sl
    e9ba:	47c8      	blx	r9
	for (i = 0; i < 2; i++) {
    e9bc:	2f01      	cmp	r7, #1
    e9be:	d102      	bne.n	e9c6 <hid_keyboard_ctrl+0x9e>
	_hiddf_keyboard_funcd.protocol = 1;
    e9c0:	73f7      	strb	r7, [r6, #15]
	_hiddf_keyboard_funcd.enabled  = true;
    e9c2:	7437      	strb	r7, [r6, #16]
	return ERR_NONE;
    e9c4:	e7bf      	b.n	e946 <hid_keyboard_ctrl+0x1e>
    e9c6:	2701      	movs	r7, #1
    e9c8:	e7d9      	b.n	e97e <hid_keyboard_ctrl+0x56>
		return hid_keyboard_disable(drv, (struct usbd_descriptors *)param);
    e9ca:	6884      	ldr	r4, [r0, #8]
	if (desc) {
    e9cc:	b11a      	cbz	r2, e9d6 <hid_keyboard_ctrl+0xae>
		ifc_desc.bInterfaceClass = desc->sod[5];
    e9ce:	6813      	ldr	r3, [r2, #0]
		if (ifc_desc.bInterfaceClass != HID_CLASS) {
    e9d0:	795b      	ldrb	r3, [r3, #5]
    e9d2:	2b03      	cmp	r3, #3
    e9d4:	d1b5      	bne.n	e942 <hid_keyboard_ctrl+0x1a>
	if (func_data->func_iface != 0xFF) {
    e9d6:	7b23      	ldrb	r3, [r4, #12]
	if (func_data->func_ep_in != 0xFF) {
    e9d8:	7b60      	ldrb	r0, [r4, #13]
	if (func_data->func_iface != 0xFF) {
    e9da:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface = 0xFF;
    e9dc:	bf1c      	itt	ne
    e9de:	23ff      	movne	r3, #255	; 0xff
    e9e0:	7323      	strbne	r3, [r4, #12]
	if (func_data->func_ep_in != 0xFF) {
    e9e2:	28ff      	cmp	r0, #255	; 0xff
    e9e4:	d003      	beq.n	e9ee <hid_keyboard_ctrl+0xc6>
		usb_d_ep_deinit(func_data->func_ep_in);
    e9e6:	4b12      	ldr	r3, [pc, #72]	; (ea30 <hid_keyboard_ctrl+0x108>)
    e9e8:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    e9ea:	23ff      	movs	r3, #255	; 0xff
    e9ec:	7363      	strb	r3, [r4, #13]
	if (func_data->func_ep_out != 0xFF) {
    e9ee:	7ba0      	ldrb	r0, [r4, #14]
    e9f0:	28ff      	cmp	r0, #255	; 0xff
    e9f2:	d003      	beq.n	e9fc <hid_keyboard_ctrl+0xd4>
		usb_d_ep_deinit(func_data->func_ep_out);
    e9f4:	4b0e      	ldr	r3, [pc, #56]	; (ea30 <hid_keyboard_ctrl+0x108>)
    e9f6:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    e9f8:	23ff      	movs	r3, #255	; 0xff
    e9fa:	73a3      	strb	r3, [r4, #14]
	_hiddf_keyboard_funcd.enabled = false;
    e9fc:	4b09      	ldr	r3, [pc, #36]	; (ea24 <hid_keyboard_ctrl+0xfc>)
    e9fe:	2400      	movs	r4, #0
    ea00:	741c      	strb	r4, [r3, #16]
	return ERR_NONE;
    ea02:	e7a0      	b.n	e946 <hid_keyboard_ctrl+0x1e>
		return ERR_UNSUPPORTED_OP;
    ea04:	f06f 041a 	mvn.w	r4, #26
    ea08:	e79d      	b.n	e946 <hid_keyboard_ctrl+0x1e>
	switch (ctrl) {
    ea0a:	f06f 040c 	mvn.w	r4, #12
    ea0e:	e79a      	b.n	e946 <hid_keyboard_ctrl+0x1e>
			return ERR_ALREADY_INITIALIZED;
    ea10:	f06f 0411 	mvn.w	r4, #17
    ea14:	e797      	b.n	e946 <hid_keyboard_ctrl+0x1e>
			return ERR_NO_RESOURCE;
    ea16:	f06f 041b 	mvn.w	r4, #27
    ea1a:	e794      	b.n	e946 <hid_keyboard_ctrl+0x1e>
				return ERR_NOT_INITIALIZED;
    ea1c:	f06f 0413 	mvn.w	r4, #19
    ea20:	e791      	b.n	e946 <hid_keyboard_ctrl+0x1e>
    ea22:	bf00      	nop
    ea24:	20008b40 	.word	0x20008b40
    ea28:	0000b7ed 	.word	0x0000b7ed
    ea2c:	0000b807 	.word	0x0000b807
    ea30:	0000f585 	.word	0x0000f585
    ea34:	0000f521 	.word	0x0000f521
    ea38:	0000f5b1 	.word	0x0000f5b1

0000ea3c <hiddf_keyboard_init>:

/**
 * \brief Initialize the USB HID Keyboard Function Driver
 */
int32_t hiddf_keyboard_init(void)
{
    ea3c:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    ea3e:	4b0a      	ldr	r3, [pc, #40]	; (ea68 <hiddf_keyboard_init+0x2c>)
    ea40:	4798      	blx	r3
    ea42:	2801      	cmp	r0, #1
    ea44:	d80c      	bhi.n	ea60 <hiddf_keyboard_init+0x24>
		return ERR_DENIED;
	}

	_hiddf_keyboard.ctrl      = hid_keyboard_ctrl;
    ea46:	4809      	ldr	r0, [pc, #36]	; (ea6c <hiddf_keyboard_init+0x30>)
    ea48:	4b09      	ldr	r3, [pc, #36]	; (ea70 <hiddf_keyboard_init+0x34>)
	_hiddf_keyboard.func_data = &_hiddf_keyboard_funcd;
    ea4a:	e9c0 3006 	strd	r3, r0, [r0, #24]

	usbdc_register_function(&_hiddf_keyboard);
    ea4e:	4b09      	ldr	r3, [pc, #36]	; (ea74 <hiddf_keyboard_init+0x38>)
    ea50:	3014      	adds	r0, #20
    ea52:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &hid_keyboard_req_h);
    ea54:	2001      	movs	r0, #1
    ea56:	4908      	ldr	r1, [pc, #32]	; (ea78 <hiddf_keyboard_init+0x3c>)
    ea58:	4b08      	ldr	r3, [pc, #32]	; (ea7c <hiddf_keyboard_init+0x40>)
    ea5a:	4798      	blx	r3
	return ERR_NONE;
    ea5c:	2000      	movs	r0, #0
}
    ea5e:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    ea60:	f06f 0010 	mvn.w	r0, #16
    ea64:	e7fb      	b.n	ea5e <hiddf_keyboard_init+0x22>
    ea66:	bf00      	nop
    ea68:	00013675 	.word	0x00013675
    ea6c:	20008b40 	.word	0x20008b40
    ea70:	0000e929 	.word	0x0000e929
    ea74:	0001361d 	.word	0x0001361d
    ea78:	20000504 	.word	0x20000504
    ea7c:	00013595 	.word	0x00013595

0000ea80 <hiddf_keyboard_keys_state_change>:
 * \param keys_desc[]  keys_descriptor array for state changing
 * \param keys_count   total keys amount for state changing
 * \return Operation status.
 */
int32_t hiddf_keyboard_keys_state_change(struct hiddf_kb_key_descriptors keys_desc[], uint8_t keys_count)
{
    ea80:	b470      	push	{r4, r5, r6}
	return _hiddf_keyboard_funcd.enabled;
    ea82:	4c20      	ldr	r4, [pc, #128]	; (eb04 <hiddf_keyboard_keys_state_change+0x84>)
	uint8_t i, j;
	uint8_t modifier_keys, regular_keys;

	if (!hiddf_keyboard_is_enabled()) {
    ea84:	7c23      	ldrb	r3, [r4, #16]
    ea86:	2b00      	cmp	r3, #0
    ea88:	d037      	beq.n	eafa <hiddf_keyboard_keys_state_change+0x7a>
		return ERR_DENIED;
	}

	memset(_hiddf_keyboard_funcd.kb_report, 0x00, 8);
    ea8a:	2300      	movs	r3, #0
    ea8c:	e9c4 3301 	strd	r3, r3, [r4, #4]
	modifier_keys = 0;
    ea90:	461a      	mov	r2, r3

	for (i = 0; i < keys_count; i++) {
		if (true == keys_desc[i].b_modifier) {
    ea92:	1c46      	adds	r6, r0, #1
	for (i = 0; i < keys_count; i++) {
    ea94:	b2dd      	uxtb	r5, r3
    ea96:	42a9      	cmp	r1, r5
    ea98:	d814      	bhi.n	eac4 <hiddf_keyboard_keys_state_change+0x44>
			modifier_keys++;
		}
	}

	regular_keys = keys_count - modifier_keys;
    ea9a:	1a8a      	subs	r2, r1, r2

	if (regular_keys > 6) {
    ea9c:	b2d2      	uxtb	r2, r2
    ea9e:	2a06      	cmp	r2, #6
    eaa0:	d818      	bhi.n	ead4 <hiddf_keyboard_keys_state_change+0x54>
    eaa2:	2500      	movs	r5, #0
		memset(&_hiddf_keyboard_funcd.kb_report[2], 0xFF, 6);
	} else {
		i = 2;
    eaa4:	2302      	movs	r3, #2
		for (j = 0; j < keys_count; j++) {
    eaa6:	b2ea      	uxtb	r2, r5
    eaa8:	4291      	cmp	r1, r2
    eaaa:	d919      	bls.n	eae0 <hiddf_keyboard_keys_state_change+0x60>
			if (HID_KB_KEY_DOWN == keys_desc[j].state) {
    eaac:	7882      	ldrb	r2, [r0, #2]
    eaae:	2a01      	cmp	r2, #1
    eab0:	d105      	bne.n	eabe <hiddf_keyboard_keys_state_change+0x3e>
				if (true == keys_desc[j].b_modifier) {
    eab2:	7846      	ldrb	r6, [r0, #1]
    eab4:	7802      	ldrb	r2, [r0, #0]
    eab6:	b1de      	cbz	r6, eaf0 <hiddf_keyboard_keys_state_change+0x70>
					_hiddf_keyboard_funcd.kb_report[0] |= keys_desc[j].key_id;
    eab8:	7926      	ldrb	r6, [r4, #4]
    eaba:	4332      	orrs	r2, r6
    eabc:	7122      	strb	r2, [r4, #4]
		for (j = 0; j < keys_count; j++) {
    eabe:	3501      	adds	r5, #1
    eac0:	3003      	adds	r0, #3
    eac2:	e7f0      	b.n	eaa6 <hiddf_keyboard_keys_state_change+0x26>
		if (true == keys_desc[i].b_modifier) {
    eac4:	eb03 0543 	add.w	r5, r3, r3, lsl #1
    eac8:	5d75      	ldrb	r5, [r6, r5]
    eaca:	b10d      	cbz	r5, ead0 <hiddf_keyboard_keys_state_change+0x50>
			modifier_keys++;
    eacc:	3201      	adds	r2, #1
    eace:	b2d2      	uxtb	r2, r2
	for (i = 0; i < keys_count; i++) {
    ead0:	3301      	adds	r3, #1
    ead2:	e7df      	b.n	ea94 <hiddf_keyboard_keys_state_change+0x14>
		memset(&_hiddf_keyboard_funcd.kb_report[2], 0xFF, 6);
    ead4:	4a0c      	ldr	r2, [pc, #48]	; (eb08 <hiddf_keyboard_keys_state_change+0x88>)
    ead6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    eada:	f8c4 3006 	str.w	r3, [r4, #6]
    eade:	8093      	strh	r3, [r2, #4]
					_hiddf_keyboard_funcd.kb_report[i++] = keys_desc[j].key_id;
				}
			}
		}
	}
	return usbdc_xfer(_hiddf_keyboard_funcd.func_ep_in, &_hiddf_keyboard_funcd.kb_report[0], 8, false);
    eae0:	7b60      	ldrb	r0, [r4, #13]
    eae2:	4c0a      	ldr	r4, [pc, #40]	; (eb0c <hiddf_keyboard_keys_state_change+0x8c>)
    eae4:	490a      	ldr	r1, [pc, #40]	; (eb10 <hiddf_keyboard_keys_state_change+0x90>)
    eae6:	46a4      	mov	ip, r4
    eae8:	2300      	movs	r3, #0
}
    eaea:	bc70      	pop	{r4, r5, r6}
	return usbdc_xfer(_hiddf_keyboard_funcd.func_ep_in, &_hiddf_keyboard_funcd.kb_report[0], 8, false);
    eaec:	2208      	movs	r2, #8
    eaee:	4760      	bx	ip
					_hiddf_keyboard_funcd.kb_report[i++] = keys_desc[j].key_id;
    eaf0:	1c5e      	adds	r6, r3, #1
    eaf2:	4423      	add	r3, r4
    eaf4:	711a      	strb	r2, [r3, #4]
    eaf6:	b2f3      	uxtb	r3, r6
    eaf8:	e7e1      	b.n	eabe <hiddf_keyboard_keys_state_change+0x3e>
}
    eafa:	f06f 0010 	mvn.w	r0, #16
    eafe:	bc70      	pop	{r4, r5, r6}
    eb00:	4770      	bx	lr
    eb02:	bf00      	nop
    eb04:	20008b40 	.word	0x20008b40
    eb08:	20008b46 	.word	0x20008b46
    eb0c:	0001323d 	.word	0x0001323d
    eb10:	20008b44 	.word	0x20008b44

0000eb14 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    eb14:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    eb18:	460e      	mov	r6, r1
    eb1a:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    eb1c:	4604      	mov	r4, r0
    eb1e:	b118      	cbz	r0, eb28 <usart_sync_write+0x14>
    eb20:	b329      	cbz	r1, eb6e <usart_sync_write+0x5a>
    eb22:	1e10      	subs	r0, r2, #0
    eb24:	bf18      	it	ne
    eb26:	2001      	movne	r0, #1
    eb28:	4912      	ldr	r1, [pc, #72]	; (eb74 <usart_sync_write+0x60>)
    eb2a:	4b13      	ldr	r3, [pc, #76]	; (eb78 <usart_sync_write+0x64>)
	while (!_usart_sync_is_ready_to_send(&descr->device))
    eb2c:	4f13      	ldr	r7, [pc, #76]	; (eb7c <usart_sync_write+0x68>)
	ASSERT(io_descr && buf && length);
    eb2e:	22f1      	movs	r2, #241	; 0xf1
    eb30:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
    eb32:	3408      	adds	r4, #8
    eb34:	46b9      	mov	r9, r7
    eb36:	4620      	mov	r0, r4
    eb38:	47b8      	blx	r7
    eb3a:	2800      	cmp	r0, #0
    eb3c:	d0fb      	beq.n	eb36 <usart_sync_write+0x22>
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    eb3e:	f8df 8044 	ldr.w	r8, [pc, #68]	; eb84 <usart_sync_write+0x70>
	uint32_t                      offset = 0;
    eb42:	2700      	movs	r7, #0
		_usart_sync_write_byte(&descr->device, buf[offset]);
    eb44:	5df1      	ldrb	r1, [r6, r7]
    eb46:	4620      	mov	r0, r4
    eb48:	47c0      	blx	r8
		while (!_usart_sync_is_ready_to_send(&descr->device))
    eb4a:	4620      	mov	r0, r4
    eb4c:	47c8      	blx	r9
    eb4e:	2800      	cmp	r0, #0
    eb50:	d0fb      	beq.n	eb4a <usart_sync_write+0x36>
			;
	} while (++offset < length);
    eb52:	3701      	adds	r7, #1
    eb54:	42bd      	cmp	r5, r7
    eb56:	d8f5      	bhi.n	eb44 <usart_sync_write+0x30>
    eb58:	2d00      	cmp	r5, #0
	while (!_usart_sync_is_transmit_done(&descr->device))
    eb5a:	4e09      	ldr	r6, [pc, #36]	; (eb80 <usart_sync_write+0x6c>)
    eb5c:	bf08      	it	eq
    eb5e:	2501      	moveq	r5, #1
    eb60:	4620      	mov	r0, r4
    eb62:	47b0      	blx	r6
    eb64:	2800      	cmp	r0, #0
    eb66:	d0fb      	beq.n	eb60 <usart_sync_write+0x4c>
		;
	return (int32_t)offset;
}
    eb68:	4628      	mov	r0, r5
    eb6a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    eb6e:	4608      	mov	r0, r1
    eb70:	e7da      	b.n	eb28 <usart_sync_write+0x14>
    eb72:	bf00      	nop
    eb74:	0001648c 	.word	0x0001648c
    eb78:	0000e03d 	.word	0x0000e03d
    eb7c:	00011069 	.word	0x00011069
    eb80:	00011073 	.word	0x00011073
    eb84:	00011055 	.word	0x00011055

0000eb88 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    eb88:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    eb8c:	460e      	mov	r6, r1
    eb8e:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    eb90:	4604      	mov	r4, r0
    eb92:	b118      	cbz	r0, eb9c <usart_sync_read+0x14>
    eb94:	b1e9      	cbz	r1, ebd2 <usart_sync_read+0x4a>
    eb96:	1e10      	subs	r0, r2, #0
    eb98:	bf18      	it	ne
    eb9a:	2001      	movne	r0, #1
    eb9c:	490e      	ldr	r1, [pc, #56]	; (ebd8 <usart_sync_read+0x50>)
    eb9e:	4b0f      	ldr	r3, [pc, #60]	; (ebdc <usart_sync_read+0x54>)
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    eba0:	f8df 903c 	ldr.w	r9, [pc, #60]	; ebe0 <usart_sync_read+0x58>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    eba4:	f8df 803c 	ldr.w	r8, [pc, #60]	; ebe4 <usart_sync_read+0x5c>
	ASSERT(io_descr && buf && length);
    eba8:	f44f 7286 	mov.w	r2, #268	; 0x10c
    ebac:	4798      	blx	r3
	uint32_t                      offset = 0;
    ebae:	2700      	movs	r7, #0
		while (!_usart_sync_is_byte_received(&descr->device))
    ebb0:	3408      	adds	r4, #8
    ebb2:	4620      	mov	r0, r4
    ebb4:	47c8      	blx	r9
    ebb6:	2800      	cmp	r0, #0
    ebb8:	d0fb      	beq.n	ebb2 <usart_sync_read+0x2a>
		buf[offset] = _usart_sync_read_byte(&descr->device);
    ebba:	4620      	mov	r0, r4
    ebbc:	47c0      	blx	r8
    ebbe:	55f0      	strb	r0, [r6, r7]
	} while (++offset < length);
    ebc0:	3701      	adds	r7, #1
    ebc2:	42bd      	cmp	r5, r7
    ebc4:	d8f5      	bhi.n	ebb2 <usart_sync_read+0x2a>

	return (int32_t)offset;
    ebc6:	2d00      	cmp	r5, #0
}
    ebc8:	bf14      	ite	ne
    ebca:	4628      	movne	r0, r5
    ebcc:	2001      	moveq	r0, #1
    ebce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    ebd2:	4608      	mov	r0, r1
    ebd4:	e7e2      	b.n	eb9c <usart_sync_read+0x14>
    ebd6:	bf00      	nop
    ebd8:	0001648c 	.word	0x0001648c
    ebdc:	0000e03d 	.word	0x0000e03d
    ebe0:	0001107d 	.word	0x0001107d
    ebe4:	00011061 	.word	0x00011061

0000ebe8 <usart_sync_init>:
{
    ebe8:	b538      	push	{r3, r4, r5, lr}
    ebea:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    ebec:	4604      	mov	r4, r0
    ebee:	b110      	cbz	r0, ebf6 <usart_sync_init+0xe>
    ebf0:	1e08      	subs	r0, r1, #0
    ebf2:	bf18      	it	ne
    ebf4:	2001      	movne	r0, #1
    ebf6:	4907      	ldr	r1, [pc, #28]	; (ec14 <usart_sync_init+0x2c>)
    ebf8:	4b07      	ldr	r3, [pc, #28]	; (ec18 <usart_sync_init+0x30>)
    ebfa:	2234      	movs	r2, #52	; 0x34
    ebfc:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
    ebfe:	4b07      	ldr	r3, [pc, #28]	; (ec1c <usart_sync_init+0x34>)
    ec00:	4629      	mov	r1, r5
    ec02:	f104 0008 	add.w	r0, r4, #8
    ec06:	4798      	blx	r3
	if (init_status) {
    ec08:	b918      	cbnz	r0, ec12 <usart_sync_init+0x2a>
	descr->io.read  = usart_sync_read;
    ec0a:	4b05      	ldr	r3, [pc, #20]	; (ec20 <usart_sync_init+0x38>)
    ec0c:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_sync_write;
    ec0e:	4b05      	ldr	r3, [pc, #20]	; (ec24 <usart_sync_init+0x3c>)
    ec10:	6023      	str	r3, [r4, #0]
}
    ec12:	bd38      	pop	{r3, r4, r5, pc}
    ec14:	0001648c 	.word	0x0001648c
    ec18:	0000e03d 	.word	0x0000e03d
    ec1c:	00010f71 	.word	0x00010f71
    ec20:	0000eb89 	.word	0x0000eb89
    ec24:	0000eb15 	.word	0x0000eb15

0000ec28 <usart_sync_enable>:
{
    ec28:	b510      	push	{r4, lr}
	ASSERT(descr);
    ec2a:	4604      	mov	r4, r0
    ec2c:	3800      	subs	r0, #0
    ec2e:	bf18      	it	ne
    ec30:	2001      	movne	r0, #1
    ec32:	4905      	ldr	r1, [pc, #20]	; (ec48 <usart_sync_enable+0x20>)
    ec34:	4b05      	ldr	r3, [pc, #20]	; (ec4c <usart_sync_enable+0x24>)
    ec36:	2253      	movs	r2, #83	; 0x53
    ec38:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
    ec3a:	f104 0008 	add.w	r0, r4, #8
    ec3e:	4b04      	ldr	r3, [pc, #16]	; (ec50 <usart_sync_enable+0x28>)
    ec40:	4798      	blx	r3
}
    ec42:	2000      	movs	r0, #0
    ec44:	bd10      	pop	{r4, pc}
    ec46:	bf00      	nop
    ec48:	0001648c 	.word	0x0001648c
    ec4c:	0000e03d 	.word	0x0000e03d
    ec50:	00011015 	.word	0x00011015

0000ec54 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
    ec54:	4b01      	ldr	r3, [pc, #4]	; (ec5c <_mclk_init+0x8>)
    ec56:	2201      	movs	r2, #1
    ec58:	715a      	strb	r2, [r3, #5]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_DIV(CONF_MCLK_CPUDIV));
}
    ec5a:	4770      	bx	lr
    ec5c:	40000800 	.word	0x40000800

0000ec60 <hri_gclk_wait_for_sync.constprop.0>:
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    ec60:	4903      	ldr	r1, [pc, #12]	; (ec70 <hri_gclk_wait_for_sync.constprop.0+0x10>)
    ec62:	f643 73fd 	movw	r3, #16381	; 0x3ffd
    ec66:	684a      	ldr	r2, [r1, #4]
    ec68:	421a      	tst	r2, r3
    ec6a:	d1fc      	bne.n	ec66 <hri_gclk_wait_for_sync.constprop.0+0x6>
}
    ec6c:	4770      	bx	lr
    ec6e:	bf00      	nop
    ec70:	40001c00 	.word	0x40001c00

0000ec74 <_gclk_init_generators_by_fref>:
	        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
#endif
}

void _gclk_init_generators_by_fref(uint32_t bm)
{
    ec74:	b510      	push	{r4, lr}

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    ec76:	07c4      	lsls	r4, r0, #31
    ec78:	d504      	bpl.n	ec84 <_gclk_init_generators_by_fref+0x10>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    ec7a:	4b0e      	ldr	r3, [pc, #56]	; (ecb4 <_gclk_init_generators_by_fref+0x40>)
    ec7c:	4a0e      	ldr	r2, [pc, #56]	; (ecb8 <_gclk_init_generators_by_fref+0x44>)
    ec7e:	621a      	str	r2, [r3, #32]
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    ec80:	4b0e      	ldr	r3, [pc, #56]	; (ecbc <_gclk_init_generators_by_fref+0x48>)
    ec82:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
    ec84:	0781      	lsls	r1, r0, #30
    ec86:	d504      	bpl.n	ec92 <_gclk_init_generators_by_fref+0x1e>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    ec88:	4b0a      	ldr	r3, [pc, #40]	; (ecb4 <_gclk_init_generators_by_fref+0x40>)
    ec8a:	4a0d      	ldr	r2, [pc, #52]	; (ecc0 <_gclk_init_generators_by_fref+0x4c>)
    ec8c:	625a      	str	r2, [r3, #36]	; 0x24
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    ec8e:	4b0b      	ldr	r3, [pc, #44]	; (ecbc <_gclk_init_generators_by_fref+0x48>)
    ec90:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_1_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_1_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_2_CONFIG == 1
	if (bm & (1ul << 2)) {
    ec92:	0742      	lsls	r2, r0, #29
    ec94:	d504      	bpl.n	eca0 <_gclk_init_generators_by_fref+0x2c>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    ec96:	4b07      	ldr	r3, [pc, #28]	; (ecb4 <_gclk_init_generators_by_fref+0x40>)
    ec98:	4a0a      	ldr	r2, [pc, #40]	; (ecc4 <_gclk_init_generators_by_fref+0x50>)
    ec9a:	629a      	str	r2, [r3, #40]	; 0x28
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    ec9c:	4b07      	ldr	r3, [pc, #28]	; (ecbc <_gclk_init_generators_by_fref+0x48>)
    ec9e:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    eca0:	0703      	lsls	r3, r0, #28
    eca2:	d506      	bpl.n	ecb2 <_gclk_init_generators_by_fref+0x3e>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    eca4:	4b03      	ldr	r3, [pc, #12]	; (ecb4 <_gclk_init_generators_by_fref+0x40>)
    eca6:	4a08      	ldr	r2, [pc, #32]	; (ecc8 <_gclk_init_generators_by_fref+0x54>)
    eca8:	62da      	str	r2, [r3, #44]	; 0x2c
		        | (CONF_GCLK_GEN_11_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_11_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_11_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_11_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
	}
#endif
}
    ecaa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    ecae:	4b03      	ldr	r3, [pc, #12]	; (ecbc <_gclk_init_generators_by_fref+0x48>)
    ecb0:	4718      	bx	r3
    ecb2:	bd10      	pop	{r4, pc}
    ecb4:	40001c00 	.word	0x40001c00
    ecb8:	00010108 	.word	0x00010108
    ecbc:	0000ec61 	.word	0x0000ec61
    ecc0:	00010106 	.word	0x00010106
    ecc4:	00100106 	.word	0x00100106
    ecc8:	00010104 	.word	0x00010104

0000eccc <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
    eccc:	b510      	push	{r4, lr}

	usart_sync_enable(&GRID_AUX);
    ecce:	4c04      	ldr	r4, [pc, #16]	; (ece0 <stdio_redirect_init+0x14>)
    ecd0:	4b04      	ldr	r3, [pc, #16]	; (ece4 <stdio_redirect_init+0x18>)
    ecd2:	4620      	mov	r0, r4
    ecd4:	4798      	blx	r3
	stdio_io_init(&GRID_AUX.io);
    ecd6:	4620      	mov	r0, r4
    ecd8:	4b03      	ldr	r3, [pc, #12]	; (ece8 <stdio_redirect_init+0x1c>)
}
    ecda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_io_init(&GRID_AUX.io);
    ecde:	4718      	bx	r3
    ece0:	2001cd70 	.word	0x2001cd70
    ece4:	0000ec29 	.word	0x0000ec29
    ece8:	0000b88d 	.word	0x0000b88d

0000ecec <flash_ready>:
 * \param[in] device The pointer to flash device structure
 */
static void flash_ready(struct _flash_device *device)
{
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_ready) {
    ecec:	6943      	ldr	r3, [r0, #20]
    ecee:	b103      	cbz	r3, ecf2 <flash_ready+0x6>
		descr->callbacks.cb_ready(descr);
    ecf0:	4718      	bx	r3
	}
}
    ecf2:	4770      	bx	lr

0000ecf4 <flash_error>:
 * \param[in] device The pointer to flash device structure
 */
static void flash_error(struct _flash_device *device)
{
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_error) {
    ecf4:	6983      	ldr	r3, [r0, #24]
    ecf6:	b103      	cbz	r3, ecfa <flash_error+0x6>
		descr->callbacks.cb_error(descr);
    ecf8:	4718      	bx	r3
	}
}
    ecfa:	4770      	bx	lr

0000ecfc <flash_is_address_aligned>:
{
    ecfc:	b538      	push	{r3, r4, r5, lr}
	ASSERT(flash);
    ecfe:	4604      	mov	r4, r0
    ed00:	3800      	subs	r0, #0
    ed02:	bf18      	it	ne
    ed04:	2001      	movne	r0, #1
{
    ed06:	460d      	mov	r5, r1
	ASSERT(flash);
    ed08:	f240 1217 	movw	r2, #279	; 0x117
    ed0c:	4906      	ldr	r1, [pc, #24]	; (ed28 <flash_is_address_aligned+0x2c>)
    ed0e:	4b07      	ldr	r3, [pc, #28]	; (ed2c <flash_is_address_aligned+0x30>)
    ed10:	4798      	blx	r3
	uint32_t page_size = _flash_get_page_size(&flash->dev);
    ed12:	4b07      	ldr	r3, [pc, #28]	; (ed30 <flash_is_address_aligned+0x34>)
    ed14:	4620      	mov	r0, r4
    ed16:	4798      	blx	r3
	if (flash_addr & (page_size - 1)) {
    ed18:	3801      	subs	r0, #1
    ed1a:	4228      	tst	r0, r5
}
    ed1c:	bf14      	ite	ne
    ed1e:	f06f 000d 	mvnne.w	r0, #13
    ed22:	2000      	moveq	r0, #0
    ed24:	bd38      	pop	{r3, r4, r5, pc}
    ed26:	bf00      	nop
    ed28:	000164a8 	.word	0x000164a8
    ed2c:	0000e03d 	.word	0x0000e03d
    ed30:	0000bf31 	.word	0x0000bf31

0000ed34 <flash_init>:
{
    ed34:	b538      	push	{r3, r4, r5, lr}
    ed36:	460d      	mov	r5, r1
	ASSERT(flash && hw);
    ed38:	4604      	mov	r4, r0
    ed3a:	b110      	cbz	r0, ed42 <flash_init+0xe>
    ed3c:	1e08      	subs	r0, r1, #0
    ed3e:	bf18      	it	ne
    ed40:	2001      	movne	r0, #1
    ed42:	4907      	ldr	r1, [pc, #28]	; (ed60 <flash_init+0x2c>)
    ed44:	4b07      	ldr	r3, [pc, #28]	; (ed64 <flash_init+0x30>)
    ed46:	2238      	movs	r2, #56	; 0x38
    ed48:	4798      	blx	r3
	rc = _flash_init(&flash->dev, hw);
    ed4a:	4b07      	ldr	r3, [pc, #28]	; (ed68 <flash_init+0x34>)
    ed4c:	4629      	mov	r1, r5
    ed4e:	4620      	mov	r0, r4
    ed50:	4798      	blx	r3
	if (rc) {
    ed52:	b918      	cbnz	r0, ed5c <flash_init+0x28>
	flash->dev.flash_cb.ready_cb = flash_ready;
    ed54:	4b05      	ldr	r3, [pc, #20]	; (ed6c <flash_init+0x38>)
    ed56:	6023      	str	r3, [r4, #0]
	flash->dev.flash_cb.error_cb = flash_error;
    ed58:	4b05      	ldr	r3, [pc, #20]	; (ed70 <flash_init+0x3c>)
    ed5a:	6063      	str	r3, [r4, #4]
}
    ed5c:	bd38      	pop	{r3, r4, r5, pc}
    ed5e:	bf00      	nop
    ed60:	000164a8 	.word	0x000164a8
    ed64:	0000e03d 	.word	0x0000e03d
    ed68:	0000bec1 	.word	0x0000bec1
    ed6c:	0000eced 	.word	0x0000eced
    ed70:	0000ecf5 	.word	0x0000ecf5

0000ed74 <flash_read>:
{
    ed74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ed78:	460d      	mov	r5, r1
    ed7a:	4616      	mov	r6, r2
    ed7c:	461f      	mov	r7, r3
	ASSERT(flash && buffer && length);
    ed7e:	4604      	mov	r4, r0
    ed80:	b118      	cbz	r0, ed8a <flash_read+0x16>
    ed82:	b1ea      	cbz	r2, edc0 <flash_read+0x4c>
    ed84:	1e18      	subs	r0, r3, #0
    ed86:	bf18      	it	ne
    ed88:	2001      	movne	r0, #1
    ed8a:	4910      	ldr	r1, [pc, #64]	; (edcc <flash_read+0x58>)
    ed8c:	4b10      	ldr	r3, [pc, #64]	; (edd0 <flash_read+0x5c>)
    ed8e:	2256      	movs	r2, #86	; 0x56
    ed90:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    ed92:	4b10      	ldr	r3, [pc, #64]	; (edd4 <flash_read+0x60>)
    ed94:	4620      	mov	r0, r4
    ed96:	4798      	blx	r3
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    ed98:	4b0f      	ldr	r3, [pc, #60]	; (edd8 <flash_read+0x64>)
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    ed9a:	4680      	mov	r8, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    ed9c:	4620      	mov	r0, r4
    ed9e:	4798      	blx	r3
	if ((src_addr > page_size * total_pages) || (src_addr + length > page_size * total_pages)) {
    eda0:	fb00 f008 	mul.w	r0, r0, r8
    eda4:	42a8      	cmp	r0, r5
    eda6:	d30d      	bcc.n	edc4 <flash_read+0x50>
    eda8:	197b      	adds	r3, r7, r5
    edaa:	4298      	cmp	r0, r3
    edac:	d30a      	bcc.n	edc4 <flash_read+0x50>
	_flash_read(&flash->dev, src_addr, buffer, length);
    edae:	4620      	mov	r0, r4
    edb0:	463b      	mov	r3, r7
    edb2:	4c0a      	ldr	r4, [pc, #40]	; (eddc <flash_read+0x68>)
    edb4:	4632      	mov	r2, r6
    edb6:	4629      	mov	r1, r5
    edb8:	47a0      	blx	r4
	return ERR_NONE;
    edba:	2000      	movs	r0, #0
}
    edbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(flash && buffer && length);
    edc0:	4610      	mov	r0, r2
    edc2:	e7e2      	b.n	ed8a <flash_read+0x16>
		return ERR_BAD_ADDRESS;
    edc4:	f06f 000d 	mvn.w	r0, #13
    edc8:	e7f8      	b.n	edbc <flash_read+0x48>
    edca:	bf00      	nop
    edcc:	000164a8 	.word	0x000164a8
    edd0:	0000e03d 	.word	0x0000e03d
    edd4:	0000bf31 	.word	0x0000bf31
    edd8:	0000bf37 	.word	0x0000bf37
    eddc:	0000bf3f 	.word	0x0000bf3f

0000ede0 <flash_write>:
{
    ede0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ede4:	460e      	mov	r6, r1
    ede6:	4617      	mov	r7, r2
    ede8:	4698      	mov	r8, r3
	ASSERT(flash && buffer && length);
    edea:	4605      	mov	r5, r0
    edec:	b118      	cbz	r0, edf6 <flash_write+0x16>
    edee:	b31a      	cbz	r2, ee38 <flash_write+0x58>
    edf0:	1e18      	subs	r0, r3, #0
    edf2:	bf18      	it	ne
    edf4:	2001      	movne	r0, #1
    edf6:	4914      	ldr	r1, [pc, #80]	; (ee48 <flash_write+0x68>)
    edf8:	4b14      	ldr	r3, [pc, #80]	; (ee4c <flash_write+0x6c>)
    edfa:	226a      	movs	r2, #106	; 0x6a
    edfc:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    edfe:	4b14      	ldr	r3, [pc, #80]	; (ee50 <flash_write+0x70>)
    ee00:	4628      	mov	r0, r5
    ee02:	4798      	blx	r3
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    ee04:	4b13      	ldr	r3, [pc, #76]	; (ee54 <flash_write+0x74>)
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    ee06:	4604      	mov	r4, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    ee08:	4628      	mov	r0, r5
    ee0a:	4798      	blx	r3
	if ((dst_addr > page_size * total_pages) || (dst_addr + length > page_size * total_pages)) {
    ee0c:	4360      	muls	r0, r4
    ee0e:	42b0      	cmp	r0, r6
    ee10:	d314      	bcc.n	ee3c <flash_write+0x5c>
    ee12:	eb08 0306 	add.w	r3, r8, r6
    ee16:	4298      	cmp	r0, r3
    ee18:	d310      	bcc.n	ee3c <flash_write+0x5c>
	if (_flash_is_locked(&flash->dev, dst_addr)) {
    ee1a:	4b0f      	ldr	r3, [pc, #60]	; (ee58 <flash_write+0x78>)
    ee1c:	4631      	mov	r1, r6
    ee1e:	4628      	mov	r0, r5
    ee20:	4798      	blx	r3
    ee22:	4604      	mov	r4, r0
    ee24:	b968      	cbnz	r0, ee42 <flash_write+0x62>
	_flash_write(&flash->dev, dst_addr, buffer, length);
    ee26:	4628      	mov	r0, r5
    ee28:	4643      	mov	r3, r8
    ee2a:	4d0c      	ldr	r5, [pc, #48]	; (ee5c <flash_write+0x7c>)
    ee2c:	463a      	mov	r2, r7
    ee2e:	4631      	mov	r1, r6
    ee30:	47a8      	blx	r5
	return ERR_NONE;
    ee32:	4620      	mov	r0, r4
}
    ee34:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(flash && buffer && length);
    ee38:	4610      	mov	r0, r2
    ee3a:	e7dc      	b.n	edf6 <flash_write+0x16>
		return ERR_BAD_ADDRESS;
    ee3c:	f06f 000d 	mvn.w	r0, #13
    ee40:	e7f8      	b.n	ee34 <flash_write+0x54>
		return ERR_DENIED;
    ee42:	f06f 0010 	mvn.w	r0, #16
    ee46:	e7f5      	b.n	ee34 <flash_write+0x54>
    ee48:	000164a8 	.word	0x000164a8
    ee4c:	0000e03d 	.word	0x0000e03d
    ee50:	0000bf31 	.word	0x0000bf31
    ee54:	0000bf37 	.word	0x0000bf37
    ee58:	0000c0cd 	.word	0x0000c0cd
    ee5c:	0000bf59 	.word	0x0000bf59

0000ee60 <flash_erase>:
{
    ee60:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ee64:	4688      	mov	r8, r1
    ee66:	4617      	mov	r7, r2
	ASSERT(flash && page_nums);
    ee68:	4604      	mov	r4, r0
    ee6a:	b110      	cbz	r0, ee72 <flash_erase+0x12>
    ee6c:	1e10      	subs	r0, r2, #0
    ee6e:	bf18      	it	ne
    ee70:	2001      	movne	r0, #1
    ee72:	4912      	ldr	r1, [pc, #72]	; (eebc <flash_erase+0x5c>)
    ee74:	4b12      	ldr	r3, [pc, #72]	; (eec0 <flash_erase+0x60>)
    ee76:	229a      	movs	r2, #154	; 0x9a
    ee78:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    ee7a:	4b12      	ldr	r3, [pc, #72]	; (eec4 <flash_erase+0x64>)
    ee7c:	4620      	mov	r0, r4
    ee7e:	4798      	blx	r3
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    ee80:	4b11      	ldr	r3, [pc, #68]	; (eec8 <flash_erase+0x68>)
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    ee82:	4605      	mov	r5, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    ee84:	4620      	mov	r0, r4
    ee86:	4798      	blx	r3
	rc = flash_is_address_aligned(flash, dst_addr);
    ee88:	4b10      	ldr	r3, [pc, #64]	; (eecc <flash_erase+0x6c>)
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    ee8a:	4681      	mov	r9, r0
	rc = flash_is_address_aligned(flash, dst_addr);
    ee8c:	4641      	mov	r1, r8
    ee8e:	4620      	mov	r0, r4
    ee90:	4798      	blx	r3
	if (rc) {
    ee92:	4606      	mov	r6, r0
    ee94:	b958      	cbnz	r0, eeae <flash_erase+0x4e>
	if ((page_nums > total_pages) || (dst_addr / page_size + page_nums > total_pages)) {
    ee96:	454f      	cmp	r7, r9
    ee98:	d80c      	bhi.n	eeb4 <flash_erase+0x54>
    ee9a:	fbb8 f5f5 	udiv	r5, r8, r5
    ee9e:	443d      	add	r5, r7
    eea0:	454d      	cmp	r5, r9
    eea2:	d807      	bhi.n	eeb4 <flash_erase+0x54>
	_flash_erase(&flash->dev, dst_addr, page_nums);
    eea4:	4b0a      	ldr	r3, [pc, #40]	; (eed0 <flash_erase+0x70>)
    eea6:	463a      	mov	r2, r7
    eea8:	4641      	mov	r1, r8
    eeaa:	4620      	mov	r0, r4
    eeac:	4798      	blx	r3
}
    eeae:	4630      	mov	r0, r6
    eeb0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ERR_INVALID_ARG;
    eeb4:	f06f 060c 	mvn.w	r6, #12
    eeb8:	e7f9      	b.n	eeae <flash_erase+0x4e>
    eeba:	bf00      	nop
    eebc:	000164a8 	.word	0x000164a8
    eec0:	0000e03d 	.word	0x0000e03d
    eec4:	0000bf31 	.word	0x0000bf31
    eec8:	0000bf37 	.word	0x0000bf37
    eecc:	0000ecfd 	.word	0x0000ecfd
    eed0:	0000c021 	.word	0x0000c021

0000eed4 <_spi_m_async_io_write>:
 *  \return ERR_NONE on success, or an error code on failure.
 *  \retval ERR_NONE Success, transfer started.
 *  \retval ERR_BUSY Busy.
 */
static int32_t _spi_m_async_io_write(struct io_descriptor *io, const uint8_t *const buf, const uint16_t length)
{
    eed4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ASSERT(io);
    eed6:	4604      	mov	r4, r0
    eed8:	3800      	subs	r0, #0
    eeda:	bf18      	it	ne
    eedc:	2001      	movne	r0, #1
{
    eede:	460f      	mov	r7, r1
    eee0:	4616      	mov	r6, r2
	ASSERT(io);
    eee2:	4909      	ldr	r1, [pc, #36]	; (ef08 <_spi_m_async_io_write+0x34>)
    eee4:	4b09      	ldr	r3, [pc, #36]	; (ef0c <_spi_m_async_io_write+0x38>)
    eee6:	f240 1227 	movw	r2, #295	; 0x127
    eeea:	4798      	blx	r3
	struct spi_m_async_descriptor *spi = CONTAINER_OF(io, struct spi_m_async_descriptor, io);

	spi->xfer.rxbuf = NULL;
    eeec:	2500      	movs	r5, #0
	spi->xfer.txbuf = (uint8_t *)buf;
	spi->xfer.size  = length;
	spi->xfercnt    = 0;

	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    eeee:	2310      	movs	r3, #16
    eef0:	7223      	strb	r3, [r4, #8]
	spi->xfer.txbuf = (uint8_t *)buf;
    eef2:	e9c4 7505 	strd	r7, r5, [r4, #20]
	spi->xfercnt    = 0;
    eef6:	e9c4 6507 	strd	r6, r5, [r4, #28]
	_spi_m_async_enable_tx(&spi->dev, true);
    eefa:	4b05      	ldr	r3, [pc, #20]	; (ef10 <_spi_m_async_io_write+0x3c>)
    eefc:	2101      	movs	r1, #1
    eefe:	f1a4 0020 	sub.w	r0, r4, #32
    ef02:	4798      	blx	r3

	return ERR_NONE;
}
    ef04:	4628      	mov	r0, r5
    ef06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ef08:	000164bf 	.word	0x000164bf
    ef0c:	0000e03d 	.word	0x0000e03d
    ef10:	0001161d 	.word	0x0001161d

0000ef14 <_spi_m_async_io_read>:
{
    ef14:	b570      	push	{r4, r5, r6, lr}
	ASSERT(io);
    ef16:	4604      	mov	r4, r0
    ef18:	3800      	subs	r0, #0
    ef1a:	bf18      	it	ne
    ef1c:	2001      	movne	r0, #1
{
    ef1e:	460d      	mov	r5, r1
    ef20:	4616      	mov	r6, r2
	ASSERT(io);
    ef22:	490c      	ldr	r1, [pc, #48]	; (ef54 <_spi_m_async_io_read+0x40>)
    ef24:	4b0c      	ldr	r3, [pc, #48]	; (ef58 <_spi_m_async_io_read+0x44>)
    ef26:	f240 1205 	movw	r2, #261	; 0x105
    ef2a:	4798      	blx	r3
	spi->xfer.rxbuf = buf;
    ef2c:	61a5      	str	r5, [r4, #24]
	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    ef2e:	2310      	movs	r3, #16
	spi->xfer.txbuf = NULL;
    ef30:	2500      	movs	r5, #0
	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    ef32:	7223      	strb	r3, [r4, #8]
	spi->xfer.txbuf = NULL;
    ef34:	6165      	str	r5, [r4, #20]
	spi->xfercnt    = 0;
    ef36:	e9c4 6507 	strd	r6, r5, [r4, #28]
	_spi_m_async_enable_rx(&spi->dev, true);
    ef3a:	3c20      	subs	r4, #32
    ef3c:	4b07      	ldr	r3, [pc, #28]	; (ef5c <_spi_m_async_io_read+0x48>)
    ef3e:	2101      	movs	r1, #1
    ef40:	4620      	mov	r0, r4
    ef42:	4798      	blx	r3
	_spi_m_async_write_one(&spi->dev, SPI_DUMMY_CHAR);
    ef44:	4b06      	ldr	r3, [pc, #24]	; (ef60 <_spi_m_async_io_read+0x4c>)
    ef46:	f240 11ff 	movw	r1, #511	; 0x1ff
    ef4a:	4620      	mov	r0, r4
    ef4c:	4798      	blx	r3
}
    ef4e:	4628      	mov	r0, r5
    ef50:	bd70      	pop	{r4, r5, r6, pc}
    ef52:	bf00      	nop
    ef54:	000164bf 	.word	0x000164bf
    ef58:	0000e03d 	.word	0x0000e03d
    ef5c:	00011649 	.word	0x00011649
    ef60:	000116b5 	.word	0x000116b5

0000ef64 <_spi_dev_error>:
{
    ef64:	b570      	push	{r4, r5, r6, lr}
	_spi_m_async_enable_tx(dev, false);
    ef66:	4b0c      	ldr	r3, [pc, #48]	; (ef98 <_spi_dev_error+0x34>)
{
    ef68:	4604      	mov	r4, r0
    ef6a:	460d      	mov	r5, r1
	_spi_m_async_enable_tx(dev, false);
    ef6c:	2100      	movs	r1, #0
    ef6e:	4798      	blx	r3
	_spi_m_async_enable_rx(dev, false);
    ef70:	4b0a      	ldr	r3, [pc, #40]	; (ef9c <_spi_dev_error+0x38>)
    ef72:	2100      	movs	r1, #0
    ef74:	4620      	mov	r0, r4
    ef76:	4798      	blx	r3
	_spi_m_async_enable_tx_complete(dev, false);
    ef78:	4b09      	ldr	r3, [pc, #36]	; (efa0 <_spi_dev_error+0x3c>)
    ef7a:	2100      	movs	r1, #0
    ef7c:	4620      	mov	r0, r4
    ef7e:	4798      	blx	r3
	spi->stat = 0;
    ef80:	2300      	movs	r3, #0
    ef82:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	if (spi->callbacks.cb_error) {
    ef86:	6b23      	ldr	r3, [r4, #48]	; 0x30
    ef88:	b123      	cbz	r3, ef94 <_spi_dev_error+0x30>
		spi->callbacks.cb_error(spi, status);
    ef8a:	4629      	mov	r1, r5
    ef8c:	1f20      	subs	r0, r4, #4
}
    ef8e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		spi->callbacks.cb_error(spi, status);
    ef92:	4718      	bx	r3
}
    ef94:	bd70      	pop	{r4, r5, r6, pc}
    ef96:	bf00      	nop
    ef98:	0001161d 	.word	0x0001161d
    ef9c:	00011649 	.word	0x00011649
    efa0:	00011681 	.word	0x00011681

0000efa4 <_spi_dev_complete>:
	if (spi->xfercnt >= spi->xfer.size) {
    efa4:	e9d0 320f 	ldrd	r3, r2, [r0, #60]	; 0x3c
    efa8:	429a      	cmp	r2, r3
{
    efaa:	b510      	push	{r4, lr}
    efac:	4604      	mov	r4, r0
	if (spi->xfercnt >= spi->xfer.size) {
    efae:	d30b      	bcc.n	efc8 <_spi_dev_complete+0x24>
		_spi_m_async_enable_tx_complete(dev, false);
    efb0:	4b06      	ldr	r3, [pc, #24]	; (efcc <_spi_dev_complete+0x28>)
    efb2:	2100      	movs	r1, #0
    efb4:	4798      	blx	r3
		spi->stat = 0;
    efb6:	2300      	movs	r3, #0
    efb8:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
		if (spi->callbacks.cb_xfer) {
    efbc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    efbe:	b11b      	cbz	r3, efc8 <_spi_dev_complete+0x24>
			spi->callbacks.cb_xfer(spi);
    efc0:	1f20      	subs	r0, r4, #4
}
    efc2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			spi->callbacks.cb_xfer(spi);
    efc6:	4718      	bx	r3
}
    efc8:	bd10      	pop	{r4, pc}
    efca:	bf00      	nop
    efcc:	00011681 	.word	0x00011681

0000efd0 <_spi_dev_rx>:
{
    efd0:	b570      	push	{r4, r5, r6, lr}
	if (spi->xfer.rxbuf) {
    efd2:	6b85      	ldr	r5, [r0, #56]	; 0x38
    efd4:	4b1c      	ldr	r3, [pc, #112]	; (f048 <_spi_dev_rx+0x78>)
{
    efd6:	4604      	mov	r4, r0
	if (spi->xfer.rxbuf) {
    efd8:	b305      	cbz	r5, f01c <_spi_dev_rx+0x4c>
		if (!(dev->char_size > 1)) {
    efda:	7902      	ldrb	r2, [r0, #4]
    efdc:	2a01      	cmp	r2, #1
    efde:	d816      	bhi.n	f00e <_spi_dev_rx+0x3e>
			spi->xfer.rxbuf[spi->xfercnt++] = (uint8_t)_spi_m_async_read_one(dev);
    efe0:	4798      	blx	r3
    efe2:	6c23      	ldr	r3, [r4, #64]	; 0x40
    efe4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    efe6:	1c59      	adds	r1, r3, #1
    efe8:	6421      	str	r1, [r4, #64]	; 0x40
    efea:	54d0      	strb	r0, [r2, r3]
	if (spi->xfercnt < spi->xfer.size) {
    efec:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
    eff0:	4299      	cmp	r1, r3
    eff2:	d21a      	bcs.n	f02a <_spi_dev_rx+0x5a>
		if (spi->xfer.txbuf) {
    eff4:	6b62      	ldr	r2, [r4, #52]	; 0x34
    eff6:	4b15      	ldr	r3, [pc, #84]	; (f04c <_spi_dev_rx+0x7c>)
    eff8:	b1aa      	cbz	r2, f026 <_spi_dev_rx+0x56>
			if (!(dev->char_size > 1)) {
    effa:	7920      	ldrb	r0, [r4, #4]
    effc:	2801      	cmp	r0, #1
				_spi_m_async_write_one(dev, spi->xfer.txbuf[spi->xfercnt]);
    effe:	bf94      	ite	ls
    f000:	5c51      	ldrbls	r1, [r2, r1]
				_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt]);
    f002:	f832 1011 	ldrhhi.w	r1, [r2, r1, lsl #1]
    f006:	4620      	mov	r0, r4
}
    f008:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt]);
    f00c:	4718      	bx	r3
			((uint16_t *)spi->xfer.rxbuf)[spi->xfercnt++] = (uint16_t)_spi_m_async_read_one(dev);
    f00e:	6c06      	ldr	r6, [r0, #64]	; 0x40
    f010:	1c72      	adds	r2, r6, #1
    f012:	6402      	str	r2, [r0, #64]	; 0x40
    f014:	4798      	blx	r3
    f016:	f825 0016 	strh.w	r0, [r5, r6, lsl #1]
    f01a:	e7e7      	b.n	efec <_spi_dev_rx+0x1c>
		_spi_m_async_read_one(dev);
    f01c:	4798      	blx	r3
		spi->xfercnt++;
    f01e:	6c23      	ldr	r3, [r4, #64]	; 0x40
    f020:	3301      	adds	r3, #1
    f022:	6423      	str	r3, [r4, #64]	; 0x40
    f024:	e7e2      	b.n	efec <_spi_dev_rx+0x1c>
			_spi_m_async_write_one(dev, dev->dummy_byte);
    f026:	88e1      	ldrh	r1, [r4, #6]
    f028:	e7ed      	b.n	f006 <_spi_dev_rx+0x36>
		_spi_m_async_enable_rx(dev, false);
    f02a:	4b09      	ldr	r3, [pc, #36]	; (f050 <_spi_dev_rx+0x80>)
    f02c:	2100      	movs	r1, #0
    f02e:	4620      	mov	r0, r4
    f030:	4798      	blx	r3
		spi->stat = 0;
    f032:	2300      	movs	r3, #0
    f034:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
		if (spi->callbacks.cb_xfer) {
    f038:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    f03a:	b11b      	cbz	r3, f044 <_spi_dev_rx+0x74>
			spi->callbacks.cb_xfer(spi);
    f03c:	1f20      	subs	r0, r4, #4
}
    f03e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			spi->callbacks.cb_xfer(spi);
    f042:	4718      	bx	r3
}
    f044:	bd70      	pop	{r4, r5, r6, pc}
    f046:	bf00      	nop
    f048:	000116e1 	.word	0x000116e1
    f04c:	000116b5 	.word	0x000116b5
    f050:	00011649 	.word	0x00011649

0000f054 <_spi_dev_tx>:
{
    f054:	b570      	push	{r4, r5, r6, lr}
    f056:	6c03      	ldr	r3, [r0, #64]	; 0x40
	if (!(dev->char_size > 1)) {
    f058:	7902      	ldrb	r2, [r0, #4]
    f05a:	6b41      	ldr	r1, [r0, #52]	; 0x34
    f05c:	1c5d      	adds	r5, r3, #1
    f05e:	2a01      	cmp	r2, #1
		_spi_m_async_write_one(dev, spi->xfer.txbuf[spi->xfercnt++]);
    f060:	6405      	str	r5, [r0, #64]	; 0x40
    f062:	bf94      	ite	ls
    f064:	5cc9      	ldrbls	r1, [r1, r3]
		_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt++]);
    f066:	f831 1013 	ldrhhi.w	r1, [r1, r3, lsl #1]
    f06a:	4a09      	ldr	r2, [pc, #36]	; (f090 <_spi_dev_tx+0x3c>)
{
    f06c:	4604      	mov	r4, r0
		_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt++]);
    f06e:	4790      	blx	r2
	if (spi->xfercnt == spi->xfer.size) {
    f070:	e9d4 320f 	ldrd	r3, r2, [r4, #60]	; 0x3c
    f074:	429a      	cmp	r2, r3
    f076:	d109      	bne.n	f08c <_spi_dev_tx+0x38>
		_spi_m_async_enable_tx(dev, false);
    f078:	4b06      	ldr	r3, [pc, #24]	; (f094 <_spi_dev_tx+0x40>)
    f07a:	2100      	movs	r1, #0
    f07c:	4620      	mov	r0, r4
    f07e:	4798      	blx	r3
		_spi_m_async_enable_tx_complete(dev, true);
    f080:	4620      	mov	r0, r4
    f082:	4b05      	ldr	r3, [pc, #20]	; (f098 <_spi_dev_tx+0x44>)
}
    f084:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_spi_m_async_enable_tx_complete(dev, true);
    f088:	2101      	movs	r1, #1
    f08a:	4718      	bx	r3
}
    f08c:	bd70      	pop	{r4, r5, r6, pc}
    f08e:	bf00      	nop
    f090:	000116b5 	.word	0x000116b5
    f094:	0001161d 	.word	0x0001161d
    f098:	00011681 	.word	0x00011681

0000f09c <spi_m_async_init>:
{
    f09c:	b570      	push	{r4, r5, r6, lr}
    f09e:	460e      	mov	r6, r1
	ASSERT(spi && hw);
    f0a0:	4604      	mov	r4, r0
    f0a2:	b110      	cbz	r0, f0aa <spi_m_async_init+0xe>
    f0a4:	1e08      	subs	r0, r1, #0
    f0a6:	bf18      	it	ne
    f0a8:	2001      	movne	r0, #1
	spi->dev.prvt = (void *)hw;
    f0aa:	4625      	mov	r5, r4
	ASSERT(spi && hw);
    f0ac:	4911      	ldr	r1, [pc, #68]	; (f0f4 <spi_m_async_init+0x58>)
    f0ae:	4b12      	ldr	r3, [pc, #72]	; (f0f8 <spi_m_async_init+0x5c>)
    f0b0:	22a5      	movs	r2, #165	; 0xa5
    f0b2:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    f0b4:	f845 6f04 	str.w	r6, [r5, #4]!
	rc            = _spi_m_async_init(&spi->dev, hw);
    f0b8:	4b10      	ldr	r3, [pc, #64]	; (f0fc <spi_m_async_init+0x60>)
    f0ba:	4631      	mov	r1, r6
    f0bc:	4628      	mov	r0, r5
    f0be:	4798      	blx	r3
	if (rc >= 0) {
    f0c0:	2800      	cmp	r0, #0
    f0c2:	db15      	blt.n	f0f0 <spi_m_async_init+0x54>
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_TX, (FUNC_PTR)_spi_dev_tx);
    f0c4:	4e0e      	ldr	r6, [pc, #56]	; (f100 <spi_m_async_init+0x64>)
    f0c6:	4a0f      	ldr	r2, [pc, #60]	; (f104 <spi_m_async_init+0x68>)
    f0c8:	2100      	movs	r1, #0
    f0ca:	4628      	mov	r0, r5
    f0cc:	47b0      	blx	r6
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_RX, (FUNC_PTR)_spi_dev_rx);
    f0ce:	4a0e      	ldr	r2, [pc, #56]	; (f108 <spi_m_async_init+0x6c>)
    f0d0:	2101      	movs	r1, #1
    f0d2:	4628      	mov	r0, r5
    f0d4:	47b0      	blx	r6
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_COMPLETE, (FUNC_PTR)_spi_dev_complete);
    f0d6:	4a0d      	ldr	r2, [pc, #52]	; (f10c <spi_m_async_init+0x70>)
    f0d8:	2102      	movs	r1, #2
    f0da:	4628      	mov	r0, r5
    f0dc:	47b0      	blx	r6
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_ERROR, (FUNC_PTR)_spi_dev_error);
    f0de:	4a0c      	ldr	r2, [pc, #48]	; (f110 <spi_m_async_init+0x74>)
    f0e0:	2103      	movs	r1, #3
    f0e2:	4628      	mov	r0, r5
    f0e4:	47b0      	blx	r6
	spi->io.read  = _spi_m_async_io_read;
    f0e6:	4b0b      	ldr	r3, [pc, #44]	; (f114 <spi_m_async_init+0x78>)
    f0e8:	62a3      	str	r3, [r4, #40]	; 0x28
	spi->io.write = _spi_m_async_io_write;
    f0ea:	4b0b      	ldr	r3, [pc, #44]	; (f118 <spi_m_async_init+0x7c>)
    f0ec:	6263      	str	r3, [r4, #36]	; 0x24
	return ERR_NONE;
    f0ee:	2000      	movs	r0, #0
}
    f0f0:	bd70      	pop	{r4, r5, r6, pc}
    f0f2:	bf00      	nop
    f0f4:	000164bf 	.word	0x000164bf
    f0f8:	0000e03d 	.word	0x0000e03d
    f0fc:	00011529 	.word	0x00011529
    f100:	00011709 	.word	0x00011709
    f104:	0000f055 	.word	0x0000f055
    f108:	0000efd1 	.word	0x0000efd1
    f10c:	0000efa5 	.word	0x0000efa5
    f110:	0000ef65 	.word	0x0000ef65
    f114:	0000ef15 	.word	0x0000ef15
    f118:	0000eed5 	.word	0x0000eed5

0000f11c <spi_m_async_enable>:
{
    f11c:	b510      	push	{r4, lr}
	ASSERT(spi);
    f11e:	4604      	mov	r4, r0
    f120:	3800      	subs	r0, #0
    f122:	4b05      	ldr	r3, [pc, #20]	; (f138 <spi_m_async_enable+0x1c>)
    f124:	4905      	ldr	r1, [pc, #20]	; (f13c <spi_m_async_enable+0x20>)
    f126:	bf18      	it	ne
    f128:	2001      	movne	r0, #1
    f12a:	22c1      	movs	r2, #193	; 0xc1
    f12c:	4798      	blx	r3
	_spi_m_async_enable(&spi->dev);
    f12e:	1d20      	adds	r0, r4, #4
    f130:	4b03      	ldr	r3, [pc, #12]	; (f140 <spi_m_async_enable+0x24>)
}
    f132:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_spi_m_async_enable(&spi->dev);
    f136:	4718      	bx	r3
    f138:	0000e03d 	.word	0x0000e03d
    f13c:	000164bf 	.word	0x000164bf
    f140:	00011581 	.word	0x00011581

0000f144 <spi_m_async_set_baudrate>:
{
    f144:	b570      	push	{r4, r5, r6, lr}
	ASSERT(spi);
    f146:	4604      	mov	r4, r0
    f148:	3800      	subs	r0, #0
    f14a:	4b0a      	ldr	r3, [pc, #40]	; (f174 <spi_m_async_set_baudrate+0x30>)
    f14c:	bf18      	it	ne
    f14e:	2001      	movne	r0, #1
{
    f150:	460d      	mov	r5, r1
	ASSERT(spi);
    f152:	22cf      	movs	r2, #207	; 0xcf
    f154:	4908      	ldr	r1, [pc, #32]	; (f178 <spi_m_async_set_baudrate+0x34>)
    f156:	4798      	blx	r3
	if (spi->stat & SPI_M_ASYNC_STATUS_BUSY) {
    f158:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    f15c:	06db      	lsls	r3, r3, #27
    f15e:	d405      	bmi.n	f16c <spi_m_async_set_baudrate+0x28>
	return _spi_m_async_set_baudrate(&spi->dev, baud_val);
    f160:	4629      	mov	r1, r5
    f162:	1d20      	adds	r0, r4, #4
    f164:	4b05      	ldr	r3, [pc, #20]	; (f17c <spi_m_async_set_baudrate+0x38>)
}
    f166:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_async_set_baudrate(&spi->dev, baud_val);
    f16a:	4718      	bx	r3
}
    f16c:	f06f 0003 	mvn.w	r0, #3
    f170:	bd70      	pop	{r4, r5, r6, pc}
    f172:	bf00      	nop
    f174:	0000e03d 	.word	0x0000e03d
    f178:	000164bf 	.word	0x000164bf
    f17c:	000115e5 	.word	0x000115e5

0000f180 <spi_m_async_set_mode>:
{
    f180:	b570      	push	{r4, r5, r6, lr}
	ASSERT(spi);
    f182:	4604      	mov	r4, r0
    f184:	3800      	subs	r0, #0
    f186:	4b0a      	ldr	r3, [pc, #40]	; (f1b0 <spi_m_async_set_mode+0x30>)
    f188:	bf18      	it	ne
    f18a:	2001      	movne	r0, #1
{
    f18c:	460d      	mov	r5, r1
	ASSERT(spi);
    f18e:	22d9      	movs	r2, #217	; 0xd9
    f190:	4908      	ldr	r1, [pc, #32]	; (f1b4 <spi_m_async_set_mode+0x34>)
    f192:	4798      	blx	r3
	if (spi->stat & SPI_M_ASYNC_STATUS_BUSY) {
    f194:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    f198:	06db      	lsls	r3, r3, #27
    f19a:	d405      	bmi.n	f1a8 <spi_m_async_set_mode+0x28>
	return _spi_m_async_set_mode(&spi->dev, mode);
    f19c:	4629      	mov	r1, r5
    f19e:	1d20      	adds	r0, r4, #4
    f1a0:	4b05      	ldr	r3, [pc, #20]	; (f1b8 <spi_m_async_set_mode+0x38>)
}
    f1a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_async_set_mode(&spi->dev, mode);
    f1a6:	4718      	bx	r3
}
    f1a8:	f06f 0003 	mvn.w	r0, #3
    f1ac:	bd70      	pop	{r4, r5, r6, pc}
    f1ae:	bf00      	nop
    f1b0:	0000e03d 	.word	0x0000e03d
    f1b4:	000164bf 	.word	0x000164bf
    f1b8:	000115b1 	.word	0x000115b1

0000f1bc <spi_m_async_transfer>:

int32_t spi_m_async_transfer(struct spi_m_async_descriptor *spi, uint8_t const *txbuf, uint8_t *const rxbuf,
                             const uint16_t length)
{
    f1bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ASSERT(spi);
    f1be:	4604      	mov	r4, r0
    f1c0:	3800      	subs	r0, #0
{
    f1c2:	461e      	mov	r6, r3
	ASSERT(spi);
    f1c4:	bf18      	it	ne
    f1c6:	2001      	movne	r0, #1
    f1c8:	4b11      	ldr	r3, [pc, #68]	; (f210 <spi_m_async_transfer+0x54>)
{
    f1ca:	460d      	mov	r5, r1
    f1cc:	4617      	mov	r7, r2
	ASSERT(spi);
    f1ce:	4911      	ldr	r1, [pc, #68]	; (f214 <spi_m_async_transfer+0x58>)
    f1d0:	f44f 729c 	mov.w	r2, #312	; 0x138
    f1d4:	4798      	blx	r3

	/* Fill transfer descriptor */
	spi->xfer.rxbuf = (uint8_t *)rxbuf;
	spi->xfer.txbuf = (uint8_t *)txbuf;
	spi->xfer.size  = length;
	spi->xfercnt    = 0;
    f1d6:	2300      	movs	r3, #0
	spi->xfer.size  = length;
    f1d8:	6426      	str	r6, [r4, #64]	; 0x40
	spi->xfercnt    = 0;
    f1da:	6463      	str	r3, [r4, #68]	; 0x44

	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
	_spi_m_async_enable_rx(&spi->dev, true);
    f1dc:	1d26      	adds	r6, r4, #4
	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    f1de:	2310      	movs	r3, #16
    f1e0:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
	spi->xfer.txbuf = (uint8_t *)txbuf;
    f1e4:	e9c4 570e 	strd	r5, r7, [r4, #56]	; 0x38
	_spi_m_async_enable_rx(&spi->dev, true);
    f1e8:	4b0b      	ldr	r3, [pc, #44]	; (f218 <spi_m_async_transfer+0x5c>)
    f1ea:	2101      	movs	r1, #1
    f1ec:	4630      	mov	r0, r6
    f1ee:	4798      	blx	r3
	if (txbuf) {
    f1f0:	4b0a      	ldr	r3, [pc, #40]	; (f21c <spi_m_async_transfer+0x60>)
    f1f2:	b155      	cbz	r5, f20a <spi_m_async_transfer+0x4e>
		if (!(spi->dev.char_size > 1)) {
    f1f4:	7a21      	ldrb	r1, [r4, #8]
    f1f6:	6c62      	ldr	r2, [r4, #68]	; 0x44
    f1f8:	2901      	cmp	r1, #1
			_spi_m_async_write_one(&spi->dev, txbuf[spi->xfercnt]);
    f1fa:	bf94      	ite	ls
    f1fc:	5ca9      	ldrbls	r1, [r5, r2]
		} else {
			_spi_m_async_write_one(&spi->dev, ((uint16_t *)txbuf)[spi->xfercnt]);
    f1fe:	f835 1012 	ldrhhi.w	r1, [r5, r2, lsl #1]
		}
	} else {
		_spi_m_async_write_one(&spi->dev, spi->dev.dummy_byte);
    f202:	4630      	mov	r0, r6
    f204:	4798      	blx	r3
	}

	return ERR_NONE;
}
    f206:	2000      	movs	r0, #0
    f208:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		_spi_m_async_write_one(&spi->dev, spi->dev.dummy_byte);
    f20a:	8961      	ldrh	r1, [r4, #10]
    f20c:	e7f9      	b.n	f202 <spi_m_async_transfer+0x46>
    f20e:	bf00      	nop
    f210:	0000e03d 	.word	0x0000e03d
    f214:	000164bf 	.word	0x000164bf
    f218:	00011649 	.word	0x00011649
    f21c:	000116b5 	.word	0x000116b5

0000f220 <spi_m_async_register_callback>:
	return ERR_NONE;
}

void spi_m_async_register_callback(struct spi_m_async_descriptor *spi, const enum spi_m_async_cb_type type,
                                   FUNC_PTR func)
{
    f220:	b570      	push	{r4, r5, r6, lr}
    f222:	460e      	mov	r6, r1
    f224:	4615      	mov	r5, r2
	ASSERT(spi && (type < SPI_M_ASYNC_CB_N));
    f226:	4604      	mov	r4, r0
    f228:	b118      	cbz	r0, f232 <spi_m_async_register_callback+0x12>
    f22a:	2901      	cmp	r1, #1
    f22c:	bf8c      	ite	hi
    f22e:	2000      	movhi	r0, #0
    f230:	2001      	movls	r0, #1
    f232:	4909      	ldr	r1, [pc, #36]	; (f258 <spi_m_async_register_callback+0x38>)
    f234:	4b09      	ldr	r3, [pc, #36]	; (f25c <spi_m_async_register_callback+0x3c>)
    f236:	f240 1263 	movw	r2, #355	; 0x163
    f23a:	4798      	blx	r3

	if (SPI_M_ASYNC_CB_XFER == type) {
    f23c:	b90e      	cbnz	r6, f242 <spi_m_async_register_callback+0x22>
		spi->callbacks.cb_xfer = (spi_m_async_cb_xfer_t)func;
    f23e:	6325      	str	r5, [r4, #48]	; 0x30
	} else {
		spi->callbacks.cb_error = (spi_m_async_cb_error_t)func;
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
	}
}
    f240:	bd70      	pop	{r4, r5, r6, pc}
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
    f242:	1e2a      	subs	r2, r5, #0
		spi->callbacks.cb_error = (spi_m_async_cb_error_t)func;
    f244:	6365      	str	r5, [r4, #52]	; 0x34
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
    f246:	f104 0004 	add.w	r0, r4, #4
    f24a:	4b05      	ldr	r3, [pc, #20]	; (f260 <spi_m_async_register_callback+0x40>)
}
    f24c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
    f250:	bf18      	it	ne
    f252:	2201      	movne	r2, #1
    f254:	2103      	movs	r1, #3
    f256:	4718      	bx	r3
    f258:	000164bf 	.word	0x000164bf
    f25c:	0000e03d 	.word	0x0000e03d
    f260:	00011739 	.word	0x00011739

0000f264 <spi_m_async_get_io_descriptor>:

int32_t spi_m_async_get_io_descriptor(struct spi_m_async_descriptor *const spi, struct io_descriptor **io)
{
    f264:	b538      	push	{r3, r4, r5, lr}
    f266:	460d      	mov	r5, r1
	ASSERT(spi && io);
    f268:	4604      	mov	r4, r0
    f26a:	b110      	cbz	r0, f272 <spi_m_async_get_io_descriptor+0xe>
    f26c:	1e08      	subs	r0, r1, #0
    f26e:	bf18      	it	ne
    f270:	2001      	movne	r0, #1
    f272:	4904      	ldr	r1, [pc, #16]	; (f284 <spi_m_async_get_io_descriptor+0x20>)
    f274:	4b04      	ldr	r3, [pc, #16]	; (f288 <spi_m_async_get_io_descriptor+0x24>)
    f276:	f240 126f 	movw	r2, #367	; 0x16f
	*io = &spi->io;
    f27a:	3424      	adds	r4, #36	; 0x24
	ASSERT(spi && io);
    f27c:	4798      	blx	r3
	*io = &spi->io;
    f27e:	602c      	str	r4, [r5, #0]
	return 0;
}
    f280:	2000      	movs	r0, #0
    f282:	bd38      	pop	{r3, r4, r5, pc}
    f284:	000164bf 	.word	0x000164bf
    f288:	0000e03d 	.word	0x0000e03d

0000f28c <crc_sync_init>:

/**
 * \brief Initialize CRC.
 */
int32_t crc_sync_init(struct crc_sync_descriptor *const descr, void *const hw)
{
    f28c:	b570      	push	{r4, r5, r6, lr}
    f28e:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    f290:	4604      	mov	r4, r0
    f292:	b110      	cbz	r0, f29a <crc_sync_init+0xe>
    f294:	1e08      	subs	r0, r1, #0
    f296:	bf18      	it	ne
    f298:	2001      	movne	r0, #1
    f29a:	4905      	ldr	r1, [pc, #20]	; (f2b0 <crc_sync_init+0x24>)
    f29c:	4b05      	ldr	r3, [pc, #20]	; (f2b4 <crc_sync_init+0x28>)
    f29e:	222b      	movs	r2, #43	; 0x2b
    f2a0:	4798      	blx	r3

	return _crc_sync_init(&descr->dev, hw);
    f2a2:	4629      	mov	r1, r5
    f2a4:	4620      	mov	r0, r4
    f2a6:	4b04      	ldr	r3, [pc, #16]	; (f2b8 <crc_sync_init+0x2c>)
}
    f2a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _crc_sync_init(&descr->dev, hw);
    f2ac:	4718      	bx	r3
    f2ae:	bf00      	nop
    f2b0:	000164dc 	.word	0x000164dc
    f2b4:	0000e03d 	.word	0x0000e03d
    f2b8:	00013a99 	.word	0x00013a99

0000f2bc <_usb_d_find_ep>:
 * \retval <0 Not found (endpoint is not initialized).
 */
static int8_t _usb_d_find_ep(const uint8_t ep)
{
	int8_t i;
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f2bc:	4a0a      	ldr	r2, [pc, #40]	; (f2e8 <_usb_d_find_ep+0x2c>)
{
    f2be:	b570      	push	{r4, r5, r6, lr}
    f2c0:	2300      	movs	r3, #0
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
			return i;
		}
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    f2c2:	f000 050f 	and.w	r5, r0, #15
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
    f2c6:	7854      	ldrb	r4, [r2, #1]
    f2c8:	4284      	cmp	r4, r0
    f2ca:	b259      	sxtb	r1, r3
    f2cc:	d00a      	beq.n	f2e4 <_usb_d_find_ep+0x28>
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
    f2ce:	7816      	ldrb	r6, [r2, #0]
    f2d0:	b90e      	cbnz	r6, f2d6 <_usb_d_find_ep+0x1a>
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    f2d2:	42ac      	cmp	r4, r5
    f2d4:	d006      	beq.n	f2e4 <_usb_d_find_ep+0x28>
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f2d6:	3301      	adds	r3, #1
    f2d8:	2b0d      	cmp	r3, #13
    f2da:	f102 0220 	add.w	r2, r2, #32
    f2de:	d1f2      	bne.n	f2c6 <_usb_d_find_ep+0xa>
			return i;
		}
	}
	return -1;
    f2e0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
}
    f2e4:	4608      	mov	r0, r1
    f2e6:	bd70      	pop	{r4, r5, r6, pc}
    f2e8:	20008b60 	.word	0x20008b60

0000f2ec <usb_d_dummy_cb_false>:
{
	(void)unused0;
	(void)unused1;
	(void)unused2;
	return false;
}
    f2ec:	2000      	movs	r0, #0
    f2ee:	4770      	bx	lr

0000f2f0 <usb_d_cb_trans_more>:
 * \brief Callback invoked when request more data
 * \param[in] ep Endpoint number with transfer direction on bit 8.
 * \param[in] transfered Number of bytes transfered.
 */
static bool usb_d_cb_trans_more(const uint8_t ep, const uint32_t transfered)
{
    f2f0:	b513      	push	{r0, r1, r4, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f2f2:	4b0a      	ldr	r3, [pc, #40]	; (f31c <usb_d_cb_trans_more+0x2c>)
{
    f2f4:	9101      	str	r1, [sp, #4]
    f2f6:	4604      	mov	r4, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f2f8:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ept->xfer.hdr.state == USB_EP_S_X_DATA) {
    f2fa:	4b09      	ldr	r3, [pc, #36]	; (f320 <usb_d_cb_trans_more+0x30>)
    f2fc:	9901      	ldr	r1, [sp, #4]
    f2fe:	eb03 1340 	add.w	r3, r3, r0, lsl #5
    f302:	789a      	ldrb	r2, [r3, #2]
    f304:	2a03      	cmp	r2, #3
    f306:	d105      	bne.n	f314 <usb_d_cb_trans_more+0x24>
		return ept->callbacks.more(ep, transfered);
    f308:	699b      	ldr	r3, [r3, #24]
    f30a:	4620      	mov	r0, r4
	}
	return false;
}
    f30c:	b002      	add	sp, #8
    f30e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return ept->callbacks.more(ep, transfered);
    f312:	4718      	bx	r3
}
    f314:	2000      	movs	r0, #0
    f316:	b002      	add	sp, #8
    f318:	bd10      	pop	{r4, pc}
    f31a:	bf00      	nop
    f31c:	0000f2bd 	.word	0x0000f2bd
    f320:	20008b60 	.word	0x20008b60

0000f324 <_usb_d_cb_trans_done>:

/**
 * Callback when USB transactions are finished.
 */
static void _usb_d_cb_trans_done(const uint8_t ep, const int32_t code, const uint32_t transferred)
{
    f324:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f328:	4b37      	ldr	r3, [pc, #220]	; (f408 <_usb_d_cb_trans_done+0xe4>)
    f32a:	4c38      	ldr	r4, [pc, #224]	; (f40c <_usb_d_cb_trans_done+0xe8>)
{
    f32c:	b085      	sub	sp, #20
    f32e:	4680      	mov	r8, r0
    f330:	460f      	mov	r7, r1
    f332:	4691      	mov	r9, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    f334:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];

	if (code == USB_TRANS_DONE) {
    f336:	0146      	lsls	r6, r0, #5
    f338:	2f00      	cmp	r7, #0
    f33a:	d143      	bne.n	f3c4 <_usb_d_cb_trans_done+0xa0>
		ept->xfer.hdr.status = USB_XFER_DONE;
    f33c:	19a5      	adds	r5, r4, r6
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f33e:	5da1      	ldrb	r1, [r4, r6]
		ept->xfer.hdr.status = USB_XFER_DONE;
    f340:	70ef      	strb	r7, [r5, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f342:	2900      	cmp	r1, #0
    f344:	d135      	bne.n	f3b2 <_usb_d_cb_trans_done+0x8e>
	if (state == USB_EP_S_X_DATA) {
    f346:	2320      	movs	r3, #32
    f348:	220c      	movs	r2, #12
    f34a:	fb13 2000 	smlabb	r0, r3, r0, r2
    f34e:	78ab      	ldrb	r3, [r5, #2]
    f350:	2b03      	cmp	r3, #3
    f352:	eb04 0200 	add.w	r2, r4, r0
    f356:	69eb      	ldr	r3, [r5, #28]
    f358:	7868      	ldrb	r0, [r5, #1]
    f35a:	d126      	bne.n	f3aa <_usb_d_cb_trans_done+0x86>
		bool err = ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DATA, ept->xfer.req);
    f35c:	2101      	movs	r1, #1
    f35e:	f995 400c 	ldrsb.w	r4, [r5, #12]
    f362:	4798      	blx	r3
		if (err) {
    f364:	786b      	ldrb	r3, [r5, #1]
    f366:	b168      	cbz	r0, f384 <_usb_d_cb_trans_done+0x60>
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    f368:	2c00      	cmp	r4, #0
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    f36a:	f240 2205 	movw	r2, #517	; 0x205
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    f36e:	bfb4      	ite	lt
    f370:	4618      	movlt	r0, r3
    f372:	f043 0080 	orrge.w	r0, r3, #128	; 0x80
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    f376:	806a      	strh	r2, [r5, #2]
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    f378:	4b25      	ldr	r3, [pc, #148]	; (f410 <_usb_d_cb_trans_done+0xec>)
    f37a:	2101      	movs	r1, #1
    f37c:	4798      	blx	r3
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
		ept->xfer.hdr.status = USB_XFER_ERROR;
	}

	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
}
    f37e:	b005      	add	sp, #20
    f380:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	struct usb_d_transfer trans
    f384:	2c00      	cmp	r4, #0
    f386:	bfac      	ite	ge
    f388:	f043 0380 	orrge.w	r3, r3, #128	; 0x80
    f38c:	f003 030f 	andlt.w	r3, r3, #15
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    f390:	2204      	movs	r2, #4
	struct usb_d_transfer trans
    f392:	f88d 300c 	strb.w	r3, [sp, #12]
    f396:	2301      	movs	r3, #1
    f398:	e9cd 0001 	strd	r0, r0, [sp, #4]
    f39c:	f88d 300d 	strb.w	r3, [sp, #13]
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    f3a0:	70aa      	strb	r2, [r5, #2]
	return _usb_d_dev_ep_trans(&trans);
    f3a2:	4b1c      	ldr	r3, [pc, #112]	; (f414 <_usb_d_cb_trans_done+0xf0>)
    f3a4:	a801      	add	r0, sp, #4
    f3a6:	4798      	blx	r3
    f3a8:	e7e9      	b.n	f37e <_usb_d_cb_trans_done+0x5a>
		ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DONE, ept->xfer.req);
    f3aa:	4798      	blx	r3
		ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    f3ac:	2302      	movs	r3, #2
    f3ae:	70ab      	strb	r3, [r5, #2]
    f3b0:	e7e5      	b.n	f37e <_usb_d_cb_trans_done+0x5a>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    f3b2:	2301      	movs	r3, #1
    f3b4:	70ab      	strb	r3, [r5, #2]
	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
    f3b6:	4434      	add	r4, r6
    f3b8:	464a      	mov	r2, r9
    f3ba:	69e3      	ldr	r3, [r4, #28]
    f3bc:	78e1      	ldrb	r1, [r4, #3]
    f3be:	4640      	mov	r0, r8
    f3c0:	4798      	blx	r3
    f3c2:	e7dc      	b.n	f37e <_usb_d_cb_trans_done+0x5a>
	} else if (code == USB_TRANS_STALL) {
    f3c4:	2f01      	cmp	r7, #1
		ept->xfer.hdr.status = USB_XFER_HALT;
    f3c6:	eb04 0306 	add.w	r3, r4, r6
	} else if (code == USB_TRANS_STALL) {
    f3ca:	d10b      	bne.n	f3e4 <_usb_d_cb_trans_done+0xc0>
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f3cc:	5da1      	ldrb	r1, [r4, r6]
		ept->xfer.hdr.status = USB_XFER_HALT;
    f3ce:	2202      	movs	r2, #2
    f3d0:	70da      	strb	r2, [r3, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f3d2:	b921      	cbnz	r1, f3de <_usb_d_cb_trans_done+0xba>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    f3d4:	709a      	strb	r2, [r3, #2]
			_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    f3d6:	4640      	mov	r0, r8
    f3d8:	4b0d      	ldr	r3, [pc, #52]	; (f410 <_usb_d_cb_trans_done+0xec>)
    f3da:	4798      	blx	r3
    f3dc:	e7eb      	b.n	f3b6 <_usb_d_cb_trans_done+0x92>
			ept->xfer.hdr.state = USB_EP_S_HALTED;
    f3de:	2205      	movs	r2, #5
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    f3e0:	709a      	strb	r2, [r3, #2]
    f3e2:	e7e8      	b.n	f3b6 <_usb_d_cb_trans_done+0x92>
	} else if (code == USB_TRANS_ABORT) {
    f3e4:	2f02      	cmp	r7, #2
    f3e6:	d107      	bne.n	f3f8 <_usb_d_cb_trans_done+0xd4>
		ept->xfer.hdr.status = USB_XFER_ABORT;
    f3e8:	2204      	movs	r2, #4
    f3ea:	70da      	strb	r2, [r3, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f3ec:	5da2      	ldrb	r2, [r4, r6]
    f3ee:	b90a      	cbnz	r2, f3f4 <_usb_d_cb_trans_done+0xd0>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    f3f0:	709f      	strb	r7, [r3, #2]
			return;
    f3f2:	e7c4      	b.n	f37e <_usb_d_cb_trans_done+0x5a>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    f3f4:	2201      	movs	r2, #1
    f3f6:	e7f3      	b.n	f3e0 <_usb_d_cb_trans_done+0xbc>
	} else if (code == USB_TRANS_RESET) {
    f3f8:	2f03      	cmp	r7, #3
		ept->xfer.hdr.state  = USB_EP_S_DISABLED;
    f3fa:	bf0c      	ite	eq
    f3fc:	f44f 62a0 	moveq.w	r2, #1280	; 0x500
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
    f400:	f240 6206 	movwne	r2, #1542	; 0x606
    f404:	805a      	strh	r2, [r3, #2]
    f406:	e7d6      	b.n	f3b6 <_usb_d_cb_trans_done+0x92>
    f408:	0000f2bd 	.word	0x0000f2bd
    f40c:	20008b60 	.word	0x20008b60
    f410:	0000d6bd 	.word	0x0000d6bd
    f414:	0000d7dd 	.word	0x0000d7dd

0000f418 <usb_d_cb_trans_setup>:
{
    f418:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f41c:	4b18      	ldr	r3, [pc, #96]	; (f480 <usb_d_cb_trans_setup+0x68>)
	uint8_t *        req      = ept->xfer.req;
    f41e:	4f19      	ldr	r7, [pc, #100]	; (f484 <usb_d_cb_trans_setup+0x6c>)
    f420:	4d19      	ldr	r5, [pc, #100]	; (f488 <usb_d_cb_trans_setup+0x70>)
{
    f422:	4604      	mov	r4, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f424:	4798      	blx	r3
	uint8_t *        req      = ept->xfer.req;
    f426:	f04f 0820 	mov.w	r8, #32
    f42a:	230c      	movs	r3, #12
    f42c:	fb18 3800 	smlabb	r8, r8, r0, r3
    f430:	44b8      	add	r8, r7
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
    f432:	4b16      	ldr	r3, [pc, #88]	; (f48c <usb_d_cb_trans_setup+0x74>)
	int8_t           ep_index = _usb_d_find_ep(ep);
    f434:	4606      	mov	r6, r0
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
    f436:	4641      	mov	r1, r8
    f438:	4620      	mov	r0, r4
    f43a:	4798      	blx	r3
	if (n != 8) {
    f43c:	b2c0      	uxtb	r0, r0
    f43e:	2808      	cmp	r0, #8
    f440:	f044 0980 	orr.w	r9, r4, #128	; 0x80
    f444:	d008      	beq.n	f458 <usb_d_cb_trans_setup+0x40>
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    f446:	2101      	movs	r1, #1
    f448:	4620      	mov	r0, r4
    f44a:	47a8      	blx	r5
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    f44c:	4648      	mov	r0, r9
    f44e:	462b      	mov	r3, r5
    f450:	2101      	movs	r1, #1
}
    f452:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    f456:	4718      	bx	r3
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    f458:	eb07 1646 	add.w	r6, r7, r6, lsl #5
	_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    f45c:	2100      	movs	r1, #0
    f45e:	4620      	mov	r0, r4
    f460:	47a8      	blx	r5
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    f462:	2701      	movs	r7, #1
	_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_CLR);
    f464:	2100      	movs	r1, #0
    f466:	4648      	mov	r0, r9
    f468:	47a8      	blx	r5
	if (!ept->callbacks.req(ep, req)) {
    f46a:	6973      	ldr	r3, [r6, #20]
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    f46c:	70b7      	strb	r7, [r6, #2]
	if (!ept->callbacks.req(ep, req)) {
    f46e:	4641      	mov	r1, r8
    f470:	4620      	mov	r0, r4
    f472:	4798      	blx	r3
    f474:	b910      	cbnz	r0, f47c <usb_d_cb_trans_setup+0x64>
		ept->xfer.hdr.state = USB_EP_S_HALTED;
    f476:	2305      	movs	r3, #5
    f478:	70b3      	strb	r3, [r6, #2]
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    f47a:	e7e4      	b.n	f446 <usb_d_cb_trans_setup+0x2e>
}
    f47c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f480:	0000f2bd 	.word	0x0000f2bd
    f484:	20008b60 	.word	0x20008b60
    f488:	0000d6bd 	.word	0x0000d6bd
    f48c:	0000d789 	.word	0x0000d789

0000f490 <usb_d_init>:

int32_t usb_d_init(void)
{
    f490:	b510      	push	{r4, lr}
	int32_t rc = _usb_d_dev_init();
    f492:	4b11      	ldr	r3, [pc, #68]	; (f4d8 <usb_d_init+0x48>)
    f494:	4798      	blx	r3
	uint8_t i;
	if (rc < 0) {
    f496:	2800      	cmp	r0, #0
    f498:	db1d      	blt.n	f4d6 <usb_d_init+0x46>
		return rc;
	}
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
    f49a:	4b10      	ldr	r3, [pc, #64]	; (f4dc <usb_d_init+0x4c>)
    f49c:	4810      	ldr	r0, [pc, #64]	; (f4e0 <usb_d_init+0x50>)
    f49e:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
    f4a2:	2100      	movs	r1, #0
    f4a4:	4798      	blx	r3
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f4a6:	4b0e      	ldr	r3, [pc, #56]	; (f4e0 <usb_d_init+0x50>)
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
    f4a8:	490e      	ldr	r1, [pc, #56]	; (f4e4 <usb_d_init+0x54>)
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
    f4aa:	2200      	movs	r2, #0
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    f4ac:	20ff      	movs	r0, #255	; 0xff
    f4ae:	3201      	adds	r2, #1
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f4b0:	2a0d      	cmp	r2, #13
		usb_d_inst.ep[i].callbacks.more = (usb_d_ep_cb_more_t)usb_d_dummy_cb_false;
    f4b2:	e9c3 1105 	strd	r1, r1, [r3, #20]
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    f4b6:	7058      	strb	r0, [r3, #1]
		usb_d_inst.ep[i].callbacks.xfer = (usb_d_ep_cb_xfer_t)usb_d_dummy_cb_false;
    f4b8:	61d9      	str	r1, [r3, #28]
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f4ba:	f103 0320 	add.w	r3, r3, #32
    f4be:	d1f6      	bne.n	f4ae <usb_d_init+0x1e>
	}
	/* Handles device driver endpoint callbacks to build transfer. */
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_SETUP, (FUNC_PTR)usb_d_cb_trans_setup);
    f4c0:	4c09      	ldr	r4, [pc, #36]	; (f4e8 <usb_d_init+0x58>)
    f4c2:	490a      	ldr	r1, [pc, #40]	; (f4ec <usb_d_init+0x5c>)
    f4c4:	2000      	movs	r0, #0
    f4c6:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_MORE, (FUNC_PTR)usb_d_cb_trans_more);
    f4c8:	4909      	ldr	r1, [pc, #36]	; (f4f0 <usb_d_init+0x60>)
    f4ca:	2001      	movs	r0, #1
    f4cc:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_DONE, (FUNC_PTR)_usb_d_cb_trans_done);
    f4ce:	2002      	movs	r0, #2
    f4d0:	4908      	ldr	r1, [pc, #32]	; (f4f4 <usb_d_init+0x64>)
    f4d2:	47a0      	blx	r4
	return ERR_NONE;
    f4d4:	2000      	movs	r0, #0
}
    f4d6:	bd10      	pop	{r4, pc}
    f4d8:	0000d2b5 	.word	0x0000d2b5
    f4dc:	000142f1 	.word	0x000142f1
    f4e0:	20008b60 	.word	0x20008b60
    f4e4:	0000f2ed 	.word	0x0000f2ed
    f4e8:	0000d97d 	.word	0x0000d97d
    f4ec:	0000f419 	.word	0x0000f419
    f4f0:	0000f2f1 	.word	0x0000f2f1
    f4f4:	0000f325 	.word	0x0000f325

0000f4f8 <usb_d_register_callback>:
}

void usb_d_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
	/* Directly uses device driver callback. */
	_usb_d_dev_register_callback(type, func);
    f4f8:	4b00      	ldr	r3, [pc, #0]	; (f4fc <usb_d_register_callback+0x4>)
    f4fa:	4718      	bx	r3
    f4fc:	0000d959 	.word	0x0000d959

0000f500 <usb_d_enable>:
}

int32_t usb_d_enable(void)
{
	return _usb_d_dev_enable();
    f500:	4b00      	ldr	r3, [pc, #0]	; (f504 <usb_d_enable+0x4>)
    f502:	4718      	bx	r3
    f504:	0000d391 	.word	0x0000d391

0000f508 <usb_d_attach>:
	_usb_d_dev_disable();
}

void usb_d_attach(void)
{
	_usb_d_dev_attach();
    f508:	4b00      	ldr	r3, [pc, #0]	; (f50c <usb_d_attach+0x4>)
    f50a:	4718      	bx	r3
    f50c:	0000d3ed 	.word	0x0000d3ed

0000f510 <usb_d_get_frame_num>:
	return _usb_d_dev_get_speed();
}

uint16_t usb_d_get_frame_num(void)
{
	return _usb_d_dev_get_frame_n();
    f510:	4b00      	ldr	r3, [pc, #0]	; (f514 <usb_d_get_frame_num+0x4>)
    f512:	4718      	bx	r3
    f514:	0000d40b 	.word	0x0000d40b

0000f518 <usb_d_set_address>:
	return _usb_d_dev_get_uframe_n();
}

void usb_d_set_address(const uint8_t addr)
{
	_usb_d_dev_set_address(addr);
    f518:	4b00      	ldr	r3, [pc, #0]	; (f51c <usb_d_set_address+0x4>)
    f51a:	4718      	bx	r3
    f51c:	0000d3ff 	.word	0x0000d3ff

0000f520 <usb_d_ep_init>:
{
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
}

int32_t usb_d_ep_init(const uint8_t ep, const uint8_t attr, const uint16_t max_pkt_size)
{
    f520:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int32_t          rc;
	int8_t           ep_index = _usb_d_find_ep(ep);
    f522:	4c11      	ldr	r4, [pc, #68]	; (f568 <usb_d_ep_init+0x48>)
{
    f524:	4606      	mov	r6, r0
    f526:	460d      	mov	r5, r1
    f528:	4617      	mov	r7, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    f52a:	47a0      	blx	r4
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index >= 0) {
    f52c:	2800      	cmp	r0, #0
    f52e:	da14      	bge.n	f55a <usb_d_ep_init+0x3a>
		return -USB_ERR_REDO;
	} else {
		ep_index = _usb_d_find_ep(0xFF);
    f530:	20ff      	movs	r0, #255	; 0xff
    f532:	47a0      	blx	r4
		if (ep_index < 0) {
    f534:	1e04      	subs	r4, r0, #0
    f536:	db13      	blt.n	f560 <usb_d_ep_init+0x40>
			return -USB_ERR_ALLOC_FAIL;
		}
		ept = &usb_d_inst.ep[ep_index];
	}
	rc = _usb_d_dev_ep_init(ep, attr, max_pkt_size);
    f538:	4b0c      	ldr	r3, [pc, #48]	; (f56c <usb_d_ep_init+0x4c>)
    f53a:	463a      	mov	r2, r7
    f53c:	4629      	mov	r1, r5
    f53e:	4630      	mov	r0, r6
    f540:	4798      	blx	r3
	if (rc < 0) {
    f542:	2800      	cmp	r0, #0
    f544:	db08      	blt.n	f558 <usb_d_ep_init+0x38>
		return rc;
	}
	ept->xfer.hdr.ep   = ep;
    f546:	4b0a      	ldr	r3, [pc, #40]	; (f570 <usb_d_ep_init+0x50>)
    f548:	0162      	lsls	r2, r4, #5
	ept->xfer.hdr.type = attr & USB_EP_XTYPE_MASK;
    f54a:	f005 0503 	and.w	r5, r5, #3
	ept->xfer.hdr.ep   = ep;
    f54e:	eb03 1444 	add.w	r4, r3, r4, lsl #5
	ept->xfer.hdr.type = attr & USB_EP_XTYPE_MASK;
    f552:	549d      	strb	r5, [r3, r2]
	ept->xfer.hdr.ep   = ep;
    f554:	7066      	strb	r6, [r4, #1]
	return ERR_NONE;
    f556:	2000      	movs	r0, #0
}
    f558:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -USB_ERR_REDO;
    f55a:	f06f 0013 	mvn.w	r0, #19
    f55e:	e7fb      	b.n	f558 <usb_d_ep_init+0x38>
			return -USB_ERR_ALLOC_FAIL;
    f560:	f06f 0014 	mvn.w	r0, #20
    f564:	e7f8      	b.n	f558 <usb_d_ep_init+0x38>
    f566:	bf00      	nop
    f568:	0000f2bd 	.word	0x0000f2bd
    f56c:	0000d419 	.word	0x0000d419
    f570:	20008b60 	.word	0x20008b60

0000f574 <usb_d_ep0_init>:
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
    f574:	2100      	movs	r1, #0
{
    f576:	4602      	mov	r2, r0
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
    f578:	4b01      	ldr	r3, [pc, #4]	; (f580 <usb_d_ep0_init+0xc>)
    f57a:	4608      	mov	r0, r1
    f57c:	4718      	bx	r3
    f57e:	bf00      	nop
    f580:	0000f521 	.word	0x0000f521

0000f584 <usb_d_ep_deinit>:

void usb_d_ep_deinit(const uint8_t ep)
{
    f584:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f586:	4b07      	ldr	r3, [pc, #28]	; (f5a4 <usb_d_ep_deinit+0x20>)
{
    f588:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f58a:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index < 0) {
    f58c:	1e04      	subs	r4, r0, #0
    f58e:	db07      	blt.n	f5a0 <usb_d_ep_deinit+0x1c>
		return;
	}
	_usb_d_dev_ep_deinit(ep);
    f590:	4b05      	ldr	r3, [pc, #20]	; (f5a8 <usb_d_ep_deinit+0x24>)
    f592:	4628      	mov	r0, r5
    f594:	4798      	blx	r3
	ept->xfer.hdr.ep = 0xFF;
    f596:	4805      	ldr	r0, [pc, #20]	; (f5ac <usb_d_ep_deinit+0x28>)
    f598:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    f59c:	23ff      	movs	r3, #255	; 0xff
    f59e:	7043      	strb	r3, [r0, #1]
}
    f5a0:	bd38      	pop	{r3, r4, r5, pc}
    f5a2:	bf00      	nop
    f5a4:	0000f2bd 	.word	0x0000f2bd
    f5a8:	0000d4d9 	.word	0x0000d4d9
    f5ac:	20008b60 	.word	0x20008b60

0000f5b0 <usb_d_ep_enable>:

int32_t usb_d_ep_enable(const uint8_t ep)
{
    f5b0:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f5b2:	4b0c      	ldr	r3, [pc, #48]	; (f5e4 <usb_d_ep_enable+0x34>)
{
    f5b4:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f5b6:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	int32_t          rc;
	if (ep_index < 0) {
    f5b8:	1e03      	subs	r3, r0, #0
    f5ba:	db10      	blt.n	f5de <usb_d_ep_enable+0x2e>
		return -USB_ERR_PARAM;
	}
	ept->xfer.hdr.state = (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) ? USB_EP_S_X_SETUP : USB_EP_S_IDLE;
    f5bc:	015b      	lsls	r3, r3, #5
    f5be:	4c0a      	ldr	r4, [pc, #40]	; (f5e8 <usb_d_ep_enable+0x38>)
    f5c0:	5ce2      	ldrb	r2, [r4, r3]
    f5c2:	441c      	add	r4, r3
    f5c4:	2a00      	cmp	r2, #0
    f5c6:	bf0c      	ite	eq
    f5c8:	2202      	moveq	r2, #2
    f5ca:	2201      	movne	r2, #1
	rc                  = _usb_d_dev_ep_enable(ep);
    f5cc:	4b07      	ldr	r3, [pc, #28]	; (f5ec <usb_d_ep_enable+0x3c>)
	ept->xfer.hdr.state = (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) ? USB_EP_S_X_SETUP : USB_EP_S_IDLE;
    f5ce:	70a2      	strb	r2, [r4, #2]
	rc                  = _usb_d_dev_ep_enable(ep);
    f5d0:	4628      	mov	r0, r5
    f5d2:	4798      	blx	r3
	if (rc < 0) {
    f5d4:	2800      	cmp	r0, #0
    f5d6:	da01      	bge.n	f5dc <usb_d_ep_enable+0x2c>
		ept->xfer.hdr.state = USB_EP_S_DISABLED;
    f5d8:	2300      	movs	r3, #0
    f5da:	70a3      	strb	r3, [r4, #2]
	}
	return rc;
}
    f5dc:	bd38      	pop	{r3, r4, r5, pc}
		return -USB_ERR_PARAM;
    f5de:	f06f 0011 	mvn.w	r0, #17
    f5e2:	e7fb      	b.n	f5dc <usb_d_ep_enable+0x2c>
    f5e4:	0000f2bd 	.word	0x0000f2bd
    f5e8:	20008b60 	.word	0x20008b60
    f5ec:	0000d54d 	.word	0x0000d54d

0000f5f0 <usb_d_ep_transfer>:
	}
	return usb_d_inst.ep[ep_index].xfer.req;
}

int32_t usb_d_ep_transfer(const struct usb_d_transfer *xfer)
{
    f5f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int8_t                ep_index = _usb_d_find_ep(xfer->ep);
    f5f4:	f890 8008 	ldrb.w	r8, [r0, #8]
    f5f8:	4b31      	ldr	r3, [pc, #196]	; (f6c0 <usb_d_ep_transfer+0xd0>)
{
    f5fa:	4605      	mov	r5, r0
    f5fc:	b087      	sub	sp, #28
	int8_t                ep_index = _usb_d_find_ep(xfer->ep);
    f5fe:	4640      	mov	r0, r8
    f600:	4798      	blx	r3
	uint32_t              len = xfer->size;
	int32_t               rc;
	volatile uint8_t      state;
	volatile hal_atomic_t flags;

	if (ep_index < 0) {
    f602:	1e04      	subs	r4, r0, #0
	bool                  dir = USB_EP_GET_DIR(xfer->ep), zlp = xfer->zlp;
    f604:	7a6f      	ldrb	r7, [r5, #9]
	uint32_t              len = xfer->size;
    f606:	686e      	ldr	r6, [r5, #4]
	if (ep_index < 0) {
    f608:	db55      	blt.n	f6b6 <usb_d_ep_transfer+0xc6>
		return -USB_ERR_PARAM;
	}

	atomic_enter_critical(&flags);
	state = ept->xfer.hdr.state;
    f60a:	f8df a0c8 	ldr.w	sl, [pc, #200]	; f6d4 <usb_d_ep_transfer+0xe4>
	atomic_enter_critical(&flags);
    f60e:	4b2d      	ldr	r3, [pc, #180]	; (f6c4 <usb_d_ep_transfer+0xd4>)
	state = ept->xfer.hdr.state;
    f610:	ea4f 1b44 	mov.w	fp, r4, lsl #5
    f614:	eb0a 1444 	add.w	r4, sl, r4, lsl #5
	atomic_enter_critical(&flags);
    f618:	a802      	add	r0, sp, #8
    f61a:	4798      	blx	r3
	state = ept->xfer.hdr.state;
    f61c:	78a3      	ldrb	r3, [r4, #2]
    f61e:	f88d 3007 	strb.w	r3, [sp, #7]
	if (state == USB_EP_S_IDLE) {
    f622:	f89d 3007 	ldrb.w	r3, [sp, #7]
    f626:	2b01      	cmp	r3, #1
    f628:	fa5f f983 	uxtb.w	r9, r3
    f62c:	4b26      	ldr	r3, [pc, #152]	; (f6c8 <usb_d_ep_transfer+0xd8>)
    f62e:	d11a      	bne.n	f666 <usb_d_ep_transfer+0x76>
		ept->xfer.hdr.state = USB_EP_S_X_DATA;
    f630:	2203      	movs	r2, #3
    f632:	70a2      	strb	r2, [r4, #2]
		atomic_leave_critical(&flags);
    f634:	a802      	add	r0, sp, #8
    f636:	4798      	blx	r3
		default: /* USB_EP_S_X_xxxx  */
			return USB_BUSY;
		}
	}

	if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f638:	f81a 300b 	ldrb.w	r3, [sl, fp]
    f63c:	b1fb      	cbz	r3, f67e <usb_d_ep_transfer+0x8e>
	bool                  dir = USB_EP_GET_DIR(xfer->ep), zlp = xfer->zlp;
    f63e:	1e3b      	subs	r3, r7, #0
    f640:	ea4f 12d8 	mov.w	r2, r8, lsr #7
    f644:	bf18      	it	ne
    f646:	2301      	movne	r3, #1
	struct usb_d_transfer trans
    f648:	6828      	ldr	r0, [r5, #0]
				zlp = false;
			}
		}
	}

	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
    f64a:	7a29      	ldrb	r1, [r5, #8]
	struct usb_d_transfer trans
    f64c:	e9cd 0603 	strd	r0, r6, [sp, #12]
    f650:	b372      	cbz	r2, f6b0 <usb_d_ep_transfer+0xc0>
    f652:	f041 0280 	orr.w	r2, r1, #128	; 0x80
    f656:	f88d 3015 	strb.w	r3, [sp, #21]
	return _usb_d_dev_ep_trans(&trans);
    f65a:	a803      	add	r0, sp, #12
    f65c:	4b1b      	ldr	r3, [pc, #108]	; (f6cc <usb_d_ep_transfer+0xdc>)
	struct usb_d_transfer trans
    f65e:	f88d 2014 	strb.w	r2, [sp, #20]
	return _usb_d_dev_ep_trans(&trans);
    f662:	4798      	blx	r3
	return rc;
    f664:	e008      	b.n	f678 <usb_d_ep_transfer+0x88>
		atomic_leave_critical(&flags);
    f666:	a802      	add	r0, sp, #8
    f668:	4798      	blx	r3
		switch (state) {
    f66a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    f66e:	2b06      	cmp	r3, #6
    f670:	b2da      	uxtb	r2, r3
    f672:	d823      	bhi.n	f6bc <usb_d_ep_transfer+0xcc>
    f674:	4b16      	ldr	r3, [pc, #88]	; (f6d0 <usb_d_ep_transfer+0xe0>)
    f676:	5698      	ldrsb	r0, [r3, r2]
}
    f678:	b007      	add	sp, #28
    f67a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint16_t req_len = USB_GET_wLength(ept->xfer.req);
    f67e:	7ce1      	ldrb	r1, [r4, #19]
    f680:	7ca2      	ldrb	r2, [r4, #18]
    f682:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    f686:	b292      	uxth	r2, r2
		if (req_len == 0) {
    f688:	b92a      	cbnz	r2, f696 <usb_d_ep_transfer+0xa6>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    f68a:	2304      	movs	r3, #4
    f68c:	70a3      	strb	r3, [r4, #2]
			len                 = 0;
    f68e:	4616      	mov	r6, r2
			zlp                 = true;
    f690:	464b      	mov	r3, r9
			dir = (USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN);
    f692:	461a      	mov	r2, r3
    f694:	e7d8      	b.n	f648 <usb_d_ep_transfer+0x58>
			if (dir) {
    f696:	f994 100c 	ldrsb.w	r1, [r4, #12]
    f69a:	4296      	cmp	r6, r2
    f69c:	bf28      	it	cs
    f69e:	4616      	movcs	r6, r2
    f6a0:	2900      	cmp	r1, #0
    f6a2:	daf6      	bge.n	f692 <usb_d_ep_transfer+0xa2>
				zlp = (req_len > len);
    f6a4:	42b2      	cmp	r2, r6
    f6a6:	bf94      	ite	ls
    f6a8:	2300      	movls	r3, #0
    f6aa:	2301      	movhi	r3, #1
			dir = (USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN);
    f6ac:	464a      	mov	r2, r9
    f6ae:	e7cb      	b.n	f648 <usb_d_ep_transfer+0x58>
	struct usb_d_transfer trans
    f6b0:	f001 020f 	and.w	r2, r1, #15
    f6b4:	e7cf      	b.n	f656 <usb_d_ep_transfer+0x66>
		return -USB_ERR_PARAM;
    f6b6:	f06f 0011 	mvn.w	r0, #17
    f6ba:	e7dd      	b.n	f678 <usb_d_ep_transfer+0x88>
		switch (state) {
    f6bc:	2001      	movs	r0, #1
    f6be:	e7db      	b.n	f678 <usb_d_ep_transfer+0x88>
    f6c0:	0000f2bd 	.word	0x0000f2bd
    f6c4:	00011b09 	.word	0x00011b09
    f6c8:	00011b17 	.word	0x00011b17
    f6cc:	0000d7dd 	.word	0x0000d7dd
    f6d0:	000164f6 	.word	0x000164f6
    f6d4:	20008b60 	.word	0x20008b60

0000f6d8 <usb_d_ep_get_status>:
	ept->xfer.hdr.state  = USB_EP_S_IDLE;
	ept->xfer.hdr.status = USB_XFER_ABORT;
}

int32_t usb_d_ep_get_status(const uint8_t ep, struct usb_d_ep_status *stat)
{
    f6d8:	b5f0      	push	{r4, r5, r6, r7, lr}
	int8_t                    ep_index = _usb_d_find_ep(ep);
    f6da:	4b12      	ldr	r3, [pc, #72]	; (f724 <usb_d_ep_get_status+0x4c>)
	struct usb_d_ep *         ept      = &usb_d_inst.ep[ep_index];
	struct usb_d_trans_status tmp;
	uint8_t                   state = ept->xfer.hdr.state;
    f6dc:	4d12      	ldr	r5, [pc, #72]	; (f728 <usb_d_ep_get_status+0x50>)
{
    f6de:	b085      	sub	sp, #20
    f6e0:	4606      	mov	r6, r0
    f6e2:	460c      	mov	r4, r1
	int8_t                    ep_index = _usb_d_find_ep(ep);
    f6e4:	4798      	blx	r3
	uint8_t                   state = ept->xfer.hdr.state;
    f6e6:	eb05 1540 	add.w	r5, r5, r0, lsl #5
	if (ep_index < 0) {
    f6ea:	2800      	cmp	r0, #0
	uint8_t                   state = ept->xfer.hdr.state;
    f6ec:	78af      	ldrb	r7, [r5, #2]
	if (ep_index < 0) {
    f6ee:	db14      	blt.n	f71a <usb_d_ep_get_status+0x42>
		return -USB_ERR_PARAM;
	}
	if (stat) {
    f6f0:	b15c      	cbz	r4, f70a <usb_d_ep_get_status+0x32>
		/* Check transaction status if transferring data. */
		_usb_d_dev_ep_get_status(ep, &tmp);
    f6f2:	4b0e      	ldr	r3, [pc, #56]	; (f72c <usb_d_ep_get_status+0x54>)
    f6f4:	a901      	add	r1, sp, #4
    f6f6:	4630      	mov	r0, r6
    f6f8:	4798      	blx	r3
		stat->ep    = ep;
    f6fa:	7026      	strb	r6, [r4, #0]
		stat->state = state;
    f6fc:	70e7      	strb	r7, [r4, #3]
		stat->code  = ept->xfer.hdr.status;
    f6fe:	78eb      	ldrb	r3, [r5, #3]
    f700:	7063      	strb	r3, [r4, #1]
		stat->count = tmp.count;
    f702:	9b02      	ldr	r3, [sp, #8]
    f704:	6063      	str	r3, [r4, #4]
		stat->size  = tmp.size;
    f706:	9b01      	ldr	r3, [sp, #4]
    f708:	60a3      	str	r3, [r4, #8]
	}
	switch (state) {
    f70a:	2f06      	cmp	r7, #6
    f70c:	d808      	bhi.n	f720 <usb_d_ep_get_status+0x48>
    f70e:	4b08      	ldr	r3, [pc, #32]	; (f730 <usb_d_ep_get_status+0x58>)
    f710:	443b      	add	r3, r7
    f712:	f993 0007 	ldrsb.w	r0, [r3, #7]
		return -USB_ERR_FUNC;
	default:
		/* Busy */
		return USB_BUSY;
	}
}
    f716:	b005      	add	sp, #20
    f718:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -USB_ERR_PARAM;
    f71a:	f06f 0011 	mvn.w	r0, #17
    f71e:	e7fa      	b.n	f716 <usb_d_ep_get_status+0x3e>
    f720:	2001      	movs	r0, #1
    f722:	e7f8      	b.n	f716 <usb_d_ep_get_status+0x3e>
    f724:	0000f2bd 	.word	0x0000f2bd
    f728:	20008b60 	.word	0x20008b60
    f72c:	0000d8e5 	.word	0x0000d8e5
    f730:	000164f6 	.word	0x000164f6

0000f734 <usb_d_ep_halt>:
	}
	return ERR_NONE;
}

int32_t usb_d_ep_halt(const uint8_t ep, const enum usb_ep_halt_ctrl ctrl)
{
    f734:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f738:	4605      	mov	r5, r0
	if (ctrl == USB_EP_HALT_CLR) {
    f73a:	460c      	mov	r4, r1
    f73c:	b9d9      	cbnz	r1, f776 <usb_d_ep_halt+0x42>
	int8_t           ep_index = _usb_d_find_ep(ep);
    f73e:	4b13      	ldr	r3, [pc, #76]	; (f78c <usb_d_ep_halt+0x58>)
    f740:	4798      	blx	r3
	if (ep_index < 0) {
    f742:	1e06      	subs	r6, r0, #0
    f744:	db1e      	blt.n	f784 <usb_d_ep_halt+0x50>
	if (_usb_d_dev_ep_stall(ep, USB_EP_STALL_GET)) {
    f746:	4f12      	ldr	r7, [pc, #72]	; (f790 <usb_d_ep_halt+0x5c>)
    f748:	2102      	movs	r1, #2
    f74a:	4628      	mov	r0, r5
    f74c:	47b8      	blx	r7
    f74e:	b180      	cbz	r0, f772 <usb_d_ep_halt+0x3e>
		rc = _usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    f750:	4621      	mov	r1, r4
    f752:	4628      	mov	r0, r5
    f754:	47b8      	blx	r7
		if (rc < 0) {
    f756:	2800      	cmp	r0, #0
    f758:	db0b      	blt.n	f772 <usb_d_ep_halt+0x3e>
		ept->xfer.hdr.state  = USB_EP_S_IDLE;
    f75a:	480e      	ldr	r0, [pc, #56]	; (f794 <usb_d_ep_halt+0x60>)
    f75c:	eb00 1046 	add.w	r0, r0, r6, lsl #5
    f760:	f240 3301 	movw	r3, #769	; 0x301
    f764:	8043      	strh	r3, [r0, #2]
		ept->callbacks.xfer(ep, USB_XFER_UNHALT, NULL);
    f766:	4622      	mov	r2, r4
    f768:	69c3      	ldr	r3, [r0, #28]
    f76a:	2103      	movs	r1, #3
    f76c:	4628      	mov	r0, r5
    f76e:	4798      	blx	r3
	return ERR_NONE;
    f770:	4620      	mov	r0, r4
	} else if (ctrl == USB_EP_HALT_SET) {
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
	} else {
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
	}
}
    f772:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (ctrl == USB_EP_HALT_SET) {
    f776:	2901      	cmp	r1, #1
}
    f778:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    f77c:	4b04      	ldr	r3, [pc, #16]	; (f790 <usb_d_ep_halt+0x5c>)
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
    f77e:	bf18      	it	ne
    f780:	2102      	movne	r1, #2
    f782:	4718      	bx	r3
		return -USB_ERR_PARAM;
    f784:	f06f 0011 	mvn.w	r0, #17
    f788:	e7f3      	b.n	f772 <usb_d_ep_halt+0x3e>
    f78a:	bf00      	nop
    f78c:	0000f2bd 	.word	0x0000f2bd
    f790:	0000d6bd 	.word	0x0000d6bd
    f794:	20008b60 	.word	0x20008b60

0000f798 <usb_d_ep_register_callback>:

void usb_d_ep_register_callback(const uint8_t ep, const enum usb_d_ep_cb_type type, const FUNC_PTR func)
{
    f798:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f79a:	4b0f      	ldr	r3, [pc, #60]	; (f7d8 <usb_d_ep_register_callback+0x40>)
{
    f79c:	4614      	mov	r4, r2
    f79e:	460d      	mov	r5, r1
	int8_t           ep_index = _usb_d_find_ep(ep);
    f7a0:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	FUNC_PTR         f        = func ? (FUNC_PTR)func : (FUNC_PTR)usb_d_dummy_cb_false;
    f7a2:	4b0e      	ldr	r3, [pc, #56]	; (f7dc <usb_d_ep_register_callback+0x44>)
    f7a4:	2c00      	cmp	r4, #0
    f7a6:	bf08      	it	eq
    f7a8:	461c      	moveq	r4, r3
	if (ep_index < 0) {
    f7aa:	2800      	cmp	r0, #0
    f7ac:	db08      	blt.n	f7c0 <usb_d_ep_register_callback+0x28>
		return;
	}
	switch (type) {
    f7ae:	2d01      	cmp	r5, #1
    f7b0:	d007      	beq.n	f7c2 <usb_d_ep_register_callback+0x2a>
    f7b2:	2d02      	cmp	r5, #2
    f7b4:	d00a      	beq.n	f7cc <usb_d_ep_register_callback+0x34>
    f7b6:	b91d      	cbnz	r5, f7c0 <usb_d_ep_register_callback+0x28>
	case USB_D_EP_CB_SETUP:
		ept->callbacks.req = (usb_d_ep_cb_setup_t)f;
    f7b8:	4b09      	ldr	r3, [pc, #36]	; (f7e0 <usb_d_ep_register_callback+0x48>)
    f7ba:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    f7be:	6144      	str	r4, [r0, #20]
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
		break;
	default:
		break;
	}
}
    f7c0:	bd38      	pop	{r3, r4, r5, pc}
		ept->callbacks.more = (usb_d_ep_cb_more_t)f;
    f7c2:	4b07      	ldr	r3, [pc, #28]	; (f7e0 <usb_d_ep_register_callback+0x48>)
    f7c4:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    f7c8:	6184      	str	r4, [r0, #24]
		break;
    f7ca:	e7f9      	b.n	f7c0 <usb_d_ep_register_callback+0x28>
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
    f7cc:	4b04      	ldr	r3, [pc, #16]	; (f7e0 <usb_d_ep_register_callback+0x48>)
    f7ce:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    f7d2:	61c4      	str	r4, [r0, #28]
		break;
    f7d4:	e7f4      	b.n	f7c0 <usb_d_ep_register_callback+0x28>
    f7d6:	bf00      	nop
    f7d8:	0000f2bd 	.word	0x0000f2bd
    f7dc:	0000f2ed 	.word	0x0000f2ed
    f7e0:	20008b60 	.word	0x20008b60

0000f7e4 <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
    f7e4:	6800      	ldr	r0, [r0, #0]
    f7e6:	b900      	cbnz	r0, f7ea <is_list_element+0x6>
    f7e8:	4770      	bx	lr
		if (it == element) {
    f7ea:	4288      	cmp	r0, r1
    f7ec:	d1fa      	bne.n	f7e4 <is_list_element>
			return true;
    f7ee:	2001      	movs	r0, #1
		}
	}

	return false;
}
    f7f0:	4770      	bx	lr
	...

0000f7f4 <list_insert_as_head>:

/**
 * \brief Insert an element as list head
 */
void list_insert_as_head(struct list_descriptor *const list, void *const element)
{
    f7f4:	b538      	push	{r3, r4, r5, lr}
	ASSERT(!is_list_element(list, element));
    f7f6:	4b07      	ldr	r3, [pc, #28]	; (f814 <list_insert_as_head+0x20>)
{
    f7f8:	460d      	mov	r5, r1
    f7fa:	4604      	mov	r4, r0
	ASSERT(!is_list_element(list, element));
    f7fc:	4798      	blx	r3
    f7fe:	f080 0001 	eor.w	r0, r0, #1
    f802:	4b05      	ldr	r3, [pc, #20]	; (f818 <list_insert_as_head+0x24>)
    f804:	4905      	ldr	r1, [pc, #20]	; (f81c <list_insert_as_head+0x28>)
    f806:	2239      	movs	r2, #57	; 0x39
    f808:	b2c0      	uxtb	r0, r0
    f80a:	4798      	blx	r3

	((struct list_element *)element)->next = list->head;
    f80c:	6823      	ldr	r3, [r4, #0]
    f80e:	602b      	str	r3, [r5, #0]
	list->head                             = (struct list_element *)element;
    f810:	6025      	str	r5, [r4, #0]
}
    f812:	bd38      	pop	{r3, r4, r5, pc}
    f814:	0000f7e5 	.word	0x0000f7e5
    f818:	0000e03d 	.word	0x0000e03d
    f81c:	00016504 	.word	0x00016504

0000f820 <list_insert_after>:
/**
 * \brief Insert an element after the given list element
 */
void list_insert_after(void *const after, void *const element)
{
	((struct list_element *)element)->next = ((struct list_element *)after)->next;
    f820:	6803      	ldr	r3, [r0, #0]
    f822:	600b      	str	r3, [r1, #0]
	((struct list_element *)after)->next   = (struct list_element *)element;
    f824:	6001      	str	r1, [r0, #0]
}
    f826:	4770      	bx	lr

0000f828 <list_insert_at_end>:

/**
 * \brief Insert an element at list end
 */
void list_insert_at_end(struct list_descriptor *const list, void *const element)
{
    f828:	b570      	push	{r4, r5, r6, lr}
	struct list_element *it = list->head;

	ASSERT(!is_list_element(list, element));
    f82a:	4b0c      	ldr	r3, [pc, #48]	; (f85c <list_insert_at_end+0x34>)
	struct list_element *it = list->head;
    f82c:	6805      	ldr	r5, [r0, #0]
{
    f82e:	4606      	mov	r6, r0
    f830:	460c      	mov	r4, r1
	ASSERT(!is_list_element(list, element));
    f832:	4798      	blx	r3
    f834:	f080 0001 	eor.w	r0, r0, #1
    f838:	4b09      	ldr	r3, [pc, #36]	; (f860 <list_insert_at_end+0x38>)
    f83a:	490a      	ldr	r1, [pc, #40]	; (f864 <list_insert_at_end+0x3c>)
    f83c:	224f      	movs	r2, #79	; 0x4f
    f83e:	b2c0      	uxtb	r0, r0
    f840:	4798      	blx	r3

	if (!list->head) {
    f842:	6833      	ldr	r3, [r6, #0]
    f844:	b913      	cbnz	r3, f84c <list_insert_at_end+0x24>
		list->head                             = (struct list_element *)element;
    f846:	6034      	str	r4, [r6, #0]
		((struct list_element *)element)->next = NULL;
    f848:	6023      	str	r3, [r4, #0]
	while (it->next) {
		it = it->next;
	}
	it->next                               = (struct list_element *)element;
	((struct list_element *)element)->next = NULL;
}
    f84a:	bd70      	pop	{r4, r5, r6, pc}
	while (it->next) {
    f84c:	462b      	mov	r3, r5
    f84e:	682d      	ldr	r5, [r5, #0]
    f850:	2d00      	cmp	r5, #0
    f852:	d1fb      	bne.n	f84c <list_insert_at_end+0x24>
	it->next                               = (struct list_element *)element;
    f854:	601c      	str	r4, [r3, #0]
	((struct list_element *)element)->next = NULL;
    f856:	6025      	str	r5, [r4, #0]
    f858:	e7f7      	b.n	f84a <list_insert_at_end+0x22>
    f85a:	bf00      	nop
    f85c:	0000f7e5 	.word	0x0000f7e5
    f860:	0000e03d 	.word	0x0000e03d
    f864:	00016504 	.word	0x00016504

0000f868 <list_remove_head>:
/**
 * \brief Removes list head
 */
void *list_remove_head(struct list_descriptor *const list)
{
	if (list->head) {
    f868:	6803      	ldr	r3, [r0, #0]
    f86a:	b10b      	cbz	r3, f870 <list_remove_head+0x8>
		struct list_element *tmp = list->head;

		list->head = list->head->next;
    f86c:	681a      	ldr	r2, [r3, #0]
    f86e:	6002      	str	r2, [r0, #0]
		return (void *)tmp;
	}

	return NULL;
}
    f870:	4618      	mov	r0, r3
    f872:	4770      	bx	lr

0000f874 <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    f874:	4b03      	ldr	r3, [pc, #12]	; (f884 <_osc32kctrl_init_sources+0x10>)
    f876:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    f878:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    f87c:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    f87e:	2201      	movs	r2, #1
    f880:	741a      	strb	r2, [r3, #16]
#endif
#endif

	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
    f882:	4770      	bx	lr
    f884:	40001400 	.word	0x40001400

0000f888 <hri_rtcmode0_wait_for_sync>:
typedef uint8_t  hri_rtcalarm_mask_reg_t;
typedef uint8_t  hri_rtcmode2_mask_reg_t;

static inline void hri_rtcmode0_wait_for_sync(const void *const hw, hri_rtcmode0_syncbusy_reg_t reg)
{
	while (((Rtc *)hw)->MODE0.SYNCBUSY.reg & reg) {
    f888:	6903      	ldr	r3, [r0, #16]
    f88a:	420b      	tst	r3, r1
    f88c:	d1fc      	bne.n	f888 <hri_rtcmode0_wait_for_sync>
	};
}
    f88e:	4770      	bx	lr

0000f890 <_rtc_timer_set_period>:
/**
 * \brief Set timer period
 */
void _rtc_timer_set_period(struct _timer_device *const dev, const uint32_t clock_cycles)
{
	hri_rtcmode0_write_COMP_reg(dev->hw, 0, clock_cycles);
    f890:	68c0      	ldr	r0, [r0, #12]

static inline void hri_rtcmode0_write_COMP_reg(const void *const hw, uint8_t index, hri_rtcmode0_comp_reg_t data)
{
	RTC_CRITICAL_SECTION_ENTER();
	((Rtc *)hw)->MODE0.COMP[index].reg = data;
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    f892:	4b02      	ldr	r3, [pc, #8]	; (f89c <_rtc_timer_set_period+0xc>)
	((Rtc *)hw)->MODE0.COMP[index].reg = data;
    f894:	6201      	str	r1, [r0, #32]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    f896:	2160      	movs	r1, #96	; 0x60
    f898:	4718      	bx	r3
    f89a:	bf00      	nop
    f89c:	0000f889 	.word	0x0000f889

0000f8a0 <_rtc_timer_get_period>:

/**
 * \brief Retrieve timer period
 */
uint32_t _rtc_timer_get_period(const struct _timer_device *const dev)
{
    f8a0:	b508      	push	{r3, lr}
	return hri_rtcmode0_read_COMP_reg(dev->hw, 0);
    f8a2:	68c0      	ldr	r0, [r0, #12]
	RTC_CRITICAL_SECTION_LEAVE();
}

static inline hri_rtcmode0_comp_reg_t hri_rtcmode0_read_COMP_reg(const void *const hw, uint8_t index)
{
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    f8a4:	4b02      	ldr	r3, [pc, #8]	; (f8b0 <_rtc_timer_get_period+0x10>)
    f8a6:	2160      	movs	r1, #96	; 0x60
    f8a8:	4798      	blx	r3
	return ((Rtc *)hw)->MODE0.COMP[index].reg;
    f8aa:	6a00      	ldr	r0, [r0, #32]
}
    f8ac:	bd08      	pop	{r3, pc}
    f8ae:	bf00      	nop
    f8b0:	0000f889 	.word	0x0000f889

0000f8b4 <_rtc_timer_is_started>:

/**
 * \brief Check if timer is running
 */
bool _rtc_timer_is_started(const struct _timer_device *const dev)
{
    f8b4:	b508      	push	{r3, lr}
	return hri_rtcmode0_get_CTRLA_ENABLE_bit(dev->hw);
    f8b6:	68c0      	ldr	r0, [r0, #12]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f8b8:	4b03      	ldr	r3, [pc, #12]	; (f8c8 <_rtc_timer_is_started+0x14>)
    f8ba:	f248 0103 	movw	r1, #32771	; 0x8003
    f8be:	4798      	blx	r3
	tmp = ((Rtc *)hw)->MODE0.CTRLA.reg;
    f8c0:	8800      	ldrh	r0, [r0, #0]
}
    f8c2:	f3c0 0040 	ubfx	r0, r0, #1, #1
    f8c6:	bd08      	pop	{r3, pc}
    f8c8:	0000f889 	.word	0x0000f889

0000f8cc <_rtc_timer_set_irq>:
 * \brief Set timer IRQ
 */
void _rtc_timer_set_irq(struct _timer_device *const dev)
{
	(void)dev;
}
    f8cc:	4770      	bx	lr
	...

0000f8d0 <_rtc_timer_stop>:
{
    f8d0:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
    f8d2:	4604      	mov	r4, r0
    f8d4:	b118      	cbz	r0, f8de <_rtc_timer_stop+0xe>
    f8d6:	68c0      	ldr	r0, [r0, #12]
    f8d8:	3800      	subs	r0, #0
    f8da:	bf18      	it	ne
    f8dc:	2001      	movne	r0, #1
    f8de:	4908      	ldr	r1, [pc, #32]	; (f900 <_rtc_timer_stop+0x30>)
    f8e0:	4b08      	ldr	r3, [pc, #32]	; (f904 <_rtc_timer_stop+0x34>)
    f8e2:	226b      	movs	r2, #107	; 0x6b
    f8e4:	4798      	blx	r3
	hri_rtcmode0_clear_CTRLA_ENABLE_bit(dev->hw);
    f8e6:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg &= ~RTC_MODE0_CTRLA_ENABLE;
    f8e8:	8803      	ldrh	r3, [r0, #0]
    f8ea:	f023 0302 	bic.w	r3, r3, #2
    f8ee:	041b      	lsls	r3, r3, #16
    f8f0:	0c1b      	lsrs	r3, r3, #16
    f8f2:	8003      	strh	r3, [r0, #0]
}
    f8f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f8f8:	4b03      	ldr	r3, [pc, #12]	; (f908 <_rtc_timer_stop+0x38>)
    f8fa:	f248 0103 	movw	r1, #32771	; 0x8003
    f8fe:	4718      	bx	r3
    f900:	00016522 	.word	0x00016522
    f904:	0000e03d 	.word	0x0000e03d
    f908:	0000f889 	.word	0x0000f889

0000f90c <_rtc_timer_start>:
{
    f90c:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
    f90e:	4604      	mov	r4, r0
    f910:	b118      	cbz	r0, f91a <_rtc_timer_start+0xe>
    f912:	68c0      	ldr	r0, [r0, #12]
    f914:	3800      	subs	r0, #0
    f916:	bf18      	it	ne
    f918:	2001      	movne	r0, #1
    f91a:	490e      	ldr	r1, [pc, #56]	; (f954 <_rtc_timer_start+0x48>)
    f91c:	4b0e      	ldr	r3, [pc, #56]	; (f958 <_rtc_timer_start+0x4c>)
    f91e:	225e      	movs	r2, #94	; 0x5e
    f920:	4798      	blx	r3
    f922:	4b0e      	ldr	r3, [pc, #56]	; (f95c <_rtc_timer_start+0x50>)
	hri_rtcmode0_write_COUNT_reg(dev->hw, 0);
    f924:	68e0      	ldr	r0, [r4, #12]
    f926:	f44f 6200 	mov.w	r2, #2048	; 0x800
    f92a:	601a      	str	r2, [r3, #0]
	((Rtc *)hw)->MODE0.COUNT.reg = data;
    f92c:	2300      	movs	r3, #0
    f92e:	6183      	str	r3, [r0, #24]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COUNT);
    f930:	4a0b      	ldr	r2, [pc, #44]	; (f960 <_rtc_timer_start+0x54>)
    f932:	2108      	movs	r1, #8
    f934:	4790      	blx	r2
	hri_rtcmode0_wait_for_sync(dev->hw, RTC_MODE0_SYNCBUSY_COUNT);
    f936:	68e0      	ldr	r0, [r4, #12]
    f938:	2108      	movs	r1, #8
    f93a:	4790      	blx	r2
	hri_rtcmode0_set_CTRLA_ENABLE_bit(dev->hw);
    f93c:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg |= RTC_MODE0_CTRLA_ENABLE;
    f93e:	8803      	ldrh	r3, [r0, #0]
    f940:	b29b      	uxth	r3, r3
    f942:	f043 0302 	orr.w	r3, r3, #2
}
    f946:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f94a:	8003      	strh	r3, [r0, #0]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f94c:	f248 0103 	movw	r1, #32771	; 0x8003
    f950:	4710      	bx	r2
    f952:	bf00      	nop
    f954:	00016522 	.word	0x00016522
    f958:	0000e03d 	.word	0x0000e03d
    f95c:	e000e100 	.word	0xe000e100
    f960:	0000f889 	.word	0x0000f889

0000f964 <_rtc_timer_deinit>:
{
    f964:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
    f966:	4604      	mov	r4, r0
    f968:	b118      	cbz	r0, f972 <_rtc_timer_deinit+0xe>
    f96a:	68c0      	ldr	r0, [r0, #12]
    f96c:	3800      	subs	r0, #0
    f96e:	bf18      	it	ne
    f970:	2001      	movne	r0, #1
    f972:	490b      	ldr	r1, [pc, #44]	; (f9a0 <_rtc_timer_deinit+0x3c>)
    f974:	4b0b      	ldr	r3, [pc, #44]	; (f9a4 <_rtc_timer_deinit+0x40>)
    f976:	2252      	movs	r2, #82	; 0x52
    f978:	4798      	blx	r3
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    f97a:	4b0b      	ldr	r3, [pc, #44]	; (f9a8 <_rtc_timer_deinit+0x44>)
    f97c:	f44f 6200 	mov.w	r2, #2048	; 0x800
    f980:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    f984:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    f988:	f3bf 8f6f 	isb	sy
	hri_rtcmode0_write_CTRLA_reg(dev->hw, RTC_MODE0_CTRLA_SWRST);
    f98c:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    f98e:	2301      	movs	r3, #1
    f990:	8003      	strh	r3, [r0, #0]
}
    f992:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f996:	4b05      	ldr	r3, [pc, #20]	; (f9ac <_rtc_timer_deinit+0x48>)
    f998:	f248 0103 	movw	r1, #32771	; 0x8003
    f99c:	4718      	bx	r3
    f99e:	bf00      	nop
    f9a0:	00016522 	.word	0x00016522
    f9a4:	0000e03d 	.word	0x0000e03d
    f9a8:	e000e100 	.word	0xe000e100
    f9ac:	0000f889 	.word	0x0000f889

0000f9b0 <_rtc_timer_init>:
{
    f9b0:	b570      	push	{r4, r5, r6, lr}
	ASSERT(dev);
    f9b2:	4604      	mov	r4, r0
{
    f9b4:	460d      	mov	r5, r1
	ASSERT(dev);
    f9b6:	3800      	subs	r0, #0
    f9b8:	bf18      	it	ne
    f9ba:	2001      	movne	r0, #1
    f9bc:	4b10      	ldr	r3, [pc, #64]	; (fa00 <_rtc_timer_init+0x50>)
    f9be:	4911      	ldr	r1, [pc, #68]	; (fa04 <_rtc_timer_init+0x54>)
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    f9c0:	2601      	movs	r6, #1
    f9c2:	2230      	movs	r2, #48	; 0x30
    f9c4:	4798      	blx	r3
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f9c6:	4a10      	ldr	r2, [pc, #64]	; (fa08 <_rtc_timer_init+0x58>)
	dev->hw = hw;
    f9c8:	60e5      	str	r5, [r4, #12]
    f9ca:	4628      	mov	r0, r5
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    f9cc:	802e      	strh	r6, [r5, #0]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f9ce:	f248 0103 	movw	r1, #32771	; 0x8003
    f9d2:	4790      	blx	r2
	hri_rtcmode0_wait_for_sync(dev->hw, RTC_MODE0_SYNCBUSY_SWRST);
    f9d4:	68e0      	ldr	r0, [r4, #12]
    f9d6:	4631      	mov	r1, r6
    f9d8:	4790      	blx	r2
	    dev->hw, RTC_MODE0_CTRLA_PRESCALER(CONF_RTC_PRESCALER) | RTC_MODE0_CTRLA_COUNTSYNC | RTC_MODE0_CTRLA_MATCHCLR);
    f9da:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    f9dc:	f248 0380 	movw	r3, #32896	; 0x8080
    f9e0:	8003      	strh	r3, [r0, #0]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f9e2:	f248 0103 	movw	r1, #32771	; 0x8003
    f9e6:	4790      	blx	r2
	hri_rtcmode0_write_COMP_reg(dev->hw, 0, CONF_RTC_COMP_VAL);
    f9e8:	68e0      	ldr	r0, [r4, #12]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    f9ea:	2160      	movs	r1, #96	; 0x60
	((Rtc *)hw)->MODE0.COMP[index].reg = data;
    f9ec:	6206      	str	r6, [r0, #32]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    f9ee:	4790      	blx	r2
	hri_rtcmode0_set_INTEN_CMP0_bit(dev->hw);
    f9f0:	68e3      	ldr	r3, [r4, #12]
	((Rtc *)hw)->MODE0.INTENSET.reg = RTC_MODE0_INTENSET_CMP0;
    f9f2:	f44f 7280 	mov.w	r2, #256	; 0x100
    f9f6:	815a      	strh	r2, [r3, #10]
	_rtc_dev = dev;
    f9f8:	4b04      	ldr	r3, [pc, #16]	; (fa0c <_rtc_timer_init+0x5c>)
}
    f9fa:	2000      	movs	r0, #0
	_rtc_dev = dev;
    f9fc:	601c      	str	r4, [r3, #0]
}
    f9fe:	bd70      	pop	{r4, r5, r6, pc}
    fa00:	0000e03d 	.word	0x0000e03d
    fa04:	00016522 	.word	0x00016522
    fa08:	0000f889 	.word	0x0000f889
    fa0c:	20008d00 	.word	0x20008d00

0000fa10 <_rtc_get_timer>:
 * \brief Retrieve timer helper functions
 */
struct _timer_hpl_interface *_rtc_get_timer(void)
{
	return &_rtc_timer_functions;
}
    fa10:	4800      	ldr	r0, [pc, #0]	; (fa14 <_rtc_get_timer+0x4>)
    fa12:	4770      	bx	lr
    fa14:	2000050c 	.word	0x2000050c

0000fa18 <RTC_Handler>:
/**
 * \brief Rtc interrupt handler
 */
void RTC_Handler(void)
{
	_rtc_timer_interrupt_handler(_rtc_dev);
    fa18:	4b07      	ldr	r3, [pc, #28]	; (fa38 <RTC_Handler+0x20>)
{
    fa1a:	b510      	push	{r4, lr}
	_rtc_timer_interrupt_handler(_rtc_dev);
    fa1c:	681c      	ldr	r4, [r3, #0]
	uint16_t flag = hri_rtcmode0_read_INTFLAG_reg(dev->hw);
    fa1e:	68e3      	ldr	r3, [r4, #12]
	return ((Rtc *)hw)->MODE0.INTFLAG.reg;
    fa20:	899b      	ldrh	r3, [r3, #12]
	if (flag & RTC_MODE0_INTFLAG_CMP0) {
    fa22:	05db      	lsls	r3, r3, #23
    fa24:	d507      	bpl.n	fa36 <RTC_Handler+0x1e>
		if (dev->timer_cb.period_expired) {
    fa26:	6823      	ldr	r3, [r4, #0]
    fa28:	b10b      	cbz	r3, fa2e <RTC_Handler+0x16>
			dev->timer_cb.period_expired(dev);
    fa2a:	4620      	mov	r0, r4
    fa2c:	4798      	blx	r3
		hri_rtcmode0_clear_interrupt_CMP0_bit(dev->hw);
    fa2e:	68e3      	ldr	r3, [r4, #12]
	((Rtc *)hw)->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_CMP0;
    fa30:	f44f 7280 	mov.w	r2, #256	; 0x100
    fa34:	819a      	strh	r2, [r3, #12]
}
    fa36:	bd10      	pop	{r4, pc}
    fa38:	20008d00 	.word	0x20008d00

0000fa3c <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
    fa3c:	b530      	push	{r4, r5, lr}
	uint8_t port = GPIO_PORT(gpio);
	uint8_t pin  = GPIO_PIN(gpio);

	if (function == GPIO_PIN_FUNCTION_OFF) {
    fa3e:	1c4b      	adds	r3, r1, #1
	uint8_t pin  = GPIO_PIN(gpio);
    fa40:	b2c5      	uxtb	r5, r0
    fa42:	4b18      	ldr	r3, [pc, #96]	; (faa4 <_gpio_set_pin_function+0x68>)
    fa44:	f000 041f 	and.w	r4, r0, #31
	uint8_t port = GPIO_PORT(gpio);
    fa48:	ea4f 1050 	mov.w	r0, r0, lsr #5
    fa4c:	ea4f 10c0 	mov.w	r0, r0, lsl #7
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    fa50:	4403      	add	r3, r0
	if (function == GPIO_PIN_FUNCTION_OFF) {
    fa52:	d107      	bne.n	fa64 <_gpio_set_pin_function+0x28>
    fa54:	4423      	add	r3, r4
    fa56:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    fa5a:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    fa5e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
    fa62:	bd30      	pop	{r4, r5, pc}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    fa64:	1918      	adds	r0, r3, r4
    fa66:	eb03 0354 	add.w	r3, r3, r4, lsr #1
    fa6a:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    fa6e:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    fa72:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    fa76:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    fa7a:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
		if (pin & 1) {
    fa7e:	f015 0f01 	tst.w	r5, #1
    fa82:	b2c9      	uxtb	r1, r1
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    fa84:	bf19      	ittee	ne
    fa86:	f002 020f 	andne.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
    fa8a:	ea42 1101 	orrne.w	r1, r2, r1, lsl #4
	tmp |= PORT_PMUX_PMUXE(data);
    fa8e:	f001 010f 	andeq.w	r1, r1, #15
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    fa92:	f002 02f0 	andeq.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXO(data);
    fa96:	bf14      	ite	ne
    fa98:	b2c9      	uxtbne	r1, r1
	tmp |= PORT_PMUX_PMUXE(data);
    fa9a:	4311      	orreq	r1, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    fa9c:	f883 1030 	strb.w	r1, [r3, #48]	; 0x30
}
    faa0:	e7df      	b.n	fa62 <_gpio_set_pin_function+0x26>
    faa2:	bf00      	nop
    faa4:	41008000 	.word	0x41008000

0000faa8 <gpio_set_pin_direction>:
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    faa8:	f000 031f 	and.w	r3, r0, #31
{
    faac:	b530      	push	{r4, r5, lr}
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    faae:	2501      	movs	r5, #1
    fab0:	409d      	lsls	r5, r3
	switch (direction) {
    fab2:	0940      	lsrs	r0, r0, #5
    fab4:	4b0f      	ldr	r3, [pc, #60]	; (faf4 <gpio_set_pin_direction+0x4c>)
    fab6:	01c0      	lsls	r0, r0, #7
    fab8:	2901      	cmp	r1, #1
    faba:	b2ac      	uxth	r4, r5
    fabc:	ea4f 4215 	mov.w	r2, r5, lsr #16
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    fac0:	4403      	add	r3, r0
    fac2:	d008      	beq.n	fad6 <gpio_set_pin_direction+0x2e>
    fac4:	2902      	cmp	r1, #2
    fac6:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    faca:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    face:	d00e      	beq.n	faee <gpio_set_pin_direction+0x46>
    fad0:	605d      	str	r5, [r3, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    fad2:	629c      	str	r4, [r3, #40]	; 0x28
    fad4:	e009      	b.n	faea <gpio_set_pin_direction+0x42>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
    fad6:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    fada:	f444 3400 	orr.w	r4, r4, #131072	; 0x20000
		hri_port_write_WRCONFIG_reg(PORT,
    fade:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    fae2:	605d      	str	r5, [r3, #4]
    fae4:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    fae8:	629c      	str	r4, [r3, #40]	; 0x28
    faea:	629a      	str	r2, [r3, #40]	; 0x28
}
    faec:	bd30      	pop	{r4, r5, pc}
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    faee:	609d      	str	r5, [r3, #8]
    faf0:	e7ef      	b.n	fad2 <gpio_set_pin_direction+0x2a>
    faf2:	bf00      	nop
    faf4:	41008000 	.word	0x41008000

0000faf8 <gpio_set_pin_pull_mode>:
	switch (pull_mode) {
    faf8:	0942      	lsrs	r2, r0, #5
    fafa:	2901      	cmp	r1, #1
    fafc:	4b0d      	ldr	r3, [pc, #52]	; (fb34 <gpio_set_pin_pull_mode+0x3c>)
    fafe:	f000 001f 	and.w	r0, r0, #31
    fb02:	ea4f 12c2 	mov.w	r2, r2, lsl #7
    fb06:	d008      	beq.n	fb1a <gpio_set_pin_pull_mode+0x22>
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    fb08:	4413      	add	r3, r2
    fb0a:	4418      	add	r0, r3
    fb0c:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    fb10:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
    fb14:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
}
    fb18:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    fb1a:	4413      	add	r3, r2
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
    fb1c:	4081      	lsls	r1, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    fb1e:	4418      	add	r0, r3
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    fb20:	6059      	str	r1, [r3, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    fb22:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
    fb26:	f042 0204 	orr.w	r2, r2, #4
    fb2a:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    fb2e:	6199      	str	r1, [r3, #24]
}
    fb30:	4770      	bx	lr
    fb32:	bf00      	nop
    fb34:	41008000 	.word	0x41008000

0000fb38 <ADC_0_init>:
}

static inline void hri_mclk_set_APBDMASK_ADC0_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC0;
    fb38:	4a14      	ldr	r2, [pc, #80]	; (fb8c <ADC_0_init+0x54>)
 */
void ADC_0_init(void)
{
	hri_mclk_set_APBDMASK_ADC0_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC0_GCLK_ID, CONF_GCLK_ADC0_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	adc_async_init(&ADC_0, ADC0, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
    fb3a:	4915      	ldr	r1, [pc, #84]	; (fb90 <ADC_0_init+0x58>)
    fb3c:	6a13      	ldr	r3, [r2, #32]
{
    fb3e:	b5f0      	push	{r4, r5, r6, r7, lr}
    fb40:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    fb44:	6213      	str	r3, [r2, #32]
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    fb46:	4b13      	ldr	r3, [pc, #76]	; (fb94 <ADC_0_init+0x5c>)
	adc_async_init(&ADC_0, ADC0, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
    fb48:	4e13      	ldr	r6, [pc, #76]	; (fb98 <ADC_0_init+0x60>)
    fb4a:	4d14      	ldr	r5, [pc, #80]	; (fb9c <ADC_0_init+0x64>)
    fb4c:	4f14      	ldr	r7, [pc, #80]	; (fba0 <ADC_0_init+0x68>)
{
    fb4e:	b085      	sub	sp, #20
    fb50:	2241      	movs	r2, #65	; 0x41
    fb52:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
	adc_async_init(&ADC_0, ADC0, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
    fb56:	4b13      	ldr	r3, [pc, #76]	; (fba4 <ADC_0_init+0x6c>)
    fb58:	9301      	str	r3, [sp, #4]
    fb5a:	2400      	movs	r4, #0
    fb5c:	2301      	movs	r3, #1
    fb5e:	9300      	str	r3, [sp, #0]
    fb60:	4632      	mov	r2, r6
    fb62:	4623      	mov	r3, r4
    fb64:	9402      	str	r4, [sp, #8]
    fb66:	4628      	mov	r0, r5
    fb68:	47b8      	blx	r7
	adc_async_register_channel_buffer(&ADC_0, 0, ADC_0_buffer, ADC_0_BUFFER_SIZE);
    fb6a:	1c72      	adds	r2, r6, #1
    fb6c:	4621      	mov	r1, r4
    fb6e:	2310      	movs	r3, #16
    fb70:	4628      	mov	r0, r5
    fb72:	4d0d      	ldr	r5, [pc, #52]	; (fba8 <ADC_0_init+0x70>)
    fb74:	47a8      	blx	r5

	// Disable digital pin circuitry
	gpio_set_pin_direction(PA07, GPIO_DIRECTION_OFF);
    fb76:	4621      	mov	r1, r4
    fb78:	4b0c      	ldr	r3, [pc, #48]	; (fbac <ADC_0_init+0x74>)
    fb7a:	2007      	movs	r0, #7
    fb7c:	4798      	blx	r3
	_gpio_set_pin_function(pin, function);
    fb7e:	490c      	ldr	r1, [pc, #48]	; (fbb0 <ADC_0_init+0x78>)
    fb80:	4b0c      	ldr	r3, [pc, #48]	; (fbb4 <ADC_0_init+0x7c>)
    fb82:	2007      	movs	r0, #7

	gpio_set_pin_function(PA07, PINMUX_PA07B_ADC0_AIN7);
}
    fb84:	b005      	add	sp, #20
    fb86:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    fb8a:	4718      	bx	r3
    fb8c:	40000800 	.word	0x40000800
    fb90:	43001c00 	.word	0x43001c00
    fb94:	40001c00 	.word	0x40001c00
    fb98:	20008d04 	.word	0x20008d04
    fb9c:	2001cd84 	.word	0x2001cd84
    fba0:	0000e335 	.word	0x0000e335
    fba4:	2001ce80 	.word	0x2001ce80
    fba8:	0000e3d9 	.word	0x0000e3d9
    fbac:	0000faa9 	.word	0x0000faa9
    fbb0:	00070001 	.word	0x00070001
    fbb4:	0000fa3d 	.word	0x0000fa3d

0000fbb8 <ADC_1_init>:
}

static inline void hri_mclk_set_APBDMASK_ADC1_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC1;
    fbb8:	4a15      	ldr	r2, [pc, #84]	; (fc10 <ADC_1_init+0x58>)
 */
void ADC_1_init(void)
{
	hri_mclk_set_APBDMASK_ADC1_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC1_GCLK_ID, CONF_GCLK_ADC1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	adc_async_init(&ADC_1, ADC1, ADC_1_map, ADC_1_CH_MAX, ADC_1_CH_AMOUNT, &ADC_1_ch[0], (void *)NULL);
    fbba:	4916      	ldr	r1, [pc, #88]	; (fc14 <ADC_1_init+0x5c>)
    fbbc:	6a13      	ldr	r3, [r2, #32]
{
    fbbe:	b5f0      	push	{r4, r5, r6, r7, lr}
    fbc0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    fbc4:	6213      	str	r3, [r2, #32]
    fbc6:	4b14      	ldr	r3, [pc, #80]	; (fc18 <ADC_1_init+0x60>)
	adc_async_init(&ADC_1, ADC1, ADC_1_map, ADC_1_CH_MAX, ADC_1_CH_AMOUNT, &ADC_1_ch[0], (void *)NULL);
    fbc8:	4e14      	ldr	r6, [pc, #80]	; (fc1c <ADC_1_init+0x64>)
    fbca:	4d15      	ldr	r5, [pc, #84]	; (fc20 <ADC_1_init+0x68>)
    fbcc:	4f15      	ldr	r7, [pc, #84]	; (fc24 <ADC_1_init+0x6c>)
{
    fbce:	b085      	sub	sp, #20
    fbd0:	2241      	movs	r2, #65	; 0x41
    fbd2:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
	adc_async_init(&ADC_1, ADC1, ADC_1_map, ADC_1_CH_MAX, ADC_1_CH_AMOUNT, &ADC_1_ch[0], (void *)NULL);
    fbd6:	4b14      	ldr	r3, [pc, #80]	; (fc28 <ADC_1_init+0x70>)
    fbd8:	9301      	str	r3, [sp, #4]
    fbda:	2400      	movs	r4, #0
    fbdc:	2301      	movs	r3, #1
    fbde:	9300      	str	r3, [sp, #0]
    fbe0:	f106 0211 	add.w	r2, r6, #17
    fbe4:	4623      	mov	r3, r4
    fbe6:	9402      	str	r4, [sp, #8]
    fbe8:	4628      	mov	r0, r5
    fbea:	47b8      	blx	r7
	adc_async_register_channel_buffer(&ADC_1, 0, ADC_1_buffer, ADC_1_BUFFER_SIZE);
    fbec:	f106 0212 	add.w	r2, r6, #18
    fbf0:	4621      	mov	r1, r4
    fbf2:	2310      	movs	r3, #16
    fbf4:	4628      	mov	r0, r5
    fbf6:	4d0d      	ldr	r5, [pc, #52]	; (fc2c <ADC_1_init+0x74>)
    fbf8:	47a8      	blx	r5

	// Disable digital pin circuitry
	gpio_set_pin_direction(PC02, GPIO_DIRECTION_OFF);
    fbfa:	4621      	mov	r1, r4
    fbfc:	4b0c      	ldr	r3, [pc, #48]	; (fc30 <ADC_1_init+0x78>)
    fbfe:	2042      	movs	r0, #66	; 0x42
    fc00:	4798      	blx	r3
    fc02:	490c      	ldr	r1, [pc, #48]	; (fc34 <ADC_1_init+0x7c>)
    fc04:	4b0c      	ldr	r3, [pc, #48]	; (fc38 <ADC_1_init+0x80>)
    fc06:	2042      	movs	r0, #66	; 0x42

	gpio_set_pin_function(PC02, PINMUX_PC02B_ADC1_AIN4);
}
    fc08:	b005      	add	sp, #20
    fc0a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    fc0e:	4718      	bx	r3
    fc10:	40000800 	.word	0x40000800
    fc14:	43002000 	.word	0x43002000
    fc18:	40001c00 	.word	0x40001c00
    fc1c:	20008d04 	.word	0x20008d04
    fc20:	2001cf58 	.word	0x2001cf58
    fc24:	0000e335 	.word	0x0000e335
    fc28:	2001cd18 	.word	0x2001cd18
    fc2c:	0000e3d9 	.word	0x0000e3d9
    fc30:	0000faa9 	.word	0x0000faa9
    fc34:	00420001 	.word	0x00420001
    fc38:	0000fa3d 	.word	0x0000fa3d

0000fc3c <CRC_0_init>:
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_DSU;
    fc3c:	4a04      	ldr	r2, [pc, #16]	; (fc50 <CRC_0_init+0x14>)
 * Enables CRC peripheral, clocks and initializes CRC driver
 */
void CRC_0_init(void)
{
	hri_mclk_set_APBBMASK_DSU_bit(MCLK);
	crc_sync_init(&CRC_0, DSU);
    fc3e:	4905      	ldr	r1, [pc, #20]	; (fc54 <CRC_0_init+0x18>)
    fc40:	6993      	ldr	r3, [r2, #24]
    fc42:	4805      	ldr	r0, [pc, #20]	; (fc58 <CRC_0_init+0x1c>)
    fc44:	f043 0302 	orr.w	r3, r3, #2
    fc48:	6193      	str	r3, [r2, #24]
    fc4a:	4b04      	ldr	r3, [pc, #16]	; (fc5c <CRC_0_init+0x20>)
    fc4c:	4718      	bx	r3
    fc4e:	bf00      	nop
    fc50:	40000800 	.word	0x40000800
    fc54:	41002000 	.word	0x41002000
    fc58:	2001cd14 	.word	0x2001cd14
    fc5c:	0000f28d 	.word	0x0000f28d

0000fc60 <EVENT_SYSTEM_0_init>:
    fc60:	4b08      	ldr	r3, [pc, #32]	; (fc84 <EVENT_SYSTEM_0_init+0x24>)
    fc62:	2240      	movs	r2, #64	; 0x40
    fc64:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
    fc68:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    fc6c:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
    fc70:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_EVSYS;
    fc74:	4a04      	ldr	r2, [pc, #16]	; (fc88 <EVENT_SYSTEM_0_init+0x28>)
    fc76:	6993      	ldr	r3, [r2, #24]
    fc78:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    fc7c:	6193      	str	r3, [r2, #24]
	hri_gclk_write_PCHCTRL_reg(GCLK, EVSYS_GCLK_ID_2, CONF_GCLK_EVSYS_CHANNEL_2_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, EVSYS_GCLK_ID_3, CONF_GCLK_EVSYS_CHANNEL_3_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_EVSYS_bit(MCLK);

	event_system_init();
    fc7e:	4b03      	ldr	r3, [pc, #12]	; (fc8c <EVENT_SYSTEM_0_init+0x2c>)
    fc80:	4718      	bx	r3
    fc82:	bf00      	nop
    fc84:	40001c00 	.word	0x40001c00
    fc88:	40000800 	.word	0x40000800
    fc8c:	00012cd9 	.word	0x00012cd9

0000fc90 <FLASH_0_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_NVMCTRL;
    fc90:	4a02      	ldr	r2, [pc, #8]	; (fc9c <FLASH_0_CLOCK_init+0xc>)
    fc92:	6913      	ldr	r3, [r2, #16]
    fc94:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    fc98:	6113      	str	r3, [r2, #16]

void FLASH_0_CLOCK_init(void)
{

	hri_mclk_set_AHBMASK_NVMCTRL_bit(MCLK);
}
    fc9a:	4770      	bx	lr
    fc9c:	40000800 	.word	0x40000800

0000fca0 <FLASH_0_init>:

void FLASH_0_init(void)
{
    fca0:	b510      	push	{r4, lr}
	FLASH_0_CLOCK_init();
    fca2:	4b04      	ldr	r3, [pc, #16]	; (fcb4 <FLASH_0_init+0x14>)
    fca4:	4798      	blx	r3
	flash_init(&FLASH_0, NVMCTRL);
}
    fca6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	flash_init(&FLASH_0, NVMCTRL);
    fcaa:	4903      	ldr	r1, [pc, #12]	; (fcb8 <FLASH_0_init+0x18>)
    fcac:	4803      	ldr	r0, [pc, #12]	; (fcbc <FLASH_0_init+0x1c>)
    fcae:	4b04      	ldr	r3, [pc, #16]	; (fcc0 <FLASH_0_init+0x20>)
    fcb0:	4718      	bx	r3
    fcb2:	bf00      	nop
    fcb4:	0000fc91 	.word	0x0000fc91
    fcb8:	41004000 	.word	0x41004000
    fcbc:	2001ccf8 	.word	0x2001ccf8
    fcc0:	0000ed35 	.word	0x0000ed35

0000fcc4 <QSPI_INSTANCE_PORT_init>:

void QSPI_INSTANCE_PORT_init(void)
{
    fcc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	// Set pin direction to input
	gpio_set_pin_direction(PB11, GPIO_DIRECTION_IN);
    fcc8:	2101      	movs	r1, #1
    fcca:	4e24      	ldr	r6, [pc, #144]	; (fd5c <QSPI_INSTANCE_PORT_init+0x98>)

	gpio_set_pin_pull_mode(PB11,
    fccc:	4d24      	ldr	r5, [pc, #144]	; (fd60 <QSPI_INSTANCE_PORT_init+0x9c>)
    fcce:	4c25      	ldr	r4, [pc, #148]	; (fd64 <QSPI_INSTANCE_PORT_init+0xa0>)
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    fcd0:	4f25      	ldr	r7, [pc, #148]	; (fd68 <QSPI_INSTANCE_PORT_init+0xa4>)
	gpio_set_pin_direction(PB11, GPIO_DIRECTION_IN);
    fcd2:	202b      	movs	r0, #43	; 0x2b
    fcd4:	47b0      	blx	r6
	gpio_set_pin_pull_mode(PB11,
    fcd6:	2100      	movs	r1, #0
    fcd8:	202b      	movs	r0, #43	; 0x2b
    fcda:	47a8      	blx	r5
    fcdc:	4923      	ldr	r1, [pc, #140]	; (fd6c <QSPI_INSTANCE_PORT_init+0xa8>)
    fcde:	202b      	movs	r0, #43	; 0x2b
    fce0:	47a0      	blx	r4
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PB11, PINMUX_PB11H_QSPI_CS);

	gpio_set_pin_direction(PA08,
    fce2:	2102      	movs	r1, #2
    fce4:	2008      	movs	r0, #8
    fce6:	47b0      	blx	r6
    fce8:	f44f 7380 	mov.w	r3, #256	; 0x100
    fcec:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA08,
    fcee:	2100      	movs	r1, #0
    fcf0:	2008      	movs	r0, #8
    fcf2:	47a8      	blx	r5
    fcf4:	491e      	ldr	r1, [pc, #120]	; (fd70 <QSPI_INSTANCE_PORT_init+0xac>)
    fcf6:	2008      	movs	r0, #8
    fcf8:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA08H_QSPI_DATA0);

	gpio_set_pin_direction(PA09,
    fcfa:	2102      	movs	r1, #2
    fcfc:	2009      	movs	r0, #9
    fcfe:	47b0      	blx	r6
    fd00:	f44f 7300 	mov.w	r3, #512	; 0x200
    fd04:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA09,
    fd06:	2100      	movs	r1, #0
    fd08:	2009      	movs	r0, #9
    fd0a:	47a8      	blx	r5
    fd0c:	4919      	ldr	r1, [pc, #100]	; (fd74 <QSPI_INSTANCE_PORT_init+0xb0>)
    fd0e:	2009      	movs	r0, #9
    fd10:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA09H_QSPI_DATA1);

	gpio_set_pin_direction(PA10,
    fd12:	2102      	movs	r1, #2
    fd14:	200a      	movs	r0, #10
    fd16:	47b0      	blx	r6
    fd18:	f44f 6380 	mov.w	r3, #1024	; 0x400
    fd1c:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA10,
    fd1e:	2100      	movs	r1, #0
    fd20:	200a      	movs	r0, #10
    fd22:	47a8      	blx	r5
    fd24:	4914      	ldr	r1, [pc, #80]	; (fd78 <QSPI_INSTANCE_PORT_init+0xb4>)
    fd26:	200a      	movs	r0, #10
    fd28:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA10H_QSPI_DATA2);

	gpio_set_pin_direction(PA11,
    fd2a:	2102      	movs	r1, #2
    fd2c:	200b      	movs	r0, #11
    fd2e:	47b0      	blx	r6
    fd30:	f44f 6300 	mov.w	r3, #2048	; 0x800
    fd34:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA11,
    fd36:	2100      	movs	r1, #0
    fd38:	200b      	movs	r0, #11
    fd3a:	47a8      	blx	r5
    fd3c:	490f      	ldr	r1, [pc, #60]	; (fd7c <QSPI_INSTANCE_PORT_init+0xb8>)
    fd3e:	200b      	movs	r0, #11
    fd40:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA11H_QSPI_DATA3);

	// Set pin direction to input
	gpio_set_pin_direction(PB10, GPIO_DIRECTION_IN);
    fd42:	2101      	movs	r1, #1
    fd44:	202a      	movs	r0, #42	; 0x2a
    fd46:	47b0      	blx	r6

	gpio_set_pin_pull_mode(PB10,
    fd48:	2100      	movs	r1, #0
    fd4a:	202a      	movs	r0, #42	; 0x2a
    fd4c:	47a8      	blx	r5
    fd4e:	4623      	mov	r3, r4
    fd50:	490b      	ldr	r1, [pc, #44]	; (fd80 <QSPI_INSTANCE_PORT_init+0xbc>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PB10, PINMUX_PB10H_QSPI_SCK);
}
    fd52:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    fd56:	202a      	movs	r0, #42	; 0x2a
    fd58:	4718      	bx	r3
    fd5a:	bf00      	nop
    fd5c:	0000faa9 	.word	0x0000faa9
    fd60:	0000faf9 	.word	0x0000faf9
    fd64:	0000fa3d 	.word	0x0000fa3d
    fd68:	41008000 	.word	0x41008000
    fd6c:	002b0007 	.word	0x002b0007
    fd70:	00080007 	.word	0x00080007
    fd74:	00090007 	.word	0x00090007
    fd78:	000a0007 	.word	0x000a0007
    fd7c:	000b0007 	.word	0x000b0007
    fd80:	002a0007 	.word	0x002a0007

0000fd84 <QSPI_INSTANCE_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_QSPI;
    fd84:	4b06      	ldr	r3, [pc, #24]	; (fda0 <QSPI_INSTANCE_CLOCK_init+0x1c>)
    fd86:	691a      	ldr	r2, [r3, #16]
    fd88:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    fd8c:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_QSPI_2X;
    fd8e:	691a      	ldr	r2, [r3, #16]
    fd90:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
    fd94:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_QSPI;
    fd96:	69da      	ldr	r2, [r3, #28]
    fd98:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    fd9c:	61da      	str	r2, [r3, #28]
void QSPI_INSTANCE_CLOCK_init(void)
{
	hri_mclk_set_AHBMASK_QSPI_bit(MCLK);
	hri_mclk_set_AHBMASK_QSPI_2X_bit(MCLK);
	hri_mclk_set_APBCMASK_QSPI_bit(MCLK);
}
    fd9e:	4770      	bx	lr
    fda0:	40000800 	.word	0x40000800

0000fda4 <QSPI_INSTANCE_init>:

void QSPI_INSTANCE_init(void)
{
    fda4:	b510      	push	{r4, lr}
	QSPI_INSTANCE_CLOCK_init();
    fda6:	4b05      	ldr	r3, [pc, #20]	; (fdbc <QSPI_INSTANCE_init+0x18>)
    fda8:	4798      	blx	r3
	qspi_dma_init(&QSPI_INSTANCE, QSPI);
    fdaa:	4b05      	ldr	r3, [pc, #20]	; (fdc0 <QSPI_INSTANCE_init+0x1c>)
    fdac:	4905      	ldr	r1, [pc, #20]	; (fdc4 <QSPI_INSTANCE_init+0x20>)
    fdae:	4806      	ldr	r0, [pc, #24]	; (fdc8 <QSPI_INSTANCE_init+0x24>)
    fdb0:	4798      	blx	r3
	QSPI_INSTANCE_PORT_init();
}
    fdb2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	QSPI_INSTANCE_PORT_init();
    fdb6:	4b05      	ldr	r3, [pc, #20]	; (fdcc <QSPI_INSTANCE_init+0x28>)
    fdb8:	4718      	bx	r3
    fdba:	bf00      	nop
    fdbc:	0000fd85 	.word	0x0000fd85
    fdc0:	00012445 	.word	0x00012445
    fdc4:	42003400 	.word	0x42003400
    fdc8:	2001cfc4 	.word	0x2001cfc4
    fdcc:	0000fcc5 	.word	0x0000fcc5

0000fdd0 <USART_EAST_CLOCK_init>:
    fdd0:	4b06      	ldr	r3, [pc, #24]	; (fdec <USART_EAST_CLOCK_init+0x1c>)
    fdd2:	2241      	movs	r2, #65	; 0x41
    fdd4:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    fdd8:	2242      	movs	r2, #66	; 0x42
    fdda:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM0;
    fdde:	4a04      	ldr	r2, [pc, #16]	; (fdf0 <USART_EAST_CLOCK_init+0x20>)
    fde0:	6953      	ldr	r3, [r2, #20]
    fde2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    fde6:	6153      	str	r3, [r2, #20]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_CORE, CONF_GCLK_SERCOM0_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_SLOW, CONF_GCLK_SERCOM0_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBAMASK_SERCOM0_bit(MCLK);
}
    fde8:	4770      	bx	lr
    fdea:	bf00      	nop
    fdec:	40001c00 	.word	0x40001c00
    fdf0:	40000800 	.word	0x40000800

0000fdf4 <USART_EAST_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_EAST_PORT_init()
{
    fdf4:	b510      	push	{r4, lr}
    fdf6:	4c05      	ldr	r4, [pc, #20]	; (fe0c <USART_EAST_PORT_init+0x18>)
    fdf8:	4905      	ldr	r1, [pc, #20]	; (fe10 <USART_EAST_PORT_init+0x1c>)
    fdfa:	2051      	movs	r0, #81	; 0x51
    fdfc:	47a0      	blx	r4
    fdfe:	4623      	mov	r3, r4
    fe00:	4904      	ldr	r1, [pc, #16]	; (fe14 <USART_EAST_PORT_init+0x20>)

	gpio_set_pin_function(PC17, PINMUX_PC17D_SERCOM0_PAD0);

	gpio_set_pin_function(PC16, PINMUX_PC16D_SERCOM0_PAD1);
}
    fe02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fe06:	2050      	movs	r0, #80	; 0x50
    fe08:	4718      	bx	r3
    fe0a:	bf00      	nop
    fe0c:	0000fa3d 	.word	0x0000fa3d
    fe10:	00510003 	.word	0x00510003
    fe14:	00500003 	.word	0x00500003

0000fe18 <USART_EAST_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_EAST_init(void)
{
    fe18:	b513      	push	{r0, r1, r4, lr}
	USART_EAST_CLOCK_init();
    fe1a:	4b07      	ldr	r3, [pc, #28]	; (fe38 <USART_EAST_init+0x20>)
	usart_async_init(&USART_EAST, SERCOM0, USART_EAST_buffer, USART_EAST_BUFFER_SIZE, (void *)NULL);
    fe1c:	4c07      	ldr	r4, [pc, #28]	; (fe3c <USART_EAST_init+0x24>)
	USART_EAST_CLOCK_init();
    fe1e:	4798      	blx	r3
	usart_async_init(&USART_EAST, SERCOM0, USART_EAST_buffer, USART_EAST_BUFFER_SIZE, (void *)NULL);
    fe20:	2300      	movs	r3, #0
    fe22:	9300      	str	r3, [sp, #0]
    fe24:	4a06      	ldr	r2, [pc, #24]	; (fe40 <USART_EAST_init+0x28>)
    fe26:	4907      	ldr	r1, [pc, #28]	; (fe44 <USART_EAST_init+0x2c>)
    fe28:	4807      	ldr	r0, [pc, #28]	; (fe48 <USART_EAST_init+0x30>)
    fe2a:	2310      	movs	r3, #16
    fe2c:	47a0      	blx	r4
	USART_EAST_PORT_init();
    fe2e:	4b07      	ldr	r3, [pc, #28]	; (fe4c <USART_EAST_init+0x34>)
}
    fe30:	b002      	add	sp, #8
    fe32:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_EAST_PORT_init();
    fe36:	4718      	bx	r3
    fe38:	0000fdd1 	.word	0x0000fdd1
    fe3c:	0001072d 	.word	0x0001072d
    fe40:	20008d26 	.word	0x20008d26
    fe44:	40003000 	.word	0x40003000
    fe48:	2001cdb0 	.word	0x2001cdb0
    fe4c:	0000fdf5 	.word	0x0000fdf5

0000fe50 <USART_NORTH_CLOCK_init>:
    fe50:	4b06      	ldr	r3, [pc, #24]	; (fe6c <USART_NORTH_CLOCK_init+0x1c>)
    fe52:	2241      	movs	r2, #65	; 0x41
    fe54:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    fe58:	2242      	movs	r2, #66	; 0x42
    fe5a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM1;
    fe5e:	4a04      	ldr	r2, [pc, #16]	; (fe70 <USART_NORTH_CLOCK_init+0x20>)
    fe60:	6953      	ldr	r3, [r2, #20]
    fe62:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    fe66:	6153      	str	r3, [r2, #20]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_CORE, CONF_GCLK_SERCOM1_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_SLOW, CONF_GCLK_SERCOM1_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBAMASK_SERCOM1_bit(MCLK);
}
    fe68:	4770      	bx	lr
    fe6a:	bf00      	nop
    fe6c:	40001c00 	.word	0x40001c00
    fe70:	40000800 	.word	0x40000800

0000fe74 <USART_NORTH_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_NORTH_PORT_init()
{
    fe74:	b510      	push	{r4, lr}
    fe76:	4c05      	ldr	r4, [pc, #20]	; (fe8c <USART_NORTH_PORT_init+0x18>)
    fe78:	4905      	ldr	r1, [pc, #20]	; (fe90 <USART_NORTH_PORT_init+0x1c>)
    fe7a:	205b      	movs	r0, #91	; 0x5b
    fe7c:	47a0      	blx	r4
    fe7e:	4623      	mov	r3, r4
    fe80:	4904      	ldr	r1, [pc, #16]	; (fe94 <USART_NORTH_PORT_init+0x20>)

	gpio_set_pin_function(PC27, PINMUX_PC27C_SERCOM1_PAD0);

	gpio_set_pin_function(PC28, PINMUX_PC28C_SERCOM1_PAD1);
}
    fe82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fe86:	205c      	movs	r0, #92	; 0x5c
    fe88:	4718      	bx	r3
    fe8a:	bf00      	nop
    fe8c:	0000fa3d 	.word	0x0000fa3d
    fe90:	005b0002 	.word	0x005b0002
    fe94:	005c0002 	.word	0x005c0002

0000fe98 <USART_NORTH_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_NORTH_init(void)
{
    fe98:	b513      	push	{r0, r1, r4, lr}
	USART_NORTH_CLOCK_init();
    fe9a:	4b07      	ldr	r3, [pc, #28]	; (feb8 <USART_NORTH_init+0x20>)
	usart_async_init(&USART_NORTH, SERCOM1, USART_NORTH_buffer, USART_NORTH_BUFFER_SIZE, (void *)NULL);
    fe9c:	4c07      	ldr	r4, [pc, #28]	; (febc <USART_NORTH_init+0x24>)
	USART_NORTH_CLOCK_init();
    fe9e:	4798      	blx	r3
	usart_async_init(&USART_NORTH, SERCOM1, USART_NORTH_buffer, USART_NORTH_BUFFER_SIZE, (void *)NULL);
    fea0:	2300      	movs	r3, #0
    fea2:	9300      	str	r3, [sp, #0]
    fea4:	4a06      	ldr	r2, [pc, #24]	; (fec0 <USART_NORTH_init+0x28>)
    fea6:	4907      	ldr	r1, [pc, #28]	; (fec4 <USART_NORTH_init+0x2c>)
    fea8:	4807      	ldr	r0, [pc, #28]	; (fec8 <USART_NORTH_init+0x30>)
    feaa:	2310      	movs	r3, #16
    feac:	47a0      	blx	r4
	USART_NORTH_PORT_init();
    feae:	4b07      	ldr	r3, [pc, #28]	; (fecc <USART_NORTH_init+0x34>)
}
    feb0:	b002      	add	sp, #8
    feb2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_NORTH_PORT_init();
    feb6:	4718      	bx	r3
    feb8:	0000fe51 	.word	0x0000fe51
    febc:	0001072d 	.word	0x0001072d
    fec0:	20008d36 	.word	0x20008d36
    fec4:	40003400 	.word	0x40003400
    fec8:	2001ce04 	.word	0x2001ce04
    fecc:	0000fe75 	.word	0x0000fe75

0000fed0 <GRID_AUX_PORT_init>:

void GRID_AUX_PORT_init(void)
{
    fed0:	b510      	push	{r4, lr}
    fed2:	4c05      	ldr	r4, [pc, #20]	; (fee8 <GRID_AUX_PORT_init+0x18>)
    fed4:	4905      	ldr	r1, [pc, #20]	; (feec <GRID_AUX_PORT_init+0x1c>)
    fed6:	2039      	movs	r0, #57	; 0x39
    fed8:	47a0      	blx	r4
    feda:	4623      	mov	r3, r4
    fedc:	4904      	ldr	r1, [pc, #16]	; (fef0 <GRID_AUX_PORT_init+0x20>)

	gpio_set_pin_function(PB25, PINMUX_PB25D_SERCOM2_PAD0);

	gpio_set_pin_function(PB24, PINMUX_PB24D_SERCOM2_PAD1);
}
    fede:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fee2:	2038      	movs	r0, #56	; 0x38
    fee4:	4718      	bx	r3
    fee6:	bf00      	nop
    fee8:	0000fa3d 	.word	0x0000fa3d
    feec:	00390003 	.word	0x00390003
    fef0:	00380003 	.word	0x00380003

0000fef4 <GRID_AUX_CLOCK_init>:
    fef4:	4b06      	ldr	r3, [pc, #24]	; (ff10 <GRID_AUX_CLOCK_init+0x1c>)
    fef6:	2241      	movs	r2, #65	; 0x41
    fef8:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    fefc:	2242      	movs	r2, #66	; 0x42
    fefe:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM2;
    ff02:	4a04      	ldr	r2, [pc, #16]	; (ff14 <GRID_AUX_CLOCK_init+0x20>)
    ff04:	6993      	ldr	r3, [r2, #24]
    ff06:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    ff0a:	6193      	str	r3, [r2, #24]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_CORE, CONF_GCLK_SERCOM2_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_SLOW, CONF_GCLK_SERCOM2_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_SERCOM2_bit(MCLK);
}
    ff0c:	4770      	bx	lr
    ff0e:	bf00      	nop
    ff10:	40001c00 	.word	0x40001c00
    ff14:	40000800 	.word	0x40000800

0000ff18 <GRID_AUX_init>:

void GRID_AUX_init(void)
{
    ff18:	b510      	push	{r4, lr}
	GRID_AUX_CLOCK_init();
    ff1a:	4b05      	ldr	r3, [pc, #20]	; (ff30 <GRID_AUX_init+0x18>)
    ff1c:	4798      	blx	r3
	usart_sync_init(&GRID_AUX, SERCOM2, (void *)NULL);
    ff1e:	4b05      	ldr	r3, [pc, #20]	; (ff34 <GRID_AUX_init+0x1c>)
    ff20:	4905      	ldr	r1, [pc, #20]	; (ff38 <GRID_AUX_init+0x20>)
    ff22:	4806      	ldr	r0, [pc, #24]	; (ff3c <GRID_AUX_init+0x24>)
    ff24:	2200      	movs	r2, #0
    ff26:	4798      	blx	r3
	GRID_AUX_PORT_init();
}
    ff28:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	GRID_AUX_PORT_init();
    ff2c:	4b04      	ldr	r3, [pc, #16]	; (ff40 <GRID_AUX_init+0x28>)
    ff2e:	4718      	bx	r3
    ff30:	0000fef5 	.word	0x0000fef5
    ff34:	0000ebe9 	.word	0x0000ebe9
    ff38:	41012000 	.word	0x41012000
    ff3c:	2001cd70 	.word	0x2001cd70
    ff40:	0000fed1 	.word	0x0000fed1

0000ff44 <UI_SPI_PORT_init>:

void UI_SPI_PORT_init(void)
{
    ff44:	b570      	push	{r4, r5, r6, lr}
    ff46:	4e12      	ldr	r6, [pc, #72]	; (ff90 <UI_SPI_PORT_init+0x4c>)
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB20, GPIO_DIRECTION_OUT);
    ff48:	4d12      	ldr	r5, [pc, #72]	; (ff94 <UI_SPI_PORT_init+0x50>)
    ff4a:	4c13      	ldr	r4, [pc, #76]	; (ff98 <UI_SPI_PORT_init+0x54>)
    ff4c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
    ff50:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
    ff54:	2102      	movs	r1, #2
    ff56:	2034      	movs	r0, #52	; 0x34
    ff58:	47a8      	blx	r5
    ff5a:	4910      	ldr	r1, [pc, #64]	; (ff9c <UI_SPI_PORT_init+0x58>)
    ff5c:	2034      	movs	r0, #52	; 0x34
    ff5e:	47a0      	blx	r4
    ff60:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
    ff64:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB21, GPIO_DIRECTION_OUT);
    ff68:	2102      	movs	r1, #2
    ff6a:	2035      	movs	r0, #53	; 0x35
    ff6c:	47a8      	blx	r5
    ff6e:	490c      	ldr	r1, [pc, #48]	; (ffa0 <UI_SPI_PORT_init+0x5c>)
    ff70:	2035      	movs	r0, #53	; 0x35
    ff72:	47a0      	blx	r4

	gpio_set_pin_function(PB21, PINMUX_PB21C_SERCOM3_PAD1);

	// Set pin direction to input
	gpio_set_pin_direction(PA20, GPIO_DIRECTION_IN);
    ff74:	2101      	movs	r1, #1
    ff76:	2014      	movs	r0, #20
    ff78:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PA20,
    ff7a:	4b0a      	ldr	r3, [pc, #40]	; (ffa4 <UI_SPI_PORT_init+0x60>)
    ff7c:	2100      	movs	r1, #0
    ff7e:	2014      	movs	r0, #20
    ff80:	4798      	blx	r3
    ff82:	4623      	mov	r3, r4
    ff84:	4908      	ldr	r1, [pc, #32]	; (ffa8 <UI_SPI_PORT_init+0x64>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA20, PINMUX_PA20D_SERCOM3_PAD2);
}
    ff86:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    ff8a:	2014      	movs	r0, #20
    ff8c:	4718      	bx	r3
    ff8e:	bf00      	nop
    ff90:	41008000 	.word	0x41008000
    ff94:	0000faa9 	.word	0x0000faa9
    ff98:	0000fa3d 	.word	0x0000fa3d
    ff9c:	00340002 	.word	0x00340002
    ffa0:	00350002 	.word	0x00350002
    ffa4:	0000faf9 	.word	0x0000faf9
    ffa8:	00140003 	.word	0x00140003

0000ffac <UI_SPI_CLOCK_init>:
    ffac:	4b06      	ldr	r3, [pc, #24]	; (ffc8 <UI_SPI_CLOCK_init+0x1c>)
    ffae:	2241      	movs	r2, #65	; 0x41
    ffb0:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
    ffb4:	2243      	movs	r2, #67	; 0x43
    ffb6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM3;
    ffba:	4a04      	ldr	r2, [pc, #16]	; (ffcc <UI_SPI_CLOCK_init+0x20>)
    ffbc:	6993      	ldr	r3, [r2, #24]
    ffbe:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    ffc2:	6193      	str	r3, [r2, #24]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_CORE, CONF_GCLK_SERCOM3_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_SLOW, CONF_GCLK_SERCOM3_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_SERCOM3_bit(MCLK);
}
    ffc4:	4770      	bx	lr
    ffc6:	bf00      	nop
    ffc8:	40001c00 	.word	0x40001c00
    ffcc:	40000800 	.word	0x40000800

0000ffd0 <UI_SPI_init>:

void UI_SPI_init(void)
{
    ffd0:	b510      	push	{r4, lr}
	UI_SPI_CLOCK_init();
    ffd2:	4b05      	ldr	r3, [pc, #20]	; (ffe8 <UI_SPI_init+0x18>)
    ffd4:	4798      	blx	r3
	spi_m_async_init(&UI_SPI, SERCOM3);
    ffd6:	4b05      	ldr	r3, [pc, #20]	; (ffec <UI_SPI_init+0x1c>)
    ffd8:	4905      	ldr	r1, [pc, #20]	; (fff0 <UI_SPI_init+0x20>)
    ffda:	4806      	ldr	r0, [pc, #24]	; (fff4 <UI_SPI_init+0x24>)
    ffdc:	4798      	blx	r3
	UI_SPI_PORT_init();
}
    ffde:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	UI_SPI_PORT_init();
    ffe2:	4b05      	ldr	r3, [pc, #20]	; (fff8 <UI_SPI_init+0x28>)
    ffe4:	4718      	bx	r3
    ffe6:	bf00      	nop
    ffe8:	0000ffad 	.word	0x0000ffad
    ffec:	0000f09d 	.word	0x0000f09d
    fff0:	41014000 	.word	0x41014000
    fff4:	2001cc70 	.word	0x2001cc70
    fff8:	0000ff45 	.word	0x0000ff45

0000fffc <USART_WEST_CLOCK_init>:
    fffc:	4b06      	ldr	r3, [pc, #24]	; (10018 <STACK_SIZE+0x18>)
    fffe:	2241      	movs	r2, #65	; 0x41
   10000:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   10004:	2242      	movs	r2, #66	; 0x42
   10006:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM4;
   1000a:	4a04      	ldr	r2, [pc, #16]	; (1001c <STACK_SIZE+0x1c>)
   1000c:	6a13      	ldr	r3, [r2, #32]
   1000e:	f043 0301 	orr.w	r3, r3, #1
   10012:	6213      	str	r3, [r2, #32]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_CORE, CONF_GCLK_SERCOM4_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_SLOW, CONF_GCLK_SERCOM4_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM4_bit(MCLK);
}
   10014:	4770      	bx	lr
   10016:	bf00      	nop
   10018:	40001c00 	.word	0x40001c00
   1001c:	40000800 	.word	0x40000800

00010020 <USART_WEST_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_WEST_PORT_init()
{
   10020:	b510      	push	{r4, lr}
   10022:	4c05      	ldr	r4, [pc, #20]	; (10038 <USART_WEST_PORT_init+0x18>)
   10024:	4905      	ldr	r1, [pc, #20]	; (1003c <USART_WEST_PORT_init+0x1c>)
   10026:	2028      	movs	r0, #40	; 0x28
   10028:	47a0      	blx	r4
   1002a:	4623      	mov	r3, r4
   1002c:	4904      	ldr	r1, [pc, #16]	; (10040 <USART_WEST_PORT_init+0x20>)

	gpio_set_pin_function(PB08, PINMUX_PB08D_SERCOM4_PAD0);

	gpio_set_pin_function(PB09, PINMUX_PB09D_SERCOM4_PAD1);
}
   1002e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10032:	2029      	movs	r0, #41	; 0x29
   10034:	4718      	bx	r3
   10036:	bf00      	nop
   10038:	0000fa3d 	.word	0x0000fa3d
   1003c:	00280003 	.word	0x00280003
   10040:	00290003 	.word	0x00290003

00010044 <USART_WEST_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_WEST_init(void)
{
   10044:	b513      	push	{r0, r1, r4, lr}
	USART_WEST_CLOCK_init();
   10046:	4b08      	ldr	r3, [pc, #32]	; (10068 <USART_WEST_init+0x24>)
	usart_async_init(&USART_WEST, SERCOM4, USART_WEST_buffer, USART_WEST_BUFFER_SIZE, (void *)NULL);
   10048:	4c08      	ldr	r4, [pc, #32]	; (1006c <USART_WEST_init+0x28>)
	USART_WEST_CLOCK_init();
   1004a:	4798      	blx	r3
	usart_async_init(&USART_WEST, SERCOM4, USART_WEST_buffer, USART_WEST_BUFFER_SIZE, (void *)NULL);
   1004c:	2300      	movs	r3, #0
   1004e:	9300      	str	r3, [sp, #0]
   10050:	4a07      	ldr	r2, [pc, #28]	; (10070 <USART_WEST_init+0x2c>)
   10052:	4808      	ldr	r0, [pc, #32]	; (10074 <USART_WEST_init+0x30>)
   10054:	2310      	movs	r3, #16
   10056:	f04f 4186 	mov.w	r1, #1124073472	; 0x43000000
   1005a:	47a0      	blx	r4
	USART_WEST_PORT_init();
   1005c:	4b06      	ldr	r3, [pc, #24]	; (10078 <USART_WEST_init+0x34>)
}
   1005e:	b002      	add	sp, #8
   10060:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_WEST_PORT_init();
   10064:	4718      	bx	r3
   10066:	bf00      	nop
   10068:	0000fffd 	.word	0x0000fffd
   1006c:	0001072d 	.word	0x0001072d
   10070:	20008d46 	.word	0x20008d46
   10074:	2001ceb8 	.word	0x2001ceb8
   10078:	00010021 	.word	0x00010021

0001007c <SYS_I2C_PORT_init>:

void SYS_I2C_PORT_init(void)
{
   1007c:	b570      	push	{r4, r5, r6, lr}

	gpio_set_pin_pull_mode(PA23,
   1007e:	2100      	movs	r1, #0
   10080:	4d07      	ldr	r5, [pc, #28]	; (100a0 <SYS_I2C_PORT_init+0x24>)
   10082:	4c08      	ldr	r4, [pc, #32]	; (100a4 <SYS_I2C_PORT_init+0x28>)
   10084:	2017      	movs	r0, #23
   10086:	47a8      	blx	r5
   10088:	4907      	ldr	r1, [pc, #28]	; (100a8 <SYS_I2C_PORT_init+0x2c>)
   1008a:	2017      	movs	r0, #23
   1008c:	47a0      	blx	r4
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA23, PINMUX_PA23D_SERCOM5_PAD0);

	gpio_set_pin_pull_mode(PA22,
   1008e:	2100      	movs	r1, #0
   10090:	2016      	movs	r0, #22
   10092:	47a8      	blx	r5
   10094:	4623      	mov	r3, r4
   10096:	4905      	ldr	r1, [pc, #20]	; (100ac <SYS_I2C_PORT_init+0x30>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA22, PINMUX_PA22D_SERCOM5_PAD1);
}
   10098:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1009c:	2016      	movs	r0, #22
   1009e:	4718      	bx	r3
   100a0:	0000faf9 	.word	0x0000faf9
   100a4:	0000fa3d 	.word	0x0000fa3d
   100a8:	00170003 	.word	0x00170003
   100ac:	00160003 	.word	0x00160003

000100b0 <SYS_I2C_CLOCK_init>:
   100b0:	4b06      	ldr	r3, [pc, #24]	; (100cc <SYS_I2C_CLOCK_init+0x1c>)
   100b2:	2241      	movs	r2, #65	; 0x41
   100b4:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
   100b8:	2242      	movs	r2, #66	; 0x42
   100ba:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM5;
   100be:	4a04      	ldr	r2, [pc, #16]	; (100d0 <SYS_I2C_CLOCK_init+0x20>)
   100c0:	6a13      	ldr	r3, [r2, #32]
   100c2:	f043 0302 	orr.w	r3, r3, #2
   100c6:	6213      	str	r3, [r2, #32]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM5_GCLK_ID_CORE, CONF_GCLK_SERCOM5_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM5_GCLK_ID_SLOW, CONF_GCLK_SERCOM5_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM5_bit(MCLK);
}
   100c8:	4770      	bx	lr
   100ca:	bf00      	nop
   100cc:	40001c00 	.word	0x40001c00
   100d0:	40000800 	.word	0x40000800

000100d4 <SYS_I2C_init>:

void SYS_I2C_init(void)
{
   100d4:	b510      	push	{r4, lr}
	SYS_I2C_CLOCK_init();
   100d6:	4b05      	ldr	r3, [pc, #20]	; (100ec <SYS_I2C_init+0x18>)
   100d8:	4798      	blx	r3
	i2c_m_async_init(&SYS_I2C, SERCOM5);
   100da:	4b05      	ldr	r3, [pc, #20]	; (100f0 <SYS_I2C_init+0x1c>)
   100dc:	4905      	ldr	r1, [pc, #20]	; (100f4 <SYS_I2C_init+0x20>)
   100de:	4806      	ldr	r0, [pc, #24]	; (100f8 <SYS_I2C_init+0x24>)
   100e0:	4798      	blx	r3
	SYS_I2C_PORT_init();
}
   100e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SYS_I2C_PORT_init();
   100e6:	4b05      	ldr	r3, [pc, #20]	; (100fc <SYS_I2C_init+0x28>)
   100e8:	4718      	bx	r3
   100ea:	bf00      	nop
   100ec:	000100b1 	.word	0x000100b1
   100f0:	0000b565 	.word	0x0000b565
   100f4:	43000400 	.word	0x43000400
   100f8:	2001cd30 	.word	0x2001cd30
   100fc:	0001007d 	.word	0x0001007d

00010100 <USART_SOUTH_CLOCK_init>:
   10100:	4b06      	ldr	r3, [pc, #24]	; (1011c <USART_SOUTH_CLOCK_init+0x1c>)
   10102:	2241      	movs	r2, #65	; 0x41
   10104:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
   10108:	2242      	movs	r2, #66	; 0x42
   1010a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM6;
   1010e:	4a04      	ldr	r2, [pc, #16]	; (10120 <USART_SOUTH_CLOCK_init+0x20>)
   10110:	6a13      	ldr	r3, [r2, #32]
   10112:	f043 0304 	orr.w	r3, r3, #4
   10116:	6213      	str	r3, [r2, #32]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM6_GCLK_ID_CORE, CONF_GCLK_SERCOM6_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM6_GCLK_ID_SLOW, CONF_GCLK_SERCOM6_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM6_bit(MCLK);
}
   10118:	4770      	bx	lr
   1011a:	bf00      	nop
   1011c:	40001c00 	.word	0x40001c00
   10120:	40000800 	.word	0x40000800

00010124 <USART_SOUTH_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_SOUTH_PORT_init()
{
   10124:	b510      	push	{r4, lr}
   10126:	4c05      	ldr	r4, [pc, #20]	; (1013c <USART_SOUTH_PORT_init+0x18>)
   10128:	4905      	ldr	r1, [pc, #20]	; (10140 <USART_SOUTH_PORT_init+0x1c>)
   1012a:	204d      	movs	r0, #77	; 0x4d
   1012c:	47a0      	blx	r4
   1012e:	4623      	mov	r3, r4
   10130:	4904      	ldr	r1, [pc, #16]	; (10144 <USART_SOUTH_PORT_init+0x20>)

	gpio_set_pin_function(PC13, PINMUX_PC13D_SERCOM6_PAD0);

	gpio_set_pin_function(PC12, PINMUX_PC12D_SERCOM6_PAD1);
}
   10132:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10136:	204c      	movs	r0, #76	; 0x4c
   10138:	4718      	bx	r3
   1013a:	bf00      	nop
   1013c:	0000fa3d 	.word	0x0000fa3d
   10140:	004d0003 	.word	0x004d0003
   10144:	004c0003 	.word	0x004c0003

00010148 <USART_SOUTH_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_SOUTH_init(void)
{
   10148:	b513      	push	{r0, r1, r4, lr}
	USART_SOUTH_CLOCK_init();
   1014a:	4b07      	ldr	r3, [pc, #28]	; (10168 <USART_SOUTH_init+0x20>)
	usart_async_init(&USART_SOUTH, SERCOM6, USART_SOUTH_buffer, USART_SOUTH_BUFFER_SIZE, (void *)NULL);
   1014c:	4c07      	ldr	r4, [pc, #28]	; (1016c <USART_SOUTH_init+0x24>)
	USART_SOUTH_CLOCK_init();
   1014e:	4798      	blx	r3
	usart_async_init(&USART_SOUTH, SERCOM6, USART_SOUTH_buffer, USART_SOUTH_BUFFER_SIZE, (void *)NULL);
   10150:	2300      	movs	r3, #0
   10152:	9300      	str	r3, [sp, #0]
   10154:	4a06      	ldr	r2, [pc, #24]	; (10170 <USART_SOUTH_init+0x28>)
   10156:	4907      	ldr	r1, [pc, #28]	; (10174 <USART_SOUTH_init+0x2c>)
   10158:	4807      	ldr	r0, [pc, #28]	; (10178 <USART_SOUTH_init+0x30>)
   1015a:	2310      	movs	r3, #16
   1015c:	47a0      	blx	r4
	USART_SOUTH_PORT_init();
   1015e:	4b07      	ldr	r3, [pc, #28]	; (1017c <USART_SOUTH_init+0x34>)
}
   10160:	b002      	add	sp, #8
   10162:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_SOUTH_PORT_init();
   10166:	4718      	bx	r3
   10168:	00010101 	.word	0x00010101
   1016c:	0001072d 	.word	0x0001072d
   10170:	20008d56 	.word	0x20008d56
   10174:	43000800 	.word	0x43000800
   10178:	2001cf08 	.word	0x2001cf08
   1017c:	00010125 	.word	0x00010125

00010180 <GRID_LED_PORT_init>:

void GRID_LED_PORT_init(void)
{
   10180:	b570      	push	{r4, r5, r6, lr}
   10182:	4e12      	ldr	r6, [pc, #72]	; (101cc <GRID_LED_PORT_init+0x4c>)
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB30, GPIO_DIRECTION_OUT);
   10184:	4d12      	ldr	r5, [pc, #72]	; (101d0 <GRID_LED_PORT_init+0x50>)
   10186:	4c13      	ldr	r4, [pc, #76]	; (101d4 <GRID_LED_PORT_init+0x54>)
   10188:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1018c:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
   10190:	2102      	movs	r1, #2
   10192:	203e      	movs	r0, #62	; 0x3e
   10194:	47a8      	blx	r5
   10196:	4910      	ldr	r1, [pc, #64]	; (101d8 <GRID_LED_PORT_init+0x58>)
   10198:	203e      	movs	r0, #62	; 0x3e
   1019a:	47a0      	blx	r4
   1019c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   101a0:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB31, GPIO_DIRECTION_OUT);
   101a4:	2102      	movs	r1, #2
   101a6:	203f      	movs	r0, #63	; 0x3f
   101a8:	47a8      	blx	r5
   101aa:	490c      	ldr	r1, [pc, #48]	; (101dc <GRID_LED_PORT_init+0x5c>)
   101ac:	203f      	movs	r0, #63	; 0x3f
   101ae:	47a0      	blx	r4

	gpio_set_pin_function(PB31, PINMUX_PB31C_SERCOM7_PAD1);

	// Set pin direction to input
	gpio_set_pin_direction(PA30, GPIO_DIRECTION_IN);
   101b0:	2101      	movs	r1, #1
   101b2:	201e      	movs	r0, #30
   101b4:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PA30,
   101b6:	4b0a      	ldr	r3, [pc, #40]	; (101e0 <GRID_LED_PORT_init+0x60>)
   101b8:	2100      	movs	r1, #0
   101ba:	201e      	movs	r0, #30
   101bc:	4798      	blx	r3
   101be:	4623      	mov	r3, r4
   101c0:	4908      	ldr	r1, [pc, #32]	; (101e4 <GRID_LED_PORT_init+0x64>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA30, PINMUX_PA30C_SERCOM7_PAD2);
}
   101c2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   101c6:	201e      	movs	r0, #30
   101c8:	4718      	bx	r3
   101ca:	bf00      	nop
   101cc:	41008000 	.word	0x41008000
   101d0:	0000faa9 	.word	0x0000faa9
   101d4:	0000fa3d 	.word	0x0000fa3d
   101d8:	003e0002 	.word	0x003e0002
   101dc:	003f0002 	.word	0x003f0002
   101e0:	0000faf9 	.word	0x0000faf9
   101e4:	001e0002 	.word	0x001e0002

000101e8 <GRID_LED_CLOCK_init>:
   101e8:	4b06      	ldr	r3, [pc, #24]	; (10204 <GRID_LED_CLOCK_init+0x1c>)
   101ea:	2241      	movs	r2, #65	; 0x41
   101ec:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
   101f0:	2242      	movs	r2, #66	; 0x42
   101f2:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM7;
   101f6:	4a04      	ldr	r2, [pc, #16]	; (10208 <GRID_LED_CLOCK_init+0x20>)
   101f8:	6a13      	ldr	r3, [r2, #32]
   101fa:	f043 0308 	orr.w	r3, r3, #8
   101fe:	6213      	str	r3, [r2, #32]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM7_GCLK_ID_CORE, CONF_GCLK_SERCOM7_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM7_GCLK_ID_SLOW, CONF_GCLK_SERCOM7_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM7_bit(MCLK);
}
   10200:	4770      	bx	lr
   10202:	bf00      	nop
   10204:	40001c00 	.word	0x40001c00
   10208:	40000800 	.word	0x40000800

0001020c <GRID_LED_init>:

void GRID_LED_init(void)
{
   1020c:	b510      	push	{r4, lr}
	GRID_LED_CLOCK_init();
   1020e:	4b05      	ldr	r3, [pc, #20]	; (10224 <GRID_LED_init+0x18>)
   10210:	4798      	blx	r3
	spi_m_dma_init(&GRID_LED, SERCOM7);
   10212:	4b05      	ldr	r3, [pc, #20]	; (10228 <GRID_LED_init+0x1c>)
   10214:	4905      	ldr	r1, [pc, #20]	; (1022c <GRID_LED_init+0x20>)
   10216:	4806      	ldr	r0, [pc, #24]	; (10230 <GRID_LED_init+0x24>)
   10218:	4798      	blx	r3
	GRID_LED_PORT_init();
}
   1021a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	GRID_LED_PORT_init();
   1021e:	4b05      	ldr	r3, [pc, #20]	; (10234 <GRID_LED_init+0x28>)
   10220:	4718      	bx	r3
   10222:	bf00      	nop
   10224:	000101e9 	.word	0x000101e9
   10228:	0000b961 	.word	0x0000b961
   1022c:	43000c00 	.word	0x43000c00
   10230:	2001ce54 	.word	0x2001ce54
   10234:	00010181 	.word	0x00010181

00010238 <delay_driver_init>:

void delay_driver_init(void)
{
	delay_init(SysTick);
   10238:	4801      	ldr	r0, [pc, #4]	; (10240 <delay_driver_init+0x8>)
   1023a:	4b02      	ldr	r3, [pc, #8]	; (10244 <delay_driver_init+0xc>)
   1023c:	4718      	bx	r3
   1023e:	bf00      	nop
   10240:	e000e010 	.word	0xe000e010
   10244:	0000dd7d 	.word	0x0000dd7d

00010248 <RAND_0_CLOCK_init>:
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_TRNG;
   10248:	4a02      	ldr	r2, [pc, #8]	; (10254 <RAND_0_CLOCK_init+0xc>)
   1024a:	69d3      	ldr	r3, [r2, #28]
   1024c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   10250:	61d3      	str	r3, [r2, #28]
}

void RAND_0_CLOCK_init(void)
{
	hri_mclk_set_APBCMASK_TRNG_bit(MCLK);
}
   10252:	4770      	bx	lr
   10254:	40000800 	.word	0x40000800

00010258 <RAND_0_init>:

void RAND_0_init(void)
{
   10258:	b510      	push	{r4, lr}
	RAND_0_CLOCK_init();
   1025a:	4b04      	ldr	r3, [pc, #16]	; (1026c <RAND_0_init+0x14>)
   1025c:	4798      	blx	r3
	rand_sync_init(&RAND_0, TRNG);
}
   1025e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	rand_sync_init(&RAND_0, TRNG);
   10262:	4903      	ldr	r1, [pc, #12]	; (10270 <RAND_0_init+0x18>)
   10264:	4803      	ldr	r0, [pc, #12]	; (10274 <RAND_0_init+0x1c>)
   10266:	4b04      	ldr	r3, [pc, #16]	; (10278 <RAND_0_init+0x20>)
   10268:	4718      	bx	r3
   1026a:	bf00      	nop
   1026c:	00010249 	.word	0x00010249
   10270:	42002800 	.word	0x42002800
   10274:	2001cd7c 	.word	0x2001cd7c
   10278:	0000e761 	.word	0x0000e761

0001027c <USB_DEVICE_INSTANCE_PORT_init>:

void USB_DEVICE_INSTANCE_PORT_init(void)
{
   1027c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	gpio_set_pin_direction(PA24,
   10280:	2102      	movs	r1, #2
   10282:	4f0f      	ldr	r7, [pc, #60]	; (102c0 <USB_DEVICE_INSTANCE_PORT_init+0x44>)
   10284:	4e0f      	ldr	r6, [pc, #60]	; (102c4 <USB_DEVICE_INSTANCE_PORT_init+0x48>)
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA24,
   10286:	4d10      	ldr	r5, [pc, #64]	; (102c8 <USB_DEVICE_INSTANCE_PORT_init+0x4c>)
   10288:	4c10      	ldr	r4, [pc, #64]	; (102cc <USB_DEVICE_INSTANCE_PORT_init+0x50>)
	gpio_set_pin_direction(PA24,
   1028a:	2018      	movs	r0, #24
   1028c:	47b8      	blx	r7
   1028e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   10292:	6173      	str	r3, [r6, #20]
	gpio_set_pin_pull_mode(PA24,
   10294:	2100      	movs	r1, #0
   10296:	2018      	movs	r0, #24
   10298:	47a8      	blx	r5
   1029a:	490d      	ldr	r1, [pc, #52]	; (102d0 <USB_DEVICE_INSTANCE_PORT_init+0x54>)
   1029c:	2018      	movs	r0, #24
   1029e:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA24H_USB_DM);

	gpio_set_pin_direction(PA25,
   102a0:	2102      	movs	r1, #2
   102a2:	2019      	movs	r0, #25
   102a4:	47b8      	blx	r7
   102a6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   102aa:	6173      	str	r3, [r6, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA25,
   102ac:	2100      	movs	r1, #0
   102ae:	2019      	movs	r0, #25
   102b0:	47a8      	blx	r5
   102b2:	4623      	mov	r3, r4
   102b4:	4907      	ldr	r1, [pc, #28]	; (102d4 <USB_DEVICE_INSTANCE_PORT_init+0x58>)
	                      // <GPIO_PIN_FUNCTION_K"> K
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA25H_USB_DP);
}
   102b6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   102ba:	2019      	movs	r0, #25
   102bc:	4718      	bx	r3
   102be:	bf00      	nop
   102c0:	0000faa9 	.word	0x0000faa9
   102c4:	41008000 	.word	0x41008000
   102c8:	0000faf9 	.word	0x0000faf9
   102cc:	0000fa3d 	.word	0x0000fa3d
   102d0:	00180007 	.word	0x00180007
   102d4:	00190007 	.word	0x00190007

000102d8 <USB_DEVICE_INSTANCE_CLOCK_init>:
   102d8:	4b07      	ldr	r3, [pc, #28]	; (102f8 <USB_DEVICE_INSTANCE_CLOCK_init+0x20>)
   102da:	2241      	movs	r2, #65	; 0x41
   102dc:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_USB;
   102e0:	f5a3 53a0 	sub.w	r3, r3, #5120	; 0x1400
   102e4:	691a      	ldr	r2, [r3, #16]
   102e6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   102ea:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_USB;
   102ec:	699a      	ldr	r2, [r3, #24]
   102ee:	f042 0201 	orr.w	r2, r2, #1
   102f2:	619a      	str	r2, [r3, #24]
{

	hri_gclk_write_PCHCTRL_reg(GCLK, USB_GCLK_ID, CONF_GCLK_USB_SRC | GCLK_PCHCTRL_CHEN);
	hri_mclk_set_AHBMASK_USB_bit(MCLK);
	hri_mclk_set_APBBMASK_USB_bit(MCLK);
}
   102f4:	4770      	bx	lr
   102f6:	bf00      	nop
   102f8:	40001c00 	.word	0x40001c00

000102fc <USB_DEVICE_INSTANCE_init>:

void USB_DEVICE_INSTANCE_init(void)
{
   102fc:	b510      	push	{r4, lr}
	USB_DEVICE_INSTANCE_CLOCK_init();
   102fe:	4b04      	ldr	r3, [pc, #16]	; (10310 <USB_DEVICE_INSTANCE_init+0x14>)
   10300:	4798      	blx	r3
	usb_d_init();
   10302:	4b04      	ldr	r3, [pc, #16]	; (10314 <USB_DEVICE_INSTANCE_init+0x18>)
   10304:	4798      	blx	r3
	USB_DEVICE_INSTANCE_PORT_init();
}
   10306:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USB_DEVICE_INSTANCE_PORT_init();
   1030a:	4b03      	ldr	r3, [pc, #12]	; (10318 <USB_DEVICE_INSTANCE_init+0x1c>)
   1030c:	4718      	bx	r3
   1030e:	bf00      	nop
   10310:	000102d9 	.word	0x000102d9
   10314:	0000f491 	.word	0x0000f491
   10318:	0001027d 	.word	0x0001027d

0001031c <WDT_0_CLOCK_init>:
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_WDT;
   1031c:	4a02      	ldr	r2, [pc, #8]	; (10328 <WDT_0_CLOCK_init+0xc>)
   1031e:	6953      	ldr	r3, [r2, #20]
   10320:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   10324:	6153      	str	r3, [r2, #20]

void WDT_0_CLOCK_init(void)
{
	hri_mclk_set_APBAMASK_WDT_bit(MCLK);
}
   10326:	4770      	bx	lr
   10328:	40000800 	.word	0x40000800

0001032c <WDT_0_init>:

void WDT_0_init(void)
{
   1032c:	b510      	push	{r4, lr}
	WDT_0_CLOCK_init();
   1032e:	4b07      	ldr	r3, [pc, #28]	; (1034c <WDT_0_init+0x20>)
   10330:	4798      	blx	r3
 * \retval 0 Completed sucessfully.
 * \retval -1 Always on or enabled, don't need init again.
 */
static inline int32_t wdt_init(struct wdt_descriptor *const wdt, const void *hw)
{
	ASSERT(wdt && hw);
   10332:	4b07      	ldr	r3, [pc, #28]	; (10350 <WDT_0_init+0x24>)
   10334:	4907      	ldr	r1, [pc, #28]	; (10354 <WDT_0_init+0x28>)
   10336:	2001      	movs	r0, #1
   10338:	2248      	movs	r2, #72	; 0x48
   1033a:	4798      	blx	r3

	wdt->dev.hw = (void *)hw;
   1033c:	4806      	ldr	r0, [pc, #24]	; (10358 <WDT_0_init+0x2c>)
   1033e:	4b07      	ldr	r3, [pc, #28]	; (1035c <WDT_0_init+0x30>)
   10340:	6003      	str	r3, [r0, #0]
	wdt_init(&WDT_0, WDT);
}
   10342:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	return _wdt_init(&wdt->dev);
   10346:	4b06      	ldr	r3, [pc, #24]	; (10360 <WDT_0_init+0x34>)
   10348:	4718      	bx	r3
   1034a:	bf00      	nop
   1034c:	0001031d 	.word	0x0001031d
   10350:	0000e03d 	.word	0x0000e03d
   10354:	00016537 	.word	0x00016537
   10358:	2001ce00 	.word	0x2001ce00
   1035c:	40002000 	.word	0x40002000
   10360:	0000b78d 	.word	0x0000b78d

00010364 <system_init>:

void system_init(void)
{
   10364:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
   10368:	4b7c      	ldr	r3, [pc, #496]	; (1055c <system_init+0x1f8>)
   1036a:	4c7d      	ldr	r4, [pc, #500]	; (10560 <system_init+0x1fc>)
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);
   1036c:	4d7d      	ldr	r5, [pc, #500]	; (10564 <system_init+0x200>)
	// GPIO on PA21

	// Set pin direction to input
	gpio_set_pin_direction(PIN_UI_SPI_CS0, GPIO_DIRECTION_IN);

	gpio_set_pin_pull_mode(PIN_UI_SPI_CS0,
   1036e:	4e7e      	ldr	r6, [pc, #504]	; (10568 <system_init+0x204>)
   10370:	4798      	blx	r3
   10372:	2320      	movs	r3, #32
   10374:	6163      	str	r3, [r4, #20]
	gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);
   10376:	2102      	movs	r1, #2
   10378:	2005      	movs	r0, #5
   1037a:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   1037c:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
	tmp &= ~PORT_PINCFG_PMUXEN;
   10380:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10384:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	gpio_set_pin_direction(PIN_UI_SPI_CS0, GPIO_DIRECTION_IN);
   10388:	2101      	movs	r1, #1
   1038a:	2015      	movs	r0, #21
   1038c:	47a8      	blx	r5
	gpio_set_pin_pull_mode(PIN_UI_SPI_CS0,
   1038e:	2100      	movs	r1, #0
   10390:	2015      	movs	r0, #21
   10392:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10394:	f894 3055 	ldrb.w	r3, [r4, #85]	; 0x55
	tmp &= ~PORT_PINCFG_PMUXEN;
   10398:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   1039c:	f884 3055 	strb.w	r3, [r4, #85]	; 0x55
	gpio_set_pin_function(PIN_UI_SPI_CS0, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PB07

	// Set pin direction to input
	gpio_set_pin_direction(PIN_GRID_SYNC_2, GPIO_DIRECTION_IN);
   103a0:	2101      	movs	r1, #1
   103a2:	2027      	movs	r0, #39	; 0x27
   103a4:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PIN_GRID_SYNC_2,
   103a6:	2100      	movs	r1, #0
   103a8:	2027      	movs	r0, #39	; 0x27
   103aa:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   103ac:	f894 30c7 	ldrb.w	r3, [r4, #199]	; 0xc7
	tmp &= ~PORT_PINCFG_PMUXEN;
   103b0:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   103b4:	f884 30c7 	strb.w	r3, [r4, #199]	; 0xc7
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   103b8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
   103bc:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(HWCFG_SHIFT, GPIO_DIRECTION_OUT);
   103c0:	2102      	movs	r1, #2
   103c2:	202d      	movs	r0, #45	; 0x2d
   103c4:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   103c6:	f894 30cd 	ldrb.w	r3, [r4, #205]	; 0xcd
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   103ca:	f44f 4780 	mov.w	r7, #16384	; 0x4000
	tmp &= ~PORT_PINCFG_PMUXEN;
   103ce:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   103d2:	f884 30cd 	strb.w	r3, [r4, #205]	; 0xcd
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(HWCFG_CLOCK, GPIO_DIRECTION_OUT);
   103d6:	2102      	movs	r1, #2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   103d8:	f8c4 7094 	str.w	r7, [r4, #148]	; 0x94
   103dc:	202e      	movs	r0, #46	; 0x2e
   103de:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   103e0:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
	tmp &= ~PORT_PINCFG_PMUXEN;
   103e4:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   103e8:	f884 30ce 	strb.w	r3, [r4, #206]	; 0xce
	gpio_set_pin_function(HWCFG_CLOCK, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PB15

	// Set pin direction to input
	gpio_set_pin_direction(HWCFG_DATA, GPIO_DIRECTION_IN);
   103ec:	2101      	movs	r1, #1
   103ee:	202f      	movs	r0, #47	; 0x2f
   103f0:	47a8      	blx	r5

	gpio_set_pin_pull_mode(HWCFG_DATA,
   103f2:	2100      	movs	r1, #0
   103f4:	202f      	movs	r0, #47	; 0x2f
   103f6:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   103f8:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
	tmp &= ~PORT_PINCFG_PMUXEN;
   103fc:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10400:	f884 30cf 	strb.w	r3, [r4, #207]	; 0xcf
	gpio_set_pin_function(HWCFG_DATA, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PC11

	// Set pin direction to input
	gpio_set_pin_direction(MAP_MODE, GPIO_DIRECTION_IN);
   10404:	2101      	movs	r1, #1
   10406:	204b      	movs	r0, #75	; 0x4b
   10408:	47a8      	blx	r5

	gpio_set_pin_pull_mode(MAP_MODE,
   1040a:	2101      	movs	r1, #1
   1040c:	204b      	movs	r0, #75	; 0x4b
   1040e:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10410:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
	tmp &= ~PORT_PINCFG_PMUXEN;
   10414:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10418:	f884 314b 	strb.w	r3, [r4, #331]	; 0x14b
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(UI_PWR_EN, GPIO_DIRECTION_OUT);
   1041c:	2102      	movs	r1, #2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   1041e:	f8c4 7114 	str.w	r7, [r4, #276]	; 0x114
   10422:	204e      	movs	r0, #78	; 0x4e
   10424:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10426:	f894 314e 	ldrb.w	r3, [r4, #334]	; 0x14e
	tmp &= ~PORT_PINCFG_PMUXEN;
   1042a:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   1042e:	f884 314e 	strb.w	r3, [r4, #334]	; 0x14e
	gpio_set_pin_function(UI_PWR_EN, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PC18

	// Set pin direction to input
	gpio_set_pin_direction(PIN_GRID_SYNC_1, GPIO_DIRECTION_IN);
   10432:	2101      	movs	r1, #1
   10434:	2052      	movs	r0, #82	; 0x52
   10436:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PIN_GRID_SYNC_1,
   10438:	2100      	movs	r1, #0
   1043a:	2052      	movs	r0, #82	; 0x52
   1043c:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   1043e:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
	timer_init(&TIMER_0, TC0, _tc_get_timer());
   10442:	4e4a      	ldr	r6, [pc, #296]	; (1056c <system_init+0x208>)
	tmp &= ~PORT_PINCFG_PMUXEN;
   10444:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10448:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   1044c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
   10450:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(MUX_A, GPIO_DIRECTION_OUT);
   10454:	2102      	movs	r1, #2
   10456:	2053      	movs	r0, #83	; 0x53
   10458:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   1045a:	f894 3153 	ldrb.w	r3, [r4, #339]	; 0x153
	tmp &= ~PORT_PINCFG_PMUXEN;
   1045e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10462:	f884 3153 	strb.w	r3, [r4, #339]	; 0x153
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10466:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   1046a:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(MUX_B, GPIO_DIRECTION_OUT);
   1046e:	2102      	movs	r1, #2
   10470:	2054      	movs	r0, #84	; 0x54
   10472:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10474:	f894 3154 	ldrb.w	r3, [r4, #340]	; 0x154
	tmp &= ~PORT_PINCFG_PMUXEN;
   10478:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   1047c:	f884 3154 	strb.w	r3, [r4, #340]	; 0x154
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10480:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(MUX_C, GPIO_DIRECTION_OUT);
   10484:	2102      	movs	r1, #2
   10486:	2055      	movs	r0, #85	; 0x55
   10488:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
   1048c:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   1048e:	f894 3155 	ldrb.w	r3, [r4, #341]	; 0x155
	timer_init(&RTC_Scheduler, RTC, _rtc_get_timer());
   10492:	4d37      	ldr	r5, [pc, #220]	; (10570 <system_init+0x20c>)
	tmp &= ~PORT_PINCFG_PMUXEN;
   10494:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10498:	f884 3155 	strb.w	r3, [r4, #341]	; 0x155

	gpio_set_pin_function(MUX_C, GPIO_PIN_FUNCTION_OFF);

	ADC_0_init();
   1049c:	4b35      	ldr	r3, [pc, #212]	; (10574 <system_init+0x210>)
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_RTC;
   1049e:	4c36      	ldr	r4, [pc, #216]	; (10578 <system_init+0x214>)
   104a0:	4798      	blx	r3
	ADC_1_init();
   104a2:	4b36      	ldr	r3, [pc, #216]	; (1057c <system_init+0x218>)
   104a4:	4798      	blx	r3

	CRC_0_init();
   104a6:	4b36      	ldr	r3, [pc, #216]	; (10580 <system_init+0x21c>)
   104a8:	4798      	blx	r3

	EVENT_SYSTEM_0_init();
   104aa:	4b36      	ldr	r3, [pc, #216]	; (10584 <system_init+0x220>)
   104ac:	4798      	blx	r3

	FLASH_0_init();
   104ae:	4b36      	ldr	r3, [pc, #216]	; (10588 <system_init+0x224>)
   104b0:	4798      	blx	r3

	QSPI_INSTANCE_init();
   104b2:	4b36      	ldr	r3, [pc, #216]	; (1058c <system_init+0x228>)
   104b4:	4798      	blx	r3
   104b6:	6963      	ldr	r3, [r4, #20]
   104b8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   104bc:	6163      	str	r3, [r4, #20]
	timer_init(&RTC_Scheduler, RTC, _rtc_get_timer());
   104be:	4b34      	ldr	r3, [pc, #208]	; (10590 <system_init+0x22c>)
   104c0:	4798      	blx	r3
   104c2:	4934      	ldr	r1, [pc, #208]	; (10594 <system_init+0x230>)
   104c4:	4602      	mov	r2, r0
   104c6:	4834      	ldr	r0, [pc, #208]	; (10598 <system_init+0x234>)
   104c8:	47a8      	blx	r5

	RTC_Scheduler_init();
	USART_EAST_init();
   104ca:	4b34      	ldr	r3, [pc, #208]	; (1059c <system_init+0x238>)
   104cc:	4798      	blx	r3
	USART_NORTH_init();
   104ce:	4b34      	ldr	r3, [pc, #208]	; (105a0 <system_init+0x23c>)
   104d0:	4798      	blx	r3

	GRID_AUX_init();
   104d2:	4b34      	ldr	r3, [pc, #208]	; (105a4 <system_init+0x240>)
   104d4:	4798      	blx	r3

	UI_SPI_init();
   104d6:	4b34      	ldr	r3, [pc, #208]	; (105a8 <system_init+0x244>)
   104d8:	4798      	blx	r3
	USART_WEST_init();
   104da:	4b34      	ldr	r3, [pc, #208]	; (105ac <system_init+0x248>)
   104dc:	4798      	blx	r3

	SYS_I2C_init();
   104de:	4b34      	ldr	r3, [pc, #208]	; (105b0 <system_init+0x24c>)
   104e0:	4798      	blx	r3
	USART_SOUTH_init();
   104e2:	4b34      	ldr	r3, [pc, #208]	; (105b4 <system_init+0x250>)
   104e4:	4798      	blx	r3

	GRID_LED_init();
   104e6:	4b34      	ldr	r3, [pc, #208]	; (105b8 <system_init+0x254>)
   104e8:	4798      	blx	r3

	delay_driver_init();
   104ea:	4b34      	ldr	r3, [pc, #208]	; (105bc <system_init+0x258>)
   104ec:	4798      	blx	r3
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC0;
   104ee:	6963      	ldr	r3, [r4, #20]
   104f0:	433b      	orrs	r3, r7
   104f2:	4f33      	ldr	r7, [pc, #204]	; (105c0 <system_init+0x25c>)
   104f4:	6163      	str	r3, [r4, #20]
   104f6:	f04f 0840 	mov.w	r8, #64	; 0x40
   104fa:	f8c7 80a4 	str.w	r8, [r7, #164]	; 0xa4
	timer_init(&TIMER_0, TC0, _tc_get_timer());
   104fe:	47b0      	blx	r6
   10500:	4930      	ldr	r1, [pc, #192]	; (105c4 <system_init+0x260>)
   10502:	4602      	mov	r2, r0
   10504:	4830      	ldr	r0, [pc, #192]	; (105c8 <system_init+0x264>)
   10506:	47a8      	blx	r5
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC1;
   10508:	6963      	ldr	r3, [r4, #20]
   1050a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   1050e:	6163      	str	r3, [r4, #20]
   10510:	f8c7 80a4 	str.w	r8, [r7, #164]	; 0xa4
	timer_init(&TIMER_1, TC1, _tc_get_timer());
   10514:	47b0      	blx	r6
   10516:	492d      	ldr	r1, [pc, #180]	; (105cc <system_init+0x268>)
   10518:	4602      	mov	r2, r0
   1051a:	482d      	ldr	r0, [pc, #180]	; (105d0 <system_init+0x26c>)
   1051c:	47a8      	blx	r5
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_TC2;
   1051e:	69a3      	ldr	r3, [r4, #24]
   10520:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   10524:	61a3      	str	r3, [r4, #24]
   10526:	f8c7 80e8 	str.w	r8, [r7, #232]	; 0xe8
	timer_init(&TIMER_2, TC2, _tc_get_timer());
   1052a:	47b0      	blx	r6
   1052c:	4929      	ldr	r1, [pc, #164]	; (105d4 <system_init+0x270>)
   1052e:	4602      	mov	r2, r0
   10530:	4829      	ldr	r0, [pc, #164]	; (105d8 <system_init+0x274>)
   10532:	47a8      	blx	r5
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_TC3;
   10534:	69a3      	ldr	r3, [r4, #24]
   10536:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   1053a:	61a3      	str	r3, [r4, #24]
   1053c:	f8c7 80e8 	str.w	r8, [r7, #232]	; 0xe8
	timer_init(&TIMER_3, TC3, _tc_get_timer());
   10540:	47b0      	blx	r6
   10542:	4926      	ldr	r1, [pc, #152]	; (105dc <system_init+0x278>)
   10544:	4602      	mov	r2, r0
   10546:	4826      	ldr	r0, [pc, #152]	; (105e0 <system_init+0x27c>)
   10548:	47a8      	blx	r5

	TIMER_0_init();
	TIMER_1_init();
	TIMER_2_init();
	TIMER_3_init();
	RAND_0_init();
   1054a:	4b26      	ldr	r3, [pc, #152]	; (105e4 <system_init+0x280>)
   1054c:	4798      	blx	r3

	USB_DEVICE_INSTANCE_init();
   1054e:	4b26      	ldr	r3, [pc, #152]	; (105e8 <system_init+0x284>)
   10550:	4798      	blx	r3

	WDT_0_init();
}
   10552:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	WDT_0_init();
   10556:	4b25      	ldr	r3, [pc, #148]	; (105ec <system_init+0x288>)
   10558:	4718      	bx	r3
   1055a:	bf00      	nop
   1055c:	0000ddb1 	.word	0x0000ddb1
   10560:	41008000 	.word	0x41008000
   10564:	0000faa9 	.word	0x0000faa9
   10568:	0000faf9 	.word	0x0000faf9
   1056c:	00013a05 	.word	0x00013a05
   10570:	0000c9d5 	.word	0x0000c9d5
   10574:	0000fb39 	.word	0x0000fb39
   10578:	40000800 	.word	0x40000800
   1057c:	0000fbb9 	.word	0x0000fbb9
   10580:	0000fc3d 	.word	0x0000fc3d
   10584:	0000fc61 	.word	0x0000fc61
   10588:	0000fca1 	.word	0x0000fca1
   1058c:	0000fda5 	.word	0x0000fda5
   10590:	0000fa11 	.word	0x0000fa11
   10594:	40002400 	.word	0x40002400
   10598:	2001ccb8 	.word	0x2001ccb8
   1059c:	0000fe19 	.word	0x0000fe19
   105a0:	0000fe99 	.word	0x0000fe99
   105a4:	0000ff19 	.word	0x0000ff19
   105a8:	0000ffd1 	.word	0x0000ffd1
   105ac:	00010045 	.word	0x00010045
   105b0:	000100d5 	.word	0x000100d5
   105b4:	00010149 	.word	0x00010149
   105b8:	0001020d 	.word	0x0001020d
   105bc:	00010239 	.word	0x00010239
   105c0:	40001c00 	.word	0x40001c00
   105c4:	40003800 	.word	0x40003800
   105c8:	2001cfa4 	.word	0x2001cfa4
   105cc:	40003c00 	.word	0x40003c00
   105d0:	2001ce98 	.word	0x2001ce98
   105d4:	4101a000 	.word	0x4101a000
   105d8:	2001ccd8 	.word	0x2001ccd8
   105dc:	4101c000 	.word	0x4101c000
   105e0:	2001cf84 	.word	0x2001cf84
   105e4:	00010259 	.word	0x00010259
   105e8:	000102fd 	.word	0x000102fd
   105ec:	0001032d 	.word	0x0001032d

000105f0 <usart_transmission_complete>:
 */
static void usart_transmission_complete(struct _usart_async_device *device)
{
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
   105f0:	2300      	movs	r3, #0
   105f2:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.tx_done) {
   105f4:	69c3      	ldr	r3, [r0, #28]
   105f6:	b10b      	cbz	r3, 105fc <usart_transmission_complete+0xc>
		descr->usart_cb.tx_done(descr);
   105f8:	3808      	subs	r0, #8
   105fa:	4718      	bx	r3
	}
}
   105fc:	4770      	bx	lr

000105fe <usart_error>:
 */
static void usart_error(struct _usart_async_device *device)
{
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
   105fe:	2300      	movs	r3, #0
   10600:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.error) {
   10602:	6a43      	ldr	r3, [r0, #36]	; 0x24
   10604:	b10b      	cbz	r3, 1060a <usart_error+0xc>
		descr->usart_cb.error(descr);
   10606:	3808      	subs	r0, #8
   10608:	4718      	bx	r3
	}
}
   1060a:	4770      	bx	lr

0001060c <usart_fill_rx_buffer>:
{
   1060c:	b570      	push	{r4, r5, r6, lr}
   1060e:	4604      	mov	r4, r0
	ringbuffer_put(&descr->rx, data);
   10610:	4b05      	ldr	r3, [pc, #20]	; (10628 <usart_fill_rx_buffer+0x1c>)
   10612:	f1a0 0508 	sub.w	r5, r0, #8
   10616:	302c      	adds	r0, #44	; 0x2c
   10618:	4798      	blx	r3
	if (descr->usart_cb.rx_done) {
   1061a:	6a23      	ldr	r3, [r4, #32]
   1061c:	b11b      	cbz	r3, 10626 <usart_fill_rx_buffer+0x1a>
		descr->usart_cb.rx_done(descr);
   1061e:	4628      	mov	r0, r5
}
   10620:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		descr->usart_cb.rx_done(descr);
   10624:	4718      	bx	r3
}
   10626:	bd70      	pop	{r4, r5, r6, pc}
   10628:	00011aa1 	.word	0x00011aa1

0001062c <usart_async_write>:
{
   1062c:	b570      	push	{r4, r5, r6, lr}
   1062e:	460e      	mov	r6, r1
   10630:	4615      	mov	r5, r2
	ASSERT(descr && buf && length);
   10632:	4604      	mov	r4, r0
   10634:	b118      	cbz	r0, 1063e <usart_async_write+0x12>
   10636:	b1d9      	cbz	r1, 10670 <usart_async_write+0x44>
   10638:	1e10      	subs	r0, r2, #0
   1063a:	bf18      	it	ne
   1063c:	2001      	movne	r0, #1
   1063e:	4b0f      	ldr	r3, [pc, #60]	; (1067c <usart_async_write+0x50>)
   10640:	490f      	ldr	r1, [pc, #60]	; (10680 <usart_async_write+0x54>)
   10642:	f240 123b 	movw	r2, #315	; 0x13b
   10646:	4798      	blx	r3
	if (descr->tx_por != descr->tx_buffer_length) {
   10648:	f8b4 2044 	ldrh.w	r2, [r4, #68]	; 0x44
   1064c:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
   10650:	429a      	cmp	r2, r3
   10652:	d10f      	bne.n	10674 <usart_async_write+0x48>
	descr->tx_por           = 0;
   10654:	2300      	movs	r3, #0
   10656:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
	descr->stat             = USART_ASYNC_STATUS_BUSY;
   1065a:	2301      	movs	r3, #1
   1065c:	6323      	str	r3, [r4, #48]	; 0x30
	_usart_async_enable_byte_sent_irq(&descr->device);
   1065e:	f104 0008 	add.w	r0, r4, #8
   10662:	4b08      	ldr	r3, [pc, #32]	; (10684 <usart_async_write+0x58>)
	descr->tx_buffer        = (uint8_t *)buf;
   10664:	64a6      	str	r6, [r4, #72]	; 0x48
	descr->tx_buffer_length = length;
   10666:	f8a4 504c 	strh.w	r5, [r4, #76]	; 0x4c
	_usart_async_enable_byte_sent_irq(&descr->device);
   1066a:	4798      	blx	r3
	return (int32_t)length;
   1066c:	4628      	mov	r0, r5
}
   1066e:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && buf && length);
   10670:	4608      	mov	r0, r1
   10672:	e7e4      	b.n	1063e <usart_async_write+0x12>
		return ERR_NO_RESOURCE;
   10674:	f06f 001b 	mvn.w	r0, #27
   10678:	e7f9      	b.n	1066e <usart_async_write+0x42>
   1067a:	bf00      	nop
   1067c:	0000e03d 	.word	0x0000e03d
   10680:	00016550 	.word	0x00016550
   10684:	00011087 	.word	0x00011087

00010688 <usart_process_byte_sent>:
	if (descr->tx_por != descr->tx_buffer_length) {
   10688:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   1068a:	f8b0 2044 	ldrh.w	r2, [r0, #68]	; 0x44
   1068e:	429a      	cmp	r2, r3
{
   10690:	b510      	push	{r4, lr}
   10692:	4604      	mov	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
   10694:	d00a      	beq.n	106ac <usart_process_byte_sent+0x24>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
   10696:	6c02      	ldr	r2, [r0, #64]	; 0x40
   10698:	1c59      	adds	r1, r3, #1
   1069a:	8781      	strh	r1, [r0, #60]	; 0x3c
   1069c:	5cd1      	ldrb	r1, [r2, r3]
   1069e:	4b04      	ldr	r3, [pc, #16]	; (106b0 <usart_process_byte_sent+0x28>)
   106a0:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
   106a2:	4b04      	ldr	r3, [pc, #16]	; (106b4 <usart_process_byte_sent+0x2c>)
   106a4:	4620      	mov	r0, r4
}
   106a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_usart_async_enable_tx_done_irq(&descr->device);
   106aa:	4718      	bx	r3
   106ac:	4b02      	ldr	r3, [pc, #8]	; (106b8 <usart_process_byte_sent+0x30>)
   106ae:	e7fa      	b.n	106a6 <usart_process_byte_sent+0x1e>
   106b0:	0001105b 	.word	0x0001105b
   106b4:	00011087 	.word	0x00011087
   106b8:	0001108f 	.word	0x0001108f

000106bc <usart_async_read>:
{
   106bc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   106c0:	460e      	mov	r6, r1
   106c2:	4617      	mov	r7, r2
	ASSERT(descr && buf && length);
   106c4:	4604      	mov	r4, r0
   106c6:	b118      	cbz	r0, 106d0 <usart_async_read+0x14>
   106c8:	b1e9      	cbz	r1, 10706 <usart_async_read+0x4a>
   106ca:	1e10      	subs	r0, r2, #0
   106cc:	bf18      	it	ne
   106ce:	2001      	movne	r0, #1
   106d0:	4910      	ldr	r1, [pc, #64]	; (10714 <usart_async_read+0x58>)
   106d2:	4b11      	ldr	r3, [pc, #68]	; (10718 <usart_async_read+0x5c>)
		ringbuffer_get(&descr->rx, &buf[was_read++]);
   106d4:	f8df 9050 	ldr.w	r9, [pc, #80]	; 10728 <usart_async_read+0x6c>
	ASSERT(descr && buf && length);
   106d8:	f44f 72ac 	mov.w	r2, #344	; 0x158
   106dc:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
   106de:	3434      	adds	r4, #52	; 0x34
	CRITICAL_SECTION_ENTER()
   106e0:	4b0e      	ldr	r3, [pc, #56]	; (1071c <usart_async_read+0x60>)
   106e2:	a801      	add	r0, sp, #4
   106e4:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
   106e6:	4b0e      	ldr	r3, [pc, #56]	; (10720 <usart_async_read+0x64>)
   106e8:	4620      	mov	r0, r4
   106ea:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
   106ec:	4b0d      	ldr	r3, [pc, #52]	; (10724 <usart_async_read+0x68>)
	num = ringbuffer_num(&descr->rx);
   106ee:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
   106f0:	a801      	add	r0, sp, #4
   106f2:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
   106f4:	2500      	movs	r5, #0
   106f6:	45a8      	cmp	r8, r5
   106f8:	d001      	beq.n	106fe <usart_async_read+0x42>
   106fa:	42bd      	cmp	r5, r7
   106fc:	d105      	bne.n	1070a <usart_async_read+0x4e>
}
   106fe:	4628      	mov	r0, r5
   10700:	b003      	add	sp, #12
   10702:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	ASSERT(descr && buf && length);
   10706:	4608      	mov	r0, r1
   10708:	e7e2      	b.n	106d0 <usart_async_read+0x14>
		ringbuffer_get(&descr->rx, &buf[was_read++]);
   1070a:	1971      	adds	r1, r6, r5
   1070c:	4620      	mov	r0, r4
   1070e:	47c8      	blx	r9
   10710:	3501      	adds	r5, #1
   10712:	e7f0      	b.n	106f6 <usart_async_read+0x3a>
   10714:	00016550 	.word	0x00016550
   10718:	0000e03d 	.word	0x0000e03d
   1071c:	00011b09 	.word	0x00011b09
   10720:	00011ae5 	.word	0x00011ae5
   10724:	00011b17 	.word	0x00011b17
   10728:	00011a61 	.word	0x00011a61

0001072c <usart_async_init>:
{
   1072c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1072e:	460d      	mov	r5, r1
   10730:	4616      	mov	r6, r2
   10732:	461f      	mov	r7, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
   10734:	4604      	mov	r4, r0
   10736:	b120      	cbz	r0, 10742 <usart_async_init+0x16>
   10738:	b309      	cbz	r1, 1077e <usart_async_init+0x52>
   1073a:	b312      	cbz	r2, 10782 <usart_async_init+0x56>
   1073c:	1e18      	subs	r0, r3, #0
   1073e:	bf18      	it	ne
   10740:	2001      	movne	r0, #1
   10742:	4912      	ldr	r1, [pc, #72]	; (1078c <usart_async_init+0x60>)
   10744:	4b12      	ldr	r3, [pc, #72]	; (10790 <usart_async_init+0x64>)
   10746:	223a      	movs	r2, #58	; 0x3a
   10748:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
   1074a:	4b12      	ldr	r3, [pc, #72]	; (10794 <usart_async_init+0x68>)
   1074c:	463a      	mov	r2, r7
   1074e:	4631      	mov	r1, r6
   10750:	f104 0034 	add.w	r0, r4, #52	; 0x34
   10754:	4798      	blx	r3
   10756:	b9b0      	cbnz	r0, 10786 <usart_async_init+0x5a>
	init_status = _usart_async_init(&descr->device, hw);
   10758:	4b0f      	ldr	r3, [pc, #60]	; (10798 <usart_async_init+0x6c>)
   1075a:	4629      	mov	r1, r5
   1075c:	f104 0008 	add.w	r0, r4, #8
   10760:	4798      	blx	r3
	if (init_status) {
   10762:	b958      	cbnz	r0, 1077c <usart_async_init+0x50>
	descr->io.read  = usart_async_read;
   10764:	4b0d      	ldr	r3, [pc, #52]	; (1079c <usart_async_init+0x70>)
   10766:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_async_write;
   10768:	4b0d      	ldr	r3, [pc, #52]	; (107a0 <usart_async_init+0x74>)
   1076a:	6023      	str	r3, [r4, #0]
	descr->device.usart_cb.tx_byte_sent = usart_process_byte_sent;
   1076c:	4b0d      	ldr	r3, [pc, #52]	; (107a4 <usart_async_init+0x78>)
   1076e:	60a3      	str	r3, [r4, #8]
	descr->device.usart_cb.rx_done_cb   = usart_fill_rx_buffer;
   10770:	4b0d      	ldr	r3, [pc, #52]	; (107a8 <usart_async_init+0x7c>)
   10772:	60e3      	str	r3, [r4, #12]
	descr->device.usart_cb.tx_done_cb   = usart_transmission_complete;
   10774:	4b0d      	ldr	r3, [pc, #52]	; (107ac <usart_async_init+0x80>)
   10776:	6123      	str	r3, [r4, #16]
	descr->device.usart_cb.error_cb     = usart_error;
   10778:	4b0d      	ldr	r3, [pc, #52]	; (107b0 <usart_async_init+0x84>)
   1077a:	6163      	str	r3, [r4, #20]
}
   1077c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
   1077e:	4608      	mov	r0, r1
   10780:	e7df      	b.n	10742 <usart_async_init+0x16>
   10782:	4610      	mov	r0, r2
   10784:	e7dd      	b.n	10742 <usart_async_init+0x16>
		return ERR_INVALID_ARG;
   10786:	f06f 000c 	mvn.w	r0, #12
   1078a:	e7f7      	b.n	1077c <usart_async_init+0x50>
   1078c:	00016550 	.word	0x00016550
   10790:	0000e03d 	.word	0x0000e03d
   10794:	00011a25 	.word	0x00011a25
   10798:	00010f9d 	.word	0x00010f9d
   1079c:	000106bd 	.word	0x000106bd
   107a0:	0001062d 	.word	0x0001062d
   107a4:	00010689 	.word	0x00010689
   107a8:	0001060d 	.word	0x0001060d
   107ac:	000105f1 	.word	0x000105f1
   107b0:	000105ff 	.word	0x000105ff

000107b4 <usart_async_enable>:
{
   107b4:	b510      	push	{r4, lr}
	ASSERT(descr);
   107b6:	4604      	mov	r4, r0
   107b8:	3800      	subs	r0, #0
   107ba:	bf18      	it	ne
   107bc:	2001      	movne	r0, #1
   107be:	4905      	ldr	r1, [pc, #20]	; (107d4 <usart_async_enable+0x20>)
   107c0:	4b05      	ldr	r3, [pc, #20]	; (107d8 <usart_async_enable+0x24>)
   107c2:	2261      	movs	r2, #97	; 0x61
   107c4:	4798      	blx	r3
	_usart_async_enable(&descr->device);
   107c6:	f104 0008 	add.w	r0, r4, #8
   107ca:	4b04      	ldr	r3, [pc, #16]	; (107dc <usart_async_enable+0x28>)
   107cc:	4798      	blx	r3
}
   107ce:	2000      	movs	r0, #0
   107d0:	bd10      	pop	{r4, pc}
   107d2:	bf00      	nop
   107d4:	00016550 	.word	0x00016550
   107d8:	0000e03d 	.word	0x0000e03d
   107dc:	00011029 	.word	0x00011029

000107e0 <usart_async_disable>:
{
   107e0:	b510      	push	{r4, lr}
	ASSERT(descr);
   107e2:	4604      	mov	r4, r0
   107e4:	3800      	subs	r0, #0
   107e6:	bf18      	it	ne
   107e8:	2001      	movne	r0, #1
   107ea:	4905      	ldr	r1, [pc, #20]	; (10800 <usart_async_disable+0x20>)
   107ec:	4b05      	ldr	r3, [pc, #20]	; (10804 <usart_async_disable+0x24>)
   107ee:	226c      	movs	r2, #108	; 0x6c
   107f0:	4798      	blx	r3
	_usart_async_disable(&descr->device);
   107f2:	f104 0008 	add.w	r0, r4, #8
   107f6:	4b04      	ldr	r3, [pc, #16]	; (10808 <usart_async_disable+0x28>)
   107f8:	4798      	blx	r3
}
   107fa:	2000      	movs	r0, #0
   107fc:	bd10      	pop	{r4, pc}
   107fe:	bf00      	nop
   10800:	00016550 	.word	0x00016550
   10804:	0000e03d 	.word	0x0000e03d
   10808:	0001103d 	.word	0x0001103d

0001080c <usart_async_get_io_descriptor>:
{
   1080c:	b538      	push	{r3, r4, r5, lr}
   1080e:	460d      	mov	r5, r1
	ASSERT(descr && io);
   10810:	4604      	mov	r4, r0
   10812:	b110      	cbz	r0, 1081a <usart_async_get_io_descriptor+0xe>
   10814:	1e08      	subs	r0, r1, #0
   10816:	bf18      	it	ne
   10818:	2001      	movne	r0, #1
   1081a:	4903      	ldr	r1, [pc, #12]	; (10828 <usart_async_get_io_descriptor+0x1c>)
   1081c:	4b03      	ldr	r3, [pc, #12]	; (1082c <usart_async_get_io_descriptor+0x20>)
   1081e:	2277      	movs	r2, #119	; 0x77
   10820:	4798      	blx	r3
	*io = &descr->io;
   10822:	602c      	str	r4, [r5, #0]
}
   10824:	2000      	movs	r0, #0
   10826:	bd38      	pop	{r3, r4, r5, pc}
   10828:	00016550 	.word	0x00016550
   1082c:	0000e03d 	.word	0x0000e03d

00010830 <usart_async_register_callback>:
{
   10830:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
   10832:	4605      	mov	r5, r0
   10834:	3800      	subs	r0, #0
{
   10836:	460c      	mov	r4, r1
	ASSERT(descr);
   10838:	bf18      	it	ne
   1083a:	2001      	movne	r0, #1
   1083c:	4911      	ldr	r1, [pc, #68]	; (10884 <usart_async_register_callback+0x54>)
   1083e:	4b12      	ldr	r3, [pc, #72]	; (10888 <usart_async_register_callback+0x58>)
{
   10840:	4616      	mov	r6, r2
	ASSERT(descr);
   10842:	2283      	movs	r2, #131	; 0x83
   10844:	4798      	blx	r3
	switch (type) {
   10846:	2c01      	cmp	r4, #1
   10848:	d00d      	beq.n	10866 <usart_async_register_callback+0x36>
   1084a:	2c02      	cmp	r4, #2
   1084c:	d011      	beq.n	10872 <usart_async_register_callback+0x42>
   1084e:	b9b4      	cbnz	r4, 1087e <usart_async_register_callback+0x4e>
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
   10850:	1e32      	subs	r2, r6, #0
		descr->usart_cb.rx_done = cb;
   10852:	62ae      	str	r6, [r5, #40]	; 0x28
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
   10854:	bf18      	it	ne
   10856:	2201      	movne	r2, #1
   10858:	2101      	movs	r1, #1
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
   1085a:	f105 0008 	add.w	r0, r5, #8
   1085e:	4b0b      	ldr	r3, [pc, #44]	; (1088c <usart_async_register_callback+0x5c>)
   10860:	4798      	blx	r3
	return ERR_NONE;
   10862:	2000      	movs	r0, #0
}
   10864:	bd70      	pop	{r4, r5, r6, pc}
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
   10866:	1e32      	subs	r2, r6, #0
		descr->usart_cb.tx_done = cb;
   10868:	626e      	str	r6, [r5, #36]	; 0x24
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
   1086a:	bf18      	it	ne
   1086c:	2201      	movne	r2, #1
   1086e:	2102      	movs	r1, #2
   10870:	e7f3      	b.n	1085a <usart_async_register_callback+0x2a>
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
   10872:	1e32      	subs	r2, r6, #0
		descr->usart_cb.error = cb;
   10874:	62ee      	str	r6, [r5, #44]	; 0x2c
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
   10876:	bf18      	it	ne
   10878:	2201      	movne	r2, #1
   1087a:	2103      	movs	r1, #3
   1087c:	e7ed      	b.n	1085a <usart_async_register_callback+0x2a>
	switch (type) {
   1087e:	f06f 000c 	mvn.w	r0, #12
   10882:	e7ef      	b.n	10864 <usart_async_register_callback+0x34>
   10884:	00016550 	.word	0x00016550
   10888:	0000e03d 	.word	0x0000e03d
   1088c:	00011099 	.word	0x00011099

00010890 <usart_async_set_parity>:
{
   10890:	b538      	push	{r3, r4, r5, lr}
	ASSERT(descr);
   10892:	4604      	mov	r4, r0
   10894:	3800      	subs	r0, #0
   10896:	bf18      	it	ne
   10898:	2001      	movne	r0, #1
{
   1089a:	460d      	mov	r5, r1
	ASSERT(descr);
   1089c:	22cb      	movs	r2, #203	; 0xcb
   1089e:	4905      	ldr	r1, [pc, #20]	; (108b4 <usart_async_set_parity+0x24>)
   108a0:	4b05      	ldr	r3, [pc, #20]	; (108b8 <usart_async_set_parity+0x28>)
   108a2:	4798      	blx	r3
	_usart_async_set_parity(&descr->device, parity);
   108a4:	f104 0008 	add.w	r0, r4, #8
   108a8:	4b04      	ldr	r3, [pc, #16]	; (108bc <usart_async_set_parity+0x2c>)
   108aa:	4629      	mov	r1, r5
   108ac:	4798      	blx	r3
}
   108ae:	2000      	movs	r0, #0
   108b0:	bd38      	pop	{r3, r4, r5, pc}
   108b2:	bf00      	nop
   108b4:	00016550 	.word	0x00016550
   108b8:	0000e03d 	.word	0x0000e03d
   108bc:	00011049 	.word	0x00011049

000108c0 <hri_sercomi2cm_wait_for_sync>:
typedef uint8_t  hri_sercomusart_rxerrcnt_reg_t;
typedef uint8_t  hri_sercomusart_rxpl_reg_t;

static inline void hri_sercomi2cm_wait_for_sync(const void *const hw, hri_sercomi2cm_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
   108c0:	69c3      	ldr	r3, [r0, #28]
   108c2:	420b      	tst	r3, r1
   108c4:	d1fc      	bne.n	108c0 <hri_sercomi2cm_wait_for_sync>
	};
}
   108c6:	4770      	bx	lr

000108c8 <hri_sercomspi_wait_for_sync>:
	return ((Sercom *)hw)->I2CS.SYNCBUSY.reg & reg;
}

static inline void hri_sercomspi_wait_for_sync(const void *const hw, hri_sercomspi_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
   108c8:	69c3      	ldr	r3, [r0, #28]
   108ca:	420b      	tst	r3, r1
   108cc:	d1fc      	bne.n	108c8 <hri_sercomspi_wait_for_sync>
	};
}
   108ce:	4770      	bx	lr

000108d0 <hri_sercomusart_wait_for_sync>:
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
}

static inline void hri_sercomusart_wait_for_sync(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
   108d0:	69c3      	ldr	r3, [r0, #28]
   108d2:	420b      	tst	r3, r1
   108d4:	d1fc      	bne.n	108d0 <hri_sercomusart_wait_for_sync>
	};
}
   108d6:	4770      	bx	lr

000108d8 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomi2cm_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
   108d8:	6802      	ldr	r2, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   108da:	4b03      	ldr	r3, [pc, #12]	; (108e8 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
   108dc:	f022 0202 	bic.w	r2, r2, #2
   108e0:	6002      	str	r2, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   108e2:	2103      	movs	r1, #3
   108e4:	4718      	bx	r3
   108e6:	bf00      	nop
   108e8:	000108c1 	.word	0x000108c1

000108ec <hri_sercomspi_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomspi_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   108ec:	6802      	ldr	r2, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   108ee:	4b03      	ldr	r3, [pc, #12]	; (108fc <hri_sercomspi_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   108f0:	f022 0202 	bic.w	r2, r2, #2
   108f4:	6002      	str	r2, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   108f6:	2103      	movs	r1, #3
   108f8:	4718      	bx	r3
   108fa:	bf00      	nop
   108fc:	000108c9 	.word	0x000108c9

00010900 <hri_sercomusart_get_CTRLA_ENABLE_bit>:
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_sercomusart_get_CTRLA_ENABLE_bit(const void *const hw)
{
   10900:	b508      	push	{r3, lr}
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10902:	2103      	movs	r1, #3
   10904:	4b02      	ldr	r3, [pc, #8]	; (10910 <hri_sercomusart_get_CTRLA_ENABLE_bit+0x10>)
   10906:	4798      	blx	r3
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
   10908:	6800      	ldr	r0, [r0, #0]
	tmp = (tmp & SERCOM_USART_CTRLA_ENABLE) >> SERCOM_USART_CTRLA_ENABLE_Pos;
	return (bool)tmp;
}
   1090a:	f3c0 0040 	ubfx	r0, r0, #1, #1
   1090e:	bd08      	pop	{r3, pc}
   10910:	000108d1 	.word	0x000108d1

00010914 <hri_sercomusart_write_CTRLA_ENABLE_bit>:

static inline void hri_sercomusart_write_CTRLA_ENABLE_bit(const void *const hw, bool value)
{
	uint32_t tmp;
	SERCOM_CRITICAL_SECTION_ENTER();
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
   10914:	6803      	ldr	r3, [r0, #0]
	tmp &= ~SERCOM_USART_CTRLA_ENABLE;
   10916:	f023 0302 	bic.w	r3, r3, #2
	tmp |= value << SERCOM_USART_CTRLA_ENABLE_Pos;
   1091a:	ea43 0141 	orr.w	r1, r3, r1, lsl #1
	((Sercom *)hw)->USART.CTRLA.reg = tmp;
   1091e:	6001      	str	r1, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10920:	4b01      	ldr	r3, [pc, #4]	; (10928 <hri_sercomusart_write_CTRLA_ENABLE_bit+0x14>)
   10922:	2103      	movs	r1, #3
   10924:	4718      	bx	r3
   10926:	bf00      	nop
   10928:	000108d1 	.word	0x000108d1

0001092c <hri_sercomusart_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomusart_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
   1092c:	6802      	ldr	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   1092e:	4b03      	ldr	r3, [pc, #12]	; (1093c <hri_sercomusart_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
   10930:	f022 0202 	bic.w	r2, r2, #2
   10934:	6002      	str	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10936:	2103      	movs	r1, #3
   10938:	4718      	bx	r3
   1093a:	bf00      	nop
   1093c:	000108d1 	.word	0x000108d1

00010940 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
   10940:	b570      	push	{r4, r5, r6, lr}
	Sercom *const sercom_modules[] = SERCOM_INSTS;
   10942:	4d0c      	ldr	r5, [pc, #48]	; (10974 <_sercom_get_hardware_index+0x34>)
{
   10944:	4606      	mov	r6, r0
	Sercom *const sercom_modules[] = SERCOM_INSTS;
   10946:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
   10948:	b088      	sub	sp, #32
	Sercom *const sercom_modules[] = SERCOM_INSTS;
   1094a:	466c      	mov	r4, sp
   1094c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1094e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   10952:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   10956:	466a      	mov	r2, sp
   10958:	2300      	movs	r3, #0
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
   1095a:	f852 1b04 	ldr.w	r1, [r2], #4
   1095e:	42b1      	cmp	r1, r6
   10960:	d102      	bne.n	10968 <_sercom_get_hardware_index+0x28>
			return i;
   10962:	b2d8      	uxtb	r0, r3
		}
	}
	return 0;
}
   10964:	b008      	add	sp, #32
   10966:	bd70      	pop	{r4, r5, r6, pc}
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   10968:	3301      	adds	r3, #1
   1096a:	2b08      	cmp	r3, #8
   1096c:	d1f5      	bne.n	1095a <_sercom_get_hardware_index+0x1a>
	return 0;
   1096e:	2000      	movs	r0, #0
   10970:	e7f8      	b.n	10964 <_sercom_get_hardware_index+0x24>
   10972:	bf00      	nop
   10974:	00016588 	.word	0x00016588

00010978 <_sercom_usart_interrupt_handler>:
 * \internal Sercom interrupt handler
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _sercom_usart_interrupt_handler(struct _usart_async_device *device)
{
   10978:	b510      	push	{r4, lr}
	void *hw = device->hw;
   1097a:	6984      	ldr	r4, [r0, #24]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
   1097c:	7e22      	ldrb	r2, [r4, #24]

	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
   1097e:	07d1      	lsls	r1, r2, #31
{
   10980:	4603      	mov	r3, r0
	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
   10982:	d508      	bpl.n	10996 <_sercom_usart_interrupt_handler+0x1e>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
   10984:	7da2      	ldrb	r2, [r4, #22]
   10986:	07d2      	lsls	r2, r2, #31
   10988:	d505      	bpl.n	10996 <_sercom_usart_interrupt_handler+0x1e>
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
   1098a:	2201      	movs	r2, #1
   1098c:	7522      	strb	r2, [r4, #20]
		hri_sercomusart_clear_INTEN_DRE_bit(hw);
		device->usart_cb.tx_byte_sent(device);
   1098e:	6803      	ldr	r3, [r0, #0]
		hri_sercomusart_clear_interrupt_ERROR_bit(hw);
		device->usart_cb.error_cb(device);
		status = hri_sercomusart_read_STATUS_reg(hw);
		hri_sercomusart_clear_STATUS_reg(hw, status);
	}
}
   10990:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		device->usart_cb.tx_byte_sent(device);
   10994:	4718      	bx	r3
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
   10996:	7e22      	ldrb	r2, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
   10998:	0790      	lsls	r0, r2, #30
   1099a:	d509      	bpl.n	109b0 <_sercom_usart_interrupt_handler+0x38>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
   1099c:	7da2      	ldrb	r2, [r4, #22]
   1099e:	0791      	lsls	r1, r2, #30
   109a0:	d506      	bpl.n	109b0 <_sercom_usart_interrupt_handler+0x38>
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
   109a2:	2202      	movs	r2, #2
   109a4:	7522      	strb	r2, [r4, #20]
		device->usart_cb.tx_done_cb(device);
   109a6:	4618      	mov	r0, r3
}
   109a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		device->usart_cb.tx_done_cb(device);
   109ac:	689a      	ldr	r2, [r3, #8]
   109ae:	4710      	bx	r2
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
   109b0:	7e22      	ldrb	r2, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
   109b2:	0752      	lsls	r2, r2, #29
   109b4:	d50d      	bpl.n	109d2 <_sercom_usart_interrupt_handler+0x5a>
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
	return ((Sercom *)hw)->USART.STATUS.reg;
   109b6:	8b62      	ldrh	r2, [r4, #26]
		if (hri_sercomusart_read_STATUS_reg(hw)
   109b8:	f002 0237 	and.w	r2, r2, #55	; 0x37
   109bc:	b112      	cbz	r2, 109c4 <_sercom_usart_interrupt_handler+0x4c>
	((Sercom *)hw)->USART.STATUS.reg = mask;
   109be:	23ff      	movs	r3, #255	; 0xff
   109c0:	8363      	strh	r3, [r4, #26]
}
   109c2:	bd10      	pop	{r4, pc}
	return ((Sercom *)hw)->USART.DATA.reg;
   109c4:	6aa1      	ldr	r1, [r4, #40]	; 0x28
		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
   109c6:	685a      	ldr	r2, [r3, #4]
}
   109c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
   109cc:	b2c9      	uxtb	r1, r1
   109ce:	4618      	mov	r0, r3
   109d0:	4710      	bx	r2
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
   109d2:	7e22      	ldrb	r2, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
   109d4:	09d2      	lsrs	r2, r2, #7
   109d6:	d0f4      	beq.n	109c2 <_sercom_usart_interrupt_handler+0x4a>
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
   109d8:	2280      	movs	r2, #128	; 0x80
   109da:	7622      	strb	r2, [r4, #24]
		device->usart_cb.error_cb(device);
   109dc:	4618      	mov	r0, r3
   109de:	68da      	ldr	r2, [r3, #12]
   109e0:	4790      	blx	r2
	return ((Sercom *)hw)->USART.STATUS.reg;
   109e2:	8b63      	ldrh	r3, [r4, #26]
   109e4:	b29b      	uxth	r3, r3
   109e6:	e7eb      	b.n	109c0 <_sercom_usart_interrupt_handler+0x48>

000109e8 <_sercom_init_irq_param>:
 * \brief Init irq param with the given sercom hardware instance
 */
static void _sercom_init_irq_param(const void *const hw, void *dev)
{

	if (hw == SERCOM0) {
   109e8:	4b11      	ldr	r3, [pc, #68]	; (10a30 <_sercom_init_irq_param+0x48>)
   109ea:	4298      	cmp	r0, r3
   109ec:	d105      	bne.n	109fa <_sercom_init_irq_param+0x12>
		_sercom0_dev = (struct _usart_async_device *)dev;
   109ee:	4b11      	ldr	r3, [pc, #68]	; (10a34 <_sercom_init_irq_param+0x4c>)
   109f0:	6019      	str	r1, [r3, #0]

	if (hw == SERCOM5) {
		_sercom5_dev = (struct _i2c_m_async_device *)dev;
	}

	if (hw == SERCOM6) {
   109f2:	4b11      	ldr	r3, [pc, #68]	; (10a38 <_sercom_init_irq_param+0x50>)
   109f4:	4298      	cmp	r0, r3
   109f6:	d018      	beq.n	10a2a <_sercom_init_irq_param+0x42>
   109f8:	4770      	bx	lr
	if (hw == SERCOM1) {
   109fa:	4b10      	ldr	r3, [pc, #64]	; (10a3c <_sercom_init_irq_param+0x54>)
   109fc:	4298      	cmp	r0, r3
   109fe:	d00b      	beq.n	10a18 <_sercom_init_irq_param+0x30>
	if (hw == SERCOM3) {
   10a00:	4b0f      	ldr	r3, [pc, #60]	; (10a40 <_sercom_init_irq_param+0x58>)
   10a02:	4298      	cmp	r0, r3
   10a04:	d00b      	beq.n	10a1e <_sercom_init_irq_param+0x36>
	if (hw == SERCOM4) {
   10a06:	f1b0 4f86 	cmp.w	r0, #1124073472	; 0x43000000
   10a0a:	d00b      	beq.n	10a24 <_sercom_init_irq_param+0x3c>
	if (hw == SERCOM5) {
   10a0c:	4b0d      	ldr	r3, [pc, #52]	; (10a44 <_sercom_init_irq_param+0x5c>)
   10a0e:	4298      	cmp	r0, r3
   10a10:	d1ef      	bne.n	109f2 <_sercom_init_irq_param+0xa>
		_sercom5_dev = (struct _i2c_m_async_device *)dev;
   10a12:	4b08      	ldr	r3, [pc, #32]	; (10a34 <_sercom_init_irq_param+0x4c>)
   10a14:	6119      	str	r1, [r3, #16]
	if (hw == SERCOM6) {
   10a16:	4770      	bx	lr
		_sercom1_dev = (struct _usart_async_device *)dev;
   10a18:	4b06      	ldr	r3, [pc, #24]	; (10a34 <_sercom_init_irq_param+0x4c>)
   10a1a:	6059      	str	r1, [r3, #4]
	if (hw == SERCOM5) {
   10a1c:	e7e9      	b.n	109f2 <_sercom_init_irq_param+0xa>
		_sercom3_dev = (struct _spi_async_dev *)dev;
   10a1e:	4b05      	ldr	r3, [pc, #20]	; (10a34 <_sercom_init_irq_param+0x4c>)
   10a20:	6099      	str	r1, [r3, #8]
	if (hw == SERCOM6) {
   10a22:	4770      	bx	lr
		_sercom4_dev = (struct _usart_async_device *)dev;
   10a24:	4b03      	ldr	r3, [pc, #12]	; (10a34 <_sercom_init_irq_param+0x4c>)
   10a26:	60d9      	str	r1, [r3, #12]
	if (hw == SERCOM6) {
   10a28:	4770      	bx	lr
		_sercom6_dev = (struct _usart_async_device *)dev;
   10a2a:	4b02      	ldr	r3, [pc, #8]	; (10a34 <_sercom_init_irq_param+0x4c>)
   10a2c:	6159      	str	r1, [r3, #20]
	}
}
   10a2e:	4770      	bx	lr
   10a30:	40003000 	.word	0x40003000
   10a34:	20008d68 	.word	0x20008d68
   10a38:	43000800 	.word	0x43000800
   10a3c:	40003400 	.word	0x40003400
   10a40:	41014000 	.word	0x41014000
   10a44:	43000400 	.word	0x43000400

00010a48 <_sercom_get_irq_num>:

/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
   10a48:	b508      	push	{r3, lr}
	return SERCOM0_0_IRQn + (_sercom_get_hardware_index(hw) << 2);
   10a4a:	4b03      	ldr	r3, [pc, #12]	; (10a58 <_sercom_get_irq_num+0x10>)
   10a4c:	4798      	blx	r3
   10a4e:	0080      	lsls	r0, r0, #2
   10a50:	302e      	adds	r0, #46	; 0x2e
}
   10a52:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
   10a56:	bd08      	pop	{r3, pc}
   10a58:	00010941 	.word	0x00010941

00010a5c <_spi_sync_enable>:
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   10a5c:	69c2      	ldr	r2, [r0, #28]
 *
 * \return Enabling status
 */
static int32_t _spi_sync_enable(void *const hw)
{
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   10a5e:	f012 0201 	ands.w	r2, r2, #1
{
   10a62:	b508      	push	{r3, lr}
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   10a64:	d108      	bne.n	10a78 <_spi_sync_enable+0x1c>
	((Sercom *)hw)->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
   10a66:	6803      	ldr	r3, [r0, #0]
   10a68:	f043 0302 	orr.w	r3, r3, #2
   10a6c:	6003      	str	r3, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10a6e:	2103      	movs	r1, #3
   10a70:	4b03      	ldr	r3, [pc, #12]	; (10a80 <_spi_sync_enable+0x24>)
   10a72:	4798      	blx	r3
		return ERR_BUSY;
	}

	hri_sercomspi_set_CTRLA_ENABLE_bit(hw);

	return ERR_NONE;
   10a74:	4610      	mov	r0, r2
}
   10a76:	bd08      	pop	{r3, pc}
		return ERR_BUSY;
   10a78:	f06f 0003 	mvn.w	r0, #3
   10a7c:	e7fb      	b.n	10a76 <_spi_sync_enable+0x1a>
   10a7e:	bf00      	nop
   10a80:	000108c9 	.word	0x000108c9

00010a84 <_spi_get_regs>:
/** \brief Return the pointer to register settings of specific SERCOM
 *  \param[in] hw_addr The hardware register base address.
 *  \return Pointer to register settings of specific SERCOM.
 */
static inline const struct sercomspi_regs_cfg *_spi_get_regs(const uint32_t hw_addr)
{
   10a84:	b508      	push	{r3, lr}
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
   10a86:	4b08      	ldr	r3, [pc, #32]	; (10aa8 <_spi_get_regs+0x24>)
   10a88:	4798      	blx	r3
	uint8_t i;

	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
		if (sercomspi_regs[i].n == n) {
   10a8a:	2803      	cmp	r0, #3
   10a8c:	d007      	beq.n	10a9e <_spi_get_regs+0x1a>
   10a8e:	2807      	cmp	r0, #7
   10a90:	d107      	bne.n	10aa2 <_spi_get_regs+0x1e>
   10a92:	2301      	movs	r3, #1
			return &sercomspi_regs[i];
   10a94:	4805      	ldr	r0, [pc, #20]	; (10aac <_spi_get_regs+0x28>)
   10a96:	eb00 1003 	add.w	r0, r0, r3, lsl #4
   10a9a:	4418      	add	r0, r3
		}
	}

	return NULL;
}
   10a9c:	bd08      	pop	{r3, pc}
		if (sercomspi_regs[i].n == n) {
   10a9e:	2300      	movs	r3, #0
   10aa0:	e7f8      	b.n	10a94 <_spi_get_regs+0x10>
	return NULL;
   10aa2:	2000      	movs	r0, #0
   10aa4:	e7fa      	b.n	10a9c <_spi_get_regs+0x18>
   10aa6:	bf00      	nop
   10aa8:	00010941 	.word	0x00010941
   10aac:	000165a8 	.word	0x000165a8

00010ab0 <_spi_dma_tx_complete>:
 */
static void _spi_dma_tx_complete(struct _dma_resource *resource)
{
	struct _spi_m_dma_dev *dev = (struct _spi_m_dma_dev *)resource->back;

	if (dev->callbacks.tx) {
   10ab0:	6883      	ldr	r3, [r0, #8]
   10ab2:	685b      	ldr	r3, [r3, #4]
   10ab4:	b103      	cbz	r3, 10ab8 <_spi_dma_tx_complete+0x8>
		dev->callbacks.tx(resource);
   10ab6:	4718      	bx	r3
	}
}
   10ab8:	4770      	bx	lr

00010aba <_spi_dma_error_occured>:
 */
static void _spi_dma_error_occured(struct _dma_resource *resource)
{
	struct _spi_m_dma_dev *dev = (struct _spi_m_dma_dev *)resource->back;

	if (dev->callbacks.error) {
   10aba:	6883      	ldr	r3, [r0, #8]
   10abc:	68db      	ldr	r3, [r3, #12]
   10abe:	b103      	cbz	r3, 10ac2 <_spi_dma_error_occured+0x8>
		dev->callbacks.error(resource);
   10ac0:	4718      	bx	r3
	}
}
   10ac2:	4770      	bx	lr

00010ac4 <__NVIC_EnableIRQ>:
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10ac4:	0942      	lsrs	r2, r0, #5
   10ac6:	2301      	movs	r3, #1
   10ac8:	f000 001f 	and.w	r0, r0, #31
   10acc:	fa03 f000 	lsl.w	r0, r3, r0
   10ad0:	4b01      	ldr	r3, [pc, #4]	; (10ad8 <__NVIC_EnableIRQ+0x14>)
   10ad2:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
}
   10ad6:	4770      	bx	lr
   10ad8:	e000e100 	.word	0xe000e100

00010adc <_spi_async_enable>:
{
   10adc:	b538      	push	{r3, r4, r5, lr}
   10ade:	4604      	mov	r4, r0
	_spi_sync_enable(hw);
   10ae0:	4b07      	ldr	r3, [pc, #28]	; (10b00 <_spi_async_enable+0x24>)
		NVIC_EnableIRQ((IRQn_Type)irq++);
   10ae2:	4d08      	ldr	r5, [pc, #32]	; (10b04 <_spi_async_enable+0x28>)
	_spi_sync_enable(hw);
   10ae4:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
   10ae6:	4620      	mov	r0, r4
   10ae8:	4b07      	ldr	r3, [pc, #28]	; (10b08 <_spi_async_enable+0x2c>)
   10aea:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   10aec:	2100      	movs	r1, #0
	uint8_t irq = _sercom_get_irq_num(hw);
   10aee:	4604      	mov	r4, r0
		NVIC_EnableIRQ((IRQn_Type)irq++);
   10af0:	1860      	adds	r0, r4, r1
   10af2:	b2c0      	uxtb	r0, r0
   10af4:	47a8      	blx	r5
	for (uint32_t i = 0; i < 4; i++) {
   10af6:	3101      	adds	r1, #1
   10af8:	2904      	cmp	r1, #4
   10afa:	d1f9      	bne.n	10af0 <_spi_async_enable+0x14>
}
   10afc:	2000      	movs	r0, #0
   10afe:	bd38      	pop	{r3, r4, r5, pc}
   10b00:	00010a5d 	.word	0x00010a5d
   10b04:	00010ac5 	.word	0x00010ac5
   10b08:	00010a49 	.word	0x00010a49

00010b0c <__NVIC_DisableIRQ>:
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10b0c:	0943      	lsrs	r3, r0, #5
   10b0e:	2201      	movs	r2, #1
   10b10:	f000 001f 	and.w	r0, r0, #31
   10b14:	fa02 f000 	lsl.w	r0, r2, r0
   10b18:	3320      	adds	r3, #32
   10b1a:	4a04      	ldr	r2, [pc, #16]	; (10b2c <__NVIC_DisableIRQ+0x20>)
   10b1c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   10b20:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   10b24:	f3bf 8f6f 	isb	sy
}
   10b28:	4770      	bx	lr
   10b2a:	bf00      	nop
   10b2c:	e000e100 	.word	0xe000e100

00010b30 <__NVIC_ClearPendingIRQ>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10b30:	0943      	lsrs	r3, r0, #5
   10b32:	2201      	movs	r2, #1
   10b34:	f000 001f 	and.w	r0, r0, #31
   10b38:	fa02 f000 	lsl.w	r0, r2, r0
   10b3c:	3360      	adds	r3, #96	; 0x60
   10b3e:	4a02      	ldr	r2, [pc, #8]	; (10b48 <__NVIC_ClearPendingIRQ+0x18>)
   10b40:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   10b44:	4770      	bx	lr
   10b46:	bf00      	nop
   10b48:	e000e100 	.word	0xe000e100

00010b4c <_get_i2cm_index>:
{
   10b4c:	b508      	push	{r3, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
   10b4e:	4b07      	ldr	r3, [pc, #28]	; (10b6c <_get_i2cm_index+0x20>)
   10b50:	4798      	blx	r3
		if (_i2cms[i].number == sercom_offset) {
   10b52:	2805      	cmp	r0, #5
   10b54:	d008      	beq.n	10b68 <_get_i2cm_index+0x1c>
	ASSERT(false);
   10b56:	2000      	movs	r0, #0
   10b58:	4905      	ldr	r1, [pc, #20]	; (10b70 <_get_i2cm_index+0x24>)
   10b5a:	4b06      	ldr	r3, [pc, #24]	; (10b74 <_get_i2cm_index+0x28>)
   10b5c:	f240 32ed 	movw	r2, #1005	; 0x3ed
   10b60:	4798      	blx	r3
   10b62:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   10b66:	bd08      	pop	{r3, pc}
			return i;
   10b68:	2000      	movs	r0, #0
   10b6a:	e7fc      	b.n	10b66 <_get_i2cm_index+0x1a>
   10b6c:	00010941 	.word	0x00010941
   10b70:	0001656d 	.word	0x0001656d
   10b74:	0000e03d 	.word	0x0000e03d

00010b78 <_sercom_i2c_send_stop>:
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
   10b78:	6842      	ldr	r2, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10b7a:	4b03      	ldr	r3, [pc, #12]	; (10b88 <_sercom_i2c_send_stop+0x10>)
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
   10b7c:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
   10b80:	6042      	str	r2, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10b82:	2104      	movs	r1, #4
   10b84:	4718      	bx	r3
   10b86:	bf00      	nop
   10b88:	000108c1 	.word	0x000108c1

00010b8c <_sercom_i2c_sync_analyse_flags>:
{
   10b8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10b90:	460e      	mov	r6, r1
   10b92:	4614      	mov	r4, r2
	((Sercom *)hw)->I2CM.STATUS.reg |= mask;
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10b94:	2104      	movs	r1, #4
   10b96:	4a56      	ldr	r2, [pc, #344]	; (10cf0 <_sercom_i2c_sync_analyse_flags+0x164>)
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
   10b98:	f8d0 8000 	ldr.w	r8, [r0]
   10b9c:	4605      	mov	r5, r0
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10b9e:	4790      	blx	r2
	return ((Sercom *)hw)->I2CM.STATUS.reg;
   10ba0:	8b43      	ldrh	r3, [r0, #26]
	if (flags & MB_FLAG) {
   10ba2:	f016 0f01 	tst.w	r6, #1
   10ba6:	b29b      	uxth	r3, r3
   10ba8:	4617      	mov	r7, r2
   10baa:	d064      	beq.n	10c76 <_sercom_i2c_sync_analyse_flags+0xea>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
   10bac:	079f      	lsls	r7, r3, #30
   10bae:	d516      	bpl.n	10bde <_sercom_i2c_sync_analyse_flags+0x52>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
   10bb0:	2201      	movs	r2, #1
   10bb2:	7602      	strb	r2, [r0, #24]
			msg->flags |= I2C_M_FAIL;
   10bb4:	8862      	ldrh	r2, [r4, #2]
   10bb6:	b292      	uxth	r2, r2
   10bb8:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
   10bbc:	8062      	strh	r2, [r4, #2]
			msg->flags &= ~I2C_M_BUSY;
   10bbe:	8862      	ldrh	r2, [r4, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10bc0:	f003 0601 	and.w	r6, r3, #1
			msg->flags &= ~I2C_M_BUSY;
   10bc4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   10bc8:	0412      	lsls	r2, r2, #16
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10bca:	f1c6 26ff 	rsb	r6, r6, #4278255360	; 0xff00ff00
			msg->flags &= ~I2C_M_BUSY;
   10bce:	0c12      	lsrs	r2, r2, #16
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10bd0:	f506 067f 	add.w	r6, r6, #16711680	; 0xff0000
			msg->flags &= ~I2C_M_BUSY;
   10bd4:	8062      	strh	r2, [r4, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10bd6:	36fc      	adds	r6, #252	; 0xfc
}
   10bd8:	4630      	mov	r0, r6
   10bda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
   10bde:	f013 0604 	ands.w	r6, r3, #4
   10be2:	d015      	beq.n	10c10 <_sercom_i2c_sync_analyse_flags+0x84>
				if (msg->len > 0) {
   10be4:	6863      	ldr	r3, [r4, #4]
   10be6:	2b00      	cmp	r3, #0
					msg->flags |= I2C_M_FAIL;
   10be8:	bfc1      	itttt	gt
   10bea:	8863      	ldrhgt	r3, [r4, #2]
   10bec:	b29b      	uxthgt	r3, r3
   10bee:	f443 5380 	orrgt.w	r3, r3, #4096	; 0x1000
   10bf2:	8063      	strhgt	r3, [r4, #2]
				if (msg->flags & I2C_M_STOP) {
   10bf4:	8863      	ldrh	r3, [r4, #2]
   10bf6:	041e      	lsls	r6, r3, #16
   10bf8:	d501      	bpl.n	10bfe <_sercom_i2c_sync_analyse_flags+0x72>
					_sercom_i2c_send_stop(hw);
   10bfa:	4b3e      	ldr	r3, [pc, #248]	; (10cf4 <_sercom_i2c_sync_analyse_flags+0x168>)
   10bfc:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
   10bfe:	8863      	ldrh	r3, [r4, #2]
   10c00:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   10c04:	041b      	lsls	r3, r3, #16
   10c06:	0c1b      	lsrs	r3, r3, #16
   10c08:	8063      	strh	r3, [r4, #2]
			return I2C_NACK;
   10c0a:	f06f 0601 	mvn.w	r6, #1
   10c0e:	e7e3      	b.n	10bd8 <_sercom_i2c_sync_analyse_flags+0x4c>
			if (msg->flags & I2C_M_TEN) {
   10c10:	8863      	ldrh	r3, [r4, #2]
   10c12:	f413 6780 	ands.w	r7, r3, #1024	; 0x400
   10c16:	d015      	beq.n	10c44 <_sercom_i2c_sync_analyse_flags+0xb8>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
   10c18:	8823      	ldrh	r3, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10c1a:	2104      	movs	r1, #4
   10c1c:	09db      	lsrs	r3, r3, #7
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
   10c1e:	f003 0706 	and.w	r7, r3, #6
   10c22:	4790      	blx	r2
	return ((Sercom *)hw)->I2CM.ADDR.reg;
   10c24:	6a43      	ldr	r3, [r0, #36]	; 0x24
   10c26:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
   10c2a:	433b      	orrs	r3, r7
				hri_sercomi2cm_write_ADDR_reg(hw,
   10c2c:	f043 03f1 	orr.w	r3, r3, #241	; 0xf1
	((Sercom *)hw)->I2CM.ADDR.reg = data;
   10c30:	6243      	str	r3, [r0, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10c32:	2104      	movs	r1, #4
   10c34:	4790      	blx	r2
				msg->flags &= ~I2C_M_TEN;
   10c36:	8863      	ldrh	r3, [r4, #2]
   10c38:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
				msg->flags &= ~I2C_M_BUSY;
   10c3c:	041b      	lsls	r3, r3, #16
   10c3e:	0c1b      	lsrs	r3, r3, #16
   10c40:	8063      	strh	r3, [r4, #2]
   10c42:	e7c9      	b.n	10bd8 <_sercom_i2c_sync_analyse_flags+0x4c>
			if (msg->len == 0) {
   10c44:	6866      	ldr	r6, [r4, #4]
   10c46:	b94e      	cbnz	r6, 10c5c <_sercom_i2c_sync_analyse_flags+0xd0>
				if (msg->flags & I2C_M_STOP) {
   10c48:	8863      	ldrh	r3, [r4, #2]
   10c4a:	0418      	lsls	r0, r3, #16
   10c4c:	d502      	bpl.n	10c54 <_sercom_i2c_sync_analyse_flags+0xc8>
					_sercom_i2c_send_stop(hw);
   10c4e:	4b29      	ldr	r3, [pc, #164]	; (10cf4 <_sercom_i2c_sync_analyse_flags+0x168>)
   10c50:	4628      	mov	r0, r5
   10c52:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
   10c54:	8863      	ldrh	r3, [r4, #2]
   10c56:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   10c5a:	e7ef      	b.n	10c3c <_sercom_i2c_sync_analyse_flags+0xb0>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
   10c5c:	68a3      	ldr	r3, [r4, #8]
   10c5e:	781b      	ldrb	r3, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
   10c60:	6283      	str	r3, [r0, #40]	; 0x28
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10c62:	2104      	movs	r1, #4
   10c64:	4790      	blx	r2
				msg->buffer++;
   10c66:	68a3      	ldr	r3, [r4, #8]
   10c68:	3301      	adds	r3, #1
   10c6a:	60a3      	str	r3, [r4, #8]
				msg->len--;
   10c6c:	6863      	ldr	r3, [r4, #4]
   10c6e:	3b01      	subs	r3, #1
   10c70:	6063      	str	r3, [r4, #4]
	return I2C_OK;
   10c72:	2600      	movs	r6, #0
}
   10c74:	e7b0      	b.n	10bd8 <_sercom_i2c_sync_analyse_flags+0x4c>
	} else if (flags & SB_FLAG) {
   10c76:	f016 0602 	ands.w	r6, r6, #2
   10c7a:	d0ad      	beq.n	10bd8 <_sercom_i2c_sync_analyse_flags+0x4c>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
   10c7c:	6862      	ldr	r2, [r4, #4]
   10c7e:	2a00      	cmp	r2, #0
   10c80:	d032      	beq.n	10ce8 <_sercom_i2c_sync_analyse_flags+0x15c>
   10c82:	0759      	lsls	r1, r3, #29
   10c84:	d430      	bmi.n	10ce8 <_sercom_i2c_sync_analyse_flags+0x15c>
			msg->len--;
   10c86:	3a01      	subs	r2, #1
   10c88:	f3c8 61c0 	ubfx	r1, r8, #27, #1
   10c8c:	6062      	str	r2, [r4, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
   10c8e:	b99a      	cbnz	r2, 10cb8 <_sercom_i2c_sync_analyse_flags+0x12c>
   10c90:	b1a9      	cbz	r1, 10cbe <_sercom_i2c_sync_analyse_flags+0x132>
				if (msg->flags & I2C_M_STOP) {
   10c92:	8863      	ldrh	r3, [r4, #2]
   10c94:	041b      	lsls	r3, r3, #16
   10c96:	d508      	bpl.n	10caa <_sercom_i2c_sync_analyse_flags+0x11e>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
   10c98:	686b      	ldr	r3, [r5, #4]
   10c9a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   10c9e:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10ca0:	2104      	movs	r1, #4
   10ca2:	4628      	mov	r0, r5
   10ca4:	47b8      	blx	r7
					_sercom_i2c_send_stop(hw);
   10ca6:	4b13      	ldr	r3, [pc, #76]	; (10cf4 <_sercom_i2c_sync_analyse_flags+0x168>)
   10ca8:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
   10caa:	8863      	ldrh	r3, [r4, #2]
   10cac:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   10cb0:	041b      	lsls	r3, r3, #16
   10cb2:	0c1b      	lsrs	r3, r3, #16
   10cb4:	8063      	strh	r3, [r4, #2]
   10cb6:	e00c      	b.n	10cd2 <_sercom_i2c_sync_analyse_flags+0x146>
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
   10cb8:	2a01      	cmp	r2, #1
   10cba:	d10a      	bne.n	10cd2 <_sercom_i2c_sync_analyse_flags+0x146>
   10cbc:	b149      	cbz	r1, 10cd2 <_sercom_i2c_sync_analyse_flags+0x146>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
   10cbe:	686b      	ldr	r3, [r5, #4]
   10cc0:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   10cc4:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10cc6:	2104      	movs	r1, #4
   10cc8:	4628      	mov	r0, r5
   10cca:	47b8      	blx	r7
			if (msg->len == 0) {
   10ccc:	6863      	ldr	r3, [r4, #4]
   10cce:	2b00      	cmp	r3, #0
   10cd0:	d0df      	beq.n	10c92 <_sercom_i2c_sync_analyse_flags+0x106>
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10cd2:	2104      	movs	r1, #4
   10cd4:	4628      	mov	r0, r5
   10cd6:	47b8      	blx	r7
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
   10cd8:	68a3      	ldr	r3, [r4, #8]
	return ((Sercom *)hw)->I2CM.DATA.reg;
   10cda:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   10cdc:	1c59      	adds	r1, r3, #1
   10cde:	60a1      	str	r1, [r4, #8]
   10ce0:	701a      	strb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
   10ce2:	2302      	movs	r3, #2
   10ce4:	762b      	strb	r3, [r5, #24]
   10ce6:	e7c4      	b.n	10c72 <_sercom_i2c_sync_analyse_flags+0xe6>
   10ce8:	2302      	movs	r3, #2
   10cea:	762b      	strb	r3, [r5, #24]
   10cec:	e78d      	b.n	10c0a <_sercom_i2c_sync_analyse_flags+0x7e>
   10cee:	bf00      	nop
   10cf0:	000108c1 	.word	0x000108c1
   10cf4:	00010b79 	.word	0x00010b79

00010cf8 <_usart_set_parity>:
{
   10cf8:	b573      	push	{r0, r1, r4, r5, r6, lr}
	bool enabled = hri_sercomusart_get_CTRLA_ENABLE_bit(hw);
   10cfa:	4b16      	ldr	r3, [pc, #88]	; (10d54 <_usart_set_parity+0x5c>)
{
   10cfc:	4604      	mov	r4, r0
   10cfe:	460d      	mov	r5, r1
	bool enabled = hri_sercomusart_get_CTRLA_ENABLE_bit(hw);
   10d00:	4798      	blx	r3
	hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
   10d02:	4b15      	ldr	r3, [pc, #84]	; (10d58 <_usart_set_parity+0x60>)
	bool enabled = hri_sercomusart_get_CTRLA_ENABLE_bit(hw);
   10d04:	4606      	mov	r6, r0
	hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
   10d06:	4620      	mov	r0, r4
   10d08:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
   10d0a:	4b14      	ldr	r3, [pc, #80]	; (10d5c <_usart_set_parity+0x64>)
   10d0c:	a801      	add	r0, sp, #4
   10d0e:	4798      	blx	r3
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
   10d10:	4a13      	ldr	r2, [pc, #76]	; (10d60 <_usart_set_parity+0x68>)
   10d12:	4620      	mov	r0, r4
   10d14:	2102      	movs	r1, #2
   10d16:	4790      	blx	r2
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_FORM(mask);
   10d18:	6823      	ldr	r3, [r4, #0]
	if (USART_PARITY_NONE != parity) {
   10d1a:	2d02      	cmp	r5, #2
   10d1c:	bf14      	ite	ne
   10d1e:	f043 7380 	orrne.w	r3, r3, #16777216	; 0x1000000
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_FORM(mask);
   10d22:	f023 7380 	biceq.w	r3, r3, #16777216	; 0x1000000
   10d26:	6023      	str	r3, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   10d28:	211f      	movs	r1, #31
   10d2a:	4790      	blx	r2
	tmp = ((Sercom *)hw)->USART.CTRLB.reg;
   10d2c:	6863      	ldr	r3, [r4, #4]
	hri_sercomusart_write_CTRLB_PMODE_bit(hw, parity);
   10d2e:	3d00      	subs	r5, #0
   10d30:	bf18      	it	ne
   10d32:	2501      	movne	r5, #1
	tmp &= ~SERCOM_USART_CTRLB_PMODE;
   10d34:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
	tmp |= value << SERCOM_USART_CTRLB_PMODE_Pos;
   10d38:	ea43 3545 	orr.w	r5, r3, r5, lsl #13
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   10d3c:	211f      	movs	r1, #31
	((Sercom *)hw)->USART.CTRLB.reg = tmp;
   10d3e:	6065      	str	r5, [r4, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   10d40:	4790      	blx	r2
	CRITICAL_SECTION_LEAVE()
   10d42:	a801      	add	r0, sp, #4
   10d44:	4b07      	ldr	r3, [pc, #28]	; (10d64 <_usart_set_parity+0x6c>)
   10d46:	4798      	blx	r3
	hri_sercomusart_write_CTRLA_ENABLE_bit(hw, enabled);
   10d48:	4b07      	ldr	r3, [pc, #28]	; (10d68 <_usart_set_parity+0x70>)
   10d4a:	4631      	mov	r1, r6
   10d4c:	4620      	mov	r0, r4
   10d4e:	4798      	blx	r3
}
   10d50:	b002      	add	sp, #8
   10d52:	bd70      	pop	{r4, r5, r6, pc}
   10d54:	00010901 	.word	0x00010901
   10d58:	0001092d 	.word	0x0001092d
   10d5c:	00011b09 	.word	0x00011b09
   10d60:	000108d1 	.word	0x000108d1
   10d64:	00011b17 	.word	0x00011b17
   10d68:	00010915 	.word	0x00010915

00010d6c <_spi_set_mode>:
{
   10d6c:	b570      	push	{r4, r5, r6, lr}
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   10d6e:	69c4      	ldr	r4, [r0, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE)) {
   10d70:	f014 0403 	ands.w	r4, r4, #3
{
   10d74:	460a      	mov	r2, r1
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE)) {
   10d76:	d10e      	bne.n	10d96 <_spi_set_mode+0x2a>
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10d78:	4e08      	ldr	r6, [pc, #32]	; (10d9c <_spi_set_mode+0x30>)
   10d7a:	2103      	movs	r1, #3
   10d7c:	47b0      	blx	r6
	return ((Sercom *)hw)->SPI.CTRLA.reg;
   10d7e:	6803      	ldr	r3, [r0, #0]
	ctrla |= (mode & 0x3u) << SERCOM_SPI_CTRLA_CPHA_Pos;
   10d80:	0712      	lsls	r2, r2, #28
	ctrla &= ~(SERCOM_SPI_CTRLA_CPOL | SERCOM_SPI_CTRLA_CPHA);
   10d82:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
	ctrla |= (mode & 0x3u) << SERCOM_SPI_CTRLA_CPHA_Pos;
   10d86:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
   10d8a:	431a      	orrs	r2, r3
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   10d8c:	6002      	str	r2, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10d8e:	2103      	movs	r1, #3
   10d90:	47b0      	blx	r6
	return ERR_NONE;
   10d92:	4620      	mov	r0, r4
}
   10d94:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_BUSY;
   10d96:	f06f 0003 	mvn.w	r0, #3
   10d9a:	e7fb      	b.n	10d94 <_spi_set_mode+0x28>
   10d9c:	000108c9 	.word	0x000108c9

00010da0 <_spi_load_regs_master>:
{
   10da0:	b538      	push	{r3, r4, r5, lr}
   10da2:	460d      	mov	r5, r1
	ASSERT(hw && regs);
   10da4:	4604      	mov	r4, r0
   10da6:	b110      	cbz	r0, 10dae <_spi_load_regs_master+0xe>
   10da8:	1e08      	subs	r0, r1, #0
   10daa:	bf18      	it	ne
   10dac:	2001      	movne	r0, #1
   10dae:	490f      	ldr	r1, [pc, #60]	; (10dec <_spi_load_regs_master+0x4c>)
   10db0:	4b0f      	ldr	r3, [pc, #60]	; (10df0 <_spi_load_regs_master+0x50>)
   10db2:	f640 127a 	movw	r2, #2426	; 0x97a
   10db6:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
   10db8:	682b      	ldr	r3, [r5, #0]
   10dba:	4a0e      	ldr	r2, [pc, #56]	; (10df4 <_spi_load_regs_master+0x54>)
	hri_sercomspi_write_CTRLA_reg(
   10dbc:	f423 7381 	bic.w	r3, r3, #258	; 0x102
   10dc0:	f023 0301 	bic.w	r3, r3, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   10dc4:	6023      	str	r3, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10dc6:	2103      	movs	r1, #3
   10dc8:	4620      	mov	r0, r4
   10dca:	4790      	blx	r2
	    (regs->ctrlb
   10dcc:	686b      	ldr	r3, [r5, #4]
	        | (SERCOM_SPI_CTRLB_RXEN));
   10dce:	f423 3338 	bic.w	r3, r3, #188416	; 0x2e000
   10dd2:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(
   10dd6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	((Sercom *)hw)->SPI.CTRLB.reg = data;
   10dda:	6063      	str	r3, [r4, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   10ddc:	2117      	movs	r1, #23
   10dde:	4790      	blx	r2
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
   10de0:	7b2b      	ldrb	r3, [r5, #12]
	((Sercom *)hw)->SPI.BAUD.reg = data;
   10de2:	7323      	strb	r3, [r4, #12]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
   10de4:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
   10de6:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
}
   10dea:	bd38      	pop	{r3, r4, r5, pc}
   10dec:	0001656d 	.word	0x0001656d
   10df0:	0000e03d 	.word	0x0000e03d
   10df4:	000108c9 	.word	0x000108c9

00010df8 <_i2c_m_sync_init_impl>:
{
   10df8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10dfc:	460c      	mov	r4, r1
	uint8_t i = _get_i2cm_index(hw);
   10dfe:	4b23      	ldr	r3, [pc, #140]	; (10e8c <_i2c_m_sync_init_impl+0x94>)
   10e00:	f8df 9094 	ldr.w	r9, [pc, #148]	; 10e98 <_i2c_m_sync_init_impl+0xa0>
   10e04:	4d22      	ldr	r5, [pc, #136]	; (10e90 <_i2c_m_sync_init_impl+0x98>)
{
   10e06:	4607      	mov	r7, r0
	uint8_t i = _get_i2cm_index(hw);
   10e08:	4608      	mov	r0, r1
   10e0a:	4798      	blx	r3
	return ((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg;
   10e0c:	69e3      	ldr	r3, [r4, #28]
	if (!hri_sercomi2cm_is_syncing(hw, SERCOM_I2CM_SYNCBUSY_SWRST)) {
   10e0e:	f013 0f01 	tst.w	r3, #1
   10e12:	fa5f f880 	uxtb.w	r8, r0
   10e16:	d115      	bne.n	10e44 <_i2c_m_sync_init_impl+0x4c>
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
   10e18:	2318      	movs	r3, #24
   10e1a:	fb03 9308 	mla	r3, r3, r8, r9
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   10e1e:	2103      	movs	r1, #3
   10e20:	4620      	mov	r0, r4
   10e22:	6c9e      	ldr	r6, [r3, #72]	; 0x48
   10e24:	47a8      	blx	r5
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
   10e26:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
   10e28:	079b      	lsls	r3, r3, #30
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
   10e2a:	f006 061c 	and.w	r6, r6, #28
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
   10e2e:	d503      	bpl.n	10e38 <_i2c_m_sync_init_impl+0x40>
			hri_sercomi2cm_clear_CTRLA_ENABLE_bit(hw);
   10e30:	4b18      	ldr	r3, [pc, #96]	; (10e94 <_i2c_m_sync_init_impl+0x9c>)
   10e32:	4798      	blx	r3
			hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_ENABLE);
   10e34:	2102      	movs	r1, #2
   10e36:	47a8      	blx	r5
		hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST | mode);
   10e38:	f046 0601 	orr.w	r6, r6, #1
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
   10e3c:	6026      	str	r6, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   10e3e:	2103      	movs	r1, #3
   10e40:	4620      	mov	r0, r4
   10e42:	47a8      	blx	r5
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);
   10e44:	4620      	mov	r0, r4
   10e46:	2101      	movs	r1, #1
   10e48:	47a8      	blx	r5
	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a);
   10e4a:	2218      	movs	r2, #24
   10e4c:	fb02 9208 	mla	r2, r2, r8, r9
   10e50:	2103      	movs	r1, #3
   10e52:	6c96      	ldr	r6, [r2, #72]	; 0x48
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
   10e54:	6026      	str	r6, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   10e56:	47a8      	blx	r5
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
   10e58:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
   10e5a:	6063      	str	r3, [r4, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10e5c:	2104      	movs	r1, #4
   10e5e:	47a8      	blx	r5
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
   10e60:	6d13      	ldr	r3, [r2, #80]	; 0x50
	((Sercom *)hw)->I2CM.BAUD.reg = data;
   10e62:	60e3      	str	r3, [r4, #12]
	service->mode = (_i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_SPEED_Msk) >> SERCOM_I2CM_CTRLA_SPEED_Pos;
   10e64:	f3c6 6301 	ubfx	r3, r6, #24, #2
   10e68:	81bb      	strh	r3, [r7, #12]
	tmp = ((Sercom *)hw)->I2CM.ADDR.reg;
   10e6a:	6a63      	ldr	r3, [r4, #36]	; 0x24
	hri_sercomi2cm_write_ADDR_HS_bit(hw, service->mode < I2C_HS ? 0 : 1);
   10e6c:	f3c6 6640 	ubfx	r6, r6, #25, #1
	tmp &= ~SERCOM_I2CM_ADDR_HS;
   10e70:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
	tmp |= value << SERCOM_I2CM_ADDR_HS_Pos;
   10e74:	ea43 3386 	orr.w	r3, r3, r6, lsl #14
	((Sercom *)hw)->I2CM.ADDR.reg = tmp;
   10e78:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10e7a:	2104      	movs	r1, #4
   10e7c:	47a8      	blx	r5
	service->trise = _i2cms[i].trise;
   10e7e:	f8b2 3056 	ldrh.w	r3, [r2, #86]	; 0x56
   10e82:	81fb      	strh	r3, [r7, #14]
}
   10e84:	2000      	movs	r0, #0
   10e86:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   10e8a:	bf00      	nop
   10e8c:	00010b4d 	.word	0x00010b4d
   10e90:	000108c1 	.word	0x000108c1
   10e94:	000108d9 	.word	0x000108d9
   10e98:	00016588 	.word	0x00016588

00010e9c <_usart_init>:
{
   10e9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
   10ea0:	4b2d      	ldr	r3, [pc, #180]	; (10f58 <_usart_init+0xbc>)
{
   10ea2:	4604      	mov	r4, r0
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
   10ea4:	4798      	blx	r3
		if (_usarts[i].number == sercom_offset) {
   10ea6:	4605      	mov	r5, r0
   10ea8:	b170      	cbz	r0, 10ec8 <_usart_init+0x2c>
   10eaa:	2801      	cmp	r0, #1
   10eac:	d00c      	beq.n	10ec8 <_usart_init+0x2c>
   10eae:	2802      	cmp	r0, #2
   10eb0:	d00a      	beq.n	10ec8 <_usart_init+0x2c>
   10eb2:	2804      	cmp	r0, #4
   10eb4:	d04b      	beq.n	10f4e <_usart_init+0xb2>
   10eb6:	2806      	cmp	r0, #6
   10eb8:	d04b      	beq.n	10f52 <_usart_init+0xb6>
	ASSERT(false);
   10eba:	4928      	ldr	r1, [pc, #160]	; (10f5c <_usart_init+0xc0>)
   10ebc:	4b28      	ldr	r3, [pc, #160]	; (10f60 <_usart_init+0xc4>)
   10ebe:	f240 2276 	movw	r2, #630	; 0x276
   10ec2:	2000      	movs	r0, #0
   10ec4:	4798      	blx	r3
	return 0;
   10ec6:	2500      	movs	r5, #0
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
   10ec8:	69e3      	ldr	r3, [r4, #28]
   10eca:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 10f6c <_usart_init+0xd0>
   10ece:	4e25      	ldr	r6, [pc, #148]	; (10f64 <_usart_init+0xc8>)
	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
   10ed0:	f013 0f01 	tst.w	r3, #1
   10ed4:	d115      	bne.n	10f02 <_usart_init+0x66>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
   10ed6:	2318      	movs	r3, #24
   10ed8:	fb03 8305 	mla	r3, r3, r5, r8
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10edc:	2103      	movs	r1, #3
   10ede:	4620      	mov	r0, r4
   10ee0:	6e1f      	ldr	r7, [r3, #96]	; 0x60
   10ee2:	47b0      	blx	r6
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
   10ee4:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
   10ee6:	079b      	lsls	r3, r3, #30
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
   10ee8:	f007 071c 	and.w	r7, r7, #28
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
   10eec:	d503      	bpl.n	10ef6 <_usart_init+0x5a>
			hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
   10eee:	4b1e      	ldr	r3, [pc, #120]	; (10f68 <_usart_init+0xcc>)
   10ef0:	4798      	blx	r3
			hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
   10ef2:	2102      	movs	r1, #2
   10ef4:	47b0      	blx	r6
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
   10ef6:	f047 0701 	orr.w	r7, r7, #1
	((Sercom *)hw)->USART.CTRLA.reg = data;
   10efa:	6027      	str	r7, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10efc:	2103      	movs	r1, #3
   10efe:	4620      	mov	r0, r4
   10f00:	47b0      	blx	r6
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST);
   10f02:	2101      	movs	r1, #1
   10f04:	4620      	mov	r0, r4
   10f06:	47b0      	blx	r6
	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
   10f08:	2018      	movs	r0, #24
   10f0a:	fb00 8505 	mla	r5, r0, r5, r8
   10f0e:	2103      	movs	r1, #3
   10f10:	6e2a      	ldr	r2, [r5, #96]	; 0x60
	((Sercom *)hw)->USART.CTRLA.reg = data;
   10f12:	6022      	str	r2, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10f14:	4620      	mov	r0, r4
   10f16:	47b0      	blx	r6
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
   10f18:	6e6b      	ldr	r3, [r5, #100]	; 0x64
	((Sercom *)hw)->USART.CTRLB.reg = data;
   10f1a:	6063      	str	r3, [r4, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   10f1c:	211f      	movs	r1, #31
   10f1e:	47b0      	blx	r6
	hri_sercomusart_write_CTRLC_reg(hw, _usarts[i].ctrl_c);
   10f20:	6eab      	ldr	r3, [r5, #104]	; 0x68
	((Sercom *)hw)->USART.CTRLC.reg = data;
   10f22:	60a3      	str	r3, [r4, #8]
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
   10f24:	f412 4fc0 	tst.w	r2, #24576	; 0x6000
   10f28:	f8b5 306c 	ldrh.w	r3, [r5, #108]	; 0x6c
   10f2c:	d008      	beq.n	10f40 <_usart_init+0xa4>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
   10f2e:	89a2      	ldrh	r2, [r4, #12]
   10f30:	f363 020c 	bfi	r2, r3, #0, #13
   10f34:	81a2      	strh	r2, [r4, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
   10f36:	89a3      	ldrh	r3, [r4, #12]
   10f38:	f895 206e 	ldrb.w	r2, [r5, #110]	; 0x6e
   10f3c:	f362 334f 	bfi	r3, r2, #13, #3
	((Sercom *)hw)->USART.RXPL.reg = data;
   10f40:	2000      	movs	r0, #0
	((Sercom *)hw)->USART.BAUD.reg = data;
   10f42:	81a3      	strh	r3, [r4, #12]
	((Sercom *)hw)->USART.RXPL.reg = data;
   10f44:	73a0      	strb	r0, [r4, #14]
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
   10f46:	f884 0030 	strb.w	r0, [r4, #48]	; 0x30
}
   10f4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
   10f4e:	2503      	movs	r5, #3
   10f50:	e7ba      	b.n	10ec8 <_usart_init+0x2c>
   10f52:	2504      	movs	r5, #4
   10f54:	e7b8      	b.n	10ec8 <_usart_init+0x2c>
   10f56:	bf00      	nop
   10f58:	00010941 	.word	0x00010941
   10f5c:	0001656d 	.word	0x0001656d
   10f60:	0000e03d 	.word	0x0000e03d
   10f64:	000108d1 	.word	0x000108d1
   10f68:	0001092d 	.word	0x0001092d
   10f6c:	00016588 	.word	0x00016588

00010f70 <_usart_sync_init>:
{
   10f70:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
   10f72:	4605      	mov	r5, r0
   10f74:	3800      	subs	r0, #0
{
   10f76:	460c      	mov	r4, r1
	ASSERT(device);
   10f78:	4b05      	ldr	r3, [pc, #20]	; (10f90 <_usart_sync_init+0x20>)
   10f7a:	4906      	ldr	r1, [pc, #24]	; (10f94 <_usart_sync_init+0x24>)
   10f7c:	bf18      	it	ne
   10f7e:	2001      	movne	r0, #1
   10f80:	22c8      	movs	r2, #200	; 0xc8
   10f82:	4798      	blx	r3
	device->hw = hw;
   10f84:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
   10f86:	4620      	mov	r0, r4
   10f88:	4b03      	ldr	r3, [pc, #12]	; (10f98 <_usart_sync_init+0x28>)
}
   10f8a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _usart_init(hw);
   10f8e:	4718      	bx	r3
   10f90:	0000e03d 	.word	0x0000e03d
   10f94:	0001656d 	.word	0x0001656d
   10f98:	00010e9d 	.word	0x00010e9d

00010f9c <_usart_async_init>:
{
   10f9c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	ASSERT(device);
   10fa0:	4606      	mov	r6, r0
   10fa2:	3800      	subs	r0, #0
   10fa4:	bf18      	it	ne
   10fa6:	2001      	movne	r0, #1
   10fa8:	4b12      	ldr	r3, [pc, #72]	; (10ff4 <_usart_async_init+0x58>)
{
   10faa:	460c      	mov	r4, r1
	ASSERT(device);
   10fac:	22d6      	movs	r2, #214	; 0xd6
   10fae:	4912      	ldr	r1, [pc, #72]	; (10ff8 <_usart_async_init+0x5c>)
   10fb0:	4798      	blx	r3
	init_status = _usart_init(hw);
   10fb2:	4b12      	ldr	r3, [pc, #72]	; (10ffc <_usart_async_init+0x60>)
   10fb4:	4620      	mov	r0, r4
   10fb6:	4798      	blx	r3
	if (init_status) {
   10fb8:	4605      	mov	r5, r0
   10fba:	b9b8      	cbnz	r0, 10fec <_usart_async_init+0x50>
	_sercom_init_irq_param(hw, (void *)device);
   10fbc:	4631      	mov	r1, r6
	device->hw = hw;
   10fbe:	61b4      	str	r4, [r6, #24]
	_sercom_init_irq_param(hw, (void *)device);
   10fc0:	4620      	mov	r0, r4
   10fc2:	4b0f      	ldr	r3, [pc, #60]	; (11000 <_usart_async_init+0x64>)
		NVIC_DisableIRQ((IRQn_Type)irq);
   10fc4:	f8df 8048 	ldr.w	r8, [pc, #72]	; 11010 <_usart_async_init+0x74>
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   10fc8:	4f0e      	ldr	r7, [pc, #56]	; (11004 <_usart_async_init+0x68>)
		NVIC_EnableIRQ((IRQn_Type)irq);
   10fca:	4e0f      	ldr	r6, [pc, #60]	; (11008 <_usart_async_init+0x6c>)
	_sercom_init_irq_param(hw, (void *)device);
   10fcc:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
   10fce:	4b0f      	ldr	r3, [pc, #60]	; (1100c <_usart_async_init+0x70>)
   10fd0:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   10fd2:	4629      	mov	r1, r5
	uint8_t irq = _sercom_get_irq_num(hw);
   10fd4:	4604      	mov	r4, r0
		NVIC_DisableIRQ((IRQn_Type)irq);
   10fd6:	1863      	adds	r3, r4, r1
   10fd8:	b2d8      	uxtb	r0, r3
   10fda:	9001      	str	r0, [sp, #4]
   10fdc:	47c0      	blx	r8
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   10fde:	9801      	ldr	r0, [sp, #4]
   10fe0:	47b8      	blx	r7
		NVIC_EnableIRQ((IRQn_Type)irq);
   10fe2:	9801      	ldr	r0, [sp, #4]
   10fe4:	47b0      	blx	r6
	for (uint32_t i = 0; i < 4; i++) {
   10fe6:	3101      	adds	r1, #1
   10fe8:	2904      	cmp	r1, #4
   10fea:	d1f4      	bne.n	10fd6 <_usart_async_init+0x3a>
}
   10fec:	4628      	mov	r0, r5
   10fee:	b002      	add	sp, #8
   10ff0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10ff4:	0000e03d 	.word	0x0000e03d
   10ff8:	0001656d 	.word	0x0001656d
   10ffc:	00010e9d 	.word	0x00010e9d
   11000:	000109e9 	.word	0x000109e9
   11004:	00010b31 	.word	0x00010b31
   11008:	00010ac5 	.word	0x00010ac5
   1100c:	00010a49 	.word	0x00010a49
   11010:	00010b0d 	.word	0x00010b0d

00011014 <_usart_sync_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
   11014:	6800      	ldr	r0, [r0, #0]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
   11016:	6803      	ldr	r3, [r0, #0]
   11018:	f043 0302 	orr.w	r3, r3, #2
   1101c:	6003      	str	r3, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   1101e:	2103      	movs	r1, #3
   11020:	4b00      	ldr	r3, [pc, #0]	; (11024 <_usart_sync_enable+0x10>)
   11022:	4718      	bx	r3
   11024:	000108d1 	.word	0x000108d1

00011028 <_usart_async_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
   11028:	6980      	ldr	r0, [r0, #24]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
   1102a:	6803      	ldr	r3, [r0, #0]
   1102c:	f043 0302 	orr.w	r3, r3, #2
   11030:	6003      	str	r3, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   11032:	2103      	movs	r1, #3
   11034:	4b00      	ldr	r3, [pc, #0]	; (11038 <_usart_async_enable+0x10>)
   11036:	4718      	bx	r3
   11038:	000108d1 	.word	0x000108d1

0001103c <_usart_async_disable>:
	hri_sercomusart_clear_CTRLA_ENABLE_bit(device->hw);
   1103c:	6980      	ldr	r0, [r0, #24]
   1103e:	4b01      	ldr	r3, [pc, #4]	; (11044 <_usart_async_disable+0x8>)
   11040:	4718      	bx	r3
   11042:	bf00      	nop
   11044:	0001092d 	.word	0x0001092d

00011048 <_usart_async_set_parity>:
	_usart_set_parity(device->hw, parity);
   11048:	6980      	ldr	r0, [r0, #24]
   1104a:	4b01      	ldr	r3, [pc, #4]	; (11050 <_usart_async_set_parity+0x8>)
   1104c:	4718      	bx	r3
   1104e:	bf00      	nop
   11050:	00010cf9 	.word	0x00010cf9

00011054 <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
   11054:	6803      	ldr	r3, [r0, #0]
	((Sercom *)hw)->USART.DATA.reg = data;
   11056:	6299      	str	r1, [r3, #40]	; 0x28
}
   11058:	4770      	bx	lr

0001105a <_usart_async_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
   1105a:	6983      	ldr	r3, [r0, #24]
   1105c:	6299      	str	r1, [r3, #40]	; 0x28
}
   1105e:	4770      	bx	lr

00011060 <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
   11060:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
   11062:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
   11064:	b2c0      	uxtb	r0, r0
   11066:	4770      	bx	lr

00011068 <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
   11068:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
   1106a:	7e18      	ldrb	r0, [r3, #24]
}
   1106c:	f000 0001 	and.w	r0, r0, #1
   11070:	4770      	bx	lr

00011072 <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
   11072:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
   11074:	7e18      	ldrb	r0, [r3, #24]
}
   11076:	f3c0 0040 	ubfx	r0, r0, #1, #1
   1107a:	4770      	bx	lr

0001107c <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
   1107c:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
   1107e:	7e18      	ldrb	r0, [r3, #24]
}
   11080:	f3c0 0080 	ubfx	r0, r0, #2, #1
   11084:	4770      	bx	lr

00011086 <_usart_async_enable_byte_sent_irq>:
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
   11086:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
   11088:	2201      	movs	r2, #1
   1108a:	759a      	strb	r2, [r3, #22]
}
   1108c:	4770      	bx	lr

0001108e <_usart_async_enable_tx_done_irq>:
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
   1108e:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
   11090:	2202      	movs	r2, #2
   11092:	759a      	strb	r2, [r3, #22]
}
   11094:	4770      	bx	lr
	...

00011098 <_usart_async_set_irq_state>:
{
   11098:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
   1109a:	4604      	mov	r4, r0
   1109c:	3800      	subs	r0, #0
{
   1109e:	460e      	mov	r6, r1
	ASSERT(device);
   110a0:	bf18      	it	ne
   110a2:	2001      	movne	r0, #1
   110a4:	490f      	ldr	r1, [pc, #60]	; (110e4 <_usart_async_set_irq_state+0x4c>)
   110a6:	4b10      	ldr	r3, [pc, #64]	; (110e8 <_usart_async_set_irq_state+0x50>)
{
   110a8:	4615      	mov	r5, r2
	ASSERT(device);
   110aa:	f240 2236 	movw	r2, #566	; 0x236
   110ae:	4798      	blx	r3
	if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
   110b0:	f016 0ffd 	tst.w	r6, #253	; 0xfd
   110b4:	d109      	bne.n	110ca <_usart_async_set_irq_state+0x32>
		hri_sercomusart_write_INTEN_DRE_bit(device->hw, state);
   110b6:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
   110b8:	2101      	movs	r1, #1
   110ba:	2202      	movs	r2, #2
   110bc:	b915      	cbnz	r5, 110c4 <_usart_async_set_irq_state+0x2c>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
   110be:	7519      	strb	r1, [r3, #20]
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_ERROR;
   110c0:	751a      	strb	r2, [r3, #20]
}
   110c2:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
   110c4:	7599      	strb	r1, [r3, #22]
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_ERROR;
   110c6:	759a      	strb	r2, [r3, #22]
   110c8:	e7fb      	b.n	110c2 <_usart_async_set_irq_state+0x2a>
	} else if (USART_ASYNC_RX_DONE == type) {
   110ca:	2e01      	cmp	r6, #1
   110cc:	d104      	bne.n	110d8 <_usart_async_set_irq_state+0x40>
		hri_sercomusart_write_INTEN_RXC_bit(device->hw, state);
   110ce:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
   110d0:	2204      	movs	r2, #4
	if (value == 0x0) {
   110d2:	2d00      	cmp	r5, #0
   110d4:	d1f7      	bne.n	110c6 <_usart_async_set_irq_state+0x2e>
   110d6:	e7f3      	b.n	110c0 <_usart_async_set_irq_state+0x28>
	} else if (USART_ASYNC_ERROR == type) {
   110d8:	2e03      	cmp	r6, #3
   110da:	d1f2      	bne.n	110c2 <_usart_async_set_irq_state+0x2a>
		hri_sercomusart_write_INTEN_ERROR_bit(device->hw, state);
   110dc:	69a3      	ldr	r3, [r4, #24]
   110de:	2280      	movs	r2, #128	; 0x80
   110e0:	e7f7      	b.n	110d2 <_usart_async_set_irq_state+0x3a>
   110e2:	bf00      	nop
   110e4:	0001656d 	.word	0x0001656d
   110e8:	0000e03d 	.word	0x0000e03d

000110ec <_i2c_m_async_init>:
{
   110ec:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	ASSERT(i2c_dev);
   110f0:	4605      	mov	r5, r0
   110f2:	3800      	subs	r0, #0
{
   110f4:	460c      	mov	r4, r1
	ASSERT(i2c_dev);
   110f6:	bf18      	it	ne
   110f8:	2001      	movne	r0, #1
   110fa:	4913      	ldr	r1, [pc, #76]	; (11148 <_i2c_m_async_init+0x5c>)
   110fc:	4b13      	ldr	r3, [pc, #76]	; (1114c <_i2c_m_async_init+0x60>)
   110fe:	f240 42d3 	movw	r2, #1235	; 0x4d3
   11102:	4798      	blx	r3
	init_status = _i2c_m_sync_init_impl(&i2c_dev->service, hw);
   11104:	4b12      	ldr	r3, [pc, #72]	; (11150 <_i2c_m_async_init+0x64>)
	i2c_dev->hw = hw;
   11106:	612c      	str	r4, [r5, #16]
	init_status = _i2c_m_sync_init_impl(&i2c_dev->service, hw);
   11108:	4621      	mov	r1, r4
   1110a:	4628      	mov	r0, r5
   1110c:	4798      	blx	r3
	if (init_status) {
   1110e:	4606      	mov	r6, r0
   11110:	b9b0      	cbnz	r0, 11140 <_i2c_m_async_init+0x54>
	_sercom_init_irq_param(hw, (void *)i2c_dev);
   11112:	4629      	mov	r1, r5
   11114:	4620      	mov	r0, r4
   11116:	4b0f      	ldr	r3, [pc, #60]	; (11154 <_i2c_m_async_init+0x68>)
		NVIC_DisableIRQ((IRQn_Type)irq);
   11118:	f8df 8048 	ldr.w	r8, [pc, #72]	; 11164 <_i2c_m_async_init+0x78>
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   1111c:	4f0e      	ldr	r7, [pc, #56]	; (11158 <_i2c_m_async_init+0x6c>)
		NVIC_EnableIRQ((IRQn_Type)irq);
   1111e:	4d0f      	ldr	r5, [pc, #60]	; (1115c <_i2c_m_async_init+0x70>)
	_sercom_init_irq_param(hw, (void *)i2c_dev);
   11120:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
   11122:	4b0f      	ldr	r3, [pc, #60]	; (11160 <_i2c_m_async_init+0x74>)
   11124:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   11126:	4631      	mov	r1, r6
	uint8_t irq = _sercom_get_irq_num(hw);
   11128:	4604      	mov	r4, r0
		NVIC_DisableIRQ((IRQn_Type)irq);
   1112a:	1863      	adds	r3, r4, r1
   1112c:	b2d8      	uxtb	r0, r3
   1112e:	9001      	str	r0, [sp, #4]
   11130:	47c0      	blx	r8
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   11132:	9801      	ldr	r0, [sp, #4]
   11134:	47b8      	blx	r7
		NVIC_EnableIRQ((IRQn_Type)irq);
   11136:	9801      	ldr	r0, [sp, #4]
   11138:	47a8      	blx	r5
	for (uint32_t i = 0; i < 4; i++) {
   1113a:	3101      	adds	r1, #1
   1113c:	2904      	cmp	r1, #4
   1113e:	d1f4      	bne.n	1112a <_i2c_m_async_init+0x3e>
}
   11140:	4630      	mov	r0, r6
   11142:	b002      	add	sp, #8
   11144:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11148:	0001656d 	.word	0x0001656d
   1114c:	0000e03d 	.word	0x0000e03d
   11150:	00010df9 	.word	0x00010df9
   11154:	000109e9 	.word	0x000109e9
   11158:	00010b31 	.word	0x00010b31
   1115c:	00010ac5 	.word	0x00010ac5
   11160:	00010a49 	.word	0x00010a49
   11164:	00010b0d 	.word	0x00010b0d

00011168 <_i2c_m_async_transfer>:
{
   11168:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	ASSERT(i2c_dev);
   1116c:	4604      	mov	r4, r0
   1116e:	3800      	subs	r0, #0
   11170:	4e3c      	ldr	r6, [pc, #240]	; (11264 <_i2c_m_async_transfer+0xfc>)
{
   11172:	460d      	mov	r5, r1
	ASSERT(i2c_dev);
   11174:	bf18      	it	ne
   11176:	2001      	movne	r0, #1
   11178:	493b      	ldr	r1, [pc, #236]	; (11268 <_i2c_m_async_transfer+0x100>)
   1117a:	f240 5229 	movw	r2, #1321	; 0x529
   1117e:	47b0      	blx	r6
	ASSERT(i2c_dev->hw);
   11180:	6920      	ldr	r0, [r4, #16]
   11182:	4939      	ldr	r1, [pc, #228]	; (11268 <_i2c_m_async_transfer+0x100>)
   11184:	3800      	subs	r0, #0
   11186:	f240 522a 	movw	r2, #1322	; 0x52a
   1118a:	bf18      	it	ne
   1118c:	2001      	movne	r0, #1
   1118e:	47b0      	blx	r6
	ASSERT(msg);
   11190:	1e28      	subs	r0, r5, #0
   11192:	bf18      	it	ne
   11194:	2001      	movne	r0, #1
   11196:	4934      	ldr	r1, [pc, #208]	; (11268 <_i2c_m_async_transfer+0x100>)
   11198:	f240 522b 	movw	r2, #1323	; 0x52b
   1119c:	47b0      	blx	r6
	if (msg->len == 0) {
   1119e:	6868      	ldr	r0, [r5, #4]
   111a0:	2800      	cmp	r0, #0
   111a2:	d048      	beq.n	11236 <_i2c_m_async_transfer+0xce>
	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
   111a4:	8863      	ldrh	r3, [r4, #2]
   111a6:	05da      	lsls	r2, r3, #23
   111a8:	d458      	bmi.n	1125c <_i2c_m_async_transfer+0xf4>
	msg->flags |= I2C_M_BUSY;
   111aa:	886b      	ldrh	r3, [r5, #2]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   111ac:	4f2f      	ldr	r7, [pc, #188]	; (1126c <_i2c_m_async_transfer+0x104>)
   111ae:	b29b      	uxth	r3, r3
   111b0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   111b4:	806b      	strh	r3, [r5, #2]
	i2c_dev->service.msg = *msg;
   111b6:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
   111ba:	e884 0007 	stmia.w	r4, {r0, r1, r2}
	hri_sercomi2cm_set_CTRLB_SMEN_bit(i2c_dev->hw);
   111be:	6920      	ldr	r0, [r4, #16]
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
   111c0:	6843      	ldr	r3, [r0, #4]
   111c2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   111c6:	6043      	str	r3, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   111c8:	2104      	movs	r1, #4
   111ca:	47b8      	blx	r7
	void *             hw    = i2c_dev->hw;
   111cc:	6925      	ldr	r5, [r4, #16]
	ASSERT(i2c_dev);
   111ce:	4926      	ldr	r1, [pc, #152]	; (11268 <_i2c_m_async_transfer+0x100>)
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
   111d0:	f8d5 8000 	ldr.w	r8, [r5]
   111d4:	f240 5201 	movw	r2, #1281	; 0x501
   111d8:	2001      	movs	r0, #1
   111da:	47b0      	blx	r6
	if (msg->len == 1 && sclsm) {
   111dc:	6863      	ldr	r3, [r4, #4]
   111de:	2b01      	cmp	r3, #1
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
   111e0:	686b      	ldr	r3, [r5, #4]
   111e2:	d12a      	bne.n	1123a <_i2c_m_async_transfer+0xd2>
   111e4:	f018 6f00 	tst.w	r8, #134217728	; 0x8000000
   111e8:	d027      	beq.n	1123a <_i2c_m_async_transfer+0xd2>
   111ea:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   111ee:	4628      	mov	r0, r5
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
   111f0:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   111f2:	2104      	movs	r1, #4
   111f4:	47b8      	blx	r7
	if (msg->addr & I2C_M_TEN) {
   111f6:	8820      	ldrh	r0, [r4, #0]
   111f8:	f410 6680 	ands.w	r6, r0, #1024	; 0x400
   111fc:	ea4f 0240 	mov.w	r2, r0, lsl #1
   11200:	d01e      	beq.n	11240 <_i2c_m_async_transfer+0xd8>
		if (msg->flags & I2C_M_RD) {
   11202:	8863      	ldrh	r3, [r4, #2]
   11204:	07db      	lsls	r3, r3, #31
			msg->flags |= I2C_M_TEN;
   11206:	bf41      	itttt	mi
   11208:	8863      	ldrhmi	r3, [r4, #2]
   1120a:	b29b      	uxthmi	r3, r3
   1120c:	f443 6380 	orrmi.w	r3, r3, #1024	; 0x400
   11210:	8063      	strhmi	r3, [r4, #2]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11212:	2104      	movs	r1, #4
   11214:	4628      	mov	r0, r5
   11216:	47b8      	blx	r7
	return ((Sercom *)hw)->I2CM.ADDR.reg;
   11218:	6a6b      	ldr	r3, [r5, #36]	; 0x24
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
   1121a:	f022 0201 	bic.w	r2, r2, #1
   1121e:	0552      	lsls	r2, r2, #21
   11220:	0d52      	lsrs	r2, r2, #21
   11222:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
   11226:	431a      	orrs	r2, r3
		hri_sercomi2cm_write_ADDR_reg(hw,
   11228:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   1122c:	4628      	mov	r0, r5
	((Sercom *)hw)->I2CM.ADDR.reg = data;
   1122e:	626a      	str	r2, [r5, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11230:	2104      	movs	r1, #4
   11232:	47b8      	blx	r7
	return ERR_NONE;
   11234:	2000      	movs	r0, #0
}
   11236:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
   1123a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
   1123e:	e7d6      	b.n	111ee <_i2c_m_async_transfer+0x86>
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11240:	2104      	movs	r1, #4
   11242:	4628      	mov	r0, r5
		                              ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0)
   11244:	8864      	ldrh	r4, [r4, #2]
   11246:	47b8      	blx	r7
   11248:	b2a4      	uxth	r4, r4
	return ((Sercom *)hw)->I2CM.ADDR.reg;
   1124a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1124c:	b2d2      	uxtb	r2, r2
   1124e:	f004 0401 	and.w	r4, r4, #1
   11252:	4322      	orrs	r2, r4
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
   11254:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
		hri_sercomi2cm_write_ADDR_reg(hw,
   11258:	431a      	orrs	r2, r3
	((Sercom *)hw)->I2CM.ADDR.reg = data;
   1125a:	e7e7      	b.n	1122c <_i2c_m_async_transfer+0xc4>
		return ERR_BUSY;
   1125c:	f06f 0003 	mvn.w	r0, #3
   11260:	e7e9      	b.n	11236 <_i2c_m_async_transfer+0xce>
   11262:	bf00      	nop
   11264:	0000e03d 	.word	0x0000e03d
   11268:	0001656d 	.word	0x0001656d
   1126c:	000108c1 	.word	0x000108c1

00011270 <_i2c_m_async_register_callback>:
	switch (type) {
   11270:	2901      	cmp	r1, #1
   11272:	d005      	beq.n	11280 <_i2c_m_async_register_callback+0x10>
   11274:	2902      	cmp	r1, #2
   11276:	d005      	beq.n	11284 <_i2c_m_async_register_callback+0x14>
   11278:	b901      	cbnz	r1, 1127c <_i2c_m_async_register_callback+0xc>
		i2c_dev->cb.error = (_i2c_error_cb_t)func;
   1127a:	6142      	str	r2, [r0, #20]
}
   1127c:	2000      	movs	r0, #0
   1127e:	4770      	bx	lr
		i2c_dev->cb.tx_complete = (_i2c_complete_cb_t)func;
   11280:	6182      	str	r2, [r0, #24]
		break;
   11282:	e7fb      	b.n	1127c <_i2c_m_async_register_callback+0xc>
		i2c_dev->cb.rx_complete = (_i2c_complete_cb_t)func;
   11284:	61c2      	str	r2, [r0, #28]
		break;
   11286:	e7f9      	b.n	1127c <_i2c_m_async_register_callback+0xc>

00011288 <SERCOM0_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom0_dev);
   11288:	4b01      	ldr	r3, [pc, #4]	; (11290 <SERCOM0_0_Handler+0x8>)
   1128a:	6818      	ldr	r0, [r3, #0]
   1128c:	4b01      	ldr	r3, [pc, #4]	; (11294 <SERCOM0_0_Handler+0xc>)
   1128e:	4718      	bx	r3
   11290:	20008d68 	.word	0x20008d68
   11294:	00010979 	.word	0x00010979

00011298 <SERCOM0_1_Handler>:
   11298:	4b00      	ldr	r3, [pc, #0]	; (1129c <SERCOM0_1_Handler+0x4>)
   1129a:	4718      	bx	r3
   1129c:	00011289 	.word	0x00011289

000112a0 <SERCOM0_2_Handler>:
   112a0:	4b00      	ldr	r3, [pc, #0]	; (112a4 <SERCOM0_2_Handler+0x4>)
   112a2:	4718      	bx	r3
   112a4:	00011289 	.word	0x00011289

000112a8 <SERCOM0_3_Handler>:
   112a8:	4b00      	ldr	r3, [pc, #0]	; (112ac <SERCOM0_3_Handler+0x4>)
   112aa:	4718      	bx	r3
   112ac:	00011289 	.word	0x00011289

000112b0 <SERCOM1_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom1_dev);
   112b0:	4b01      	ldr	r3, [pc, #4]	; (112b8 <SERCOM1_0_Handler+0x8>)
   112b2:	6858      	ldr	r0, [r3, #4]
   112b4:	4b01      	ldr	r3, [pc, #4]	; (112bc <SERCOM1_0_Handler+0xc>)
   112b6:	4718      	bx	r3
   112b8:	20008d68 	.word	0x20008d68
   112bc:	00010979 	.word	0x00010979

000112c0 <SERCOM1_1_Handler>:
   112c0:	4b00      	ldr	r3, [pc, #0]	; (112c4 <SERCOM1_1_Handler+0x4>)
   112c2:	4718      	bx	r3
   112c4:	000112b1 	.word	0x000112b1

000112c8 <SERCOM1_2_Handler>:
   112c8:	4b00      	ldr	r3, [pc, #0]	; (112cc <SERCOM1_2_Handler+0x4>)
   112ca:	4718      	bx	r3
   112cc:	000112b1 	.word	0x000112b1

000112d0 <SERCOM1_3_Handler>:
   112d0:	4b00      	ldr	r3, [pc, #0]	; (112d4 <SERCOM1_3_Handler+0x4>)
   112d2:	4718      	bx	r3
   112d4:	000112b1 	.word	0x000112b1

000112d8 <SERCOM3_0_Handler>:
	_spi_handler(_sercom3_dev);
   112d8:	4b0f      	ldr	r3, [pc, #60]	; (11318 <SERCOM3_0_Handler+0x40>)
   112da:	6898      	ldr	r0, [r3, #8]
	void *                      hw = dev->prvt;
   112dc:	6802      	ldr	r2, [r0, #0]
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
   112de:	7e13      	ldrb	r3, [r2, #24]
	return ((Sercom *)hw)->SPI.INTENSET.reg;
   112e0:	7d91      	ldrb	r1, [r2, #22]
	st &= hri_sercomspi_read_INTEN_reg(hw);
   112e2:	400b      	ands	r3, r1
	if (st & SERCOM_SPI_INTFLAG_DRE) {
   112e4:	07d9      	lsls	r1, r3, #31
   112e6:	d501      	bpl.n	112ec <SERCOM3_0_Handler+0x14>
		dev->callbacks.tx(dev);
   112e8:	6883      	ldr	r3, [r0, #8]
		dev->callbacks.rx(dev);
   112ea:	4718      	bx	r3
	} else if (st & SERCOM_SPI_INTFLAG_RXC) {
   112ec:	0759      	lsls	r1, r3, #29
   112ee:	d501      	bpl.n	112f4 <SERCOM3_0_Handler+0x1c>
		dev->callbacks.rx(dev);
   112f0:	68c3      	ldr	r3, [r0, #12]
   112f2:	e7fa      	b.n	112ea <SERCOM3_0_Handler+0x12>
	} else if (st & SERCOM_SPI_INTFLAG_TXC) {
   112f4:	0799      	lsls	r1, r3, #30
   112f6:	d503      	bpl.n	11300 <SERCOM3_0_Handler+0x28>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
   112f8:	2302      	movs	r3, #2
   112fa:	7613      	strb	r3, [r2, #24]
		dev->callbacks.complete(dev);
   112fc:	6903      	ldr	r3, [r0, #16]
   112fe:	e7f4      	b.n	112ea <SERCOM3_0_Handler+0x12>
	} else if (st & SERCOM_SPI_INTFLAG_ERROR) {
   11300:	061b      	lsls	r3, r3, #24
   11302:	d507      	bpl.n	11314 <SERCOM3_0_Handler+0x3c>
	((Sercom *)hw)->SPI.STATUS.reg = mask;
   11304:	2304      	movs	r3, #4
   11306:	8353      	strh	r3, [r2, #26]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
   11308:	2380      	movs	r3, #128	; 0x80
   1130a:	7613      	strb	r3, [r2, #24]
		dev->callbacks.err(dev, ERR_OVERFLOW);
   1130c:	f06f 0112 	mvn.w	r1, #18
   11310:	6943      	ldr	r3, [r0, #20]
   11312:	4718      	bx	r3
}
   11314:	4770      	bx	lr
   11316:	bf00      	nop
   11318:	20008d68 	.word	0x20008d68

0001131c <SERCOM3_1_Handler>:
   1131c:	4b00      	ldr	r3, [pc, #0]	; (11320 <SERCOM3_1_Handler+0x4>)
   1131e:	4718      	bx	r3
   11320:	000112d9 	.word	0x000112d9

00011324 <SERCOM3_2_Handler>:
   11324:	4b00      	ldr	r3, [pc, #0]	; (11328 <SERCOM3_2_Handler+0x4>)
   11326:	4718      	bx	r3
   11328:	000112d9 	.word	0x000112d9

0001132c <SERCOM3_3_Handler>:
   1132c:	4b00      	ldr	r3, [pc, #0]	; (11330 <SERCOM3_3_Handler+0x4>)
   1132e:	4718      	bx	r3
   11330:	000112d9 	.word	0x000112d9

00011334 <SERCOM4_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom4_dev);
   11334:	4b01      	ldr	r3, [pc, #4]	; (1133c <SERCOM4_0_Handler+0x8>)
   11336:	68d8      	ldr	r0, [r3, #12]
   11338:	4b01      	ldr	r3, [pc, #4]	; (11340 <SERCOM4_0_Handler+0xc>)
   1133a:	4718      	bx	r3
   1133c:	20008d68 	.word	0x20008d68
   11340:	00010979 	.word	0x00010979

00011344 <SERCOM4_1_Handler>:
   11344:	4b00      	ldr	r3, [pc, #0]	; (11348 <SERCOM4_1_Handler+0x4>)
   11346:	4718      	bx	r3
   11348:	00011335 	.word	0x00011335

0001134c <SERCOM4_2_Handler>:
   1134c:	4b00      	ldr	r3, [pc, #0]	; (11350 <SERCOM4_2_Handler+0x4>)
   1134e:	4718      	bx	r3
   11350:	00011335 	.word	0x00011335

00011354 <SERCOM4_3_Handler>:
   11354:	4b00      	ldr	r3, [pc, #0]	; (11358 <SERCOM4_3_Handler+0x4>)
   11356:	4718      	bx	r3
   11358:	00011335 	.word	0x00011335

0001135c <SERCOM5_0_Handler>:
	_sercom_i2c_m_irq_handler(_sercom5_dev);
   1135c:	4b1f      	ldr	r3, [pc, #124]	; (113dc <SERCOM5_0_Handler+0x80>)
	ASSERT(i2c_dev);
   1135e:	4920      	ldr	r1, [pc, #128]	; (113e0 <SERCOM5_0_Handler+0x84>)
{
   11360:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	_sercom_i2c_m_irq_handler(_sercom5_dev);
   11364:	691c      	ldr	r4, [r3, #16]
	ASSERT(i2c_dev);
   11366:	4f1f      	ldr	r7, [pc, #124]	; (113e4 <SERCOM5_0_Handler+0x88>)
	void *   hw    = i2c_dev->hw;
   11368:	6926      	ldr	r6, [r4, #16]
	ASSERT(i2c_dev);
   1136a:	f240 425f 	movw	r2, #1119	; 0x45f
   1136e:	2001      	movs	r0, #1
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
   11370:	7e35      	ldrb	r5, [r6, #24]
   11372:	47b8      	blx	r7
	ASSERT(i2c_dev->hw);
   11374:	6920      	ldr	r0, [r4, #16]
   11376:	491a      	ldr	r1, [pc, #104]	; (113e0 <SERCOM5_0_Handler+0x84>)
   11378:	3800      	subs	r0, #0
   1137a:	bf18      	it	ne
   1137c:	2001      	movne	r0, #1
   1137e:	b2ed      	uxtb	r5, r5
   11380:	f44f 628c 	mov.w	r2, #1120	; 0x460
   11384:	47b8      	blx	r7
	while (!(flags & ERROR_FLAG)) {
   11386:	0629      	lsls	r1, r5, #24
   11388:	d415      	bmi.n	113b6 <SERCOM5_0_Handler+0x5a>
		ret = _sercom_i2c_sync_analyse_flags(hw, flags, &i2c_dev->service.msg);
   1138a:	4629      	mov	r1, r5
   1138c:	4b16      	ldr	r3, [pc, #88]	; (113e8 <SERCOM5_0_Handler+0x8c>)
   1138e:	4622      	mov	r2, r4
   11390:	4630      	mov	r0, r6
   11392:	4798      	blx	r3
		if (ret != 0) {
   11394:	4601      	mov	r1, r0
   11396:	b978      	cbnz	r0, 113b8 <SERCOM5_0_Handler+0x5c>
		if ((flags & MB_FLAG) && i2c_dev->cb.tx_complete) {
   11398:	07ea      	lsls	r2, r5, #31
   1139a:	d505      	bpl.n	113a8 <SERCOM5_0_Handler+0x4c>
   1139c:	69a3      	ldr	r3, [r4, #24]
   1139e:	b11b      	cbz	r3, 113a8 <SERCOM5_0_Handler+0x4c>
			i2c_dev->cb.rx_complete(i2c_dev);
   113a0:	4620      	mov	r0, r4
}
   113a2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			i2c_dev->cb.rx_complete(i2c_dev);
   113a6:	4718      	bx	r3
		} else if ((flags & SB_FLAG) && i2c_dev->cb.rx_complete) {
   113a8:	07ab      	lsls	r3, r5, #30
   113aa:	d502      	bpl.n	113b2 <SERCOM5_0_Handler+0x56>
   113ac:	69e3      	ldr	r3, [r4, #28]
   113ae:	2b00      	cmp	r3, #0
   113b0:	d1f6      	bne.n	113a0 <SERCOM5_0_Handler+0x44>
}
   113b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	int32_t  ret   = I2C_OK;
   113b6:	2100      	movs	r1, #0
	i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
   113b8:	8863      	ldrh	r3, [r4, #2]
   113ba:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   113be:	041b      	lsls	r3, r3, #16
   113c0:	0c1b      	lsrs	r3, r3, #16
   113c2:	8063      	strh	r3, [r4, #2]
	if (i2c_dev->cb.error) {
   113c4:	6963      	ldr	r3, [r4, #20]
   113c6:	2b00      	cmp	r3, #0
   113c8:	d0f3      	beq.n	113b2 <SERCOM5_0_Handler+0x56>
		if (ret != I2C_OK) {
   113ca:	b121      	cbz	r1, 113d6 <SERCOM5_0_Handler+0x7a>
			i2c_dev->cb.error(i2c_dev, I2C_ERR_BUS);
   113cc:	4620      	mov	r0, r4
   113ce:	4798      	blx	r3
	((Sercom *)hw)->I2CM.INTFLAG.reg = mask;
   113d0:	2380      	movs	r3, #128	; 0x80
   113d2:	7633      	strb	r3, [r6, #24]
}
   113d4:	e7ed      	b.n	113b2 <SERCOM5_0_Handler+0x56>
			i2c_dev->cb.error(i2c_dev, I2C_ERR_BUS);
   113d6:	f06f 0104 	mvn.w	r1, #4
   113da:	e7f7      	b.n	113cc <SERCOM5_0_Handler+0x70>
   113dc:	20008d68 	.word	0x20008d68
   113e0:	0001656d 	.word	0x0001656d
   113e4:	0000e03d 	.word	0x0000e03d
   113e8:	00010b8d 	.word	0x00010b8d

000113ec <SERCOM5_1_Handler>:
   113ec:	4b00      	ldr	r3, [pc, #0]	; (113f0 <SERCOM5_1_Handler+0x4>)
   113ee:	4718      	bx	r3
   113f0:	0001135d 	.word	0x0001135d

000113f4 <SERCOM5_2_Handler>:
   113f4:	4b00      	ldr	r3, [pc, #0]	; (113f8 <SERCOM5_2_Handler+0x4>)
   113f6:	4718      	bx	r3
   113f8:	0001135d 	.word	0x0001135d

000113fc <SERCOM5_3_Handler>:
   113fc:	4b00      	ldr	r3, [pc, #0]	; (11400 <SERCOM5_3_Handler+0x4>)
   113fe:	4718      	bx	r3
   11400:	0001135d 	.word	0x0001135d

00011404 <SERCOM6_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom6_dev);
   11404:	4b01      	ldr	r3, [pc, #4]	; (1140c <SERCOM6_0_Handler+0x8>)
   11406:	6958      	ldr	r0, [r3, #20]
   11408:	4b01      	ldr	r3, [pc, #4]	; (11410 <SERCOM6_0_Handler+0xc>)
   1140a:	4718      	bx	r3
   1140c:	20008d68 	.word	0x20008d68
   11410:	00010979 	.word	0x00010979

00011414 <SERCOM6_1_Handler>:
   11414:	4b00      	ldr	r3, [pc, #0]	; (11418 <SERCOM6_1_Handler+0x4>)
   11416:	4718      	bx	r3
   11418:	00011405 	.word	0x00011405

0001141c <SERCOM6_2_Handler>:
   1141c:	4b00      	ldr	r3, [pc, #0]	; (11420 <SERCOM6_2_Handler+0x4>)
   1141e:	4718      	bx	r3
   11420:	00011405 	.word	0x00011405

00011424 <SERCOM6_3_Handler>:
   11424:	4b00      	ldr	r3, [pc, #0]	; (11428 <SERCOM6_3_Handler+0x4>)
   11426:	4718      	bx	r3
   11428:	00011405 	.word	0x00011405

0001142c <_spi_m_sync_init>:
{
   1142c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11430:	4b37      	ldr	r3, [pc, #220]	; (11510 <_spi_m_sync_init+0xe4>)
{
   11432:	4606      	mov	r6, r0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11434:	4608      	mov	r0, r1
{
   11436:	460c      	mov	r4, r1
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11438:	4798      	blx	r3
   1143a:	4605      	mov	r5, r0
	ASSERT(dev && hw);
   1143c:	2e00      	cmp	r6, #0
   1143e:	d05d      	beq.n	114fc <_spi_m_sync_init+0xd0>
   11440:	1e20      	subs	r0, r4, #0
   11442:	bf18      	it	ne
   11444:	2001      	movne	r0, #1
   11446:	4f33      	ldr	r7, [pc, #204]	; (11514 <_spi_m_sync_init+0xe8>)
   11448:	4933      	ldr	r1, [pc, #204]	; (11518 <_spi_m_sync_init+0xec>)
   1144a:	f640 2278 	movw	r2, #2680	; 0xa78
   1144e:	47b8      	blx	r7
	if (regs == NULL) {
   11450:	46b9      	mov	r9, r7
   11452:	2d00      	cmp	r5, #0
   11454:	d058      	beq.n	11508 <_spi_m_sync_init+0xdc>
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   11456:	69e3      	ldr	r3, [r4, #28]
   11458:	4f30      	ldr	r7, [pc, #192]	; (1151c <_spi_m_sync_init+0xf0>)
	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   1145a:	f013 0f01 	tst.w	r3, #1
   1145e:	d113      	bne.n	11488 <_spi_m_sync_init+0x5c>
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   11460:	2103      	movs	r1, #3
   11462:	4620      	mov	r0, r4
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   11464:	f8d5 8000 	ldr.w	r8, [r5]
   11468:	47b8      	blx	r7
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
   1146a:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   1146c:	079b      	lsls	r3, r3, #30
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   1146e:	f008 081c 	and.w	r8, r8, #28
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   11472:	d503      	bpl.n	1147c <_spi_m_sync_init+0x50>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
   11474:	4b2a      	ldr	r3, [pc, #168]	; (11520 <_spi_m_sync_init+0xf4>)
   11476:	4798      	blx	r3
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
   11478:	2102      	movs	r1, #2
   1147a:	47b8      	blx	r7
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
   1147c:	f048 0301 	orr.w	r3, r8, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   11480:	6023      	str	r3, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   11482:	2103      	movs	r1, #3
   11484:	4620      	mov	r0, r4
   11486:	47b8      	blx	r7
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);
   11488:	2101      	movs	r1, #1
   1148a:	4620      	mov	r0, r4
   1148c:	47b8      	blx	r7
	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
   1148e:	682b      	ldr	r3, [r5, #0]
	dev->prvt = hw;
   11490:	6034      	str	r4, [r6, #0]
	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
   11492:	f003 031c 	and.w	r3, r3, #28
   11496:	2b08      	cmp	r3, #8
   11498:	d132      	bne.n	11500 <_spi_m_sync_init+0xd4>
	ASSERT(hw && regs);
   1149a:	f640 128e 	movw	r2, #2446	; 0x98e
   1149e:	491e      	ldr	r1, [pc, #120]	; (11518 <_spi_m_sync_init+0xec>)
   114a0:	2001      	movs	r0, #1
   114a2:	47c8      	blx	r9
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
   114a4:	682b      	ldr	r3, [r5, #0]
	hri_sercomspi_write_CTRLA_reg(
   114a6:	f423 7381 	bic.w	r3, r3, #258	; 0x102
   114aa:	f023 0301 	bic.w	r3, r3, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   114ae:	6023      	str	r3, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   114b0:	2103      	movs	r1, #3
   114b2:	4620      	mov	r0, r4
   114b4:	47b8      	blx	r7
	                              (regs->ctrlb & ~(SERCOM_SPI_CTRLB_MSSEN))
   114b6:	686b      	ldr	r3, [r5, #4]
	                                  | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_SSDE | SERCOM_SPI_CTRLB_PLOADEN));
   114b8:	f423 3308 	bic.w	r3, r3, #139264	; 0x22000
   114bc:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(hw,
   114c0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   114c4:	f443 7310 	orr.w	r3, r3, #576	; 0x240
	((Sercom *)hw)->SPI.CTRLB.reg = data;
   114c8:	6063      	str	r3, [r4, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   114ca:	2117      	movs	r1, #23
   114cc:	47b8      	blx	r7
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
   114ce:	68ab      	ldr	r3, [r5, #8]
	((Sercom *)hw)->SPI.ADDR.reg = data;
   114d0:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
   114d2:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
   114d4:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   114d8:	69e3      	ldr	r3, [r4, #28]
	while (hri_sercomspi_is_syncing(hw, 0xFFFFFFFF))
   114da:	2b00      	cmp	r3, #0
   114dc:	d1fc      	bne.n	114d8 <_spi_m_sync_init+0xac>
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
   114de:	686b      	ldr	r3, [r5, #4]
   114e0:	f013 0f07 	tst.w	r3, #7
   114e4:	bf0c      	ite	eq
   114e6:	2301      	moveq	r3, #1
   114e8:	2302      	movne	r3, #2
   114ea:	7133      	strb	r3, [r6, #4]
	dev->dummy_byte = regs->dummy_byte;
   114ec:	7bab      	ldrb	r3, [r5, #14]
   114ee:	7bea      	ldrb	r2, [r5, #15]
   114f0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   114f4:	80f3      	strh	r3, [r6, #6]
	return ERR_NONE;
   114f6:	2000      	movs	r0, #0
}
   114f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(dev && hw);
   114fc:	4630      	mov	r0, r6
   114fe:	e7a2      	b.n	11446 <_spi_m_sync_init+0x1a>
		_spi_load_regs_master(hw, regs);
   11500:	4b08      	ldr	r3, [pc, #32]	; (11524 <_spi_m_sync_init+0xf8>)
   11502:	4629      	mov	r1, r5
   11504:	4798      	blx	r3
   11506:	e7ea      	b.n	114de <_spi_m_sync_init+0xb2>
		return ERR_INVALID_ARG;
   11508:	f06f 000c 	mvn.w	r0, #12
   1150c:	e7f4      	b.n	114f8 <_spi_m_sync_init+0xcc>
   1150e:	bf00      	nop
   11510:	00010a85 	.word	0x00010a85
   11514:	0000e03d 	.word	0x0000e03d
   11518:	0001656d 	.word	0x0001656d
   1151c:	000108c9 	.word	0x000108c9
   11520:	000108ed 	.word	0x000108ed
   11524:	00010da1 	.word	0x00010da1

00011528 <_spi_m_async_init>:
{
   11528:	b573      	push	{r0, r1, r4, r5, r6, lr}
	int32_t rc = _spi_m_sync_init((struct _spi_m_sync_dev *)dev, hw);
   1152a:	4b10      	ldr	r3, [pc, #64]	; (1156c <_spi_m_async_init+0x44>)
{
   1152c:	4605      	mov	r5, r0
   1152e:	460e      	mov	r6, r1
	int32_t rc = _spi_m_sync_init((struct _spi_m_sync_dev *)dev, hw);
   11530:	4798      	blx	r3
	if (rc < 0) {
   11532:	2800      	cmp	r0, #0
   11534:	db17      	blt.n	11566 <_spi_m_async_init+0x3e>
	_sercom_init_irq_param(hw, (void *)dev);
   11536:	4629      	mov	r1, r5
	spid->callbacks.complete = NULL;
   11538:	2400      	movs	r4, #0
	_sercom_init_irq_param(hw, (void *)dev);
   1153a:	4630      	mov	r0, r6
   1153c:	4b0c      	ldr	r3, [pc, #48]	; (11570 <_spi_m_async_init+0x48>)
		NVIC_DisableIRQ((IRQn_Type)irq);
   1153e:	4e0d      	ldr	r6, [pc, #52]	; (11574 <_spi_m_async_init+0x4c>)
	_sercom_init_irq_param(hw, (void *)dev);
   11540:	4798      	blx	r3
	spid->callbacks.rx       = NULL;
   11542:	e9c5 4403 	strd	r4, r4, [r5, #12]
	spid->callbacks.tx       = NULL;
   11546:	60ac      	str	r4, [r5, #8]
	uint8_t irq              = _sercom_get_irq_num(hw);
   11548:	4b0b      	ldr	r3, [pc, #44]	; (11578 <_spi_m_async_init+0x50>)
   1154a:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   1154c:	4621      	mov	r1, r4
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   1154e:	4c0b      	ldr	r4, [pc, #44]	; (1157c <_spi_m_async_init+0x54>)
	uint8_t irq              = _sercom_get_irq_num(hw);
   11550:	4605      	mov	r5, r0
		NVIC_DisableIRQ((IRQn_Type)irq);
   11552:	186b      	adds	r3, r5, r1
   11554:	b2d8      	uxtb	r0, r3
   11556:	9001      	str	r0, [sp, #4]
   11558:	47b0      	blx	r6
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   1155a:	9801      	ldr	r0, [sp, #4]
   1155c:	47a0      	blx	r4
	for (uint32_t i = 0; i < 4; i++) {
   1155e:	3101      	adds	r1, #1
   11560:	2904      	cmp	r1, #4
   11562:	d1f6      	bne.n	11552 <_spi_m_async_init+0x2a>
   11564:	2000      	movs	r0, #0
}
   11566:	b002      	add	sp, #8
   11568:	bd70      	pop	{r4, r5, r6, pc}
   1156a:	bf00      	nop
   1156c:	0001142d 	.word	0x0001142d
   11570:	000109e9 	.word	0x000109e9
   11574:	00010b0d 	.word	0x00010b0d
   11578:	00010a49 	.word	0x00010a49
   1157c:	00010b31 	.word	0x00010b31

00011580 <_spi_m_async_enable>:
{
   11580:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
   11582:	4604      	mov	r4, r0
   11584:	b118      	cbz	r0, 1158e <_spi_m_async_enable+0xe>
   11586:	6800      	ldr	r0, [r0, #0]
   11588:	3800      	subs	r0, #0
   1158a:	bf18      	it	ne
   1158c:	2001      	movne	r0, #1
   1158e:	4b05      	ldr	r3, [pc, #20]	; (115a4 <_spi_m_async_enable+0x24>)
   11590:	4905      	ldr	r1, [pc, #20]	; (115a8 <_spi_m_async_enable+0x28>)
   11592:	f640 22e5 	movw	r2, #2789	; 0xae5
   11596:	4798      	blx	r3
	return _spi_async_enable(dev->prvt);
   11598:	6820      	ldr	r0, [r4, #0]
   1159a:	4b04      	ldr	r3, [pc, #16]	; (115ac <_spi_m_async_enable+0x2c>)
}
   1159c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _spi_async_enable(dev->prvt);
   115a0:	4718      	bx	r3
   115a2:	bf00      	nop
   115a4:	0000e03d 	.word	0x0000e03d
   115a8:	0001656d 	.word	0x0001656d
   115ac:	00010add 	.word	0x00010add

000115b0 <_spi_m_async_set_mode>:
{
   115b0:	b570      	push	{r4, r5, r6, lr}
   115b2:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   115b4:	4604      	mov	r4, r0
   115b6:	b118      	cbz	r0, 115c0 <_spi_m_async_set_mode+0x10>
   115b8:	6800      	ldr	r0, [r0, #0]
   115ba:	3800      	subs	r0, #0
   115bc:	bf18      	it	ne
   115be:	2001      	movne	r0, #1
   115c0:	4905      	ldr	r1, [pc, #20]	; (115d8 <_spi_m_async_set_mode+0x28>)
   115c2:	4b06      	ldr	r3, [pc, #24]	; (115dc <_spi_m_async_set_mode+0x2c>)
   115c4:	f640 3216 	movw	r2, #2838	; 0xb16
   115c8:	4798      	blx	r3
	return _spi_set_mode(dev->prvt, mode);
   115ca:	6820      	ldr	r0, [r4, #0]
   115cc:	4b04      	ldr	r3, [pc, #16]	; (115e0 <_spi_m_async_set_mode+0x30>)
   115ce:	4629      	mov	r1, r5
}
   115d0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_set_mode(dev->prvt, mode);
   115d4:	4718      	bx	r3
   115d6:	bf00      	nop
   115d8:	0001656d 	.word	0x0001656d
   115dc:	0000e03d 	.word	0x0000e03d
   115e0:	00010d6d 	.word	0x00010d6d

000115e4 <_spi_m_async_set_baudrate>:
{
   115e4:	b538      	push	{r3, r4, r5, lr}
   115e6:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   115e8:	4604      	mov	r4, r0
   115ea:	b118      	cbz	r0, 115f4 <_spi_m_async_set_baudrate+0x10>
   115ec:	6800      	ldr	r0, [r0, #0]
   115ee:	3800      	subs	r0, #0
   115f0:	bf18      	it	ne
   115f2:	2001      	movne	r0, #1
   115f4:	4907      	ldr	r1, [pc, #28]	; (11614 <_spi_m_async_set_baudrate+0x30>)
   115f6:	4b08      	ldr	r3, [pc, #32]	; (11618 <_spi_m_async_set_baudrate+0x34>)
   115f8:	f640 3245 	movw	r2, #2885	; 0xb45
   115fc:	4798      	blx	r3
	return _spi_set_baudrate(dev->prvt, baud_val);
   115fe:	6823      	ldr	r3, [r4, #0]
   11600:	69d8      	ldr	r0, [r3, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   11602:	f010 0001 	ands.w	r0, r0, #1
	hri_sercomspi_write_BAUD_reg(hw, baud_val);
   11606:	bf06      	itte	eq
   11608:	b2ed      	uxtbeq	r5, r5
	((Sercom *)hw)->SPI.BAUD.reg = data;
   1160a:	731d      	strbeq	r5, [r3, #12]
		return ERR_BUSY;
   1160c:	f06f 0003 	mvnne.w	r0, #3
}
   11610:	bd38      	pop	{r3, r4, r5, pc}
   11612:	bf00      	nop
   11614:	0001656d 	.word	0x0001656d
   11618:	0000e03d 	.word	0x0000e03d

0001161c <_spi_m_async_enable_tx>:
{
   1161c:	b538      	push	{r3, r4, r5, lr}
	void *hw = dev->prvt;
   1161e:	6804      	ldr	r4, [r0, #0]
	ASSERT(dev && hw);
   11620:	4b07      	ldr	r3, [pc, #28]	; (11640 <_spi_m_async_enable_tx+0x24>)
   11622:	1e20      	subs	r0, r4, #0
{
   11624:	460d      	mov	r5, r1
	ASSERT(dev && hw);
   11626:	f640 4208 	movw	r2, #3080	; 0xc08
   1162a:	4906      	ldr	r1, [pc, #24]	; (11644 <_spi_m_async_enable_tx+0x28>)
   1162c:	bf18      	it	ne
   1162e:	2001      	movne	r0, #1
   11630:	4798      	blx	r3
	if (state) {
   11632:	2301      	movs	r3, #1
   11634:	b115      	cbz	r5, 1163c <_spi_m_async_enable_tx+0x20>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_DRE;
   11636:	75a3      	strb	r3, [r4, #22]
}
   11638:	2000      	movs	r0, #0
   1163a:	bd38      	pop	{r3, r4, r5, pc}
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_DRE;
   1163c:	7523      	strb	r3, [r4, #20]
}
   1163e:	e7fb      	b.n	11638 <_spi_m_async_enable_tx+0x1c>
   11640:	0000e03d 	.word	0x0000e03d
   11644:	0001656d 	.word	0x0001656d

00011648 <_spi_m_async_enable_rx>:
{
   11648:	b570      	push	{r4, r5, r6, lr}
	void *hw = dev->prvt;
   1164a:	6804      	ldr	r4, [r0, #0]
	ASSERT(dev);
   1164c:	4e0a      	ldr	r6, [pc, #40]	; (11678 <_spi_m_async_enable_rx+0x30>)
   1164e:	f640 421c 	movw	r2, #3100	; 0xc1c
   11652:	2001      	movs	r0, #1
{
   11654:	460d      	mov	r5, r1
	ASSERT(dev);
   11656:	4909      	ldr	r1, [pc, #36]	; (1167c <_spi_m_async_enable_rx+0x34>)
   11658:	47b0      	blx	r6
	ASSERT(hw);
   1165a:	1e20      	subs	r0, r4, #0
   1165c:	4907      	ldr	r1, [pc, #28]	; (1167c <_spi_m_async_enable_rx+0x34>)
   1165e:	f640 421d 	movw	r2, #3101	; 0xc1d
   11662:	bf18      	it	ne
   11664:	2001      	movne	r0, #1
   11666:	47b0      	blx	r6
	if (state) {
   11668:	2304      	movs	r3, #4
   1166a:	b115      	cbz	r5, 11672 <_spi_m_async_enable_rx+0x2a>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_RXC;
   1166c:	75a3      	strb	r3, [r4, #22]
}
   1166e:	2000      	movs	r0, #0
   11670:	bd70      	pop	{r4, r5, r6, pc}
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_RXC;
   11672:	7523      	strb	r3, [r4, #20]
}
   11674:	e7fb      	b.n	1166e <_spi_m_async_enable_rx+0x26>
   11676:	bf00      	nop
   11678:	0000e03d 	.word	0x0000e03d
   1167c:	0001656d 	.word	0x0001656d

00011680 <_spi_m_async_enable_tx_complete>:
{
   11680:	b538      	push	{r3, r4, r5, lr}
   11682:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   11684:	4604      	mov	r4, r0
   11686:	b118      	cbz	r0, 11690 <_spi_m_async_enable_tx_complete+0x10>
   11688:	6800      	ldr	r0, [r0, #0]
   1168a:	3800      	subs	r0, #0
   1168c:	bf18      	it	ne
   1168e:	2001      	movne	r0, #1
   11690:	4b06      	ldr	r3, [pc, #24]	; (116ac <_spi_m_async_enable_tx_complete+0x2c>)
   11692:	4907      	ldr	r1, [pc, #28]	; (116b0 <_spi_m_async_enable_tx_complete+0x30>)
   11694:	f640 422f 	movw	r2, #3119	; 0xc2f
   11698:	4798      	blx	r3
	if (state) {
   1169a:	6823      	ldr	r3, [r4, #0]
   1169c:	2202      	movs	r2, #2
   1169e:	b115      	cbz	r5, 116a6 <_spi_m_async_enable_tx_complete+0x26>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_TXC;
   116a0:	759a      	strb	r2, [r3, #22]
}
   116a2:	2000      	movs	r0, #0
   116a4:	bd38      	pop	{r3, r4, r5, pc}
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_TXC;
   116a6:	751a      	strb	r2, [r3, #20]
}
   116a8:	e7fb      	b.n	116a2 <_spi_m_async_enable_tx_complete+0x22>
   116aa:	bf00      	nop
   116ac:	0000e03d 	.word	0x0000e03d
   116b0:	0001656d 	.word	0x0001656d

000116b4 <_spi_m_async_write_one>:
{
   116b4:	b538      	push	{r3, r4, r5, lr}
   116b6:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   116b8:	4604      	mov	r4, r0
   116ba:	b118      	cbz	r0, 116c4 <_spi_m_async_write_one+0x10>
   116bc:	6800      	ldr	r0, [r0, #0]
   116be:	3800      	subs	r0, #0
   116c0:	bf18      	it	ne
   116c2:	2001      	movne	r0, #1
   116c4:	4904      	ldr	r1, [pc, #16]	; (116d8 <_spi_m_async_write_one+0x24>)
   116c6:	4b05      	ldr	r3, [pc, #20]	; (116dc <_spi_m_async_write_one+0x28>)
   116c8:	f640 4241 	movw	r2, #3137	; 0xc41
   116cc:	4798      	blx	r3
	hri_sercomspi_write_DATA_reg(dev->prvt, data);
   116ce:	6823      	ldr	r3, [r4, #0]
}
   116d0:	2000      	movs	r0, #0
	((Sercom *)hw)->SPI.DATA.reg = data;
   116d2:	629d      	str	r5, [r3, #40]	; 0x28
   116d4:	bd38      	pop	{r3, r4, r5, pc}
   116d6:	bf00      	nop
   116d8:	0001656d 	.word	0x0001656d
   116dc:	0000e03d 	.word	0x0000e03d

000116e0 <_spi_m_async_read_one>:
{
   116e0:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
   116e2:	4604      	mov	r4, r0
   116e4:	b118      	cbz	r0, 116ee <_spi_m_async_read_one+0xe>
   116e6:	6800      	ldr	r0, [r0, #0]
   116e8:	3800      	subs	r0, #0
   116ea:	bf18      	it	ne
   116ec:	2001      	movne	r0, #1
   116ee:	4904      	ldr	r1, [pc, #16]	; (11700 <_spi_m_async_read_one+0x20>)
   116f0:	4b04      	ldr	r3, [pc, #16]	; (11704 <_spi_m_async_read_one+0x24>)
   116f2:	f640 425c 	movw	r2, #3164	; 0xc5c
   116f6:	4798      	blx	r3
	return hri_sercomspi_read_DATA_reg(dev->prvt);
   116f8:	6823      	ldr	r3, [r4, #0]
	return ((Sercom *)hw)->SPI.DATA.reg;
   116fa:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
   116fc:	b280      	uxth	r0, r0
   116fe:	bd10      	pop	{r4, pc}
   11700:	0001656d 	.word	0x0001656d
   11704:	0000e03d 	.word	0x0000e03d

00011708 <_spi_m_async_register_callback>:
{
   11708:	b570      	push	{r4, r5, r6, lr}
   1170a:	460d      	mov	r5, r1
   1170c:	4616      	mov	r6, r2
	ASSERT(dev && (cb_type < SPI_DEV_CB_N));
   1170e:	4604      	mov	r4, r0
   11710:	b118      	cbz	r0, 1171a <_spi_m_async_register_callback+0x12>
   11712:	2903      	cmp	r1, #3
   11714:	bf8c      	ite	hi
   11716:	2000      	movhi	r0, #0
   11718:	2001      	movls	r0, #1
   1171a:	4905      	ldr	r1, [pc, #20]	; (11730 <_spi_m_async_register_callback+0x28>)
   1171c:	4b05      	ldr	r3, [pc, #20]	; (11734 <_spi_m_async_register_callback+0x2c>)
   1171e:	f640 4275 	movw	r2, #3189	; 0xc75
   11722:	4798      	blx	r3
	p_ls[cb_type] = (func_t)func;
   11724:	eb04 0185 	add.w	r1, r4, r5, lsl #2
}
   11728:	2000      	movs	r0, #0
	p_ls[cb_type] = (func_t)func;
   1172a:	608e      	str	r6, [r1, #8]
}
   1172c:	bd70      	pop	{r4, r5, r6, pc}
   1172e:	bf00      	nop
   11730:	0001656d 	.word	0x0001656d
   11734:	0000e03d 	.word	0x0000e03d

00011738 <_spi_m_async_set_irq_state>:
{
   11738:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
   1173a:	4604      	mov	r4, r0
   1173c:	3800      	subs	r0, #0
{
   1173e:	460e      	mov	r6, r1
	ASSERT(device);
   11740:	bf18      	it	ne
   11742:	2001      	movne	r0, #1
   11744:	4907      	ldr	r1, [pc, #28]	; (11764 <_spi_m_async_set_irq_state+0x2c>)
   11746:	4b08      	ldr	r3, [pc, #32]	; (11768 <_spi_m_async_set_irq_state+0x30>)
{
   11748:	4615      	mov	r5, r2
	ASSERT(device);
   1174a:	f640 42b6 	movw	r2, #3254	; 0xcb6
   1174e:	4798      	blx	r3
	if (SPI_DEV_CB_ERROR == type) {
   11750:	2e03      	cmp	r6, #3
   11752:	d103      	bne.n	1175c <_spi_m_async_set_irq_state+0x24>
		hri_sercomspi_write_INTEN_ERROR_bit(device->prvt, state);
   11754:	6823      	ldr	r3, [r4, #0]
	if (value == 0x0) {
   11756:	2280      	movs	r2, #128	; 0x80
   11758:	b90d      	cbnz	r5, 1175e <_spi_m_async_set_irq_state+0x26>
		((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_ERROR;
   1175a:	751a      	strb	r2, [r3, #20]
}
   1175c:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_ERROR;
   1175e:	759a      	strb	r2, [r3, #22]
   11760:	e7fc      	b.n	1175c <_spi_m_async_set_irq_state+0x24>
   11762:	bf00      	nop
   11764:	0001656d 	.word	0x0001656d
   11768:	0000e03d 	.word	0x0000e03d

0001176c <_spi_m_dma_init>:

int32_t _spi_m_dma_init(struct _spi_m_dma_dev *dev, void *const hw)
{
   1176c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11770:	4b25      	ldr	r3, [pc, #148]	; (11808 <_spi_m_dma_init+0x9c>)
{
   11772:	4605      	mov	r5, r0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11774:	4608      	mov	r0, r1
{
   11776:	460c      	mov	r4, r1
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11778:	4798      	blx	r3
   1177a:	4606      	mov	r6, r0

	ASSERT(dev && hw);
   1177c:	2d00      	cmp	r5, #0
   1177e:	d03e      	beq.n	117fe <_spi_m_dma_init+0x92>
   11780:	1e20      	subs	r0, r4, #0
   11782:	bf18      	it	ne
   11784:	2001      	movne	r0, #1
   11786:	4921      	ldr	r1, [pc, #132]	; (1180c <_spi_m_dma_init+0xa0>)
   11788:	4b21      	ldr	r3, [pc, #132]	; (11810 <_spi_m_dma_init+0xa4>)
   1178a:	f640 52e3 	movw	r2, #3555	; 0xde3
   1178e:	4798      	blx	r3

	if (regs == NULL) {
   11790:	2e00      	cmp	r6, #0
   11792:	d036      	beq.n	11802 <_spi_m_dma_init+0x96>
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   11794:	69e3      	ldr	r3, [r4, #28]
   11796:	f8df 8094 	ldr.w	r8, [pc, #148]	; 1182c <_spi_m_dma_init+0xc0>
		return ERR_INVALID_ARG;
	}

	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   1179a:	f013 0f01 	tst.w	r3, #1
   1179e:	d112      	bne.n	117c6 <_spi_m_dma_init+0x5a>
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   117a0:	2103      	movs	r1, #3
   117a2:	4620      	mov	r0, r4
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   117a4:	6837      	ldr	r7, [r6, #0]
   117a6:	47c0      	blx	r8
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
   117a8:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   117aa:	079b      	lsls	r3, r3, #30
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   117ac:	f007 071c 	and.w	r7, r7, #28
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   117b0:	d503      	bpl.n	117ba <_spi_m_dma_init+0x4e>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
   117b2:	4b18      	ldr	r3, [pc, #96]	; (11814 <_spi_m_dma_init+0xa8>)
   117b4:	4798      	blx	r3
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
   117b6:	2102      	movs	r1, #2
   117b8:	47c0      	blx	r8
		}
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
   117ba:	f047 0701 	orr.w	r7, r7, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   117be:	6027      	str	r7, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   117c0:	2103      	movs	r1, #3
   117c2:	4620      	mov	r0, r4
   117c4:	47c0      	blx	r8
	}
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);

	dev->prvt = hw;
   117c6:	462f      	mov	r7, r5
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);
   117c8:	4620      	mov	r0, r4
   117ca:	2101      	movs	r1, #1
   117cc:	47c0      	blx	r8

	_spi_load_regs_master(hw, regs);
   117ce:	4631      	mov	r1, r6
	dev->prvt = hw;
   117d0:	f847 4b18 	str.w	r4, [r7], #24
	_spi_load_regs_master(hw, regs);
   117d4:	4b10      	ldr	r3, [pc, #64]	; (11818 <_spi_m_dma_init+0xac>)
   117d6:	4798      	blx	r3
	uint8_t index = _sercom_get_hardware_index(hw);
   117d8:	4b10      	ldr	r3, [pc, #64]	; (1181c <_spi_m_dma_init+0xb0>)
   117da:	4620      	mov	r0, r4
   117dc:	4798      	blx	r3
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   117de:	2807      	cmp	r0, #7
		dev->resource->back                 = dev;
		dev->resource->dma_cb.transfer_done = _spi_dma_rx_complete;
		dev->resource->dma_cb.error         = _spi_dma_error_occured;
	}
	/* Initialize DMA tx channel */
	_dma_get_channel_resource(&dev->resource, _spi_get_tx_dma_channel(hw));
   117e0:	4b0f      	ldr	r3, [pc, #60]	; (11820 <_spi_m_dma_init+0xb4>)
   117e2:	bf0c      	ite	eq
   117e4:	2108      	moveq	r1, #8
   117e6:	2100      	movne	r1, #0
   117e8:	4638      	mov	r0, r7
   117ea:	4798      	blx	r3
	dev->resource->back                 = dev;
   117ec:	69ab      	ldr	r3, [r5, #24]
	dev->resource->dma_cb.transfer_done = _spi_dma_tx_complete;
   117ee:	4a0d      	ldr	r2, [pc, #52]	; (11824 <_spi_m_dma_init+0xb8>)
   117f0:	601a      	str	r2, [r3, #0]
	dev->resource->dma_cb.error         = _spi_dma_error_occured;
   117f2:	4a0d      	ldr	r2, [pc, #52]	; (11828 <_spi_m_dma_init+0xbc>)
	dev->resource->back                 = dev;
   117f4:	609d      	str	r5, [r3, #8]
	dev->resource->dma_cb.error         = _spi_dma_error_occured;
   117f6:	605a      	str	r2, [r3, #4]

	return ERR_NONE;
   117f8:	2000      	movs	r0, #0
}
   117fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(dev && hw);
   117fe:	4628      	mov	r0, r5
   11800:	e7c1      	b.n	11786 <_spi_m_dma_init+0x1a>
		return ERR_INVALID_ARG;
   11802:	f06f 000c 	mvn.w	r0, #12
   11806:	e7f8      	b.n	117fa <_spi_m_dma_init+0x8e>
   11808:	00010a85 	.word	0x00010a85
   1180c:	0001656d 	.word	0x0001656d
   11810:	0000e03d 	.word	0x0000e03d
   11814:	000108ed 	.word	0x000108ed
   11818:	00010da1 	.word	0x00010da1
   1181c:	00010941 	.word	0x00010941
   11820:	0000e281 	.word	0x0000e281
   11824:	00010ab1 	.word	0x00010ab1
   11828:	00010abb 	.word	0x00010abb
   1182c:	000108c9 	.word	0x000108c9

00011830 <_spi_m_dma_enable>:
{
	return _spi_deinit(dev->prvt);
}

int32_t _spi_m_dma_enable(struct _spi_m_dma_dev *dev)
{
   11830:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
   11832:	4604      	mov	r4, r0
   11834:	b118      	cbz	r0, 1183e <_spi_m_dma_enable+0xe>
   11836:	6800      	ldr	r0, [r0, #0]
   11838:	3800      	subs	r0, #0
   1183a:	bf18      	it	ne
   1183c:	2001      	movne	r0, #1
   1183e:	4b05      	ldr	r3, [pc, #20]	; (11854 <_spi_m_dma_enable+0x24>)
   11840:	4905      	ldr	r1, [pc, #20]	; (11858 <_spi_m_dma_enable+0x28>)
   11842:	f640 620e 	movw	r2, #3598	; 0xe0e
   11846:	4798      	blx	r3

	return _spi_sync_enable(dev->prvt);
   11848:	6820      	ldr	r0, [r4, #0]
   1184a:	4b04      	ldr	r3, [pc, #16]	; (1185c <_spi_m_dma_enable+0x2c>)
}
   1184c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _spi_sync_enable(dev->prvt);
   11850:	4718      	bx	r3
   11852:	bf00      	nop
   11854:	0000e03d 	.word	0x0000e03d
   11858:	0001656d 	.word	0x0001656d
   1185c:	00010a5d 	.word	0x00010a5d

00011860 <_spi_m_dma_register_callback>:
	return size;
}

void _spi_m_dma_register_callback(struct _spi_m_dma_dev *dev, enum _spi_dma_dev_cb_type type, _spi_dma_cb_t func)
{
	switch (type) {
   11860:	2901      	cmp	r1, #1
{
   11862:	b573      	push	{r0, r1, r4, r5, r6, lr}
   11864:	4605      	mov	r5, r0
   11866:	460e      	mov	r6, r1
   11868:	4614      	mov	r4, r2
	switch (type) {
   1186a:	d014      	beq.n	11896 <_spi_m_dma_register_callback+0x36>
   1186c:	2902      	cmp	r1, #2
   1186e:	d020      	beq.n	118b2 <_spi_m_dma_register_callback+0x52>
   11870:	2900      	cmp	r1, #0
   11872:	d138      	bne.n	118e6 <_spi_m_dma_register_callback+0x86>
	case SPI_DEV_CB_DMA_TX:
		dev->callbacks.tx = func;
   11874:	6042      	str	r2, [r0, #4]
	uint8_t index = _sercom_get_hardware_index(hw);
   11876:	4b1d      	ldr	r3, [pc, #116]	; (118ec <_spi_m_dma_register_callback+0x8c>)
   11878:	6800      	ldr	r0, [r0, #0]
   1187a:	4798      	blx	r3
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   1187c:	2807      	cmp	r0, #7
   1187e:	bf08      	it	eq
   11880:	2608      	moveq	r6, #8
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_COMPLETE_CB, func != NULL);
   11882:	1e22      	subs	r2, r4, #0
   11884:	bf18      	it	ne
   11886:	2201      	movne	r2, #1
   11888:	2100      	movs	r1, #0
   1188a:	4630      	mov	r0, r6
		break;
	case SPI_DEV_CB_DMA_RX:
		dev->callbacks.rx = func;
		_dma_set_irq_state(_spi_get_rx_dma_channel(dev->prvt), DMA_TRANSFER_COMPLETE_CB, func != NULL);
   1188c:	4b18      	ldr	r3, [pc, #96]	; (118f0 <_spi_m_dma_register_callback+0x90>)
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
		break;
	case SPI_DEV_CB_DMA_N:
		break;
	}
}
   1188e:	b002      	add	sp, #8
   11890:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
   11894:	4718      	bx	r3
		dev->callbacks.rx = func;
   11896:	6082      	str	r2, [r0, #8]
	uint8_t index = _sercom_get_hardware_index(hw);
   11898:	4b14      	ldr	r3, [pc, #80]	; (118ec <_spi_m_dma_register_callback+0x8c>)
   1189a:	6800      	ldr	r0, [r0, #0]
   1189c:	4798      	blx	r3
		_dma_set_irq_state(_spi_get_rx_dma_channel(dev->prvt), DMA_TRANSFER_COMPLETE_CB, func != NULL);
   1189e:	1e22      	subs	r2, r4, #0
   118a0:	bf18      	it	ne
   118a2:	2201      	movne	r2, #1
   118a4:	2807      	cmp	r0, #7
   118a6:	f04f 0100 	mov.w	r1, #0
   118aa:	bf8c      	ite	hi
   118ac:	2000      	movhi	r0, #0
   118ae:	2001      	movls	r0, #1
   118b0:	e7ec      	b.n	1188c <_spi_m_dma_register_callback+0x2c>
		dev->callbacks.error = func;
   118b2:	60c2      	str	r2, [r0, #12]
	uint8_t index = _sercom_get_hardware_index(hw);
   118b4:	4e0d      	ldr	r6, [pc, #52]	; (118ec <_spi_m_dma_register_callback+0x8c>)
   118b6:	6800      	ldr	r0, [r0, #0]
   118b8:	47b0      	blx	r6
		_dma_set_irq_state(_spi_get_rx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
   118ba:	1e22      	subs	r2, r4, #0
   118bc:	bf18      	it	ne
   118be:	2201      	movne	r2, #1
   118c0:	2807      	cmp	r0, #7
   118c2:	bf8c      	ite	hi
   118c4:	2000      	movhi	r0, #0
   118c6:	2001      	movls	r0, #1
   118c8:	2101      	movs	r1, #1
   118ca:	4c09      	ldr	r4, [pc, #36]	; (118f0 <_spi_m_dma_register_callback+0x90>)
   118cc:	9201      	str	r2, [sp, #4]
   118ce:	47a0      	blx	r4
	uint8_t index = _sercom_get_hardware_index(hw);
   118d0:	6828      	ldr	r0, [r5, #0]
   118d2:	47b0      	blx	r6
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   118d4:	2807      	cmp	r0, #7
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
   118d6:	9a01      	ldr	r2, [sp, #4]
   118d8:	f04f 0101 	mov.w	r1, #1
   118dc:	bf0c      	ite	eq
   118de:	2008      	moveq	r0, #8
   118e0:	2000      	movne	r0, #0
   118e2:	4623      	mov	r3, r4
   118e4:	e7d3      	b.n	1188e <_spi_m_dma_register_callback+0x2e>
}
   118e6:	b002      	add	sp, #8
   118e8:	bd70      	pop	{r4, r5, r6, pc}
   118ea:	bf00      	nop
   118ec:	00010941 	.word	0x00010941
   118f0:	0000e19d 	.word	0x0000e19d

000118f4 <_spi_m_dma_transfer>:

int32_t _spi_m_dma_transfer(struct _spi_m_dma_dev *dev, uint8_t const *txbuf, uint8_t *const rxbuf,
                            const uint16_t length)
{
   118f4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const struct sercomspi_regs_cfg *regs  = _spi_get_regs((uint32_t)dev->prvt);
   118f8:	f8d0 8000 	ldr.w	r8, [r0]
	uint8_t index = _sercom_get_hardware_index(hw);
   118fc:	f8df 911c 	ldr.w	r9, [pc, #284]	; 11a1c <_spi_m_dma_transfer+0x128>
{
   11900:	4605      	mov	r5, r0
   11902:	461f      	mov	r7, r3
	uint8_t index = _sercom_get_hardware_index(hw);
   11904:	4640      	mov	r0, r8
   11906:	4b3d      	ldr	r3, [pc, #244]	; (119fc <_spi_m_dma_transfer+0x108>)
{
   11908:	460e      	mov	r6, r1
   1190a:	4692      	mov	sl, r2
	uint8_t index = _sercom_get_hardware_index(hw);
   1190c:	4798      	blx	r3
	switch (index) {
   1190e:	2807      	cmp	r0, #7
   11910:	4b3b      	ldr	r3, [pc, #236]	; (11a00 <_spi_m_dma_transfer+0x10c>)
   11912:	d86a      	bhi.n	119ea <_spi_m_dma_transfer+0xf6>
	switch (index) {
   11914:	d06c      	beq.n	119f0 <_spi_m_dma_transfer+0xfc>
		return CONF_SERCOM_0_SPI_M_DMA_RX_CHANNEL;
   11916:	f04f 0b01 	mov.w	fp, #1
	uint8_t                          rx_ch = _spi_get_rx_dma_channel(dev->prvt);
	uint8_t                          tx_ch = _spi_get_tx_dma_channel(dev->prvt);

	if (rxbuf) {
   1191a:	f1ba 0f00 	cmp.w	sl, #0
   1191e:	d114      	bne.n	1194a <_spi_m_dma_transfer+0x56>
   11920:	4654      	mov	r4, sl
	ASSERT(dev && dev->prvt);
   11922:	f1b8 0000 	subs.w	r0, r8, #0
   11926:	bf18      	it	ne
   11928:	2001      	movne	r0, #1
   1192a:	4936      	ldr	r1, [pc, #216]	; (11a04 <_spi_m_dma_transfer+0x110>)
   1192c:	f640 523d 	movw	r2, #3389	; 0xd3d
   11930:	4798      	blx	r3
	return _spi_sync_rx_disable(dev->prvt);
   11932:	6828      	ldr	r0, [r5, #0]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   11934:	69c3      	ldr	r3, [r0, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_CTRLB)) {
   11936:	075b      	lsls	r3, r3, #29
   11938:	d42b      	bmi.n	11992 <_spi_m_dma_transfer+0x9e>
	((Sercom *)hw)->SPI.CTRLB.reg &= ~SERCOM_SPI_CTRLB_RXEN;
   1193a:	6843      	ldr	r3, [r0, #4]
   1193c:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   11940:	6043      	str	r3, [r0, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   11942:	2117      	movs	r1, #23
   11944:	4b30      	ldr	r3, [pc, #192]	; (11a08 <_spi_m_dma_transfer+0x114>)
   11946:	4798      	blx	r3
}
   11948:	e023      	b.n	11992 <_spi_m_dma_transfer+0x9e>
	if (rxbuf) {
   1194a:	2400      	movs	r4, #0
	ASSERT(dev && dev->prvt);
   1194c:	f1b8 0000 	subs.w	r0, r8, #0
   11950:	bf18      	it	ne
   11952:	2001      	movne	r0, #1
   11954:	f640 5236 	movw	r2, #3382	; 0xd36
   11958:	492a      	ldr	r1, [pc, #168]	; (11a04 <_spi_m_dma_transfer+0x110>)
   1195a:	4798      	blx	r3
	return _spi_sync_rx_enable(dev->prvt);
   1195c:	6828      	ldr	r0, [r5, #0]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   1195e:	69c3      	ldr	r3, [r0, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_CTRLB)) {
   11960:	075a      	lsls	r2, r3, #29
   11962:	d406      	bmi.n	11972 <_spi_m_dma_transfer+0x7e>
	((Sercom *)hw)->SPI.CTRLB.reg |= SERCOM_SPI_CTRLB_RXEN;
   11964:	6843      	ldr	r3, [r0, #4]
   11966:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1196a:	6043      	str	r3, [r0, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   1196c:	2117      	movs	r1, #23
   1196e:	4b26      	ldr	r3, [pc, #152]	; (11a08 <_spi_m_dma_transfer+0x114>)
   11970:	4798      	blx	r3
	return (uint32_t) & (((Sercom *)hw)->SPI.DATA);
   11972:	6829      	ldr	r1, [r5, #0]
		/* Enable spi rx */
		_spi_m_dma_rx_enable(dev);
		_dma_set_source_address(rx_ch, (void *)_spi_m_get_source_for_dma(dev->prvt));
   11974:	4b25      	ldr	r3, [pc, #148]	; (11a0c <_spi_m_dma_transfer+0x118>)
   11976:	3128      	adds	r1, #40	; 0x28
   11978:	4658      	mov	r0, fp
   1197a:	4798      	blx	r3
		_dma_set_destination_address(rx_ch, rxbuf);
   1197c:	4651      	mov	r1, sl
   1197e:	4658      	mov	r0, fp
   11980:	47c8      	blx	r9
		_dma_set_data_amount(rx_ch, length);
   11982:	4b23      	ldr	r3, [pc, #140]	; (11a10 <_spi_m_dma_transfer+0x11c>)
   11984:	4639      	mov	r1, r7
   11986:	4658      	mov	r0, fp
   11988:	4798      	blx	r3
		_dma_enable_transaction(rx_ch, false);
   1198a:	4b22      	ldr	r3, [pc, #136]	; (11a14 <_spi_m_dma_transfer+0x120>)
   1198c:	2100      	movs	r1, #0
   1198e:	4658      	mov	r0, fp
   11990:	4798      	blx	r3
	} else {
		/* Disable spi rx */
		_spi_m_dma_rx_disable(dev);
	}

	if (txbuf) {
   11992:	f8df a07c 	ldr.w	sl, [pc, #124]	; 11a10 <_spi_m_dma_transfer+0x11c>
   11996:	f8df b088 	ldr.w	fp, [pc, #136]	; 11a20 <_spi_m_dma_transfer+0x12c>
   1199a:	b1c6      	cbz	r6, 119ce <_spi_m_dma_transfer+0xda>
		/* Enable spi tx */
		_dma_set_source_address(tx_ch, txbuf);
   1199c:	4b1b      	ldr	r3, [pc, #108]	; (11a0c <_spi_m_dma_transfer+0x118>)
   1199e:	4631      	mov	r1, r6
   119a0:	4620      	mov	r0, r4
   119a2:	4798      	blx	r3
	return (uint32_t) & (((Sercom *)hw)->SPI.DATA);
   119a4:	6829      	ldr	r1, [r5, #0]
		_dma_set_destination_address(tx_ch, (void *)_spi_m_get_destination_for_dma(dev->prvt));
   119a6:	4620      	mov	r0, r4
   119a8:	3128      	adds	r1, #40	; 0x28
   119aa:	47c8      	blx	r9
		_dma_srcinc_enable(tx_ch, true);
   119ac:	2101      	movs	r1, #1
		_dma_set_data_amount(tx_ch, length);
	} else {
		_dma_set_source_address(tx_ch, &regs->dummy_byte);
		_dma_set_destination_address(tx_ch, (void *)_spi_m_get_destination_for_dma(dev->prvt));
		_dma_srcinc_enable(tx_ch, false);
   119ae:	4620      	mov	r0, r4
   119b0:	47d8      	blx	fp
		_dma_set_data_amount(tx_ch, length);
   119b2:	4639      	mov	r1, r7
   119b4:	4620      	mov	r0, r4
   119b6:	47d0      	blx	sl
	}
	_dma_enable_transaction(tx_ch, false);
   119b8:	4b16      	ldr	r3, [pc, #88]	; (11a14 <_spi_m_dma_transfer+0x120>)
   119ba:	2100      	movs	r1, #0
   119bc:	4620      	mov	r0, r4
   119be:	4798      	blx	r3

	return ERR_NONE;
}
   119c0:	2000      	movs	r0, #0
   119c2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return CONF_SERCOM_0_SPI_M_DMA_RX_CHANNEL;
   119c6:	f04f 0b01 	mov.w	fp, #1
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   119ca:	2408      	movs	r4, #8
   119cc:	e7be      	b.n	1194c <_spi_m_dma_transfer+0x58>
	const struct sercomspi_regs_cfg *regs  = _spi_get_regs((uint32_t)dev->prvt);
   119ce:	4b12      	ldr	r3, [pc, #72]	; (11a18 <_spi_m_dma_transfer+0x124>)
   119d0:	4640      	mov	r0, r8
   119d2:	4798      	blx	r3
		_dma_set_source_address(tx_ch, &regs->dummy_byte);
   119d4:	4b0d      	ldr	r3, [pc, #52]	; (11a0c <_spi_m_dma_transfer+0x118>)
   119d6:	f100 010e 	add.w	r1, r0, #14
   119da:	4620      	mov	r0, r4
   119dc:	4798      	blx	r3
	return (uint32_t) & (((Sercom *)hw)->SPI.DATA);
   119de:	6829      	ldr	r1, [r5, #0]
		_dma_set_destination_address(tx_ch, (void *)_spi_m_get_destination_for_dma(dev->prvt));
   119e0:	4620      	mov	r0, r4
   119e2:	3128      	adds	r1, #40	; 0x28
   119e4:	47c8      	blx	r9
		_dma_srcinc_enable(tx_ch, false);
   119e6:	4631      	mov	r1, r6
   119e8:	e7e1      	b.n	119ae <_spi_m_dma_transfer+0xba>
		return CONF_SERCOM_0_SPI_M_DMA_TX_CHANNEL;
   119ea:	f04f 0b00 	mov.w	fp, #0
   119ee:	e794      	b.n	1191a <_spi_m_dma_transfer+0x26>
	if (rxbuf) {
   119f0:	f1ba 0f00 	cmp.w	sl, #0
   119f4:	d1e7      	bne.n	119c6 <_spi_m_dma_transfer+0xd2>
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   119f6:	2408      	movs	r4, #8
   119f8:	e793      	b.n	11922 <_spi_m_dma_transfer+0x2e>
   119fa:	bf00      	nop
   119fc:	00010941 	.word	0x00010941
   11a00:	0000e03d 	.word	0x0000e03d
   11a04:	0001656d 	.word	0x0001656d
   11a08:	000108c9 	.word	0x000108c9
   11a0c:	0000e1d5 	.word	0x0000e1d5
   11a10:	0000e201 	.word	0x0000e201
   11a14:	0000e245 	.word	0x0000e245
   11a18:	00010a85 	.word	0x00010a85
   11a1c:	0000e1c5 	.word	0x0000e1c5
   11a20:	0000e1e5 	.word	0x0000e1e5

00011a24 <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
   11a24:	b570      	push	{r4, r5, r6, lr}
   11a26:	460e      	mov	r6, r1
   11a28:	4614      	mov	r4, r2
	ASSERT(rb && buf && size);
   11a2a:	4605      	mov	r5, r0
   11a2c:	b118      	cbz	r0, 11a36 <ringbuffer_init+0x12>
   11a2e:	b189      	cbz	r1, 11a54 <ringbuffer_init+0x30>
   11a30:	1e10      	subs	r0, r2, #0
   11a32:	bf18      	it	ne
   11a34:	2001      	movne	r0, #1
   11a36:	4908      	ldr	r1, [pc, #32]	; (11a58 <ringbuffer_init+0x34>)
   11a38:	4b08      	ldr	r3, [pc, #32]	; (11a5c <ringbuffer_init+0x38>)
   11a3a:	2228      	movs	r2, #40	; 0x28
   11a3c:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
   11a3e:	1e63      	subs	r3, r4, #1
   11a40:	ea13 0004 	ands.w	r0, r3, r4
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
	rb->read_index  = 0;
   11a44:	bf03      	ittte	eq
   11a46:	e9c5 3001 	strdeq	r3, r0, [r5, #4]
	rb->write_index = rb->read_index;
   11a4a:	60e8      	streq	r0, [r5, #12]
	rb->buf         = (uint8_t *)buf;
   11a4c:	602e      	streq	r6, [r5, #0]
		return ERR_INVALID_ARG;
   11a4e:	f06f 000c 	mvnne.w	r0, #12

	return ERR_NONE;
}
   11a52:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
   11a54:	4608      	mov	r0, r1
   11a56:	e7ee      	b.n	11a36 <ringbuffer_init+0x12>
   11a58:	0001665c 	.word	0x0001665c
   11a5c:	0000e03d 	.word	0x0000e03d

00011a60 <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
   11a60:	b538      	push	{r3, r4, r5, lr}
   11a62:	460d      	mov	r5, r1
	ASSERT(rb && data);
   11a64:	4604      	mov	r4, r0
   11a66:	b110      	cbz	r0, 11a6e <ringbuffer_get+0xe>
   11a68:	1e08      	subs	r0, r1, #0
   11a6a:	bf18      	it	ne
   11a6c:	2001      	movne	r0, #1
   11a6e:	4b0a      	ldr	r3, [pc, #40]	; (11a98 <ringbuffer_get+0x38>)
   11a70:	490a      	ldr	r1, [pc, #40]	; (11a9c <ringbuffer_get+0x3c>)
   11a72:	2240      	movs	r2, #64	; 0x40
   11a74:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
   11a76:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   11a7a:	429a      	cmp	r2, r3
   11a7c:	d009      	beq.n	11a92 <ringbuffer_get+0x32>
		*data = rb->buf[rb->read_index & rb->size];
   11a7e:	6862      	ldr	r2, [r4, #4]
   11a80:	4013      	ands	r3, r2
   11a82:	6822      	ldr	r2, [r4, #0]
   11a84:	5cd3      	ldrb	r3, [r2, r3]
   11a86:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
   11a88:	68a3      	ldr	r3, [r4, #8]
   11a8a:	3301      	adds	r3, #1
   11a8c:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
   11a8e:	2000      	movs	r0, #0
	}

	return ERR_NOT_FOUND;
}
   11a90:	bd38      	pop	{r3, r4, r5, pc}
	return ERR_NOT_FOUND;
   11a92:	f06f 0009 	mvn.w	r0, #9
   11a96:	e7fb      	b.n	11a90 <ringbuffer_get+0x30>
   11a98:	0000e03d 	.word	0x0000e03d
   11a9c:	0001665c 	.word	0x0001665c

00011aa0 <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
   11aa0:	b538      	push	{r3, r4, r5, lr}
	ASSERT(rb);
   11aa2:	4604      	mov	r4, r0
   11aa4:	3800      	subs	r0, #0
   11aa6:	bf18      	it	ne
   11aa8:	2001      	movne	r0, #1
{
   11aaa:	460d      	mov	r5, r1
	ASSERT(rb);
   11aac:	4b0b      	ldr	r3, [pc, #44]	; (11adc <ringbuffer_put+0x3c>)
   11aae:	490c      	ldr	r1, [pc, #48]	; (11ae0 <ringbuffer_put+0x40>)
   11ab0:	2251      	movs	r2, #81	; 0x51
   11ab2:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
   11ab4:	68e3      	ldr	r3, [r4, #12]
   11ab6:	6862      	ldr	r2, [r4, #4]
   11ab8:	4013      	ands	r3, r2
   11aba:	6822      	ldr	r2, [r4, #0]
   11abc:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
   11abe:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
   11ac2:	68e3      	ldr	r3, [r4, #12]
   11ac4:	1a59      	subs	r1, r3, r1
   11ac6:	4291      	cmp	r1, r2
		rb->read_index = rb->write_index - rb->size;
   11ac8:	bf88      	it	hi
   11aca:	1a9a      	subhi	r2, r3, r2
	}

	rb->write_index++;
   11acc:	f103 0301 	add.w	r3, r3, #1
		rb->read_index = rb->write_index - rb->size;
   11ad0:	bf88      	it	hi
   11ad2:	60a2      	strhi	r2, [r4, #8]
	rb->write_index++;
   11ad4:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
   11ad6:	2000      	movs	r0, #0
   11ad8:	bd38      	pop	{r3, r4, r5, pc}
   11ada:	bf00      	nop
   11adc:	0000e03d 	.word	0x0000e03d
   11ae0:	0001665c 	.word	0x0001665c

00011ae4 <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
   11ae4:	b510      	push	{r4, lr}
	ASSERT(rb);
   11ae6:	4604      	mov	r4, r0
   11ae8:	3800      	subs	r0, #0
   11aea:	bf18      	it	ne
   11aec:	2001      	movne	r0, #1
   11aee:	4904      	ldr	r1, [pc, #16]	; (11b00 <ringbuffer_num+0x1c>)
   11af0:	4b04      	ldr	r3, [pc, #16]	; (11b04 <ringbuffer_num+0x20>)
   11af2:	2267      	movs	r2, #103	; 0x67
   11af4:	4798      	blx	r3

	return rb->write_index - rb->read_index;
   11af6:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
}
   11afa:	1ac0      	subs	r0, r0, r3
   11afc:	bd10      	pop	{r4, pc}
   11afe:	bf00      	nop
   11b00:	0001665c 	.word	0x0001665c
   11b04:	0000e03d 	.word	0x0000e03d

00011b08 <atomic_enter_critical>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   11b08:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
   11b0c:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
   11b0e:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
   11b10:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
   11b14:	4770      	bx	lr

00011b16 <atomic_leave_critical>:
   11b16:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
   11b1a:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   11b1c:	f383 8810 	msr	PRIMASK, r3
}
   11b20:	4770      	bx	lr
	...

00011b24 <RTC_Scheduler_ping_cb>:
static struct timer_task RTC_Scheduler_heartbeat;

void RTC_Scheduler_ping_cb(const struct timer_task *const timer_task)
{

	pingflag++;
   11b24:	4a0d      	ldr	r2, [pc, #52]	; (11b5c <RTC_Scheduler_ping_cb+0x38>)
   11b26:	7813      	ldrb	r3, [r2, #0]
   11b28:	3301      	adds	r3, #1
   11b2a:	b2db      	uxtb	r3, r3
   11b2c:	7013      	strb	r3, [r2, #0]
	
	switch (pingflag%4)
   11b2e:	7813      	ldrb	r3, [r2, #0]
   11b30:	f003 0303 	and.w	r3, r3, #3
   11b34:	2b02      	cmp	r3, #2
   11b36:	f642 7248 	movw	r2, #12104	; 0x2f48
   11b3a:	d00a      	beq.n	11b52 <RTC_Scheduler_ping_cb+0x2e>
   11b3c:	2b03      	cmp	r3, #3
   11b3e:	d00a      	beq.n	11b56 <RTC_Scheduler_ping_cb+0x32>
   11b40:	2b01      	cmp	r3, #1
   11b42:	d003      	beq.n	11b4c <RTC_Scheduler_ping_cb+0x28>
	{
		case 0:
			GRID_PORT_N.ping_flag = 1;
   11b44:	4b06      	ldr	r3, [pc, #24]	; (11b60 <RTC_Scheduler_ping_cb+0x3c>)
			break;
		case 2:
			GRID_PORT_S.ping_flag = 1;
			break;
		case 3:
			GRID_PORT_W.ping_flag = 1;
   11b46:	2101      	movs	r1, #1
   11b48:	5499      	strb	r1, [r3, r2]
			break;
	}
	
}
   11b4a:	4770      	bx	lr
			GRID_PORT_E.ping_flag = 1;
   11b4c:	4905      	ldr	r1, [pc, #20]	; (11b64 <RTC_Scheduler_ping_cb+0x40>)
   11b4e:	548b      	strb	r3, [r1, r2]
			break;
   11b50:	4770      	bx	lr
			GRID_PORT_S.ping_flag = 1;
   11b52:	4b05      	ldr	r3, [pc, #20]	; (11b68 <RTC_Scheduler_ping_cb+0x44>)
   11b54:	e7f7      	b.n	11b46 <RTC_Scheduler_ping_cb+0x22>
			GRID_PORT_W.ping_flag = 1;
   11b56:	4b05      	ldr	r3, [pc, #20]	; (11b6c <RTC_Scheduler_ping_cb+0x48>)
   11b58:	e7f5      	b.n	11b46 <RTC_Scheduler_ping_cb+0x22>
   11b5a:	bf00      	nop
   11b5c:	20008d80 	.word	0x20008d80
   11b60:	20009150 	.word	0x20009150
   11b64:	20019870 	.word	0x20019870
   11b68:	200138d4 	.word	0x200138d4
   11b6c:	200102d4 	.word	0x200102d4

00011b70 <RTC_Scheduler_heartbeat_cb>:
	}

}

void RTC_Scheduler_heartbeat_cb(const struct timer_task *const timer_task)
{
   11b70:	b410      	push	{r4}
	
	grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_HEARTBEAT);
   11b72:	4c04      	ldr	r4, [pc, #16]	; (11b84 <RTC_Scheduler_heartbeat_cb+0x14>)
   11b74:	4804      	ldr	r0, [pc, #16]	; (11b88 <RTC_Scheduler_heartbeat_cb+0x18>)
   11b76:	2200      	movs	r2, #0
   11b78:	46a4      	mov	ip, r4
   11b7a:	230c      	movs	r3, #12

}
   11b7c:	f85d 4b04 	ldr.w	r4, [sp], #4
	grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_HEARTBEAT);
   11b80:	4611      	mov	r1, r2
   11b82:	4760      	bx	ip
   11b84:	0000a149 	.word	0x0000a149
   11b88:	2001c7c0 	.word	0x2001c7c0

00011b8c <example_task>:
{
   11b8c:	b507      	push	{r0, r1, r2, lr}
		CRITICAL_SECTION_ENTER()
   11b8e:	4e08      	ldr	r6, [pc, #32]	; (11bb0 <example_task+0x24>)
		printf("ExampleTask ????... %d \r\n", globaltest);
   11b90:	4d08      	ldr	r5, [pc, #32]	; (11bb4 <example_task+0x28>)
   11b92:	4c09      	ldr	r4, [pc, #36]	; (11bb8 <example_task+0x2c>)
		CRITICAL_SECTION_ENTER()
   11b94:	a801      	add	r0, sp, #4
   11b96:	47b0      	blx	r6
		printf("ExampleTask ????... %d \r\n", globaltest);
   11b98:	6869      	ldr	r1, [r5, #4]
   11b9a:	4b08      	ldr	r3, [pc, #32]	; (11bbc <example_task+0x30>)
   11b9c:	4620      	mov	r0, r4
   11b9e:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
   11ba0:	a801      	add	r0, sp, #4
   11ba2:	4b07      	ldr	r3, [pc, #28]	; (11bc0 <example_task+0x34>)
   11ba4:	4798      	blx	r3
		vTaskDelay(1000*configTICK_RATE_HZ/1000);
   11ba6:	4b07      	ldr	r3, [pc, #28]	; (11bc4 <example_task+0x38>)
   11ba8:	f241 3088 	movw	r0, #5000	; 0x1388
   11bac:	4798      	blx	r3
	while (1) {
   11bae:	e7f1      	b.n	11b94 <example_task+0x8>
   11bb0:	00011b09 	.word	0x00011b09
   11bb4:	20008d80 	.word	0x20008d80
   11bb8:	00016680 	.word	0x00016680
   11bbc:	00014451 	.word	0x00014451
   11bc0:	00011b17 	.word	0x00011b17
   11bc4:	0001299d 	.word	0x0001299d

00011bc8 <inbound_task>:
static void inbound_task(void *p){
   11bc8:	b508      	push	{r3, lr}
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   11bca:	4c02      	ldr	r4, [pc, #8]	; (11bd4 <inbound_task+0xc>)
   11bcc:	2005      	movs	r0, #5
   11bce:	47a0      	blx	r4
	while (1) {
   11bd0:	e7fc      	b.n	11bcc <inbound_task+0x4>
   11bd2:	bf00      	nop
   11bd4:	0001299d 	.word	0x0001299d

00011bd8 <usb_task_inner>:
static void usb_task_inner(){
   11bd8:	b570      	push	{r4, r5, r6, lr}
	grid_keyboard_tx_pop();
   11bda:	4b2c      	ldr	r3, [pc, #176]	; (11c8c <usb_task_inner+0xb4>)
static void usb_task_inner(){
   11bdc:	b08a      	sub	sp, #40	; 0x28
	grid_keyboard_tx_pop();
   11bde:	4798      	blx	r3
	grid_midi_tx_pop();        
   11be0:	4b2b      	ldr	r3, [pc, #172]	; (11c90 <usb_task_inner+0xb8>)
   11be2:	4798      	blx	r3
	audiodf_midi_read(midi_rx_buffer,16);
   11be4:	4b2b      	ldr	r3, [pc, #172]	; (11c94 <usb_task_inner+0xbc>)
   11be6:	482c      	ldr	r0, [pc, #176]	; (11c98 <usb_task_inner+0xc0>)
   11be8:	2110      	movs	r1, #16
   11bea:	4798      	blx	r3
		if (midi_rx_buffer[i]){
   11bec:	492b      	ldr	r1, [pc, #172]	; (11c9c <usb_task_inner+0xc4>)
	audiodf_midi_read(midi_rx_buffer,16);
   11bee:	2200      	movs	r2, #0
	uint8_t found = 0;
   11bf0:	4613      	mov	r3, r2
   11bf2:	460d      	mov	r5, r1
		if (midi_rx_buffer[i]){
   11bf4:	1888      	adds	r0, r1, r2
   11bf6:	7a00      	ldrb	r0, [r0, #8]
   11bf8:	b108      	cbz	r0, 11bfe <usb_task_inner+0x26>
			found++;
   11bfa:	3301      	adds	r3, #1
   11bfc:	b2db      	uxtb	r3, r3
	for (uint8_t i=0; i<16; i++){
   11bfe:	3201      	adds	r2, #1
   11c00:	2a10      	cmp	r2, #16
   11c02:	d1f7      	bne.n	11bf4 <usb_task_inner+0x1c>
	if (found){
   11c04:	b313      	cbz	r3, 11c4c <usb_task_inner+0x74>
		printf("MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   11c06:	7a29      	ldrb	r1, [r5, #8]
   11c08:	7a6a      	ldrb	r2, [r5, #9]
   11c0a:	7aab      	ldrb	r3, [r5, #10]
   11c0c:	7ae8      	ldrb	r0, [r5, #11]
   11c0e:	4c24      	ldr	r4, [pc, #144]	; (11ca0 <usb_task_inner+0xc8>)
   11c10:	9000      	str	r0, [sp, #0]
   11c12:	4824      	ldr	r0, [pc, #144]	; (11ca4 <usb_task_inner+0xcc>)
		sprintf(message, "MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   11c14:	4e24      	ldr	r6, [pc, #144]	; (11ca8 <usb_task_inner+0xd0>)
		printf("MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   11c16:	47a0      	blx	r4
		uint8_t message[30] = {0};
   11c18:	2400      	movs	r4, #0
   11c1a:	4b24      	ldr	r3, [pc, #144]	; (11cac <usb_task_inner+0xd4>)
   11c1c:	9402      	str	r4, [sp, #8]
   11c1e:	221a      	movs	r2, #26
   11c20:	4621      	mov	r1, r4
   11c22:	a803      	add	r0, sp, #12
   11c24:	4798      	blx	r3
		sprintf(message, "MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   11c26:	7a2a      	ldrb	r2, [r5, #8]
   11c28:	7a6b      	ldrb	r3, [r5, #9]
   11c2a:	7aa9      	ldrb	r1, [r5, #10]
   11c2c:	7ae8      	ldrb	r0, [r5, #11]
   11c2e:	e9cd 1000 	strd	r1, r0, [sp]
   11c32:	491c      	ldr	r1, [pc, #112]	; (11ca4 <usb_task_inner+0xcc>)
   11c34:	a802      	add	r0, sp, #8
   11c36:	47b0      	blx	r6
		grid_debug_print_text(message);
   11c38:	4b1d      	ldr	r3, [pc, #116]	; (11cb0 <usb_task_inner+0xd8>)
   11c3a:	a802      	add	r0, sp, #8
   11c3c:	4798      	blx	r3
   11c3e:	4621      	mov	r1, r4
			midi_rx_buffer[i] = 0;
   11c40:	4622      	mov	r2, r4
   11c42:	186b      	adds	r3, r5, r1
   11c44:	3101      	adds	r1, #1
		for (uint8_t i=0; i<16; i++){
   11c46:	2910      	cmp	r1, #16
			midi_rx_buffer[i] = 0;
   11c48:	721a      	strb	r2, [r3, #8]
		for (uint8_t i=0; i<16; i++){
   11c4a:	d1fa      	bne.n	11c42 <usb_task_inner+0x6a>
	cdcdf_acm_read(GRID_PORT_H.rx_double_buffer, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS);			
   11c4c:	4b19      	ldr	r3, [pc, #100]	; (11cb4 <usb_task_inner+0xdc>)
   11c4e:	481a      	ldr	r0, [pc, #104]	; (11cb8 <usb_task_inner+0xe0>)
   11c50:	f44f 7100 	mov.w	r1, #512	; 0x200
   11c54:	4798      	blx	r3
	uint16_t usblength = strlen(GRID_PORT_H.rx_double_buffer);
   11c56:	4818      	ldr	r0, [pc, #96]	; (11cb8 <usb_task_inner+0xe0>)
   11c58:	4b18      	ldr	r3, [pc, #96]	; (11cbc <usb_task_inner+0xe4>)
   11c5a:	4798      	blx	r3
	if (usblength){	
   11c5c:	4606      	mov	r6, r0
   11c5e:	b190      	cbz	r0, 11c86 <usb_task_inner+0xae>
		GRID_PORT_H.rx_double_buffer_status = 1;			
   11c60:	4d17      	ldr	r5, [pc, #92]	; (11cc0 <usb_task_inner+0xe8>)
   11c62:	2301      	movs	r3, #1
   11c64:	622b      	str	r3, [r5, #32]
		GRID_PORT_H.rx_double_buffer_read_start_index = 0;
   11c66:	2400      	movs	r4, #0
		GRID_PORT_H.rx_double_buffer_seek_start_index = usblength-3; //-3
   11c68:	1ec3      	subs	r3, r0, #3
		GRID_PORT_H.rx_double_buffer_read_start_index = 0;
   11c6a:	62ac      	str	r4, [r5, #40]	; 0x28
		grid_port_receive_task(&GRID_PORT_H);
   11c6c:	4628      	mov	r0, r5
		GRID_PORT_H.rx_double_buffer_seek_start_index = usblength-3; //-3
   11c6e:	626b      	str	r3, [r5, #36]	; 0x24
		grid_port_receive_task(&GRID_PORT_H);
   11c70:	4b14      	ldr	r3, [pc, #80]	; (11cc4 <usb_task_inner+0xec>)
   11c72:	4798      	blx	r3
		for(uint32_t i=0; i<usblength; i++){
   11c74:	4623      	mov	r3, r4
			GRID_PORT_H.rx_double_buffer[i] = 0;
   11c76:	f241 32b4 	movw	r2, #5044	; 0x13b4
   11c7a:	4620      	mov	r0, r4
   11c7c:	18e9      	adds	r1, r5, r3
		for(uint32_t i=0; i<usblength; i++){
   11c7e:	3301      	adds	r3, #1
   11c80:	429e      	cmp	r6, r3
			GRID_PORT_H.rx_double_buffer[i] = 0;
   11c82:	5488      	strb	r0, [r1, r2]
		for(uint32_t i=0; i<usblength; i++){
   11c84:	d1fa      	bne.n	11c7c <usb_task_inner+0xa4>
}
   11c86:	b00a      	add	sp, #40	; 0x28
   11c88:	bd70      	pop	{r4, r5, r6, pc}
   11c8a:	bf00      	nop
   11c8c:	0000b021 	.word	0x0000b021
   11c90:	0000af01 	.word	0x0000af01
   11c94:	0000451d 	.word	0x0000451d
   11c98:	20008d88 	.word	0x20008d88
   11c9c:	20008d80 	.word	0x20008d80
   11ca0:	00014451 	.word	0x00014451
   11ca4:	0001669a 	.word	0x0001669a
   11ca8:	00014791 	.word	0x00014791
   11cac:	000142f1 	.word	0x000142f1
   11cb0:	00009231 	.word	0x00009231
   11cb4:	0000bd25 	.word	0x0000bd25
   11cb8:	20017bd8 	.word	0x20017bd8
   11cbc:	0001480f 	.word	0x0001480f
   11cc0:	20016824 	.word	0x20016824
   11cc4:	00004d41 	.word	0x00004d41

00011cc8 <usb_task>:
{
   11cc8:	b508      	push	{r3, lr}
		usb_task_inner();
   11cca:	4d03      	ldr	r5, [pc, #12]	; (11cd8 <usb_task+0x10>)
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   11ccc:	4c03      	ldr	r4, [pc, #12]	; (11cdc <usb_task+0x14>)
		usb_task_inner();
   11cce:	47a8      	blx	r5
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   11cd0:	2005      	movs	r0, #5
   11cd2:	47a0      	blx	r4
	while (1) {
   11cd4:	e7fb      	b.n	11cce <usb_task+0x6>
   11cd6:	bf00      	nop
   11cd8:	00011bd9 	.word	0x00011bd9
   11cdc:	0001299d 	.word	0x0001299d

00011ce0 <receive_task_inner>:
static void receive_task_inner(){
   11ce0:	b510      	push	{r4, lr}
	grid_port_receive_task(&GRID_PORT_N);
   11ce2:	4806      	ldr	r0, [pc, #24]	; (11cfc <receive_task_inner+0x1c>)
   11ce4:	4c06      	ldr	r4, [pc, #24]	; (11d00 <receive_task_inner+0x20>)
   11ce6:	47a0      	blx	r4
	grid_port_receive_task(&GRID_PORT_E);
   11ce8:	4806      	ldr	r0, [pc, #24]	; (11d04 <receive_task_inner+0x24>)
   11cea:	47a0      	blx	r4
	grid_port_receive_task(&GRID_PORT_S);
   11cec:	4806      	ldr	r0, [pc, #24]	; (11d08 <receive_task_inner+0x28>)
   11cee:	47a0      	blx	r4
	grid_port_receive_task(&GRID_PORT_W);							
   11cf0:	4623      	mov	r3, r4
   11cf2:	4806      	ldr	r0, [pc, #24]	; (11d0c <receive_task_inner+0x2c>)
}
   11cf4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_port_receive_task(&GRID_PORT_W);							
   11cf8:	4718      	bx	r3
   11cfa:	bf00      	nop
   11cfc:	20009150 	.word	0x20009150
   11d00:	00004d41 	.word	0x00004d41
   11d04:	20019870 	.word	0x20019870
   11d08:	200138d4 	.word	0x200138d4
   11d0c:	200102d4 	.word	0x200102d4

00011d10 <receive_task>:
static void receive_task(void *p){
   11d10:	b508      	push	{r3, lr}
		receive_task_inner();
   11d12:	4d03      	ldr	r5, [pc, #12]	; (11d20 <receive_task+0x10>)
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   11d14:	4c03      	ldr	r4, [pc, #12]	; (11d24 <receive_task+0x14>)
		receive_task_inner();
   11d16:	47a8      	blx	r5
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   11d18:	2005      	movs	r0, #5
   11d1a:	47a0      	blx	r4
	while (1) {
   11d1c:	e7fb      	b.n	11d16 <receive_task+0x6>
   11d1e:	bf00      	nop
   11d20:	00011ce1 	.word	0x00011ce1
   11d24:	0001299d 	.word	0x0001299d

00011d28 <nvm_task_inner>:
static void nvm_task_inner(){
   11d28:	b510      	push	{r4, lr}
	if (GRID_PORT_U.rx_double_buffer_status == 0){
   11d2a:	4c1a      	ldr	r4, [pc, #104]	; (11d94 <nvm_task_inner+0x6c>)
   11d2c:	6a23      	ldr	r3, [r4, #32]
   11d2e:	b943      	cbnz	r3, 11d42 <nvm_task_inner+0x1a>
		if (grid_nvm_ui_bulk_read_is_in_progress(&grid_nvm_state, &grid_ui_state)){
   11d30:	4919      	ldr	r1, [pc, #100]	; (11d98 <nvm_task_inner+0x70>)
   11d32:	481a      	ldr	r0, [pc, #104]	; (11d9c <nvm_task_inner+0x74>)
   11d34:	4b1a      	ldr	r3, [pc, #104]	; (11da0 <nvm_task_inner+0x78>)
   11d36:	4798      	blx	r3
   11d38:	b118      	cbz	r0, 11d42 <nvm_task_inner+0x1a>
			grid_nvm_ui_bulk_read_next(&grid_nvm_state, &grid_ui_state);
   11d3a:	4917      	ldr	r1, [pc, #92]	; (11d98 <nvm_task_inner+0x70>)
   11d3c:	4817      	ldr	r0, [pc, #92]	; (11d9c <nvm_task_inner+0x74>)
   11d3e:	4b19      	ldr	r3, [pc, #100]	; (11da4 <nvm_task_inner+0x7c>)
   11d40:	4798      	blx	r3
	if (grid_nvm_ui_bulk_clear_is_in_progress(&grid_nvm_state, &grid_ui_state)){
   11d42:	4915      	ldr	r1, [pc, #84]	; (11d98 <nvm_task_inner+0x70>)
   11d44:	4815      	ldr	r0, [pc, #84]	; (11d9c <nvm_task_inner+0x74>)
   11d46:	4b18      	ldr	r3, [pc, #96]	; (11da8 <nvm_task_inner+0x80>)
   11d48:	4798      	blx	r3
   11d4a:	b118      	cbz	r0, 11d54 <nvm_task_inner+0x2c>
		grid_nvm_ui_bulk_clear_next(&grid_nvm_state, &grid_ui_state);
   11d4c:	4912      	ldr	r1, [pc, #72]	; (11d98 <nvm_task_inner+0x70>)
   11d4e:	4813      	ldr	r0, [pc, #76]	; (11d9c <nvm_task_inner+0x74>)
   11d50:	4b16      	ldr	r3, [pc, #88]	; (11dac <nvm_task_inner+0x84>)
   11d52:	4798      	blx	r3
	if (grid_nvm_ui_bulk_store_is_in_progress(&grid_nvm_state, &grid_ui_state)){
   11d54:	4910      	ldr	r1, [pc, #64]	; (11d98 <nvm_task_inner+0x70>)
   11d56:	4811      	ldr	r0, [pc, #68]	; (11d9c <nvm_task_inner+0x74>)
   11d58:	4b15      	ldr	r3, [pc, #84]	; (11db0 <nvm_task_inner+0x88>)
   11d5a:	4798      	blx	r3
   11d5c:	b118      	cbz	r0, 11d66 <nvm_task_inner+0x3e>
		grid_nvm_ui_bulk_store_next(&grid_nvm_state, &grid_ui_state);
   11d5e:	490e      	ldr	r1, [pc, #56]	; (11d98 <nvm_task_inner+0x70>)
   11d60:	480e      	ldr	r0, [pc, #56]	; (11d9c <nvm_task_inner+0x74>)
   11d62:	4b14      	ldr	r3, [pc, #80]	; (11db4 <nvm_task_inner+0x8c>)
   11d64:	4798      	blx	r3
	uint32_t nvmlength = GRID_PORT_U.rx_double_buffer_status;
   11d66:	6a23      	ldr	r3, [r4, #32]
	if (nvmlength){
   11d68:	b143      	cbz	r3, 11d7c <nvm_task_inner+0x54>
		GRID_PORT_U.rx_double_buffer_status = 1;
   11d6a:	2201      	movs	r2, #1
   11d6c:	6222      	str	r2, [r4, #32]
		GRID_PORT_U.rx_double_buffer_seek_start_index = nvmlength-1; //-3
   11d6e:	3b01      	subs	r3, #1
		GRID_PORT_U.rx_double_buffer_read_start_index = 0;
   11d70:	2200      	movs	r2, #0
   11d72:	62a2      	str	r2, [r4, #40]	; 0x28
		grid_port_receive_task(&GRID_PORT_U);	
   11d74:	4807      	ldr	r0, [pc, #28]	; (11d94 <nvm_task_inner+0x6c>)
		GRID_PORT_U.rx_double_buffer_seek_start_index = nvmlength-1; //-3
   11d76:	6263      	str	r3, [r4, #36]	; 0x24
		grid_port_receive_task(&GRID_PORT_U);	
   11d78:	4b0f      	ldr	r3, [pc, #60]	; (11db8 <nvm_task_inner+0x90>)
   11d7a:	4798      	blx	r3
static void nvm_task_inner(){
   11d7c:	2300      	movs	r3, #0
		GRID_PORT_U.rx_double_buffer[i] = 0;
   11d7e:	f241 32b4 	movw	r2, #5044	; 0x13b4
   11d82:	4618      	mov	r0, r3
   11d84:	18e1      	adds	r1, r4, r3
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++)
   11d86:	3301      	adds	r3, #1
   11d88:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
		GRID_PORT_U.rx_double_buffer[i] = 0;
   11d8c:	5488      	strb	r0, [r1, r2]
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++)
   11d8e:	d1f9      	bne.n	11d84 <nvm_task_inner+0x5c>
}
   11d90:	bd10      	pop	{r4, pc}
   11d92:	bf00      	nop
   11d94:	2000c0b0 	.word	0x2000c0b0
   11d98:	2000effc 	.word	0x2000effc
   11d9c:	2000fa1c 	.word	0x2000fa1c
   11da0:	000087e7 	.word	0x000087e7
   11da4:	000087ed 	.word	0x000087ed
   11da8:	00008abf 	.word	0x00008abf
   11dac:	00008ac5 	.word	0x00008ac5
   11db0:	000088fb 	.word	0x000088fb
   11db4:	00008901 	.word	0x00008901
   11db8:	00004d41 	.word	0x00004d41

00011dbc <inbound_task_inner>:
static void inbound_task_inner(){
   11dbc:	b510      	push	{r4, lr}
	grid_port_process_inbound(&GRID_PORT_U, 1); // Loopback
   11dbe:	2101      	movs	r1, #1
   11dc0:	4c0a      	ldr	r4, [pc, #40]	; (11dec <inbound_task_inner+0x30>)
   11dc2:	480b      	ldr	r0, [pc, #44]	; (11df0 <inbound_task_inner+0x34>)
   11dc4:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_N, 0);		
   11dc6:	2100      	movs	r1, #0
   11dc8:	480a      	ldr	r0, [pc, #40]	; (11df4 <inbound_task_inner+0x38>)
   11dca:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_E, 0);		
   11dcc:	2100      	movs	r1, #0
   11dce:	480a      	ldr	r0, [pc, #40]	; (11df8 <inbound_task_inner+0x3c>)
   11dd0:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_S, 0);
   11dd2:	2100      	movs	r1, #0
   11dd4:	4809      	ldr	r0, [pc, #36]	; (11dfc <inbound_task_inner+0x40>)
   11dd6:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_W, 0);
   11dd8:	2100      	movs	r1, #0
   11dda:	4809      	ldr	r0, [pc, #36]	; (11e00 <inbound_task_inner+0x44>)
   11ddc:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_H, 0);	// USB	
   11dde:	4623      	mov	r3, r4
   11de0:	4808      	ldr	r0, [pc, #32]	; (11e04 <inbound_task_inner+0x48>)
}
   11de2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_port_process_inbound(&GRID_PORT_H, 0);	// USB	
   11de6:	2100      	movs	r1, #0
   11de8:	4718      	bx	r3
   11dea:	bf00      	nop
   11dec:	000051c1 	.word	0x000051c1
   11df0:	2000c0b0 	.word	0x2000c0b0
   11df4:	20009150 	.word	0x20009150
   11df8:	20019870 	.word	0x20019870
   11dfc:	200138d4 	.word	0x200138d4
   11e00:	200102d4 	.word	0x200102d4
   11e04:	20016824 	.word	0x20016824

00011e08 <outbound_task_inner>:
static void outbound_task_inner(){
   11e08:	b510      	push	{r4, lr}
	grid_port_process_outbound_usart(&GRID_PORT_N);
   11e0a:	4808      	ldr	r0, [pc, #32]	; (11e2c <outbound_task_inner+0x24>)
   11e0c:	4c08      	ldr	r4, [pc, #32]	; (11e30 <outbound_task_inner+0x28>)
   11e0e:	47a0      	blx	r4
	grid_port_process_outbound_usart(&GRID_PORT_E);
   11e10:	4808      	ldr	r0, [pc, #32]	; (11e34 <outbound_task_inner+0x2c>)
   11e12:	47a0      	blx	r4
	grid_port_process_outbound_usart(&GRID_PORT_S);
   11e14:	4808      	ldr	r0, [pc, #32]	; (11e38 <outbound_task_inner+0x30>)
   11e16:	47a0      	blx	r4
	grid_port_process_outbound_usart(&GRID_PORT_W);
   11e18:	4808      	ldr	r0, [pc, #32]	; (11e3c <outbound_task_inner+0x34>)
   11e1a:	47a0      	blx	r4
	grid_port_process_outbound_usb(&GRID_PORT_H);
   11e1c:	4b08      	ldr	r3, [pc, #32]	; (11e40 <outbound_task_inner+0x38>)
   11e1e:	4809      	ldr	r0, [pc, #36]	; (11e44 <outbound_task_inner+0x3c>)
   11e20:	4798      	blx	r3
}
   11e22:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_port_process_outbound_ui(&GRID_PORT_U);
   11e26:	4808      	ldr	r0, [pc, #32]	; (11e48 <outbound_task_inner+0x40>)
   11e28:	4b08      	ldr	r3, [pc, #32]	; (11e4c <outbound_task_inner+0x44>)
   11e2a:	4718      	bx	r3
   11e2c:	20009150 	.word	0x20009150
   11e30:	000062cd 	.word	0x000062cd
   11e34:	20019870 	.word	0x20019870
   11e38:	200138d4 	.word	0x200138d4
   11e3c:	200102d4 	.word	0x200102d4
   11e40:	00005385 	.word	0x00005385
   11e44:	20016824 	.word	0x20016824
   11e48:	2000c0b0 	.word	0x2000c0b0
   11e4c:	00005679 	.word	0x00005679

00011e50 <led_task_inner>:
static void led_task_inner(){
   11e50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (grid_sys_state.alert_state){
   11e54:	4c45      	ldr	r4, [pc, #276]	; (11f6c <led_task_inner+0x11c>)
static void led_task_inner(){
   11e56:	ed2d 8b02 	vpush	{d8}
	if (grid_sys_state.alert_state){
   11e5a:	8963      	ldrh	r3, [r4, #10]
   11e5c:	b29b      	uxth	r3, r3
static void led_task_inner(){
   11e5e:	b083      	sub	sp, #12
	if (grid_sys_state.alert_state){
   11e60:	b98b      	cbnz	r3, 11e86 <led_task_inner+0x36>
	grid_task_enter_task(&grid_task_state, GRID_TASK_LED);
   11e62:	2106      	movs	r1, #6
   11e64:	4b42      	ldr	r3, [pc, #264]	; (11f70 <led_task_inner+0x120>)
   11e66:	4843      	ldr	r0, [pc, #268]	; (11f74 <led_task_inner+0x124>)
   11e68:	4798      	blx	r3
	grid_led_tick(&grid_led_state);
   11e6a:	4843      	ldr	r0, [pc, #268]	; (11f78 <led_task_inner+0x128>)
   11e6c:	4b43      	ldr	r3, [pc, #268]	; (11f7c <led_task_inner+0x12c>)
   11e6e:	4798      	blx	r3
	grid_led_lowlevel_render_all(&grid_led_state);	
   11e70:	4841      	ldr	r0, [pc, #260]	; (11f78 <led_task_inner+0x128>)
   11e72:	4b43      	ldr	r3, [pc, #268]	; (11f80 <led_task_inner+0x130>)
   11e74:	4798      	blx	r3
	grid_led_lowlevel_hardware_start_transfer(&grid_led_state);
   11e76:	4840      	ldr	r0, [pc, #256]	; (11f78 <led_task_inner+0x128>)
   11e78:	4b42      	ldr	r3, [pc, #264]	; (11f84 <led_task_inner+0x134>)
}
   11e7a:	b003      	add	sp, #12
   11e7c:	ecbd 8b02 	vpop	{d8}
   11e80:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_led_lowlevel_hardware_start_transfer(&grid_led_state);
   11e84:	4718      	bx	r3
		grid_sys_state.alert_state--;
   11e86:	8963      	ldrh	r3, [r4, #10]
   11e88:	3b01      	subs	r3, #1
   11e8a:	b29b      	uxth	r3, r3
   11e8c:	8163      	strh	r3, [r4, #10]
		if (grid_sys_alert_read_color_changed_flag(&grid_sys_state)){
   11e8e:	4620      	mov	r0, r4
   11e90:	4b3d      	ldr	r3, [pc, #244]	; (11f88 <led_task_inner+0x138>)
   11e92:	4798      	blx	r3
   11e94:	b988      	cbnz	r0, 11eba <led_task_inner+0x6a>
		uint8_t intensity = grid_sys_alert_get_color_intensity(&grid_sys_state);
   11e96:	4835      	ldr	r0, [pc, #212]	; (11f6c <led_task_inner+0x11c>)
   11e98:	4b3c      	ldr	r3, [pc, #240]	; (11f8c <led_task_inner+0x13c>)
			grid_led_set_phase(&grid_led_state, i, GRID_LED_LAYER_ALERT, intensity);
   11e9a:	4e37      	ldr	r6, [pc, #220]	; (11f78 <led_task_inner+0x128>)
   11e9c:	4f3c      	ldr	r7, [pc, #240]	; (11f90 <led_task_inner+0x140>)
		uint8_t intensity = grid_sys_alert_get_color_intensity(&grid_sys_state);
   11e9e:	4798      	blx	r3
		for (uint8_t i=0; i<grid_led_state.led_number; i++){	
   11ea0:	2400      	movs	r4, #0
		uint8_t intensity = grid_sys_alert_get_color_intensity(&grid_sys_state);
   11ea2:	4605      	mov	r5, r0
		for (uint8_t i=0; i<grid_led_state.led_number; i++){	
   11ea4:	4b34      	ldr	r3, [pc, #208]	; (11f78 <led_task_inner+0x128>)
   11ea6:	785b      	ldrb	r3, [r3, #1]
   11ea8:	b2e1      	uxtb	r1, r4
   11eaa:	428b      	cmp	r3, r1
   11eac:	d9d9      	bls.n	11e62 <led_task_inner+0x12>
			grid_led_set_phase(&grid_led_state, i, GRID_LED_LAYER_ALERT, intensity);
   11eae:	462b      	mov	r3, r5
   11eb0:	2200      	movs	r2, #0
   11eb2:	4630      	mov	r0, r6
   11eb4:	47b8      	blx	r7
		for (uint8_t i=0; i<grid_led_state.led_number; i++){	
   11eb6:	3401      	adds	r4, #1
   11eb8:	e7f4      	b.n	11ea4 <led_task_inner+0x54>
			grid_sys_alert_clear_color_changed_flag(&grid_sys_state);			
   11eba:	4b36      	ldr	r3, [pc, #216]	; (11f94 <led_task_inner+0x144>)
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   11ebc:	4e2e      	ldr	r6, [pc, #184]	; (11f78 <led_task_inner+0x128>)
			grid_sys_alert_clear_color_changed_flag(&grid_sys_state);			
   11ebe:	4620      	mov	r0, r4
   11ec0:	4798      	blx	r3
			uint8_t color_r   = grid_sys_alert_get_color_r(&grid_sys_state);
   11ec2:	4b35      	ldr	r3, [pc, #212]	; (11f98 <led_task_inner+0x148>)
   11ec4:	4620      	mov	r0, r4
   11ec6:	4798      	blx	r3
			uint8_t color_g   = grid_sys_alert_get_color_g(&grid_sys_state);
   11ec8:	4b34      	ldr	r3, [pc, #208]	; (11f9c <led_task_inner+0x14c>)
			uint8_t color_r   = grid_sys_alert_get_color_r(&grid_sys_state);
   11eca:	ee08 0a10 	vmov	s16, r0
			uint8_t color_g   = grid_sys_alert_get_color_g(&grid_sys_state);
   11ece:	4620      	mov	r0, r4
   11ed0:	4798      	blx	r3
			uint8_t color_b   = grid_sys_alert_get_color_b(&grid_sys_state);
   11ed2:	4b33      	ldr	r3, [pc, #204]	; (11fa0 <led_task_inner+0x150>)
			uint8_t color_g   = grid_sys_alert_get_color_g(&grid_sys_state);
   11ed4:	4682      	mov	sl, r0
			uint8_t color_b   = grid_sys_alert_get_color_b(&grid_sys_state);
   11ed6:	4620      	mov	r0, r4
   11ed8:	4798      	blx	r3
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   11eda:	f04f 0900 	mov.w	r9, #0
			uint8_t color_b   = grid_sys_alert_get_color_b(&grid_sys_state);
   11ede:	4683      	mov	fp, r0
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   11ee0:	4b30      	ldr	r3, [pc, #192]	; (11fa4 <led_task_inner+0x154>)
   11ee2:	4630      	mov	r0, r6
   11ee4:	4798      	blx	r3
   11ee6:	fa5f f589 	uxtb.w	r5, r9
   11eea:	42a8      	cmp	r0, r5
   11eec:	f109 0901 	add.w	r9, r9, #1
   11ef0:	d9d1      	bls.n	11e96 <led_task_inner+0x46>
				grid_led_set_min(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0   , color_g*0   , color_b*0);
   11ef2:	2400      	movs	r4, #0
   11ef4:	4622      	mov	r2, r4
   11ef6:	e9cd 4400 	strd	r4, r4, [sp]
   11efa:	4623      	mov	r3, r4
   11efc:	4629      	mov	r1, r5
   11efe:	4630      	mov	r0, r6
   11f00:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 11fb8 <led_task_inner+0x168>
				grid_led_set_mid(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0.5 , color_g*0.5 , color_b*0.5);
   11f04:	4f28      	ldr	r7, [pc, #160]	; (11fa8 <led_task_inner+0x158>)
				grid_led_set_min(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0   , color_g*0   , color_b*0);
   11f06:	47c0      	blx	r8
				grid_led_set_mid(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0.5 , color_g*0.5 , color_b*0.5);
   11f08:	ee18 0a10 	vmov	r0, s16
   11f0c:	4b27      	ldr	r3, [pc, #156]	; (11fac <led_task_inner+0x15c>)
   11f0e:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 11fbc <led_task_inner+0x16c>
   11f12:	4798      	blx	r3
   11f14:	4b26      	ldr	r3, [pc, #152]	; (11fb0 <led_task_inner+0x160>)
   11f16:	2200      	movs	r2, #0
   11f18:	47b8      	blx	r7
   11f1a:	47c0      	blx	r8
   11f1c:	4b23      	ldr	r3, [pc, #140]	; (11fac <led_task_inner+0x15c>)
   11f1e:	b2c2      	uxtb	r2, r0
   11f20:	4658      	mov	r0, fp
   11f22:	ee08 2a90 	vmov	s17, r2
   11f26:	4798      	blx	r3
   11f28:	2200      	movs	r2, #0
   11f2a:	4b21      	ldr	r3, [pc, #132]	; (11fb0 <led_task_inner+0x160>)
   11f2c:	47b8      	blx	r7
   11f2e:	47c0      	blx	r8
   11f30:	b2c0      	uxtb	r0, r0
   11f32:	9001      	str	r0, [sp, #4]
   11f34:	4b1d      	ldr	r3, [pc, #116]	; (11fac <led_task_inner+0x15c>)
   11f36:	4650      	mov	r0, sl
   11f38:	4798      	blx	r3
   11f3a:	4b1d      	ldr	r3, [pc, #116]	; (11fb0 <led_task_inner+0x160>)
   11f3c:	2200      	movs	r2, #0
   11f3e:	47b8      	blx	r7
   11f40:	47c0      	blx	r8
   11f42:	b2c0      	uxtb	r0, r0
   11f44:	ee18 3a90 	vmov	r3, s17
   11f48:	9000      	str	r0, [sp, #0]
   11f4a:	4622      	mov	r2, r4
   11f4c:	4629      	mov	r1, r5
   11f4e:	4630      	mov	r0, r6
   11f50:	f8df 806c 	ldr.w	r8, [pc, #108]	; 11fc0 <led_task_inner+0x170>
   11f54:	47c0      	blx	r8
				grid_led_set_max(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*1   , color_g*1   , color_b*1);
   11f56:	4622      	mov	r2, r4
   11f58:	e9cd ab00 	strd	sl, fp, [sp]
   11f5c:	ee18 3a10 	vmov	r3, s16
   11f60:	4c14      	ldr	r4, [pc, #80]	; (11fb4 <led_task_inner+0x164>)
   11f62:	4629      	mov	r1, r5
   11f64:	4630      	mov	r0, r6
   11f66:	47a0      	blx	r4
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   11f68:	e7ba      	b.n	11ee0 <led_task_inner+0x90>
   11f6a:	bf00      	nop
   11f6c:	2000f008 	.word	0x2000f008
   11f70:	00008d33 	.word	0x00008d33
   11f74:	200102b0 	.word	0x200102b0
   11f78:	2001c838 	.word	0x2001c838
   11f7c:	00006c41 	.word	0x00006c41
   11f80:	00007031 	.word	0x00007031
   11f84:	00007051 	.word	0x00007051
   11f88:	0000977d 	.word	0x0000977d
   11f8c:	00009787 	.word	0x00009787
   11f90:	00006d49 	.word	0x00006d49
   11f94:	00009781 	.word	0x00009781
   11f98:	000097e5 	.word	0x000097e5
   11f9c:	000097e9 	.word	0x000097e9
   11fa0:	000097ed 	.word	0x000097ed
   11fa4:	00006c3d 	.word	0x00006c3d
   11fa8:	00013e19 	.word	0x00013e19
   11fac:	00013d45 	.word	0x00013d45
   11fb0:	3fe00000 	.word	0x3fe00000
   11fb4:	00006cb9 	.word	0x00006cb9
   11fb8:	00006c79 	.word	0x00006c79
   11fbc:	0001423d 	.word	0x0001423d
   11fc0:	00006c99 	.word	0x00006c99

00011fc4 <RTC_Scheduler_realtime_cb>:
{
   11fc4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	grid_sys_rtc_tick_time(&grid_sys_state);	
   11fc6:	4d16      	ldr	r5, [pc, #88]	; (12020 <RTC_Scheduler_realtime_cb+0x5c>)
   11fc8:	4b16      	ldr	r3, [pc, #88]	; (12024 <RTC_Scheduler_realtime_cb+0x60>)
   11fca:	4628      	mov	r0, r5
   11fcc:	4798      	blx	r3
	grid_task_timer_tick(&grid_task_state);
   11fce:	4816      	ldr	r0, [pc, #88]	; (12028 <RTC_Scheduler_realtime_cb+0x64>)
   11fd0:	4b16      	ldr	r3, [pc, #88]	; (1202c <RTC_Scheduler_realtime_cb+0x68>)
   11fd2:	4798      	blx	r3
	CRITICAL_SECTION_ENTER();
   11fd4:	4b16      	ldr	r3, [pc, #88]	; (12030 <RTC_Scheduler_realtime_cb+0x6c>)
   11fd6:	a801      	add	r0, sp, #4
   11fd8:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
   11fda:	4a16      	ldr	r2, [pc, #88]	; (12034 <RTC_Scheduler_realtime_cb+0x70>)
   11fdc:	f8d2 1100 	ldr.w	r1, [r2, #256]	; 0x100
	return ((Port *)hw)->Group[submodule_index].IN.reg;
   11fe0:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
   11fe4:	f8d2 4110 	ldr.w	r4, [r2, #272]	; 0x110
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
   11fe8:	405c      	eors	r4, r3
   11fea:	400c      	ands	r4, r1
   11fec:	405c      	eors	r4, r3
	CRITICAL_SECTION_LEAVE();
   11fee:	a801      	add	r0, sp, #4
   11ff0:	4b11      	ldr	r3, [pc, #68]	; (12038 <RTC_Scheduler_realtime_cb+0x74>)
   11ff2:	4798      	blx	r3
	if (mapmode_value != grid_sys_state.mapmodestate){
   11ff4:	7c2a      	ldrb	r2, [r5, #16]
	uint8_t mapmode_value = !gpio_get_pin_level(MAP_MODE);
   11ff6:	f484 6300 	eor.w	r3, r4, #2048	; 0x800
   11ffa:	f3c3 23c0 	ubfx	r3, r3, #11, #1
	if (mapmode_value != grid_sys_state.mapmodestate){
   11ffe:	429a      	cmp	r2, r3
   12000:	d009      	beq.n	12016 <RTC_Scheduler_realtime_cb+0x52>
		grid_sys_state.mapmodestate = mapmode_value;
   12002:	742b      	strb	r3, [r5, #16]
		if (grid_sys_state.mapmodestate == 0){ // RELEASE
   12004:	7c2b      	ldrb	r3, [r5, #16]
   12006:	4c0d      	ldr	r4, [pc, #52]	; (1203c <RTC_Scheduler_realtime_cb+0x78>)
   12008:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   1200c:	b92b      	cbnz	r3, 1201a <RTC_Scheduler_realtime_cb+0x56>
			grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_MAPMODE_RELEASE);
   1200e:	2308      	movs	r3, #8
			grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_MAPMODE_PRESS);		
   12010:	480b      	ldr	r0, [pc, #44]	; (12040 <RTC_Scheduler_realtime_cb+0x7c>)
   12012:	4611      	mov	r1, r2
   12014:	47a0      	blx	r4
}
   12016:	b003      	add	sp, #12
   12018:	bd30      	pop	{r4, r5, pc}
			grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_MAPMODE_PRESS);		
   1201a:	2307      	movs	r3, #7
   1201c:	2200      	movs	r2, #0
   1201e:	e7f7      	b.n	12010 <RTC_Scheduler_realtime_cb+0x4c>
   12020:	2000f008 	.word	0x2000f008
   12024:	0000976b 	.word	0x0000976b
   12028:	200102b0 	.word	0x200102b0
   1202c:	00008d3b 	.word	0x00008d3b
   12030:	00011b09 	.word	0x00011b09
   12034:	41008000 	.word	0x41008000
   12038:	00011b17 	.word	0x00011b17
   1203c:	0000a149 	.word	0x0000a149
   12040:	2001c7c0 	.word	0x2001c7c0

00012044 <outbound_task>:
   12044:	b508      	push	{r3, lr}
   12046:	4c02      	ldr	r4, [pc, #8]	; (12050 <outbound_task+0xc>)
   12048:	2005      	movs	r0, #5
   1204a:	47a0      	blx	r4
   1204c:	e7fc      	b.n	12048 <outbound_task+0x4>
   1204e:	bf00      	nop
   12050:	0001299d 	.word	0x0001299d

00012054 <led_task>:
{
   12054:	b508      	push	{r3, lr}
		globaltest++;
   12056:	4c08      	ldr	r4, [pc, #32]	; (12078 <led_task+0x24>)
		inbound_task_inner();
   12058:	4e08      	ldr	r6, [pc, #32]	; (1207c <led_task+0x28>)
		outbound_task_inner();
   1205a:	4d09      	ldr	r5, [pc, #36]	; (12080 <led_task+0x2c>)
		globaltest++;
   1205c:	6863      	ldr	r3, [r4, #4]
   1205e:	3301      	adds	r3, #1
   12060:	6063      	str	r3, [r4, #4]
		inbound_task_inner();
   12062:	47b0      	blx	r6
		outbound_task_inner();
   12064:	47a8      	blx	r5
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   12066:	4807      	ldr	r0, [pc, #28]	; (12084 <led_task+0x30>)
   12068:	4b07      	ldr	r3, [pc, #28]	; (12088 <led_task+0x34>)
   1206a:	4798      	blx	r3
		led_task_inner();
   1206c:	4b07      	ldr	r3, [pc, #28]	; (1208c <led_task+0x38>)
   1206e:	4798      	blx	r3
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   12070:	4b07      	ldr	r3, [pc, #28]	; (12090 <led_task+0x3c>)
   12072:	2005      	movs	r0, #5
   12074:	4798      	blx	r3
	while (1) {
   12076:	e7f1      	b.n	1205c <led_task+0x8>
   12078:	20008d80 	.word	0x20008d80
   1207c:	00011dbd 	.word	0x00011dbd
   12080:	00011e09 	.word	0x00011e09
   12084:	2000c0b0 	.word	0x2000c0b0
   12088:	0000a75d 	.word	0x0000a75d
   1208c:	00011e51 	.word	0x00011e51
   12090:	0001299d 	.word	0x0001299d

00012094 <vApplicationStackOverflowHook>:
void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName ){
   12094:	b583      	push	{r0, r1, r7, lr}
	CRITICAL_SECTION_ENTER()
   12096:	4b08      	ldr	r3, [pc, #32]	; (120b8 <vApplicationStackOverflowHook+0x24>)
		printf("Stack overflow in task %s\r\n", pcTaskGetName(xTask));
   12098:	4f08      	ldr	r7, [pc, #32]	; (120bc <vApplicationStackOverflowHook+0x28>)
   1209a:	4e09      	ldr	r6, [pc, #36]	; (120c0 <vApplicationStackOverflowHook+0x2c>)
   1209c:	4d09      	ldr	r5, [pc, #36]	; (120c4 <vApplicationStackOverflowHook+0x30>)
void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName ){
   1209e:	4604      	mov	r4, r0
	CRITICAL_SECTION_ENTER()
   120a0:	a801      	add	r0, sp, #4
   120a2:	4798      	blx	r3
		printf("Stack overflow in task %s\r\n", pcTaskGetName(xTask));
   120a4:	4620      	mov	r0, r4
   120a6:	47b8      	blx	r7
   120a8:	4601      	mov	r1, r0
   120aa:	4630      	mov	r0, r6
   120ac:	47a8      	blx	r5
		delay_ms(1000);
   120ae:	4b06      	ldr	r3, [pc, #24]	; (120c8 <vApplicationStackOverflowHook+0x34>)
   120b0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   120b4:	4798      	blx	r3
	while(1){
   120b6:	e7f5      	b.n	120a4 <vApplicationStackOverflowHook+0x10>
   120b8:	00011b09 	.word	0x00011b09
   120bc:	00012781 	.word	0x00012781
   120c0:	000166b5 	.word	0x000166b5
   120c4:	00014451 	.word	0x00014451
   120c8:	0000dd8d 	.word	0x0000dd8d

000120cc <init_timer>:


void init_timer(void)
{
   120cc:	b570      	push	{r4, r5, r6, lr}
	
		
	//RTC_Scheduler_ping.interval = RTC1SEC/20; //50ms
	RTC_Scheduler_ping.interval = RTC1MS*GRID_PARAMETER_PING_interval;
   120ce:	4c14      	ldr	r4, [pc, #80]	; (12120 <init_timer+0x54>)
	
	RTC_Scheduler_realtime.interval = 1;
	RTC_Scheduler_realtime.cb       = RTC_Scheduler_realtime_cb;
	RTC_Scheduler_realtime.mode     = TIMER_TASK_REPEAT;

	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_ping);
   120d0:	4d14      	ldr	r5, [pc, #80]	; (12124 <init_timer+0x58>)
   120d2:	4e15      	ldr	r6, [pc, #84]	; (12128 <init_timer+0x5c>)
	RTC_Scheduler_ping.interval = RTC1MS*GRID_PARAMETER_PING_interval;
   120d4:	f44f 63c8 	mov.w	r3, #1600	; 0x640
	RTC_Scheduler_heartbeat.interval = RTC1MS*GRID_PARAMETER_HEARTBEAT_interval;
   120d8:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
	RTC_Scheduler_ping.interval = RTC1MS*GRID_PARAMETER_PING_interval;
   120dc:	6223      	str	r3, [r4, #32]
	RTC_Scheduler_heartbeat.interval = RTC1MS*GRID_PARAMETER_HEARTBEAT_interval;
   120de:	6362      	str	r2, [r4, #52]	; 0x34
	RTC_Scheduler_ping.cb       = RTC_Scheduler_ping_cb;
   120e0:	4b12      	ldr	r3, [pc, #72]	; (1212c <init_timer+0x60>)
	RTC_Scheduler_heartbeat.cb       = RTC_Scheduler_heartbeat_cb;
   120e2:	4a13      	ldr	r2, [pc, #76]	; (12130 <init_timer+0x64>)
	RTC_Scheduler_ping.cb       = RTC_Scheduler_ping_cb;
   120e4:	6263      	str	r3, [r4, #36]	; 0x24
	RTC_Scheduler_heartbeat.cb       = RTC_Scheduler_heartbeat_cb;
   120e6:	63a2      	str	r2, [r4, #56]	; 0x38
	RTC_Scheduler_ping.mode     = TIMER_TASK_REPEAT;
   120e8:	2301      	movs	r3, #1
	RTC_Scheduler_realtime.cb       = RTC_Scheduler_realtime_cb;
   120ea:	4a12      	ldr	r2, [pc, #72]	; (12134 <init_timer+0x68>)
	RTC_Scheduler_ping.mode     = TIMER_TASK_REPEAT;
   120ec:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_ping);
   120f0:	f104 0118 	add.w	r1, r4, #24
   120f4:	4628      	mov	r0, r5
	RTC_Scheduler_heartbeat.mode     = TIMER_TASK_REPEAT;
   120f6:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
	RTC_Scheduler_realtime.interval = 1;
   120fa:	64a3      	str	r3, [r4, #72]	; 0x48
	RTC_Scheduler_realtime.mode     = TIMER_TASK_REPEAT;
   120fc:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
	RTC_Scheduler_realtime.cb       = RTC_Scheduler_realtime_cb;
   12100:	64e2      	str	r2, [r4, #76]	; 0x4c
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_ping);
   12102:	47b0      	blx	r6
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_heartbeat);
   12104:	f104 012c 	add.w	r1, r4, #44	; 0x2c
   12108:	4628      	mov	r0, r5
   1210a:	47b0      	blx	r6
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_realtime);
   1210c:	f104 0140 	add.w	r1, r4, #64	; 0x40
   12110:	4628      	mov	r0, r5
   12112:	47b0      	blx	r6
	
	timer_start(&RTC_Scheduler);
   12114:	4628      	mov	r0, r5
   12116:	4b08      	ldr	r3, [pc, #32]	; (12138 <init_timer+0x6c>)
	
}
   12118:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	timer_start(&RTC_Scheduler);
   1211c:	4718      	bx	r3
   1211e:	bf00      	nop
   12120:	20008d80 	.word	0x20008d80
   12124:	2001ccb8 	.word	0x2001ccb8
   12128:	0000ca55 	.word	0x0000ca55
   1212c:	00011b25 	.word	0x00011b25
   12130:	00011b71 	.word	0x00011b71
   12134:	00011fc5 	.word	0x00011fc5
   12138:	0000ca15 	.word	0x0000ca15

0001213c <main>:

//====================== USB TEST =====================//

int main(void)
{
   1213c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	


	atmel_start_init();	
   12140:	4b81      	ldr	r3, [pc, #516]	; (12348 <main+0x20c>)
    
            
            
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_PORT, "Start Initialized");
   12142:	4e82      	ldr	r6, [pc, #520]	; (1234c <main+0x210>)
	// 	}
	// }


    
	if (xTaskCreate(usb_task, "Usb Task", TASK_USB_STACK_SIZE, NULL, TASK_USB_PRIORITY, &xCreatedUsbTask)
   12144:	4c82      	ldr	r4, [pc, #520]	; (12350 <main+0x214>)
   12146:	4d83      	ldr	r5, [pc, #524]	; (12354 <main+0x218>)
{
   12148:	b085      	sub	sp, #20
	atmel_start_init();	
   1214a:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_PORT, "Start Initialized");
   1214c:	4982      	ldr	r1, [pc, #520]	; (12358 <main+0x21c>)
   1214e:	4883      	ldr	r0, [pc, #524]	; (1235c <main+0x220>)
   12150:	47b0      	blx	r6
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_PORT, "D51 Init");
   12152:	4983      	ldr	r1, [pc, #524]	; (12360 <main+0x224>)
   12154:	4881      	ldr	r0, [pc, #516]	; (1235c <main+0x220>)
   12156:	47b0      	blx	r6
	grid_d51_init(); // Check User Row
   12158:	4b82      	ldr	r3, [pc, #520]	; (12364 <main+0x228>)
   1215a:	4798      	blx	r3
	audiodf_midi_init();
   1215c:	4b82      	ldr	r3, [pc, #520]	; (12368 <main+0x22c>)
   1215e:	4798      	blx	r3
	composite_device_start();
   12160:	4b82      	ldr	r3, [pc, #520]	; (1236c <main+0x230>)
   12162:	4798      	blx	r3
	grid_usb_serial_init();
   12164:	4b82      	ldr	r3, [pc, #520]	; (12370 <main+0x234>)
   12166:	4798      	blx	r3
	grid_usb_midi_init();
   12168:	4b82      	ldr	r3, [pc, #520]	; (12374 <main+0x238>)
   1216a:	4798      	blx	r3
	grid_keyboard_init(&grid_keyboard_state);
   1216c:	4b82      	ldr	r3, [pc, #520]	; (12378 <main+0x23c>)
   1216e:	4883      	ldr	r0, [pc, #524]	; (1237c <main+0x240>)
   12170:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Composite Device Initialized");
   12172:	4983      	ldr	r1, [pc, #524]	; (12380 <main+0x244>)
   12174:	4879      	ldr	r0, [pc, #484]	; (1235c <main+0x220>)
   12176:	47b0      	blx	r6
	rand_sync_enable(&RAND_0);	
   12178:	4b82      	ldr	r3, [pc, #520]	; (12384 <main+0x248>)
   1217a:	4883      	ldr	r0, [pc, #524]	; (12388 <main+0x24c>)
   1217c:	4798      	blx	r3
	grid_expr_init(&grid_expr_state);
   1217e:	4883      	ldr	r0, [pc, #524]	; (1238c <main+0x250>)
   12180:	4b83      	ldr	r3, [pc, #524]	; (12390 <main+0x254>)
   12182:	4798      	blx	r3
	grid_module_common_init();
   12184:	4b83      	ldr	r3, [pc, #524]	; (12394 <main+0x258>)
   12186:	4798      	blx	r3
    grid_ui_reinit(&grid_ui_state);
   12188:	4b83      	ldr	r3, [pc, #524]	; (12398 <main+0x25c>)
   1218a:	4884      	ldr	r0, [pc, #528]	; (1239c <main+0x260>)
   1218c:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Grid Module Initialized");
   1218e:	4984      	ldr	r1, [pc, #528]	; (123a0 <main+0x264>)
   12190:	4872      	ldr	r0, [pc, #456]	; (1235c <main+0x220>)
   12192:	47b0      	blx	r6
	init_timer();
   12194:	4b83      	ldr	r3, [pc, #524]	; (123a4 <main+0x268>)
   12196:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Entering Main Loop");
   12198:	4983      	ldr	r1, [pc, #524]	; (123a8 <main+0x26c>)
   1219a:	4870      	ldr	r0, [pc, #448]	; (1235c <main+0x220>)
   1219c:	47b0      	blx	r6
	grid_sys_nvm_load_configuration(&grid_sys_state, &grid_nvm_state);
   1219e:	4983      	ldr	r1, [pc, #524]	; (123ac <main+0x270>)
   121a0:	4883      	ldr	r0, [pc, #524]	; (123b0 <main+0x274>)
   121a2:	4b84      	ldr	r3, [pc, #528]	; (123b4 <main+0x278>)
   121a4:	4798      	blx	r3
	grid_ui_nvm_load_all_configuration(&grid_ui_state, &grid_nvm_state);	
   121a6:	4981      	ldr	r1, [pc, #516]	; (123ac <main+0x270>)
   121a8:	487c      	ldr	r0, [pc, #496]	; (1239c <main+0x260>)
   121aa:	4b83      	ldr	r3, [pc, #524]	; (123b8 <main+0x27c>)
   121ac:	4798      	blx	r3
	if (xTaskCreate(usb_task, "Usb Task", TASK_USB_STACK_SIZE, NULL, TASK_USB_PRIORITY, &xCreatedUsbTask)
   121ae:	2301      	movs	r3, #1
   121b0:	9300      	str	r3, [sp, #0]
   121b2:	4982      	ldr	r1, [pc, #520]	; (123bc <main+0x280>)
   121b4:	4882      	ldr	r0, [pc, #520]	; (123c0 <main+0x284>)
   121b6:	9401      	str	r4, [sp, #4]
   121b8:	2300      	movs	r3, #0
   121ba:	f44f 7200 	mov.w	r2, #512	; 0x200
   121be:	47a8      	blx	r5
   121c0:	2801      	cmp	r0, #1
   121c2:	9603      	str	r6, [sp, #12]
   121c4:	d000      	beq.n	121c8 <main+0x8c>
	    != pdPASS) {
		while (1) {
   121c6:	e7fe      	b.n	121c6 <main+0x8a>
			;
		}
	}

	if (xTaskCreate(usb_task, "Nvm Task", TASK_NVM_STACK_SIZE, NULL, TASK_NVM_PRIORITY, &xCreatedNvmTask)
   121c8:	1d23      	adds	r3, r4, #4
   121ca:	2602      	movs	r6, #2
   121cc:	9301      	str	r3, [sp, #4]
   121ce:	497d      	ldr	r1, [pc, #500]	; (123c4 <main+0x288>)
   121d0:	487b      	ldr	r0, [pc, #492]	; (123c0 <main+0x284>)
   121d2:	9600      	str	r6, [sp, #0]
   121d4:	2300      	movs	r3, #0
   121d6:	f44f 7280 	mov.w	r2, #256	; 0x100
   121da:	47a8      	blx	r5
   121dc:	2801      	cmp	r0, #1
   121de:	d000      	beq.n	121e2 <main+0xa6>
	    != pdPASS) {
		while (1) {
   121e0:	e7fe      	b.n	121e0 <main+0xa4>
			;
		}
	}

	if (xTaskCreate(usb_task, "Ui Task", TASK_UI_STACK_SIZE, NULL, TASK_UI_PRIORITY, &xCreatedUiTask)
   121e2:	f104 0308 	add.w	r3, r4, #8
   121e6:	9301      	str	r3, [sp, #4]
   121e8:	2305      	movs	r3, #5
   121ea:	9300      	str	r3, [sp, #0]
   121ec:	4976      	ldr	r1, [pc, #472]	; (123c8 <main+0x28c>)
   121ee:	4874      	ldr	r0, [pc, #464]	; (123c0 <main+0x284>)
   121f0:	2300      	movs	r3, #0
   121f2:	f44f 6280 	mov.w	r2, #1024	; 0x400
   121f6:	47a8      	blx	r5
   121f8:	2801      	cmp	r0, #1
   121fa:	d000      	beq.n	121fe <main+0xc2>
	    != pdPASS) {
		while (1) {
   121fc:	e7fe      	b.n	121fc <main+0xc0>
			;
		}
	}

	if (xTaskCreate(receive_task, "Receive Task", TASK_RECEIVE_STACK_SIZE, NULL, TASK_RECEIVE_PRIORITY, &xCreatedReceiveTask)
   121fe:	f104 030c 	add.w	r3, r4, #12
   12202:	e9cd 6300 	strd	r6, r3, [sp]
   12206:	4971      	ldr	r1, [pc, #452]	; (123cc <main+0x290>)
   12208:	4871      	ldr	r0, [pc, #452]	; (123d0 <main+0x294>)
   1220a:	2300      	movs	r3, #0
   1220c:	f44f 7280 	mov.w	r2, #256	; 0x100
   12210:	47a8      	blx	r5
   12212:	2801      	cmp	r0, #1
   12214:	d000      	beq.n	12218 <main+0xdc>
	    != pdPASS) {
		while (1) {
   12216:	e7fe      	b.n	12216 <main+0xda>
			;
		}
	}

	if (xTaskCreate(inbound_task, "Inbound Task", TASK_INBOUND_STACK_SIZE, NULL, TASK_INBOUND_PRIORITY, &xCreatedInboundTask)
   12218:	f104 0310 	add.w	r3, r4, #16
   1221c:	e9cd 6300 	strd	r6, r3, [sp]
   12220:	496c      	ldr	r1, [pc, #432]	; (123d4 <main+0x298>)
   12222:	486d      	ldr	r0, [pc, #436]	; (123d8 <main+0x29c>)
   12224:	2300      	movs	r3, #0
   12226:	f44f 7280 	mov.w	r2, #256	; 0x100
   1222a:	47a8      	blx	r5
   1222c:	2801      	cmp	r0, #1
   1222e:	d000      	beq.n	12232 <main+0xf6>
	    != pdPASS) {
		while (1) {
   12230:	e7fe      	b.n	12230 <main+0xf4>
			;
		}
	}

	if (xTaskCreate(outbound_task, "Outbound Task", TASK_OUTBOUND_STACK_SIZE, NULL, TASK_OUTBOUND_PRIORITY, &xCreatedOutboundTask)
   12232:	f104 0314 	add.w	r3, r4, #20
   12236:	e9cd 6300 	strd	r6, r3, [sp]
   1223a:	4968      	ldr	r1, [pc, #416]	; (123dc <main+0x2a0>)
   1223c:	4868      	ldr	r0, [pc, #416]	; (123e0 <main+0x2a4>)
   1223e:	2300      	movs	r3, #0
   12240:	f44f 7280 	mov.w	r2, #256	; 0x100
   12244:	47a8      	blx	r5
   12246:	2801      	cmp	r0, #1
   12248:	d000      	beq.n	1224c <main+0x110>
	    != pdPASS) {
		while (1) {
   1224a:	e7fe      	b.n	1224a <main+0x10e>
			;
		}
	}


	if (xTaskCreate(led_task, "Led Task", TASK_LED_STACK_SIZE, NULL, TASK_LED_PRIORITY, &xCreatedLedTask)
   1224c:	f104 0318 	add.w	r3, r4, #24
   12250:	9301      	str	r3, [sp, #4]
   12252:	2304      	movs	r3, #4
   12254:	9300      	str	r3, [sp, #0]
   12256:	4963      	ldr	r1, [pc, #396]	; (123e4 <main+0x2a8>)
   12258:	4863      	ldr	r0, [pc, #396]	; (123e8 <main+0x2ac>)
   1225a:	2300      	movs	r3, #0
   1225c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   12260:	47a8      	blx	r5
   12262:	2801      	cmp	r0, #1
   12264:	d000      	beq.n	12268 <main+0x12c>
	    != pdPASS) {
		while (1) {
   12266:	e7fe      	b.n	12266 <main+0x12a>
			;
		}
	}
    
	if (xTaskCreate(example_task, "Example", TASK_EXAMPLE_STACK_SIZE, NULL, TASK_EXAMPLE_STACK_PRIORITY, &xCreatedExampleTask)
   12268:	341c      	adds	r4, #28
   1226a:	e9cd 6400 	strd	r6, r4, [sp]
   1226e:	495f      	ldr	r1, [pc, #380]	; (123ec <main+0x2b0>)
   12270:	485f      	ldr	r0, [pc, #380]	; (123f0 <main+0x2b4>)
   12272:	2300      	movs	r3, #0
   12274:	2280      	movs	r2, #128	; 0x80
   12276:	47a8      	blx	r5
   12278:	2801      	cmp	r0, #1
   1227a:	d000      	beq.n	1227e <main+0x142>
	    != pdPASS) {
		while (1) {
   1227c:	e7fe      	b.n	1227c <main+0x140>
   1227e:	4d5d      	ldr	r5, [pc, #372]	; (123f4 <main+0x2b8>)
   12280:	f8df a1b0 	ldr.w	sl, [pc, #432]	; 12434 <main+0x2f8>
	uint32_t loopcounter = 0;
   12284:	2400      	movs	r4, #0
	
		
		if (usb_init_flag == 0){
			
			
			if (usb_d_get_frame_num() == 0){
   12286:	4b5c      	ldr	r3, [pc, #368]	; (123f8 <main+0x2bc>)
   12288:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 12438 <main+0x2fc>
   1228c:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 1243c <main+0x300>
   12290:	4f5a      	ldr	r7, [pc, #360]	; (123fc <main+0x2c0>)
   12292:	4e5b      	ldr	r6, [pc, #364]	; (12400 <main+0x2c4>)
   12294:	4798      	blx	r3
   12296:	2800      	cmp	r0, #0
   12298:	d031      	beq.n	122fe <main+0x1c2>
				
			}
			else{			
			
				grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 500); // GREEN	
   1229a:	2400      	movs	r4, #0
   1229c:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   122a0:	22ff      	movs	r2, #255	; 0xff
   122a2:	e9cd 4300 	strd	r4, r3, [sp]
   122a6:	4621      	mov	r1, r4
   122a8:	4623      	mov	r3, r4
   122aa:	4841      	ldr	r0, [pc, #260]	; (123b0 <main+0x274>)
   122ac:	f8df b190 	ldr.w	fp, [pc, #400]	; 12440 <main+0x304>
   122b0:	47d8      	blx	fp
				
				GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Composite Device Connected");
   122b2:	4954      	ldr	r1, [pc, #336]	; (12404 <main+0x2c8>)
   122b4:	9b03      	ldr	r3, [sp, #12]
   122b6:	4829      	ldr	r0, [pc, #164]	; (1235c <main+0x220>)
   122b8:	4798      	blx	r3
				
				grid_sys_set_bank(&grid_sys_state, grid_sys_get_bank_number_of_first_valid(&grid_sys_state));
   122ba:	4b53      	ldr	r3, [pc, #332]	; (12408 <main+0x2cc>)
   122bc:	483c      	ldr	r0, [pc, #240]	; (123b0 <main+0x274>)
   122be:	4798      	blx	r3
   122c0:	4b52      	ldr	r3, [pc, #328]	; (1240c <main+0x2d0>)
   122c2:	4601      	mov	r1, r0
   122c4:	483a      	ldr	r0, [pc, #232]	; (123b0 <main+0x274>)
   122c6:	4798      	blx	r3
				
				grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_RESPONSE);
   122c8:	4622      	mov	r2, r4
   122ca:	4621      	mov	r1, r4
   122cc:	4850      	ldr	r0, [pc, #320]	; (12410 <main+0x2d4>)
   122ce:	4c51      	ldr	r4, [pc, #324]	; (12414 <main+0x2d8>)
   122d0:	2309      	movs	r3, #9
   122d2:	47a0      	blx	r4
				
				usb_init_flag = 1;
				
				

				printf("Forever! \r\n");
   122d4:	4b50      	ldr	r3, [pc, #320]	; (12418 <main+0x2dc>)
   122d6:	4851      	ldr	r0, [pc, #324]	; (1241c <main+0x2e0>)
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   122d8:	4c51      	ldr	r4, [pc, #324]	; (12420 <main+0x2e4>)
				printf("Forever! \r\n");
   122da:	4798      	blx	r3
				delay_ms(2);
   122dc:	2002      	movs	r0, #2
   122de:	47a8      	blx	r5


				vTaskStartScheduler();
   122e0:	4b50      	ldr	r3, [pc, #320]	; (12424 <main+0x2e8>)
   122e2:	4798      	blx	r3

				while(1){
				
		
					
					usb_task_inner();
   122e4:	47d0      	blx	sl
					nvm_task_inner();
   122e6:	47c8      	blx	r9

					receive_task_inner();
   122e8:	47c0      	blx	r8
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   122ea:	4620      	mov	r0, r4
   122ec:	47b8      	blx	r7

					ui_task_inner();

					inbound_task_inner();
   122ee:	47b0      	blx	r6

					outbound_task_inner();
   122f0:	4b4d      	ldr	r3, [pc, #308]	; (12428 <main+0x2ec>)
   122f2:	4798      	blx	r3

					led_task_inner();
   122f4:	4b4d      	ldr	r3, [pc, #308]	; (1242c <main+0x2f0>)
   122f6:	4798      	blx	r3

					delay_ms(1);
   122f8:	2001      	movs	r0, #1
   122fa:	47a8      	blx	r5
				while(1){
   122fc:	e7f2      	b.n	122e4 <main+0x1a8>
		
		
		
		// Request neighbor bank settings if we don't have it initialized
		
 		if (grid_sys_get_bank_valid(&grid_sys_state) == 0 && loopcounter%80 == 0){
   122fe:	f8df b0b0 	ldr.w	fp, [pc, #176]	; 123b0 <main+0x274>
   12302:	4b4b      	ldr	r3, [pc, #300]	; (12430 <main+0x2f4>)
   12304:	4658      	mov	r0, fp
   12306:	4798      	blx	r3
   12308:	b980      	cbnz	r0, 1232c <main+0x1f0>
   1230a:	2250      	movs	r2, #80	; 0x50
   1230c:	fbb4 f3f2 	udiv	r3, r4, r2
   12310:	fb02 4313 	mls	r3, r2, r3, r4
   12314:	b953      	cbnz	r3, 1232c <main+0x1f0>
 								
			if (grid_sys_state.bank_init_flag == 0)	{
   12316:	f89b 3027 	ldrb.w	r3, [fp, #39]	; 0x27
   1231a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   1231e:	b92b      	cbnz	r3, 1232c <main+0x1f0>
				
				grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_REQUEST);
   12320:	483b      	ldr	r0, [pc, #236]	; (12410 <main+0x2d4>)
   12322:	f8df b0f0 	ldr.w	fp, [pc, #240]	; 12414 <main+0x2d8>
   12326:	230a      	movs	r3, #10
   12328:	4611      	mov	r1, r2
   1232a:	47d8      	blx	fp
	

		
		
		
		usb_task_inner();
   1232c:	47d0      	blx	sl
		


		nvm_task_inner();
   1232e:	47c8      	blx	r9
		
					


		receive_task_inner();
   12330:	47c0      	blx	r8
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   12332:	483b      	ldr	r0, [pc, #236]	; (12420 <main+0x2e4>)
   12334:	47b8      	blx	r7
		
		
		
		
		
		inbound_task_inner();
   12336:	47b0      	blx	r6

		outbound_task_inner();
   12338:	4b3b      	ldr	r3, [pc, #236]	; (12428 <main+0x2ec>)
   1233a:	4798      	blx	r3

		led_task_inner();
   1233c:	4b3b      	ldr	r3, [pc, #236]	; (1242c <main+0x2f0>)
   1233e:	4798      	blx	r3

		delay_ms(1);
   12340:	2001      	movs	r0, #1
		loopcounter++;
   12342:	3401      	adds	r4, #1
		delay_ms(1);
   12344:	47a8      	blx	r5
		if (usb_init_flag == 0){
   12346:	e79e      	b.n	12286 <main+0x14a>
   12348:	000130b5 	.word	0x000130b5
   1234c:	00014451 	.word	0x00014451
   12350:	20008dd4 	.word	0x20008dd4
   12354:	00012539 	.word	0x00012539
   12358:	000166d1 	.word	0x000166d1
   1235c:	00015acf 	.word	0x00015acf
   12360:	000166e3 	.word	0x000166e3
   12364:	00006339 	.word	0x00006339
   12368:	00004495 	.word	0x00004495
   1236c:	0000c8fd 	.word	0x0000c8fd
   12370:	0000ac99 	.word	0x0000ac99
   12374:	0000ae91 	.word	0x0000ae91
   12378:	0000af7d 	.word	0x0000af7d
   1237c:	20010264 	.word	0x20010264
   12380:	000166ec 	.word	0x000166ec
   12384:	0000e78d 	.word	0x0000e78d
   12388:	2001cd7c 	.word	0x2001cd7c
   1238c:	20013220 	.word	0x20013220
   12390:	000063a9 	.word	0x000063a9
   12394:	00007081 	.word	0x00007081
   12398:	0000a081 	.word	0x0000a081
   1239c:	2000effc 	.word	0x2000effc
   123a0:	00016709 	.word	0x00016709
   123a4:	000120cd 	.word	0x000120cd
   123a8:	00016721 	.word	0x00016721
   123ac:	2000fa1c 	.word	0x2000fa1c
   123b0:	2000f008 	.word	0x2000f008
   123b4:	0000909d 	.word	0x0000909d
   123b8:	00009aad 	.word	0x00009aad
   123bc:	00016734 	.word	0x00016734
   123c0:	00011cc9 	.word	0x00011cc9
   123c4:	0001673d 	.word	0x0001673d
   123c8:	00016746 	.word	0x00016746
   123cc:	0001674e 	.word	0x0001674e
   123d0:	00011d11 	.word	0x00011d11
   123d4:	0001675b 	.word	0x0001675b
   123d8:	00011bc9 	.word	0x00011bc9
   123dc:	00016768 	.word	0x00016768
   123e0:	00012045 	.word	0x00012045
   123e4:	00016776 	.word	0x00016776
   123e8:	00012055 	.word	0x00012055
   123ec:	0001677f 	.word	0x0001677f
   123f0:	00011b8d 	.word	0x00011b8d
   123f4:	0000dd8d 	.word	0x0000dd8d
   123f8:	0000f511 	.word	0x0000f511
   123fc:	0000a75d 	.word	0x0000a75d
   12400:	00011dbd 	.word	0x00011dbd
   12404:	00016787 	.word	0x00016787
   12408:	00009701 	.word	0x00009701
   1240c:	0000971b 	.word	0x0000971b
   12410:	2001c7c0 	.word	0x2001c7c0
   12414:	0000a149 	.word	0x0000a149
   12418:	0001455d 	.word	0x0001455d
   1241c:	000167a2 	.word	0x000167a2
   12420:	2000c0b0 	.word	0x2000c0b0
   12424:	000126dd 	.word	0x000126dd
   12428:	00011e09 	.word	0x00011e09
   1242c:	00011e51 	.word	0x00011e51
   12430:	000096c3 	.word	0x000096c3
   12434:	00011bd9 	.word	0x00011bd9
   12438:	00011d29 	.word	0x00011d29
   1243c:	00011ce1 	.word	0x00011ce1
   12440:	000097cb 	.word	0x000097cb

00012444 <qspi_dma_init>:
 * \brief Driver version
 */
#define QSPI_DMA_DRIVER_VERSION 0x00000001u

int32_t qspi_dma_init(struct qspi_dma_descriptor *qspi, void *const hw)
{
   12444:	b570      	push	{r4, r5, r6, lr}
   12446:	460d      	mov	r5, r1
	ASSERT(qspi && hw);
   12448:	4604      	mov	r4, r0
   1244a:	b110      	cbz	r0, 12452 <qspi_dma_init+0xe>
   1244c:	1e08      	subs	r0, r1, #0
   1244e:	bf18      	it	ne
   12450:	2001      	movne	r0, #1
   12452:	4905      	ldr	r1, [pc, #20]	; (12468 <qspi_dma_init+0x24>)
   12454:	4b05      	ldr	r3, [pc, #20]	; (1246c <qspi_dma_init+0x28>)
   12456:	2231      	movs	r2, #49	; 0x31
   12458:	4798      	blx	r3

	return _qspi_dma_init(&qspi->dev, hw);
   1245a:	4629      	mov	r1, r5
   1245c:	4620      	mov	r0, r4
   1245e:	4b04      	ldr	r3, [pc, #16]	; (12470 <qspi_dma_init+0x2c>)
}
   12460:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _qspi_dma_init(&qspi->dev, hw);
   12464:	4718      	bx	r3
   12466:	bf00      	nop
   12468:	000167ad 	.word	0x000167ad
   1246c:	0000e03d 	.word	0x0000e03d
   12470:	0000be19 	.word	0x0000be19

00012474 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
   12474:	4906      	ldr	r1, [pc, #24]	; (12490 <prvIdleTask+0x1c>)
				taskYIELD();
   12476:	4b07      	ldr	r3, [pc, #28]	; (12494 <prvIdleTask+0x20>)
   12478:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
   1247c:	6808      	ldr	r0, [r1, #0]
   1247e:	2801      	cmp	r0, #1
   12480:	d9fc      	bls.n	1247c <prvIdleTask+0x8>
				taskYIELD();
   12482:	601a      	str	r2, [r3, #0]
   12484:	f3bf 8f4f 	dsb	sy
   12488:	f3bf 8f6f 	isb	sy
   1248c:	e7f6      	b.n	1247c <prvIdleTask+0x8>
   1248e:	bf00      	nop
   12490:	20008df8 	.word	0x20008df8
   12494:	e000ed04 	.word	0xe000ed04

00012498 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
   12498:	4b07      	ldr	r3, [pc, #28]	; (124b8 <prvResetNextTaskUnblockTime+0x20>)
   1249a:	f8d3 22a8 	ldr.w	r2, [r3, #680]	; 0x2a8
   1249e:	6812      	ldr	r2, [r2, #0]
   124a0:	b922      	cbnz	r2, 124ac <prvResetNextTaskUnblockTime+0x14>
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   124a2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
   124a6:	f8c3 22ac 	str.w	r2, [r3, #684]	; 0x2ac
	}
}
   124aa:	4770      	bx	lr
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
   124ac:	f8d3 22a8 	ldr.w	r2, [r3, #680]	; 0x2a8
   124b0:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
   124b2:	68d2      	ldr	r2, [r2, #12]
   124b4:	6852      	ldr	r2, [r2, #4]
   124b6:	e7f6      	b.n	124a6 <prvResetNextTaskUnblockTime+0xe>
   124b8:	20008df8 	.word	0x20008df8

000124bc <prvAddCurrentTaskToDelayedList>:

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
   124bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	TickType_t       xTimeToWake;
	const TickType_t xConstTickCount = xTickCount;
   124c0:	4f19      	ldr	r7, [pc, #100]	; (12528 <prvAddCurrentTaskToDelayedList+0x6c>)
	}
#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
   124c2:	4b1a      	ldr	r3, [pc, #104]	; (1252c <prvAddCurrentTaskToDelayedList+0x70>)
	const TickType_t xConstTickCount = xTickCount;
   124c4:	f8d7 62b0 	ldr.w	r6, [r7, #688]	; 0x2b0
{
   124c8:	4605      	mov	r5, r0
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
   124ca:	f8d7 02b4 	ldr.w	r0, [r7, #692]	; 0x2b4
   124ce:	3004      	adds	r0, #4
{
   124d0:	4688      	mov	r8, r1
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
   124d2:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

#if (INCLUDE_vTaskSuspend == 1)
	{
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
   124d4:	1c6b      	adds	r3, r5, #1
   124d6:	463c      	mov	r4, r7
   124d8:	d10b      	bne.n	124f2 <prvAddCurrentTaskToDelayedList+0x36>
   124da:	f1b8 0f00 	cmp.w	r8, #0
   124de:	d008      	beq.n	124f2 <prvAddCurrentTaskToDelayedList+0x36>
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
   124e0:	f8d7 12b4 	ldr.w	r1, [r7, #692]	; 0x2b4
   124e4:	4b12      	ldr	r3, [pc, #72]	; (12530 <prvAddCurrentTaskToDelayedList+0x74>)
   124e6:	3104      	adds	r1, #4
   124e8:	f507 7020 	add.w	r0, r7, #640	; 0x280

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		(void)xCanBlockIndefinitely;
	}
#endif /* INCLUDE_vTaskSuspend */
}
   124ec:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
   124f0:	4718      	bx	r3
			listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
   124f2:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   124f6:	1975      	adds	r5, r6, r5
   124f8:	605d      	str	r5, [r3, #4]
			if (xTimeToWake < xConstTickCount) {
   124fa:	4b0e      	ldr	r3, [pc, #56]	; (12534 <prvAddCurrentTaskToDelayedList+0x78>)
   124fc:	d305      	bcc.n	1250a <prvAddCurrentTaskToDelayedList+0x4e>
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
   124fe:	f8d4 02b8 	ldr.w	r0, [r4, #696]	; 0x2b8
   12502:	f8d4 12b4 	ldr.w	r1, [r4, #692]	; 0x2b4
   12506:	3104      	adds	r1, #4
   12508:	e7f0      	b.n	124ec <prvAddCurrentTaskToDelayedList+0x30>
				vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
   1250a:	f8d4 02a8 	ldr.w	r0, [r4, #680]	; 0x2a8
   1250e:	f8d4 12b4 	ldr.w	r1, [r4, #692]	; 0x2b4
   12512:	3104      	adds	r1, #4
   12514:	4798      	blx	r3
				if (xTimeToWake < xNextTaskUnblockTime) {
   12516:	f8d4 32ac 	ldr.w	r3, [r4, #684]	; 0x2ac
   1251a:	42ab      	cmp	r3, r5
					xNextTaskUnblockTime = xTimeToWake;
   1251c:	bf88      	it	hi
   1251e:	f8c4 52ac 	strhi.w	r5, [r4, #684]	; 0x2ac
}
   12522:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12526:	bf00      	nop
   12528:	20008df8 	.word	0x20008df8
   1252c:	0000b167 	.word	0x0000b167
   12530:	0000b121 	.word	0x0000b121
   12534:	0000b139 	.word	0x0000b139

00012538 <xTaskCreate>:
{
   12538:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		pxStack = (StackType_t *)pvPortMalloc(
   1253c:	0095      	lsls	r5, r2, #2
   1253e:	4c5b      	ldr	r4, [pc, #364]	; (126ac <xTaskCreate+0x174>)
{
   12540:	4607      	mov	r7, r0
		pxStack = (StackType_t *)pvPortMalloc(
   12542:	4628      	mov	r0, r5
{
   12544:	460e      	mov	r6, r1
   12546:	4698      	mov	r8, r3
		pxStack = (StackType_t *)pvPortMalloc(
   12548:	47a0      	blx	r4
		if (pxStack != NULL) {
   1254a:	4681      	mov	r9, r0
   1254c:	2800      	cmp	r0, #0
   1254e:	f000 809b 	beq.w	12688 <xTaskCreate+0x150>
			pxNewTCB = (TCB_t *)pvPortMalloc(
   12552:	2054      	movs	r0, #84	; 0x54
   12554:	47a0      	blx	r4
			if (pxNewTCB != NULL) {
   12556:	4604      	mov	r4, r0
   12558:	2800      	cmp	r0, #0
   1255a:	f000 8092 	beq.w	12682 <xTaskCreate+0x14a>
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
   1255e:	4b54      	ldr	r3, [pc, #336]	; (126b0 <xTaskCreate+0x178>)
				pxNewTCB->pxStack = pxStack;
   12560:	f8c0 9030 	str.w	r9, [r0, #48]	; 0x30
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
   12564:	462a      	mov	r2, r5
   12566:	21a5      	movs	r1, #165	; 0xa5
   12568:	4648      	mov	r0, r9
   1256a:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
   1256c:	f8d4 b030 	ldr.w	fp, [r4, #48]	; 0x30
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
   12570:	1e73      	subs	r3, r6, #1
   12572:	f104 0234 	add.w	r2, r4, #52	; 0x34
   12576:	3607      	adds	r6, #7
		pxNewTCB->pcTaskName[x] = pcName[x];
   12578:	f813 1f01 	ldrb.w	r1, [r3, #1]!
   1257c:	f802 1b01 	strb.w	r1, [r2], #1
		if (pcName[x] == 0x00) {
   12580:	7819      	ldrb	r1, [r3, #0]
   12582:	b109      	cbz	r1, 12588 <xTaskCreate+0x50>
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
   12584:	42b3      	cmp	r3, r6
   12586:	d1f7      	bne.n	12578 <xTaskCreate+0x40>
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
   12588:	9e0a      	ldr	r6, [sp, #40]	; 0x28
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   1258a:	4a4a      	ldr	r2, [pc, #296]	; (126b4 <xTaskCreate+0x17c>)
   1258c:	2e1f      	cmp	r6, #31
   1258e:	bf28      	it	cs
   12590:	261f      	movcs	r6, #31
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
   12592:	f04f 0a00 	mov.w	sl, #0
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   12596:	f104 0904 	add.w	r9, r4, #4
		pxNewTCB->uxMutexesHeld  = 0;
   1259a:	e9c4 6a11 	strd	r6, sl, [r4, #68]	; 0x44
	pxNewTCB->uxPriority = uxPriority;
   1259e:	62e6      	str	r6, [r4, #44]	; 0x2c
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   125a0:	4648      	mov	r0, r9
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
   125a2:	f884 a03b 	strb.w	sl, [r4, #59]	; 0x3b
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
   125a6:	3d04      	subs	r5, #4
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   125a8:	4790      	blx	r2
	listSET_LIST_ITEM_VALUE(
   125aa:	f1c6 0620 	rsb	r6, r6, #32
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
   125ae:	4a41      	ldr	r2, [pc, #260]	; (126b4 <xTaskCreate+0x17c>)
   125b0:	f104 0018 	add.w	r0, r4, #24
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
   125b4:	445d      	add	r5, fp
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
   125b6:	4790      	blx	r2
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
   125b8:	4b3f      	ldr	r3, [pc, #252]	; (126b8 <xTaskCreate+0x180>)
		pxNewTCB->ulNotifiedValue = 0;
   125ba:	f8c4 a04c 	str.w	sl, [r4, #76]	; 0x4c
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
   125be:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE(
   125c0:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
   125c2:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ucNotifyState   = taskNOT_WAITING_NOTIFICATION;
   125c4:	f884 a050 	strb.w	sl, [r4, #80]	; 0x50
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
   125c8:	4642      	mov	r2, r8
   125ca:	4639      	mov	r1, r7
   125cc:	f025 0007 	bic.w	r0, r5, #7
   125d0:	4798      	blx	r3
	if ((void *)pxCreatedTask != NULL) {
   125d2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
   125d4:	6020      	str	r0, [r4, #0]
	if ((void *)pxCreatedTask != NULL) {
   125d6:	b103      	cbz	r3, 125da <xTaskCreate+0xa2>
		*pxCreatedTask = (TaskHandle_t)pxNewTCB;
   125d8:	601c      	str	r4, [r3, #0]
		uxCurrentNumberOfTasks++;
   125da:	4d38      	ldr	r5, [pc, #224]	; (126bc <xTaskCreate+0x184>)
	taskENTER_CRITICAL();
   125dc:	4b38      	ldr	r3, [pc, #224]	; (126c0 <xTaskCreate+0x188>)
   125de:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
   125e0:	f8d5 32bc 	ldr.w	r3, [r5, #700]	; 0x2bc
   125e4:	3301      	adds	r3, #1
   125e6:	f8c5 32bc 	str.w	r3, [r5, #700]	; 0x2bc
		if (pxCurrentTCB == NULL) {
   125ea:	f8d5 62b4 	ldr.w	r6, [r5, #692]	; 0x2b4
   125ee:	2e00      	cmp	r6, #0
   125f0:	d14e      	bne.n	12690 <xTaskCreate+0x158>
			pxCurrentTCB = pxNewTCB;
   125f2:	f8c5 42b4 	str.w	r4, [r5, #692]	; 0x2b4
			if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
   125f6:	f8d5 32bc 	ldr.w	r3, [r5, #700]	; 0x2bc
   125fa:	2b01      	cmp	r3, #1
   125fc:	d119      	bne.n	12632 <xTaskCreate+0xfa>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
   125fe:	4f31      	ldr	r7, [pc, #196]	; (126c4 <xTaskCreate+0x18c>)
   12600:	46a8      	mov	r8, r5
   12602:	4640      	mov	r0, r8
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
   12604:	3601      	adds	r6, #1
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
   12606:	47b8      	blx	r7
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
   12608:	2e20      	cmp	r6, #32
   1260a:	f108 0814 	add.w	r8, r8, #20
   1260e:	d1f8      	bne.n	12602 <xTaskCreate+0xca>
	vListInitialise(&xDelayedTaskList1);
   12610:	4e2d      	ldr	r6, [pc, #180]	; (126c8 <xTaskCreate+0x190>)
   12612:	4630      	mov	r0, r6
	vListInitialise(&xDelayedTaskList2);
   12614:	f106 0814 	add.w	r8, r6, #20
	vListInitialise(&xDelayedTaskList1);
   12618:	47b8      	blx	r7
	vListInitialise(&xDelayedTaskList2);
   1261a:	4640      	mov	r0, r8
   1261c:	47b8      	blx	r7
	vListInitialise(&xPendingReadyList);
   1261e:	f1a6 002c 	sub.w	r0, r6, #44	; 0x2c
   12622:	47b8      	blx	r7
		vListInitialise(&xSuspendedTaskList);
   12624:	f1a6 0040 	sub.w	r0, r6, #64	; 0x40
   12628:	47b8      	blx	r7
	pxDelayedTaskList         = &xDelayedTaskList1;
   1262a:	f8c5 62a8 	str.w	r6, [r5, #680]	; 0x2a8
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   1262e:	f8c5 82b8 	str.w	r8, [r5, #696]	; 0x2b8
		uxTaskNumber++;
   12632:	f8d5 32ec 	ldr.w	r3, [r5, #748]	; 0x2ec
		prvAddTaskToReadyList(pxNewTCB);
   12636:	f8d5 22f0 	ldr.w	r2, [r5, #752]	; 0x2f0
		uxTaskNumber++;
   1263a:	3301      	adds	r3, #1
   1263c:	f8c5 32ec 	str.w	r3, [r5, #748]	; 0x2ec
			pxNewTCB->uxTCBNumber = uxTaskNumber;
   12640:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList(pxNewTCB);
   12642:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   12644:	2014      	movs	r0, #20
   12646:	4293      	cmp	r3, r2
   12648:	bf88      	it	hi
   1264a:	f8c5 32f0 	strhi.w	r3, [r5, #752]	; 0x2f0
   1264e:	fb00 5003 	mla	r0, r0, r3, r5
   12652:	4649      	mov	r1, r9
   12654:	4b1d      	ldr	r3, [pc, #116]	; (126cc <xTaskCreate+0x194>)
   12656:	4798      	blx	r3
	taskEXIT_CRITICAL();
   12658:	4b1d      	ldr	r3, [pc, #116]	; (126d0 <xTaskCreate+0x198>)
   1265a:	4798      	blx	r3
	if (xSchedulerRunning != pdFALSE) {
   1265c:	f8d5 32e8 	ldr.w	r3, [r5, #744]	; 0x2e8
   12660:	b16b      	cbz	r3, 1267e <xTaskCreate+0x146>
		if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
   12662:	f8d5 32b4 	ldr.w	r3, [r5, #692]	; 0x2b4
   12666:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12668:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   1266a:	429a      	cmp	r2, r3
   1266c:	d207      	bcs.n	1267e <xTaskCreate+0x146>
			taskYIELD_IF_USING_PREEMPTION();
   1266e:	4b19      	ldr	r3, [pc, #100]	; (126d4 <xTaskCreate+0x19c>)
   12670:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12674:	601a      	str	r2, [r3, #0]
   12676:	f3bf 8f4f 	dsb	sy
   1267a:	f3bf 8f6f 	isb	sy
		xReturn = pdPASS;
   1267e:	2001      	movs	r0, #1
	return xReturn;
   12680:	e004      	b.n	1268c <xTaskCreate+0x154>
				vPortFree(pxStack);
   12682:	4b15      	ldr	r3, [pc, #84]	; (126d8 <xTaskCreate+0x1a0>)
   12684:	4648      	mov	r0, r9
   12686:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   12688:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   1268c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (xSchedulerRunning == pdFALSE) {
   12690:	f8d5 32e8 	ldr.w	r3, [r5, #744]	; 0x2e8
   12694:	2b00      	cmp	r3, #0
   12696:	d1cc      	bne.n	12632 <xTaskCreate+0xfa>
				if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
   12698:	f8d5 32b4 	ldr.w	r3, [r5, #692]	; 0x2b4
   1269c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1269e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   126a0:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
   126a2:	bf98      	it	ls
   126a4:	f8c5 42b4 	strls.w	r4, [r5, #692]	; 0x2b4
   126a8:	e7c3      	b.n	12632 <xTaskCreate+0xfa>
   126aa:	bf00      	nop
   126ac:	0000b615 	.word	0x0000b615
   126b0:	000142f1 	.word	0x000142f1
   126b4:	0000b11b 	.word	0x0000b11b
   126b8:	0000b205 	.word	0x0000b205
   126bc:	20008df8 	.word	0x20008df8
   126c0:	0000b255 	.word	0x0000b255
   126c4:	0000b105 	.word	0x0000b105
   126c8:	200090b8 	.word	0x200090b8
   126cc:	0000b121 	.word	0x0000b121
   126d0:	0000b299 	.word	0x0000b299
   126d4:	e000ed04 	.word	0xe000ed04
   126d8:	0000b719 	.word	0x0000b719

000126dc <vTaskStartScheduler>:
{
   126dc:	b573      	push	{r0, r1, r4, r5, r6, lr}
		xReturn = xTaskCreate(prvIdleTask,
   126de:	4c1a      	ldr	r4, [pc, #104]	; (12748 <vTaskStartScheduler+0x6c>)
   126e0:	491a      	ldr	r1, [pc, #104]	; (1274c <vTaskStartScheduler+0x70>)
   126e2:	481b      	ldr	r0, [pc, #108]	; (12750 <vTaskStartScheduler+0x74>)
   126e4:	4e1b      	ldr	r6, [pc, #108]	; (12754 <vTaskStartScheduler+0x78>)
   126e6:	f504 733e 	add.w	r3, r4, #760	; 0x2f8
   126ea:	2500      	movs	r5, #0
   126ec:	9301      	str	r3, [sp, #4]
   126ee:	9500      	str	r5, [sp, #0]
   126f0:	462b      	mov	r3, r5
   126f2:	2240      	movs	r2, #64	; 0x40
   126f4:	47b0      	blx	r6
		if (xReturn == pdPASS) {
   126f6:	2801      	cmp	r0, #1
   126f8:	d118      	bne.n	1272c <vTaskStartScheduler+0x50>
			xReturn = xTimerCreateTimerTask();
   126fa:	4b17      	ldr	r3, [pc, #92]	; (12758 <vTaskStartScheduler+0x7c>)
   126fc:	4798      	blx	r3
	if (xReturn == pdPASS) {
   126fe:	2801      	cmp	r0, #1
   12700:	d114      	bne.n	1272c <vTaskStartScheduler+0x50>
   12702:	f04f 0380 	mov.w	r3, #128	; 0x80
   12706:	f383 8811 	msr	BASEPRI, r3
   1270a:	f3bf 8f6f 	isb	sy
   1270e:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
   12712:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12716:	f8c4 32ac 	str.w	r3, [r4, #684]	; 0x2ac
		if (xPortStartScheduler() != pdFALSE) {
   1271a:	4b10      	ldr	r3, [pc, #64]	; (1275c <vTaskStartScheduler+0x80>)
		xSchedulerRunning    = pdTRUE;
   1271c:	f8c4 02e8 	str.w	r0, [r4, #744]	; 0x2e8
		xTickCount           = (TickType_t)0U;
   12720:	f8c4 52b0 	str.w	r5, [r4, #688]	; 0x2b0
}
   12724:	b002      	add	sp, #8
   12726:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if (xPortStartScheduler() != pdFALSE) {
   1272a:	4718      	bx	r3
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
   1272c:	3001      	adds	r0, #1
   1272e:	d108      	bne.n	12742 <vTaskStartScheduler+0x66>
   12730:	f04f 0380 	mov.w	r3, #128	; 0x80
   12734:	f383 8811 	msr	BASEPRI, r3
   12738:	f3bf 8f6f 	isb	sy
   1273c:	f3bf 8f4f 	dsb	sy
   12740:	e7fe      	b.n	12740 <vTaskStartScheduler+0x64>
}
   12742:	b002      	add	sp, #8
   12744:	bd70      	pop	{r4, r5, r6, pc}
   12746:	bf00      	nop
   12748:	20008df8 	.word	0x20008df8
   1274c:	000167c7 	.word	0x000167c7
   12750:	00012475 	.word	0x00012475
   12754:	00012539 	.word	0x00012539
   12758:	0000da71 	.word	0x0000da71
   1275c:	0000b379 	.word	0x0000b379

00012760 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
   12760:	4a03      	ldr	r2, [pc, #12]	; (12770 <vTaskSuspendAll+0x10>)
   12762:	f8d2 32f4 	ldr.w	r3, [r2, #756]	; 0x2f4
   12766:	3301      	adds	r3, #1
   12768:	f8c2 32f4 	str.w	r3, [r2, #756]	; 0x2f4
}
   1276c:	4770      	bx	lr
   1276e:	bf00      	nop
   12770:	20008df8 	.word	0x20008df8

00012774 <xTaskGetTickCount>:
		xTicks = xTickCount;
   12774:	4b01      	ldr	r3, [pc, #4]	; (1277c <xTaskGetTickCount+0x8>)
   12776:	f8d3 02b0 	ldr.w	r0, [r3, #688]	; 0x2b0
}
   1277a:	4770      	bx	lr
   1277c:	20008df8 	.word	0x20008df8

00012780 <pcTaskGetName>:
	pxTCB = prvGetTCBFromHandle(xTaskToQuery);
   12780:	b960      	cbnz	r0, 1279c <pcTaskGetName+0x1c>
   12782:	4b07      	ldr	r3, [pc, #28]	; (127a0 <pcTaskGetName+0x20>)
   12784:	f8d3 02b4 	ldr.w	r0, [r3, #692]	; 0x2b4
	configASSERT(pxTCB);
   12788:	b940      	cbnz	r0, 1279c <pcTaskGetName+0x1c>
   1278a:	f04f 0380 	mov.w	r3, #128	; 0x80
   1278e:	f383 8811 	msr	BASEPRI, r3
   12792:	f3bf 8f6f 	isb	sy
   12796:	f3bf 8f4f 	dsb	sy
   1279a:	e7fe      	b.n	1279a <pcTaskGetName+0x1a>
}
   1279c:	3034      	adds	r0, #52	; 0x34
   1279e:	4770      	bx	lr
   127a0:	20008df8 	.word	0x20008df8

000127a4 <xTaskIncrementTick>:
{
   127a4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   127a8:	4b3b      	ldr	r3, [pc, #236]	; (12898 <xTaskIncrementTick+0xf4>)
   127aa:	f8d3 22f4 	ldr.w	r2, [r3, #756]	; 0x2f4
   127ae:	461c      	mov	r4, r3
   127b0:	2a00      	cmp	r2, #0
   127b2:	d16a      	bne.n	1288a <xTaskIncrementTick+0xe6>
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
   127b4:	f8d3 72b0 	ldr.w	r7, [r3, #688]	; 0x2b0
   127b8:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
   127ba:	f8c3 72b0 	str.w	r7, [r3, #688]	; 0x2b0
		if (xConstTickCount
   127be:	b9df      	cbnz	r7, 127f8 <xTaskIncrementTick+0x54>
			taskSWITCH_DELAYED_LISTS();
   127c0:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
   127c4:	681b      	ldr	r3, [r3, #0]
   127c6:	b143      	cbz	r3, 127da <xTaskIncrementTick+0x36>
   127c8:	f04f 0380 	mov.w	r3, #128	; 0x80
   127cc:	f383 8811 	msr	BASEPRI, r3
   127d0:	f3bf 8f6f 	isb	sy
   127d4:	f3bf 8f4f 	dsb	sy
   127d8:	e7fe      	b.n	127d8 <xTaskIncrementTick+0x34>
   127da:	f8d4 32a8 	ldr.w	r3, [r4, #680]	; 0x2a8
   127de:	f8d4 22b8 	ldr.w	r2, [r4, #696]	; 0x2b8
   127e2:	f8c4 22a8 	str.w	r2, [r4, #680]	; 0x2a8
   127e6:	f8c4 32b8 	str.w	r3, [r4, #696]	; 0x2b8
   127ea:	f8d4 32fc 	ldr.w	r3, [r4, #764]	; 0x2fc
   127ee:	3301      	adds	r3, #1
   127f0:	f8c4 32fc 	str.w	r3, [r4, #764]	; 0x2fc
   127f4:	4b29      	ldr	r3, [pc, #164]	; (1289c <xTaskIncrementTick+0xf8>)
   127f6:	4798      	blx	r3
		if (xConstTickCount >= xNextTaskUnblockTime) {
   127f8:	f8d4 32ac 	ldr.w	r3, [r4, #684]	; 0x2ac
   127fc:	42bb      	cmp	r3, r7
	BaseType_t xSwitchRequired = pdFALSE;
   127fe:	f04f 0500 	mov.w	r5, #0
		if (xConstTickCount >= xNextTaskUnblockTime) {
   12802:	d910      	bls.n	12826 <xTaskIncrementTick+0x82>
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
   12804:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   12808:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1280a:	2314      	movs	r3, #20
   1280c:	4353      	muls	r3, r2
   1280e:	58e3      	ldr	r3, [r4, r3]
				xSwitchRequired = pdTRUE;
   12810:	2b02      	cmp	r3, #2
   12812:	bf28      	it	cs
   12814:	2501      	movcs	r5, #1
		if (xYieldPending != pdFALSE) {
   12816:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
			xSwitchRequired = pdTRUE;
   1281a:	2b00      	cmp	r3, #0
}
   1281c:	bf0c      	ite	eq
   1281e:	4628      	moveq	r0, r5
   12820:	2001      	movne	r0, #1
   12822:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					(void)uxListRemove(&(pxTCB->xStateListItem));
   12826:	f8df 8078 	ldr.w	r8, [pc, #120]	; 128a0 <xTaskIncrementTick+0xfc>
					prvAddTaskToReadyList(pxTCB);
   1282a:	f8df 9078 	ldr.w	r9, [pc, #120]	; 128a4 <xTaskIncrementTick+0x100>
   1282e:	f04f 0a14 	mov.w	sl, #20
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
   12832:	f8d4 32a8 	ldr.w	r3, [r4, #680]	; 0x2a8
   12836:	681b      	ldr	r3, [r3, #0]
   12838:	b923      	cbnz	r3, 12844 <xTaskIncrementTick+0xa0>
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1283a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
						xNextTaskUnblockTime = xItemValue;
   1283e:	f8c4 32ac 	str.w	r3, [r4, #684]	; 0x2ac
						break;
   12842:	e7df      	b.n	12804 <xTaskIncrementTick+0x60>
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
   12844:	f8d4 32a8 	ldr.w	r3, [r4, #680]	; 0x2a8
   12848:	68db      	ldr	r3, [r3, #12]
   1284a:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
   1284c:	6873      	ldr	r3, [r6, #4]
					if (xConstTickCount < xItemValue) {
   1284e:	429f      	cmp	r7, r3
   12850:	d3f5      	bcc.n	1283e <xTaskIncrementTick+0x9a>
					(void)uxListRemove(&(pxTCB->xStateListItem));
   12852:	f106 0b04 	add.w	fp, r6, #4
   12856:	4658      	mov	r0, fp
   12858:	47c0      	blx	r8
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
   1285a:	6ab3      	ldr	r3, [r6, #40]	; 0x28
   1285c:	b113      	cbz	r3, 12864 <xTaskIncrementTick+0xc0>
						(void)uxListRemove(&(pxTCB->xEventListItem));
   1285e:	f106 0018 	add.w	r0, r6, #24
   12862:	47c0      	blx	r8
					prvAddTaskToReadyList(pxTCB);
   12864:	6af0      	ldr	r0, [r6, #44]	; 0x2c
   12866:	f8d4 32f0 	ldr.w	r3, [r4, #752]	; 0x2f0
   1286a:	4298      	cmp	r0, r3
   1286c:	bf88      	it	hi
   1286e:	f8c4 02f0 	strhi.w	r0, [r4, #752]	; 0x2f0
   12872:	4659      	mov	r1, fp
   12874:	fb0a 4000 	mla	r0, sl, r0, r4
   12878:	47c8      	blx	r9
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
   1287a:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   1287e:	6af2      	ldr	r2, [r6, #44]	; 0x2c
   12880:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
   12882:	429a      	cmp	r2, r3
   12884:	bf28      	it	cs
   12886:	2501      	movcs	r5, #1
   12888:	e7d3      	b.n	12832 <xTaskIncrementTick+0x8e>
		++uxPendedTicks;
   1288a:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
   1288e:	3301      	adds	r3, #1
   12890:	f8c4 3300 	str.w	r3, [r4, #768]	; 0x300
	BaseType_t xSwitchRequired = pdFALSE;
   12894:	2500      	movs	r5, #0
   12896:	e7be      	b.n	12816 <xTaskIncrementTick+0x72>
   12898:	20008df8 	.word	0x20008df8
   1289c:	00012499 	.word	0x00012499
   128a0:	0000b167 	.word	0x0000b167
   128a4:	0000b121 	.word	0x0000b121

000128a8 <xTaskResumeAll>:
{
   128a8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	configASSERT(uxSchedulerSuspended);
   128ac:	4c33      	ldr	r4, [pc, #204]	; (1297c <xTaskResumeAll+0xd4>)
   128ae:	f8d4 32f4 	ldr.w	r3, [r4, #756]	; 0x2f4
   128b2:	b943      	cbnz	r3, 128c6 <xTaskResumeAll+0x1e>
   128b4:	f04f 0380 	mov.w	r3, #128	; 0x80
   128b8:	f383 8811 	msr	BASEPRI, r3
   128bc:	f3bf 8f6f 	isb	sy
   128c0:	f3bf 8f4f 	dsb	sy
   128c4:	e7fe      	b.n	128c4 <xTaskResumeAll+0x1c>
	taskENTER_CRITICAL();
   128c6:	4b2e      	ldr	r3, [pc, #184]	; (12980 <xTaskResumeAll+0xd8>)
   128c8:	4798      	blx	r3
		--uxSchedulerSuspended;
   128ca:	f8d4 32f4 	ldr.w	r3, [r4, #756]	; 0x2f4
   128ce:	3b01      	subs	r3, #1
   128d0:	f8c4 32f4 	str.w	r3, [r4, #756]	; 0x2f4
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   128d4:	f8d4 52f4 	ldr.w	r5, [r4, #756]	; 0x2f4
   128d8:	b135      	cbz	r5, 128e8 <xTaskResumeAll+0x40>
	BaseType_t xAlreadyYielded = pdFALSE;
   128da:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   128dc:	4b29      	ldr	r3, [pc, #164]	; (12984 <xTaskResumeAll+0xdc>)
   128de:	4798      	blx	r3
}
   128e0:	4620      	mov	r0, r4
   128e2:	b002      	add	sp, #8
   128e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
   128e8:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
   128ec:	2b00      	cmp	r3, #0
   128ee:	d0f4      	beq.n	128da <xTaskResumeAll+0x32>
					(void)uxListRemove(&(pxTCB->xEventListItem));
   128f0:	4e25      	ldr	r6, [pc, #148]	; (12988 <xTaskResumeAll+0xe0>)
					prvAddTaskToReadyList(pxTCB);
   128f2:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 12998 <xTaskResumeAll+0xf0>
   128f6:	2714      	movs	r7, #20
   128f8:	e01d      	b.n	12936 <xTaskResumeAll+0x8e>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
   128fa:	f8d4 32a0 	ldr.w	r3, [r4, #672]	; 0x2a0
   128fe:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
   12900:	f105 0018 	add.w	r0, r5, #24
   12904:	47b0      	blx	r6
					(void)uxListRemove(&(pxTCB->xStateListItem));
   12906:	1d29      	adds	r1, r5, #4
   12908:	4608      	mov	r0, r1
   1290a:	9101      	str	r1, [sp, #4]
   1290c:	47b0      	blx	r6
					prvAddTaskToReadyList(pxTCB);
   1290e:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
   12910:	f8d4 32f0 	ldr.w	r3, [r4, #752]	; 0x2f0
   12914:	9901      	ldr	r1, [sp, #4]
   12916:	4298      	cmp	r0, r3
   12918:	bf88      	it	hi
   1291a:	f8c4 02f0 	strhi.w	r0, [r4, #752]	; 0x2f0
   1291e:	fb07 4000 	mla	r0, r7, r0, r4
   12922:	47c0      	blx	r8
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
   12924:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   12928:	6aea      	ldr	r2, [r5, #44]	; 0x2c
   1292a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1292c:	429a      	cmp	r2, r3
   1292e:	d302      	bcc.n	12936 <xTaskResumeAll+0x8e>
						xYieldPending = pdTRUE;
   12930:	2301      	movs	r3, #1
   12932:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
   12936:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
   1293a:	2b00      	cmp	r3, #0
   1293c:	d1dd      	bne.n	128fa <xTaskResumeAll+0x52>
				if (pxTCB != NULL) {
   1293e:	b10d      	cbz	r5, 12944 <xTaskResumeAll+0x9c>
					prvResetNextTaskUnblockTime();
   12940:	4b12      	ldr	r3, [pc, #72]	; (1298c <xTaskResumeAll+0xe4>)
   12942:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   12944:	f8d4 5300 	ldr.w	r5, [r4, #768]	; 0x300
					if (uxPendedCounts > (UBaseType_t)0U) {
   12948:	b14d      	cbz	r5, 1295e <xTaskResumeAll+0xb6>
							if (xTaskIncrementTick() != pdFALSE) {
   1294a:	4e11      	ldr	r6, [pc, #68]	; (12990 <xTaskResumeAll+0xe8>)
								xYieldPending = pdTRUE;
   1294c:	2701      	movs	r7, #1
							if (xTaskIncrementTick() != pdFALSE) {
   1294e:	47b0      	blx	r6
   12950:	b108      	cbz	r0, 12956 <xTaskResumeAll+0xae>
								xYieldPending = pdTRUE;
   12952:	f8c4 7304 	str.w	r7, [r4, #772]	; 0x304
						} while (uxPendedCounts > (UBaseType_t)0U);
   12956:	3d01      	subs	r5, #1
   12958:	d1f9      	bne.n	1294e <xTaskResumeAll+0xa6>
						uxPendedTicks = 0;
   1295a:	f8c4 5300 	str.w	r5, [r4, #768]	; 0x300
				if (xYieldPending != pdFALSE) {
   1295e:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
   12962:	2b00      	cmp	r3, #0
   12964:	d0b9      	beq.n	128da <xTaskResumeAll+0x32>
					taskYIELD_IF_USING_PREEMPTION();
   12966:	4b0b      	ldr	r3, [pc, #44]	; (12994 <xTaskResumeAll+0xec>)
   12968:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1296c:	601a      	str	r2, [r3, #0]
   1296e:	f3bf 8f4f 	dsb	sy
   12972:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
   12976:	2401      	movs	r4, #1
   12978:	e7b0      	b.n	128dc <xTaskResumeAll+0x34>
   1297a:	bf00      	nop
   1297c:	20008df8 	.word	0x20008df8
   12980:	0000b255 	.word	0x0000b255
   12984:	0000b299 	.word	0x0000b299
   12988:	0000b167 	.word	0x0000b167
   1298c:	00012499 	.word	0x00012499
   12990:	000127a5 	.word	0x000127a5
   12994:	e000ed04 	.word	0xe000ed04
   12998:	0000b121 	.word	0x0000b121

0001299c <vTaskDelay>:
{
   1299c:	b508      	push	{r3, lr}
	if (xTicksToDelay > (TickType_t)0U) {
   1299e:	b940      	cbnz	r0, 129b2 <vTaskDelay+0x16>
		portYIELD_WITHIN_API();
   129a0:	4b0f      	ldr	r3, [pc, #60]	; (129e0 <vTaskDelay+0x44>)
   129a2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   129a6:	601a      	str	r2, [r3, #0]
   129a8:	f3bf 8f4f 	dsb	sy
   129ac:	f3bf 8f6f 	isb	sy
}
   129b0:	bd08      	pop	{r3, pc}
		configASSERT(uxSchedulerSuspended == 0);
   129b2:	4b0c      	ldr	r3, [pc, #48]	; (129e4 <vTaskDelay+0x48>)
   129b4:	f8d3 12f4 	ldr.w	r1, [r3, #756]	; 0x2f4
   129b8:	b141      	cbz	r1, 129cc <vTaskDelay+0x30>
   129ba:	f04f 0380 	mov.w	r3, #128	; 0x80
   129be:	f383 8811 	msr	BASEPRI, r3
   129c2:	f3bf 8f6f 	isb	sy
   129c6:	f3bf 8f4f 	dsb	sy
   129ca:	e7fe      	b.n	129ca <vTaskDelay+0x2e>
		vTaskSuspendAll();
   129cc:	4b06      	ldr	r3, [pc, #24]	; (129e8 <vTaskDelay+0x4c>)
   129ce:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
   129d0:	4b06      	ldr	r3, [pc, #24]	; (129ec <vTaskDelay+0x50>)
   129d2:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
   129d4:	4b06      	ldr	r3, [pc, #24]	; (129f0 <vTaskDelay+0x54>)
   129d6:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
   129d8:	2800      	cmp	r0, #0
   129da:	d0e1      	beq.n	129a0 <vTaskDelay+0x4>
   129dc:	e7e8      	b.n	129b0 <vTaskDelay+0x14>
   129de:	bf00      	nop
   129e0:	e000ed04 	.word	0xe000ed04
   129e4:	20008df8 	.word	0x20008df8
   129e8:	00012761 	.word	0x00012761
   129ec:	000124bd 	.word	0x000124bd
   129f0:	000128a9 	.word	0x000128a9

000129f4 <vTaskSwitchContext>:
{
   129f4:	b538      	push	{r3, r4, r5, lr}
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
   129f6:	4b20      	ldr	r3, [pc, #128]	; (12a78 <vTaskSwitchContext+0x84>)
   129f8:	f8d3 22f4 	ldr.w	r2, [r3, #756]	; 0x2f4
   129fc:	461c      	mov	r4, r3
   129fe:	b11a      	cbz	r2, 12a08 <vTaskSwitchContext+0x14>
		xYieldPending = pdTRUE;
   12a00:	2201      	movs	r2, #1
   12a02:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   12a06:	bd38      	pop	{r3, r4, r5, pc}
		xYieldPending = pdFALSE;
   12a08:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		taskCHECK_FOR_STACK_OVERFLOW();
   12a0c:	f8d3 22b4 	ldr.w	r2, [r3, #692]	; 0x2b4
   12a10:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
   12a14:	6812      	ldr	r2, [r2, #0]
   12a16:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   12a18:	429a      	cmp	r2, r3
   12a1a:	d806      	bhi.n	12a2a <vTaskSwitchContext+0x36>
   12a1c:	f8d4 02b4 	ldr.w	r0, [r4, #692]	; 0x2b4
   12a20:	f8d4 12b4 	ldr.w	r1, [r4, #692]	; 0x2b4
   12a24:	4b15      	ldr	r3, [pc, #84]	; (12a7c <vTaskSwitchContext+0x88>)
   12a26:	3134      	adds	r1, #52	; 0x34
   12a28:	4798      	blx	r3
		taskSELECT_HIGHEST_PRIORITY_TASK();
   12a2a:	f8d4 22f0 	ldr.w	r2, [r4, #752]	; 0x2f0
   12a2e:	2514      	movs	r5, #20
   12a30:	fb05 f302 	mul.w	r3, r5, r2
   12a34:	18e1      	adds	r1, r4, r3
   12a36:	58e0      	ldr	r0, [r4, r3]
   12a38:	b190      	cbz	r0, 12a60 <vTaskSwitchContext+0x6c>
   12a3a:	6848      	ldr	r0, [r1, #4]
   12a3c:	3308      	adds	r3, #8
   12a3e:	6840      	ldr	r0, [r0, #4]
   12a40:	6048      	str	r0, [r1, #4]
   12a42:	4423      	add	r3, r4
   12a44:	4298      	cmp	r0, r3
   12a46:	bf04      	itt	eq
   12a48:	6843      	ldreq	r3, [r0, #4]
   12a4a:	604b      	streq	r3, [r1, #4]
   12a4c:	2314      	movs	r3, #20
   12a4e:	fb03 4302 	mla	r3, r3, r2, r4
   12a52:	685b      	ldr	r3, [r3, #4]
   12a54:	68db      	ldr	r3, [r3, #12]
   12a56:	f8c4 32b4 	str.w	r3, [r4, #692]	; 0x2b4
   12a5a:	f8c4 22f0 	str.w	r2, [r4, #752]	; 0x2f0
}
   12a5e:	e7d2      	b.n	12a06 <vTaskSwitchContext+0x12>
		taskSELECT_HIGHEST_PRIORITY_TASK();
   12a60:	b942      	cbnz	r2, 12a74 <vTaskSwitchContext+0x80>
   12a62:	f04f 0380 	mov.w	r3, #128	; 0x80
   12a66:	f383 8811 	msr	BASEPRI, r3
   12a6a:	f3bf 8f6f 	isb	sy
   12a6e:	f3bf 8f4f 	dsb	sy
   12a72:	e7fe      	b.n	12a72 <vTaskSwitchContext+0x7e>
   12a74:	3a01      	subs	r2, #1
   12a76:	e7db      	b.n	12a30 <vTaskSwitchContext+0x3c>
   12a78:	20008df8 	.word	0x20008df8
   12a7c:	00012095 	.word	0x00012095

00012a80 <vTaskPlaceOnEventList>:
{
   12a80:	b510      	push	{r4, lr}
   12a82:	460c      	mov	r4, r1
	configASSERT(pxEventList);
   12a84:	b940      	cbnz	r0, 12a98 <vTaskPlaceOnEventList+0x18>
   12a86:	f04f 0380 	mov.w	r3, #128	; 0x80
   12a8a:	f383 8811 	msr	BASEPRI, r3
   12a8e:	f3bf 8f6f 	isb	sy
   12a92:	f3bf 8f4f 	dsb	sy
   12a96:	e7fe      	b.n	12a96 <vTaskPlaceOnEventList+0x16>
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
   12a98:	4b05      	ldr	r3, [pc, #20]	; (12ab0 <vTaskPlaceOnEventList+0x30>)
   12a9a:	f8d3 12b4 	ldr.w	r1, [r3, #692]	; 0x2b4
   12a9e:	4b05      	ldr	r3, [pc, #20]	; (12ab4 <vTaskPlaceOnEventList+0x34>)
   12aa0:	3118      	adds	r1, #24
   12aa2:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
   12aa4:	4620      	mov	r0, r4
   12aa6:	4b04      	ldr	r3, [pc, #16]	; (12ab8 <vTaskPlaceOnEventList+0x38>)
}
   12aa8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
   12aac:	2101      	movs	r1, #1
   12aae:	4718      	bx	r3
   12ab0:	20008df8 	.word	0x20008df8
   12ab4:	0000b139 	.word	0x0000b139
   12ab8:	000124bd 	.word	0x000124bd

00012abc <vTaskPlaceOnEventListRestricted>:
{
   12abc:	b570      	push	{r4, r5, r6, lr}
   12abe:	460d      	mov	r5, r1
   12ac0:	4614      	mov	r4, r2
	configASSERT(pxEventList);
   12ac2:	b940      	cbnz	r0, 12ad6 <vTaskPlaceOnEventListRestricted+0x1a>
   12ac4:	f04f 0380 	mov.w	r3, #128	; 0x80
   12ac8:	f383 8811 	msr	BASEPRI, r3
   12acc:	f3bf 8f6f 	isb	sy
   12ad0:	f3bf 8f4f 	dsb	sy
   12ad4:	e7fe      	b.n	12ad4 <vTaskPlaceOnEventListRestricted+0x18>
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
   12ad6:	4b08      	ldr	r3, [pc, #32]	; (12af8 <vTaskPlaceOnEventListRestricted+0x3c>)
   12ad8:	f8d3 12b4 	ldr.w	r1, [r3, #692]	; 0x2b4
   12adc:	4b07      	ldr	r3, [pc, #28]	; (12afc <vTaskPlaceOnEventListRestricted+0x40>)
   12ade:	3118      	adds	r1, #24
   12ae0:	4798      	blx	r3
		xTicksToWait = portMAX_DELAY;
   12ae2:	2c00      	cmp	r4, #0
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
   12ae4:	4621      	mov	r1, r4
   12ae6:	bf08      	it	eq
   12ae8:	4628      	moveq	r0, r5
   12aea:	4b05      	ldr	r3, [pc, #20]	; (12b00 <vTaskPlaceOnEventListRestricted+0x44>)
}
   12aec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
   12af0:	bf18      	it	ne
   12af2:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   12af6:	4718      	bx	r3
   12af8:	20008df8 	.word	0x20008df8
   12afc:	0000b121 	.word	0x0000b121
   12b00:	000124bd 	.word	0x000124bd

00012b04 <xTaskRemoveFromEventList>:
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
   12b04:	68c3      	ldr	r3, [r0, #12]
{
   12b06:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
   12b08:	68df      	ldr	r7, [r3, #12]
	configASSERT(pxUnblockedTCB);
   12b0a:	b947      	cbnz	r7, 12b1e <xTaskRemoveFromEventList+0x1a>
   12b0c:	f04f 0380 	mov.w	r3, #128	; 0x80
   12b10:	f383 8811 	msr	BASEPRI, r3
   12b14:	f3bf 8f6f 	isb	sy
   12b18:	f3bf 8f4f 	dsb	sy
   12b1c:	e7fe      	b.n	12b1c <xTaskRemoveFromEventList+0x18>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
   12b1e:	f107 0118 	add.w	r1, r7, #24
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   12b22:	4c15      	ldr	r4, [pc, #84]	; (12b78 <xTaskRemoveFromEventList+0x74>)
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
   12b24:	4e15      	ldr	r6, [pc, #84]	; (12b7c <xTaskRemoveFromEventList+0x78>)
   12b26:	9101      	str	r1, [sp, #4]
   12b28:	4608      	mov	r0, r1
   12b2a:	47b0      	blx	r6
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   12b2c:	f8d4 32f4 	ldr.w	r3, [r4, #756]	; 0x2f4
   12b30:	4d13      	ldr	r5, [pc, #76]	; (12b80 <xTaskRemoveFromEventList+0x7c>)
   12b32:	9901      	ldr	r1, [sp, #4]
   12b34:	b9e3      	cbnz	r3, 12b70 <xTaskRemoveFromEventList+0x6c>
		(void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
   12b36:	1d39      	adds	r1, r7, #4
   12b38:	4608      	mov	r0, r1
   12b3a:	9101      	str	r1, [sp, #4]
   12b3c:	47b0      	blx	r6
		prvAddTaskToReadyList(pxUnblockedTCB);
   12b3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   12b40:	f8d4 22f0 	ldr.w	r2, [r4, #752]	; 0x2f0
   12b44:	9901      	ldr	r1, [sp, #4]
   12b46:	4293      	cmp	r3, r2
   12b48:	f04f 0014 	mov.w	r0, #20
   12b4c:	bf88      	it	hi
   12b4e:	f8c4 32f0 	strhi.w	r3, [r4, #752]	; 0x2f0
   12b52:	fb00 4003 	mla	r0, r0, r3, r4
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
   12b56:	47a8      	blx	r5
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
   12b58:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   12b5c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   12b5e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12b60:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
   12b62:	bf8a      	itet	hi
   12b64:	2001      	movhi	r0, #1
		xReturn = pdFALSE;
   12b66:	2000      	movls	r0, #0
		xYieldPending = pdTRUE;
   12b68:	f8c4 0304 	strhi.w	r0, [r4, #772]	; 0x304
}
   12b6c:	b003      	add	sp, #12
   12b6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
   12b70:	f504 7025 	add.w	r0, r4, #660	; 0x294
   12b74:	e7ef      	b.n	12b56 <xTaskRemoveFromEventList+0x52>
   12b76:	bf00      	nop
   12b78:	20008df8 	.word	0x20008df8
   12b7c:	0000b167 	.word	0x0000b167
   12b80:	0000b121 	.word	0x0000b121

00012b84 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
   12b84:	4b03      	ldr	r3, [pc, #12]	; (12b94 <vTaskInternalSetTimeOutState+0x10>)
   12b86:	f8d3 22fc 	ldr.w	r2, [r3, #764]	; 0x2fc
	pxTimeOut->xTimeOnEntering = xTickCount;
   12b8a:	f8d3 32b0 	ldr.w	r3, [r3, #688]	; 0x2b0
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
   12b8e:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   12b90:	6043      	str	r3, [r0, #4]
}
   12b92:	4770      	bx	lr
   12b94:	20008df8 	.word	0x20008df8

00012b98 <xTaskCheckForTimeOut>:
{
   12b98:	b570      	push	{r4, r5, r6, lr}
   12b9a:	460c      	mov	r4, r1
	configASSERT(pxTimeOut);
   12b9c:	4605      	mov	r5, r0
   12b9e:	b940      	cbnz	r0, 12bb2 <xTaskCheckForTimeOut+0x1a>
   12ba0:	f04f 0380 	mov.w	r3, #128	; 0x80
   12ba4:	f383 8811 	msr	BASEPRI, r3
   12ba8:	f3bf 8f6f 	isb	sy
   12bac:	f3bf 8f4f 	dsb	sy
   12bb0:	e7fe      	b.n	12bb0 <xTaskCheckForTimeOut+0x18>
	configASSERT(pxTicksToWait);
   12bb2:	b941      	cbnz	r1, 12bc6 <xTaskCheckForTimeOut+0x2e>
   12bb4:	f04f 0380 	mov.w	r3, #128	; 0x80
   12bb8:	f383 8811 	msr	BASEPRI, r3
   12bbc:	f3bf 8f6f 	isb	sy
   12bc0:	f3bf 8f4f 	dsb	sy
   12bc4:	e7fe      	b.n	12bc4 <xTaskCheckForTimeOut+0x2c>
	taskENTER_CRITICAL();
   12bc6:	4b11      	ldr	r3, [pc, #68]	; (12c0c <xTaskCheckForTimeOut+0x74>)
   12bc8:	4798      	blx	r3
		    if (*pxTicksToWait == portMAX_DELAY) {
   12bca:	6823      	ldr	r3, [r4, #0]
		const TickType_t xConstTickCount = xTickCount;
   12bcc:	4810      	ldr	r0, [pc, #64]	; (12c10 <xTaskCheckForTimeOut+0x78>)
		    if (*pxTicksToWait == portMAX_DELAY) {
   12bce:	1c5a      	adds	r2, r3, #1
		const TickType_t xConstTickCount = xTickCount;
   12bd0:	f8d0 12b0 	ldr.w	r1, [r0, #688]	; 0x2b0
		    if (*pxTicksToWait == portMAX_DELAY) {
   12bd4:	d010      	beq.n	12bf8 <xTaskCheckForTimeOut+0x60>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
   12bd6:	f8d0 02fc 	ldr.w	r0, [r0, #764]	; 0x2fc
   12bda:	682e      	ldr	r6, [r5, #0]
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
   12bdc:	686a      	ldr	r2, [r5, #4]
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
   12bde:	4286      	cmp	r6, r0
   12be0:	d001      	beq.n	12be6 <xTaskCheckForTimeOut+0x4e>
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
   12be2:	428a      	cmp	r2, r1
   12be4:	d90f      	bls.n	12c06 <xTaskCheckForTimeOut+0x6e>
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
   12be6:	1a88      	subs	r0, r1, r2
		} else if (xElapsedTime < *pxTicksToWait) /*lint !e961 Explicit casting is only redundant with some compilers,
   12be8:	4283      	cmp	r3, r0
   12bea:	d90a      	bls.n	12c02 <xTaskCheckForTimeOut+0x6a>
			*pxTicksToWait -= xElapsedTime;
   12bec:	1a5b      	subs	r3, r3, r1
   12bee:	4413      	add	r3, r2
   12bf0:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState(pxTimeOut);
   12bf2:	4628      	mov	r0, r5
   12bf4:	4b07      	ldr	r3, [pc, #28]	; (12c14 <xTaskCheckForTimeOut+0x7c>)
   12bf6:	4798      	blx	r3
			xReturn = pdFALSE;
   12bf8:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   12bfa:	4b07      	ldr	r3, [pc, #28]	; (12c18 <xTaskCheckForTimeOut+0x80>)
   12bfc:	4798      	blx	r3
}
   12bfe:	4620      	mov	r0, r4
   12c00:	bd70      	pop	{r4, r5, r6, pc}
			*pxTicksToWait = 0;
   12c02:	2300      	movs	r3, #0
   12c04:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
   12c06:	2401      	movs	r4, #1
   12c08:	e7f7      	b.n	12bfa <xTaskCheckForTimeOut+0x62>
   12c0a:	bf00      	nop
   12c0c:	0000b255 	.word	0x0000b255
   12c10:	20008df8 	.word	0x20008df8
   12c14:	00012b85 	.word	0x00012b85
   12c18:	0000b299 	.word	0x0000b299

00012c1c <vTaskMissedYield>:
	xYieldPending = pdTRUE;
   12c1c:	4b02      	ldr	r3, [pc, #8]	; (12c28 <vTaskMissedYield+0xc>)
   12c1e:	2201      	movs	r2, #1
   12c20:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   12c24:	4770      	bx	lr
   12c26:	bf00      	nop
   12c28:	20008df8 	.word	0x20008df8

00012c2c <xTaskGetSchedulerState>:
	if (xSchedulerRunning == pdFALSE) {
   12c2c:	4b06      	ldr	r3, [pc, #24]	; (12c48 <xTaskGetSchedulerState+0x1c>)
   12c2e:	f8d3 22e8 	ldr.w	r2, [r3, #744]	; 0x2e8
   12c32:	b132      	cbz	r2, 12c42 <xTaskGetSchedulerState+0x16>
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   12c34:	f8d3 32f4 	ldr.w	r3, [r3, #756]	; 0x2f4
   12c38:	2b00      	cmp	r3, #0
			xReturn = taskSCHEDULER_SUSPENDED;
   12c3a:	bf0c      	ite	eq
   12c3c:	2002      	moveq	r0, #2
   12c3e:	2000      	movne	r0, #0
   12c40:	4770      	bx	lr
		xReturn = taskSCHEDULER_NOT_STARTED;
   12c42:	2001      	movs	r0, #1
}
   12c44:	4770      	bx	lr
   12c46:	bf00      	nop
   12c48:	20008df8 	.word	0x20008df8

00012c4c <xTaskPriorityDisinherit>:
{
   12c4c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (pxMutexHolder != NULL) {
   12c4e:	b910      	cbnz	r0, 12c56 <xTaskPriorityDisinherit+0xa>
	BaseType_t   xReturn = pdFALSE;
   12c50:	2000      	movs	r0, #0
}
   12c52:	b003      	add	sp, #12
   12c54:	bd30      	pop	{r4, r5, pc}
		configASSERT(pxTCB == pxCurrentTCB);
   12c56:	4d1d      	ldr	r5, [pc, #116]	; (12ccc <xTaskPriorityDisinherit+0x80>)
   12c58:	f8d5 42b4 	ldr.w	r4, [r5, #692]	; 0x2b4
   12c5c:	4284      	cmp	r4, r0
   12c5e:	d008      	beq.n	12c72 <xTaskPriorityDisinherit+0x26>
   12c60:	f04f 0380 	mov.w	r3, #128	; 0x80
   12c64:	f383 8811 	msr	BASEPRI, r3
   12c68:	f3bf 8f6f 	isb	sy
   12c6c:	f3bf 8f4f 	dsb	sy
   12c70:	e7fe      	b.n	12c70 <xTaskPriorityDisinherit+0x24>
		configASSERT(pxTCB->uxMutexesHeld);
   12c72:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   12c74:	b943      	cbnz	r3, 12c88 <xTaskPriorityDisinherit+0x3c>
   12c76:	f04f 0380 	mov.w	r3, #128	; 0x80
   12c7a:	f383 8811 	msr	BASEPRI, r3
   12c7e:	f3bf 8f6f 	isb	sy
   12c82:	f3bf 8f4f 	dsb	sy
   12c86:	e7fe      	b.n	12c86 <xTaskPriorityDisinherit+0x3a>
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
   12c88:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   12c8a:	6c62      	ldr	r2, [r4, #68]	; 0x44
		(pxTCB->uxMutexesHeld)--;
   12c8c:	3b01      	subs	r3, #1
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
   12c8e:	4291      	cmp	r1, r2
		(pxTCB->uxMutexesHeld)--;
   12c90:	64a3      	str	r3, [r4, #72]	; 0x48
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
   12c92:	d0dd      	beq.n	12c50 <xTaskPriorityDisinherit+0x4>
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
   12c94:	2b00      	cmp	r3, #0
   12c96:	d1db      	bne.n	12c50 <xTaskPriorityDisinherit+0x4>
				if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
   12c98:	1d21      	adds	r1, r4, #4
   12c9a:	4b0d      	ldr	r3, [pc, #52]	; (12cd0 <xTaskPriorityDisinherit+0x84>)
   12c9c:	9101      	str	r1, [sp, #4]
   12c9e:	4608      	mov	r0, r1
   12ca0:	4798      	blx	r3
				pxTCB->uxPriority = pxTCB->uxBasePriority;
   12ca2:	6c63      	ldr	r3, [r4, #68]	; 0x44
   12ca4:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE(
   12ca6:	f1c3 0220 	rsb	r2, r3, #32
   12caa:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyList(pxTCB);
   12cac:	f8d5 22f0 	ldr.w	r2, [r5, #752]	; 0x2f0
   12cb0:	9901      	ldr	r1, [sp, #4]
   12cb2:	4293      	cmp	r3, r2
   12cb4:	f04f 0014 	mov.w	r0, #20
   12cb8:	fb00 5003 	mla	r0, r0, r3, r5
   12cbc:	bf88      	it	hi
   12cbe:	f8c5 32f0 	strhi.w	r3, [r5, #752]	; 0x2f0
   12cc2:	4b04      	ldr	r3, [pc, #16]	; (12cd4 <xTaskPriorityDisinherit+0x88>)
   12cc4:	4798      	blx	r3
				xReturn = pdTRUE;
   12cc6:	2001      	movs	r0, #1
	return xReturn;
   12cc8:	e7c3      	b.n	12c52 <xTaskPriorityDisinherit+0x6>
   12cca:	bf00      	nop
   12ccc:	20008df8 	.word	0x20008df8
   12cd0:	0000b167 	.word	0x0000b167
   12cd4:	0000b121 	.word	0x0000b121

00012cd8 <event_system_init>:
/**
 * \brief Initialize event system.
 */
int32_t event_system_init(void)
{
	return _event_system_init();
   12cd8:	4b00      	ldr	r3, [pc, #0]	; (12cdc <event_system_init+0x4>)
   12cda:	4718      	bx	r3
   12cdc:	0000ba4d 	.word	0x0000ba4d

00012ce0 <hri_adc_wait_for_sync>:
typedef uint8_t  hri_adc_status_reg_t;
typedef uint8_t  hri_adc_swtrig_reg_t;

static inline void hri_adc_wait_for_sync(const void *const hw, hri_adc_syncbusy_reg_t reg)
{
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
   12ce0:	6b03      	ldr	r3, [r0, #48]	; 0x30
   12ce2:	420b      	tst	r3, r1
   12ce4:	d1fc      	bne.n	12ce0 <hri_adc_wait_for_sync>
	};
}
   12ce6:	4770      	bx	lr

00012ce8 <hri_adc_set_CTRLA_ENABLE_bit>:
}

static inline void hri_adc_set_CTRLA_ENABLE_bit(const void *const hw)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg |= ADC_CTRLA_ENABLE;
   12ce8:	8803      	ldrh	r3, [r0, #0]
   12cea:	b29b      	uxth	r3, r3
   12cec:	f043 0302 	orr.w	r3, r3, #2
   12cf0:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   12cf2:	2103      	movs	r1, #3
   12cf4:	4b00      	ldr	r3, [pc, #0]	; (12cf8 <hri_adc_set_CTRLA_ENABLE_bit+0x10>)
   12cf6:	4718      	bx	r3
   12cf8:	00012ce1 	.word	0x00012ce1

00012cfc <hri_adc_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_adc_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg &= ~ADC_CTRLA_ENABLE;
   12cfc:	8803      	ldrh	r3, [r0, #0]
   12cfe:	f023 0302 	bic.w	r3, r3, #2
   12d02:	041b      	lsls	r3, r3, #16
   12d04:	0c1b      	lsrs	r3, r3, #16
   12d06:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   12d08:	2103      	movs	r1, #3
   12d0a:	4b01      	ldr	r3, [pc, #4]	; (12d10 <hri_adc_clear_CTRLA_ENABLE_bit+0x14>)
   12d0c:	4718      	bx	r3
   12d0e:	bf00      	nop
   12d10:	00012ce1 	.word	0x00012ce1

00012d14 <_adc_interrupt_handler>:
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _adc_interrupt_handler(struct _adc_async_device *device)
{
	void *const hw      = device->hw;
   12d14:	6942      	ldr	r2, [r0, #20]
	return ((Adc *)hw)->INTFLAG.reg;
   12d16:	f892 102e 	ldrb.w	r1, [r2, #46]	; 0x2e
	return ((Adc *)hw)->INTENSET.reg;
   12d1a:	f892 302d 	ldrb.w	r3, [r2, #45]	; 0x2d
	uint8_t     intflag = hri_adc_read_INTFLAG_reg(hw);
	intflag &= hri_adc_read_INTEN_reg(hw);
   12d1e:	400b      	ands	r3, r1
{
   12d20:	b430      	push	{r4, r5}
	if (intflag & ADC_INTFLAG_RESRDY) {
   12d22:	f013 0501 	ands.w	r5, r3, #1
   12d26:	d009      	beq.n	12d3c <_adc_interrupt_handler+0x28>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_RESRDY;
   12d28:	2301      	movs	r3, #1
   12d2a:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
	return ((Adc *)hw)->RESULT.reg;
   12d2e:	f8b2 2040 	ldrh.w	r2, [r2, #64]	; 0x40
		hri_adc_clear_interrupt_RESRDY_bit(hw);
		device->adc_async_ch_cb.convert_done(device, 0, hri_adc_read_RESULT_reg(hw));
   12d32:	6883      	ldr	r3, [r0, #8]
		device->adc_async_cb.error_cb(device, 0);
	} else if (intflag & ADC_INTFLAG_WINMON) {
		hri_adc_clear_interrupt_WINMON_bit(hw);
		device->adc_async_cb.window_cb(device, 0);
	}
}
   12d34:	bc30      	pop	{r4, r5}
		device->adc_async_ch_cb.convert_done(device, 0, hri_adc_read_RESULT_reg(hw));
   12d36:	b292      	uxth	r2, r2
   12d38:	2100      	movs	r1, #0
   12d3a:	4718      	bx	r3
	} else if (intflag & ADC_INTFLAG_OVERRUN) {
   12d3c:	f013 0102 	ands.w	r1, r3, #2
   12d40:	d006      	beq.n	12d50 <_adc_interrupt_handler+0x3c>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_OVERRUN;
   12d42:	2302      	movs	r3, #2
   12d44:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
		device->adc_async_cb.error_cb(device, 0);
   12d48:	6843      	ldr	r3, [r0, #4]
   12d4a:	4629      	mov	r1, r5
}
   12d4c:	bc30      	pop	{r4, r5}
		device->adc_async_cb.window_cb(device, 0);
   12d4e:	4718      	bx	r3
	} else if (intflag & ADC_INTFLAG_WINMON) {
   12d50:	075b      	lsls	r3, r3, #29
   12d52:	d504      	bpl.n	12d5e <_adc_interrupt_handler+0x4a>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_WINMON;
   12d54:	2304      	movs	r3, #4
   12d56:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
		device->adc_async_cb.window_cb(device, 0);
   12d5a:	6803      	ldr	r3, [r0, #0]
   12d5c:	e7f6      	b.n	12d4c <_adc_interrupt_handler+0x38>
}
   12d5e:	bc30      	pop	{r4, r5}
   12d60:	4770      	bx	lr
	...

00012d64 <_adc_get_regs>:
{
   12d64:	b508      	push	{r3, lr}
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
   12d66:	f100 433d 	add.w	r3, r0, #3170893824	; 0xbd000000
   12d6a:	f5a3 53e0 	sub.w	r3, r3, #7168	; 0x1c00
		if (_adcs[i].number == n) {
   12d6e:	f413 3f7f 	tst.w	r3, #261120	; 0x3fc00
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
   12d72:	f3c3 2087 	ubfx	r0, r3, #10, #8
		if (_adcs[i].number == n) {
   12d76:	d007      	beq.n	12d88 <_adc_get_regs+0x24>
   12d78:	2801      	cmp	r0, #1
   12d7a:	d005      	beq.n	12d88 <_adc_get_regs+0x24>
	ASSERT(false);
   12d7c:	2000      	movs	r0, #0
   12d7e:	4903      	ldr	r1, [pc, #12]	; (12d8c <_adc_get_regs+0x28>)
   12d80:	4b03      	ldr	r3, [pc, #12]	; (12d90 <_adc_get_regs+0x2c>)
   12d82:	228c      	movs	r2, #140	; 0x8c
   12d84:	4798      	blx	r3
	return 0;
   12d86:	2000      	movs	r0, #0
}
   12d88:	bd08      	pop	{r3, pc}
   12d8a:	bf00      	nop
   12d8c:	000167db 	.word	0x000167db
   12d90:	0000e03d 	.word	0x0000e03d

00012d94 <__NVIC_ClearPendingIRQ>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12d94:	0943      	lsrs	r3, r0, #5
   12d96:	2201      	movs	r2, #1
   12d98:	f000 001f 	and.w	r0, r0, #31
   12d9c:	fa02 f000 	lsl.w	r0, r2, r0
   12da0:	3360      	adds	r3, #96	; 0x60
   12da2:	4a02      	ldr	r2, [pc, #8]	; (12dac <__NVIC_ClearPendingIRQ+0x18>)
   12da4:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   12da8:	4770      	bx	lr
   12daa:	bf00      	nop
   12dac:	e000e100 	.word	0xe000e100

00012db0 <_adc_get_irq_num.isra.0>:
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
   12db0:	f100 403d 	add.w	r0, r0, #3170893824	; 0xbd000000
   12db4:	f5a0 50e0 	sub.w	r0, r0, #7168	; 0x1c00
   12db8:	0a80      	lsrs	r0, r0, #10
	return ADC0_0_IRQn + (_adc_get_hardware_index(device->hw) << 1);
   12dba:	0040      	lsls	r0, r0, #1
   12dbc:	3076      	adds	r0, #118	; 0x76
}
   12dbe:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
   12dc2:	4770      	bx	lr

00012dc4 <__NVIC_DisableIRQ>:
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12dc4:	0943      	lsrs	r3, r0, #5
   12dc6:	2201      	movs	r2, #1
   12dc8:	f000 001f 	and.w	r0, r0, #31
   12dcc:	fa02 f000 	lsl.w	r0, r2, r0
   12dd0:	3320      	adds	r3, #32
   12dd2:	4a04      	ldr	r2, [pc, #16]	; (12de4 <__NVIC_DisableIRQ+0x20>)
   12dd4:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   12dd8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   12ddc:	f3bf 8f6f 	isb	sy
}
   12de0:	4770      	bx	lr
   12de2:	bf00      	nop
   12de4:	e000e100 	.word	0xe000e100

00012de8 <_adc_init>:
{
   12de8:	b538      	push	{r3, r4, r5, lr}
	if (hw == ADC0) {
   12dea:	4b39      	ldr	r3, [pc, #228]	; (12ed0 <_adc_init+0xe8>)
   12dec:	4298      	cmp	r0, r3
{
   12dee:	460c      	mov	r4, r1
	if (hw == ADC0) {
   12df0:	d15c      	bne.n	12eac <_adc_init+0xc4>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
   12df2:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
   12df6:	681b      	ldr	r3, [r3, #0]
   12df8:	00da      	lsls	r2, r3, #3
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC0_FUSES_BIASR2R_ADDR >> ADC0_FUSES_BIASR2R_Pos))
   12dfa:	0919      	lsrs	r1, r3, #4
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
   12dfc:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC0_FUSES_BIASR2R_ADDR >> ADC0_FUSES_BIASR2R_Pos))
   12e00:	f001 0170 	and.w	r1, r1, #112	; 0x70
   12e04:	430a      	orrs	r2, r1
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC0_FUSES_BIASCOMP_ADDR >> ADC0_FUSES_BIASCOMP_Pos));
   12e06:	f3c3 0382 	ubfx	r3, r3, #2, #3
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
   12e0a:	431a      	orrs	r2, r3
	return ((Adc *)hw)->SYNCBUSY.reg & reg;
   12e0c:	6b03      	ldr	r3, [r0, #48]	; 0x30
   12e0e:	4d31      	ldr	r5, [pc, #196]	; (12ed4 <_adc_init+0xec>)
	if (!hri_adc_is_syncing(hw, ADC_SYNCBUSY_SWRST)) {
   12e10:	f013 0f01 	tst.w	r3, #1
   12e14:	d10c      	bne.n	12e30 <_adc_init+0x48>
}

static inline hri_adc_ctrla_reg_t hri_adc_get_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t mask)
{
	uint16_t tmp;
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   12e16:	2103      	movs	r1, #3
   12e18:	47a8      	blx	r5
	tmp = ((Adc *)hw)->CTRLA.reg;
   12e1a:	8803      	ldrh	r3, [r0, #0]
		if (hri_adc_get_CTRLA_reg(hw, ADC_CTRLA_ENABLE)) {
   12e1c:	079b      	lsls	r3, r3, #30
   12e1e:	d503      	bpl.n	12e28 <_adc_init+0x40>
			hri_adc_clear_CTRLA_ENABLE_bit(hw);
   12e20:	4b2d      	ldr	r3, [pc, #180]	; (12ed8 <_adc_init+0xf0>)
   12e22:	4798      	blx	r3
			hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_ENABLE);
   12e24:	2102      	movs	r1, #2
   12e26:	47a8      	blx	r5
}

static inline void hri_adc_write_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg = data;
   12e28:	2301      	movs	r3, #1
   12e2a:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   12e2c:	2103      	movs	r1, #3
   12e2e:	47a8      	blx	r5
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST);
   12e30:	2101      	movs	r1, #1
   12e32:	47a8      	blx	r5
	hri_adc_write_CTRLB_reg(hw, _adcs[i].ctrl_b);
   12e34:	4929      	ldr	r1, [pc, #164]	; (12edc <_adc_init+0xf4>)
}

static inline void hri_adc_write_CALIB_reg(const void *const hw, hri_adc_calib_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CALIB.reg = data;
   12e36:	f8a0 2048 	strh.w	r2, [r0, #72]	; 0x48
   12e3a:	2316      	movs	r3, #22
   12e3c:	fb03 1404 	mla	r4, r3, r4, r1
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12e40:	f640 71ff 	movw	r1, #4095	; 0xfff
   12e44:	88a3      	ldrh	r3, [r4, #4]
	((Adc *)hw)->CTRLB.reg = data;
   12e46:	80c3      	strh	r3, [r0, #6]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12e48:	47a8      	blx	r5
	hri_adc_write_REFCTRL_reg(hw, _adcs[i].ref_ctrl);
   12e4a:	79a3      	ldrb	r3, [r4, #6]
	((Adc *)hw)->REFCTRL.reg = data;
   12e4c:	7203      	strb	r3, [r0, #8]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12e4e:	f640 71ff 	movw	r1, #4095	; 0xfff
   12e52:	47a8      	blx	r5
	hri_adc_write_EVCTRL_reg(hw, _adcs[i].ev_ctrl);
   12e54:	79e3      	ldrb	r3, [r4, #7]
	((Adc *)hw)->EVCTRL.reg = data;
   12e56:	7083      	strb	r3, [r0, #2]
	hri_adc_write_INPUTCTRL_reg(hw, _adcs[i].input_ctrl);
   12e58:	8923      	ldrh	r3, [r4, #8]
	((Adc *)hw)->INPUTCTRL.reg = data;
   12e5a:	8083      	strh	r3, [r0, #4]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12e5c:	f640 71ff 	movw	r1, #4095	; 0xfff
   12e60:	47a8      	blx	r5
	hri_adc_write_AVGCTRL_reg(hw, _adcs[i].avg_ctrl);
   12e62:	7aa3      	ldrb	r3, [r4, #10]
	((Adc *)hw)->AVGCTRL.reg = data;
   12e64:	7283      	strb	r3, [r0, #10]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12e66:	f640 71ff 	movw	r1, #4095	; 0xfff
   12e6a:	47a8      	blx	r5
	hri_adc_write_SAMPCTRL_reg(hw, _adcs[i].samp_ctrl);
   12e6c:	7ae3      	ldrb	r3, [r4, #11]
	((Adc *)hw)->SAMPCTRL.reg = data;
   12e6e:	72c3      	strb	r3, [r0, #11]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12e70:	f640 71ff 	movw	r1, #4095	; 0xfff
   12e74:	47a8      	blx	r5
	hri_adc_write_WINLT_reg(hw, _adcs[i].win_lt);
   12e76:	89a3      	ldrh	r3, [r4, #12]
	((Adc *)hw)->WINLT.reg = data;
   12e78:	8183      	strh	r3, [r0, #12]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINLT);
   12e7a:	2180      	movs	r1, #128	; 0x80
   12e7c:	47a8      	blx	r5
	hri_adc_write_WINUT_reg(hw, _adcs[i].win_ut);
   12e7e:	89e3      	ldrh	r3, [r4, #14]
	((Adc *)hw)->WINUT.reg = data;
   12e80:	81c3      	strh	r3, [r0, #14]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINUT);
   12e82:	f44f 7180 	mov.w	r1, #256	; 0x100
   12e86:	47a8      	blx	r5
	hri_adc_write_GAINCORR_reg(hw, _adcs[i].gain_corr);
   12e88:	8a23      	ldrh	r3, [r4, #16]
	((Adc *)hw)->GAINCORR.reg = data;
   12e8a:	8203      	strh	r3, [r0, #16]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_GAINCORR);
   12e8c:	f44f 7100 	mov.w	r1, #512	; 0x200
   12e90:	47a8      	blx	r5
	hri_adc_write_OFFSETCORR_reg(hw, _adcs[i].offset_corr);
   12e92:	8a63      	ldrh	r3, [r4, #18]
	((Adc *)hw)->OFFSETCORR.reg = data;
   12e94:	8243      	strh	r3, [r0, #18]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_OFFSETCORR);
   12e96:	f44f 6180 	mov.w	r1, #1024	; 0x400
   12e9a:	47a8      	blx	r5
	hri_adc_write_DBGCTRL_reg(hw, _adcs[i].dbg_ctrl);
   12e9c:	7d23      	ldrb	r3, [r4, #20]
	((Adc *)hw)->DBGCTRL.reg = data;
   12e9e:	70c3      	strb	r3, [r0, #3]
	hri_adc_write_CTRLA_reg(hw, _adcs[i].ctrl_a);
   12ea0:	8863      	ldrh	r3, [r4, #2]
	((Adc *)hw)->CTRLA.reg = data;
   12ea2:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   12ea4:	2103      	movs	r1, #3
   12ea6:	47a8      	blx	r5
}
   12ea8:	2000      	movs	r0, #0
   12eaa:	bd38      	pop	{r3, r4, r5, pc}
	} else if (hw == ADC1) {
   12eac:	4b0c      	ldr	r3, [pc, #48]	; (12ee0 <_adc_init+0xf8>)
   12eae:	4298      	cmp	r0, r3
   12eb0:	d10c      	bne.n	12ecc <_adc_init+0xe4>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
   12eb2:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
   12eb6:	681b      	ldr	r3, [r3, #0]
   12eb8:	0ada      	lsrs	r2, r3, #11
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
   12eba:	0c99      	lsrs	r1, r3, #18
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
   12ebc:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
   12ec0:	f001 0170 	and.w	r1, r1, #112	; 0x70
   12ec4:	430a      	orrs	r2, r1
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC1_FUSES_BIASCOMP_ADDR >> ADC1_FUSES_BIASCOMP_Pos));
   12ec6:	f3c3 4302 	ubfx	r3, r3, #16, #3
   12eca:	e79e      	b.n	12e0a <_adc_init+0x22>
	uint16_t calib_reg = 0;
   12ecc:	2200      	movs	r2, #0
   12ece:	e79d      	b.n	12e0c <_adc_init+0x24>
   12ed0:	43001c00 	.word	0x43001c00
   12ed4:	00012ce1 	.word	0x00012ce1
   12ed8:	00012cfd 	.word	0x00012cfd
   12edc:	000167f0 	.word	0x000167f0
   12ee0:	43002000 	.word	0x43002000

00012ee4 <_adc_async_init>:
{
   12ee4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	ASSERT(device);
   12ee8:	4604      	mov	r4, r0
   12eea:	3800      	subs	r0, #0
   12eec:	bf18      	it	ne
   12eee:	2001      	movne	r0, #1
{
   12ef0:	460d      	mov	r5, r1
	ASSERT(device);
   12ef2:	22f1      	movs	r2, #241	; 0xf1
   12ef4:	4923      	ldr	r1, [pc, #140]	; (12f84 <_adc_async_init+0xa0>)
   12ef6:	4b24      	ldr	r3, [pc, #144]	; (12f88 <_adc_async_init+0xa4>)
   12ef8:	4798      	blx	r3
	init_status = _adc_init(hw, _adc_get_regs((uint32_t)hw));
   12efa:	4b24      	ldr	r3, [pc, #144]	; (12f8c <_adc_async_init+0xa8>)
   12efc:	4628      	mov	r0, r5
   12efe:	4798      	blx	r3
   12f00:	4b23      	ldr	r3, [pc, #140]	; (12f90 <_adc_async_init+0xac>)
   12f02:	4601      	mov	r1, r0
   12f04:	4628      	mov	r0, r5
   12f06:	4798      	blx	r3
	if (init_status) {
   12f08:	4606      	mov	r6, r0
   12f0a:	2800      	cmp	r0, #0
   12f0c:	d130      	bne.n	12f70 <_adc_async_init+0x8c>
	if (hw == ADC0) {
   12f0e:	4b21      	ldr	r3, [pc, #132]	; (12f94 <_adc_async_init+0xb0>)
	device->hw = hw;
   12f10:	6165      	str	r5, [r4, #20]
	if (hw == ADC0) {
   12f12:	429d      	cmp	r5, r3
   12f14:	d12f      	bne.n	12f76 <_adc_async_init+0x92>
		_adc0_dev = dev;
   12f16:	4b20      	ldr	r3, [pc, #128]	; (12f98 <_adc_async_init+0xb4>)
   12f18:	601c      	str	r4, [r3, #0]
	NVIC_DisableIRQ(_adc_get_irq_num(device) + 0);
   12f1a:	4920      	ldr	r1, [pc, #128]	; (12f9c <_adc_async_init+0xb8>)
   12f1c:	f8df 9088 	ldr.w	r9, [pc, #136]	; 12fa8 <_adc_async_init+0xc4>
	NVIC_ClearPendingIRQ(_adc_get_irq_num(device) + 0);
   12f20:	f8df 8088 	ldr.w	r8, [pc, #136]	; 12fac <_adc_async_init+0xc8>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12f24:	4f1e      	ldr	r7, [pc, #120]	; (12fa0 <_adc_async_init+0xbc>)
	NVIC_DisableIRQ(_adc_get_irq_num(device) + 0);
   12f26:	4628      	mov	r0, r5
   12f28:	4788      	blx	r1
   12f2a:	b200      	sxth	r0, r0
   12f2c:	47c8      	blx	r9
	NVIC_ClearPendingIRQ(_adc_get_irq_num(device) + 0);
   12f2e:	6960      	ldr	r0, [r4, #20]
   12f30:	4788      	blx	r1
   12f32:	b200      	sxth	r0, r0
   12f34:	47c0      	blx	r8
	NVIC_EnableIRQ(_adc_get_irq_num(device) + 0);
   12f36:	6960      	ldr	r0, [r4, #20]
   12f38:	4788      	blx	r1
   12f3a:	2501      	movs	r5, #1
   12f3c:	0942      	lsrs	r2, r0, #5
   12f3e:	f000 031f 	and.w	r3, r0, #31
   12f42:	fa05 f303 	lsl.w	r3, r5, r3
	NVIC_DisableIRQ(_adc_get_irq_num(device) + 1);
   12f46:	4428      	add	r0, r5
   12f48:	f847 3022 	str.w	r3, [r7, r2, lsl #2]
   12f4c:	b200      	sxth	r0, r0
   12f4e:	47c8      	blx	r9
	NVIC_ClearPendingIRQ(_adc_get_irq_num(device) + 1);
   12f50:	6960      	ldr	r0, [r4, #20]
   12f52:	4788      	blx	r1
   12f54:	4428      	add	r0, r5
   12f56:	b200      	sxth	r0, r0
   12f58:	47c0      	blx	r8
	NVIC_EnableIRQ(_adc_get_irq_num(device) + 1);
   12f5a:	6960      	ldr	r0, [r4, #20]
   12f5c:	4788      	blx	r1
   12f5e:	1943      	adds	r3, r0, r5
   12f60:	f3c3 124a 	ubfx	r2, r3, #5, #11
   12f64:	f003 031f 	and.w	r3, r3, #31
   12f68:	fa05 f303 	lsl.w	r3, r5, r3
   12f6c:	f847 3022 	str.w	r3, [r7, r2, lsl #2]
}
   12f70:	4630      	mov	r0, r6
   12f72:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (hw == ADC1) {
   12f76:	4b0b      	ldr	r3, [pc, #44]	; (12fa4 <_adc_async_init+0xc0>)
   12f78:	429d      	cmp	r5, r3
		_adc1_dev = dev;
   12f7a:	bf04      	itt	eq
   12f7c:	4b06      	ldreq	r3, [pc, #24]	; (12f98 <_adc_async_init+0xb4>)
   12f7e:	605c      	streq	r4, [r3, #4]
   12f80:	e7cb      	b.n	12f1a <_adc_async_init+0x36>
   12f82:	bf00      	nop
   12f84:	000167db 	.word	0x000167db
   12f88:	0000e03d 	.word	0x0000e03d
   12f8c:	00012d65 	.word	0x00012d65
   12f90:	00012de9 	.word	0x00012de9
   12f94:	43001c00 	.word	0x43001c00
   12f98:	20009100 	.word	0x20009100
   12f9c:	00012db1 	.word	0x00012db1
   12fa0:	e000e100 	.word	0xe000e100
   12fa4:	43002000 	.word	0x43002000
   12fa8:	00012dc5 	.word	0x00012dc5
   12fac:	00012d95 	.word	0x00012d95

00012fb0 <_adc_async_enable_channel>:
	hri_adc_set_CTRLA_ENABLE_bit(device->hw);
   12fb0:	6940      	ldr	r0, [r0, #20]
   12fb2:	4b01      	ldr	r3, [pc, #4]	; (12fb8 <_adc_async_enable_channel+0x8>)
   12fb4:	4718      	bx	r3
   12fb6:	bf00      	nop
   12fb8:	00012ce9 	.word	0x00012ce9

00012fbc <_adc_async_get_data_size>:
	return hri_adc_read_CTRLB_RESSEL_bf(device->hw) == ADC_CTRLB_RESSEL_8BIT_Val ? 1 : 2;
   12fbc:	6943      	ldr	r3, [r0, #20]
	tmp = ((Adc *)hw)->CTRLB.reg;
   12fbe:	88db      	ldrh	r3, [r3, #6]
   12fc0:	f3c3 03c1 	ubfx	r3, r3, #3, #2
   12fc4:	2b03      	cmp	r3, #3
}
   12fc6:	bf0c      	ite	eq
   12fc8:	2001      	moveq	r0, #1
   12fca:	2002      	movne	r0, #2
   12fcc:	4770      	bx	lr
	...

00012fd0 <_adc_async_convert>:
	hri_adc_set_SWTRIG_START_bit(device->hw);
   12fd0:	6940      	ldr	r0, [r0, #20]
	((Adc *)hw)->SWTRIG.reg |= ADC_SWTRIG_START;
   12fd2:	7d03      	ldrb	r3, [r0, #20]
   12fd4:	f043 0302 	orr.w	r3, r3, #2
   12fd8:	7503      	strb	r3, [r0, #20]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12fda:	f640 71ff 	movw	r1, #4095	; 0xfff
   12fde:	4b01      	ldr	r3, [pc, #4]	; (12fe4 <_adc_async_convert+0x14>)
   12fe0:	4718      	bx	r3
   12fe2:	bf00      	nop
   12fe4:	00012ce1 	.word	0x00012ce1

00012fe8 <_adc_async_set_irq_state>:
	if (ADC_ASYNC_DEVICE_MONITOR_CB == type) {
   12fe8:	2a01      	cmp	r2, #1
	void *const hw = device->hw;
   12fea:	6941      	ldr	r1, [r0, #20]
	if (ADC_ASYNC_DEVICE_MONITOR_CB == type) {
   12fec:	d104      	bne.n	12ff8 <_adc_async_set_irq_state+0x10>
	if (value == 0x0) {
   12fee:	2204      	movs	r2, #4
	if (value == 0x0) {
   12ff0:	b93b      	cbnz	r3, 13002 <_adc_async_set_irq_state+0x1a>
		((Adc *)hw)->INTENCLR.reg = ADC_INTENSET_RESRDY;
   12ff2:	f881 202c 	strb.w	r2, [r1, #44]	; 0x2c
   12ff6:	4770      	bx	lr
	} else if (ADC_ASYNC_DEVICE_ERROR_CB == type) {
   12ff8:	2a02      	cmp	r2, #2
   12ffa:	d0f9      	beq.n	12ff0 <_adc_async_set_irq_state+0x8>
	} else if (ADC_ASYNC_DEVICE_CONVERT_CB == type) {
   12ffc:	b91a      	cbnz	r2, 13006 <_adc_async_set_irq_state+0x1e>
	if (value == 0x0) {
   12ffe:	2201      	movs	r2, #1
   13000:	e7f6      	b.n	12ff0 <_adc_async_set_irq_state+0x8>
		((Adc *)hw)->INTENSET.reg = ADC_INTENSET_RESRDY;
   13002:	f881 202d 	strb.w	r2, [r1, #45]	; 0x2d
}
   13006:	4770      	bx	lr

00013008 <ADC0_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void ADC0_0_Handler(void)
{
	_adc_interrupt_handler(_adc0_dev);
   13008:	4b01      	ldr	r3, [pc, #4]	; (13010 <ADC0_0_Handler+0x8>)
   1300a:	6818      	ldr	r0, [r3, #0]
   1300c:	4b01      	ldr	r3, [pc, #4]	; (13014 <ADC0_0_Handler+0xc>)
   1300e:	4718      	bx	r3
   13010:	20009100 	.word	0x20009100
   13014:	00012d15 	.word	0x00012d15

00013018 <ADC0_1_Handler>:
   13018:	4b00      	ldr	r3, [pc, #0]	; (1301c <ADC0_1_Handler+0x4>)
   1301a:	4718      	bx	r3
   1301c:	00013009 	.word	0x00013009

00013020 <ADC1_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void ADC1_0_Handler(void)
{
	_adc_interrupt_handler(_adc1_dev);
   13020:	4b01      	ldr	r3, [pc, #4]	; (13028 <ADC1_0_Handler+0x8>)
   13022:	6858      	ldr	r0, [r3, #4]
   13024:	4b01      	ldr	r3, [pc, #4]	; (1302c <ADC1_0_Handler+0xc>)
   13026:	4718      	bx	r3
   13028:	20009100 	.word	0x20009100
   1302c:	00012d15 	.word	0x00012d15

00013030 <ADC1_1_Handler>:
   13030:	4b00      	ldr	r3, [pc, #0]	; (13034 <ADC1_1_Handler+0x4>)
   13032:	4718      	bx	r3
   13034:	00013021 	.word	0x00013021

00013038 <Dummy_Handler>:
/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
	while (1) {
   13038:	e7fe      	b.n	13038 <Dummy_Handler>
	...

0001303c <Reset_Handler>:
{
   1303c:	b508      	push	{r3, lr}
	if (pSrc != pDest) {
   1303e:	4a14      	ldr	r2, [pc, #80]	; (13090 <Reset_Handler+0x54>)
   13040:	4b14      	ldr	r3, [pc, #80]	; (13094 <Reset_Handler+0x58>)
   13042:	429a      	cmp	r2, r3
   13044:	d002      	beq.n	1304c <Reset_Handler+0x10>
		for (; pDest < &_erelocate;) {
   13046:	4914      	ldr	r1, [pc, #80]	; (13098 <Reset_Handler+0x5c>)
   13048:	428b      	cmp	r3, r1
   1304a:	d318      	bcc.n	1307e <Reset_Handler+0x42>
	pSrc  = &_etext;
   1304c:	4b13      	ldr	r3, [pc, #76]	; (1309c <Reset_Handler+0x60>)
	for (pDest = &_szero; pDest < &_ezero;) {
   1304e:	4a14      	ldr	r2, [pc, #80]	; (130a0 <Reset_Handler+0x64>)
		*pDest++ = 0;
   13050:	2100      	movs	r1, #0
	for (pDest = &_szero; pDest < &_ezero;) {
   13052:	4293      	cmp	r3, r2
   13054:	d318      	bcc.n	13088 <Reset_Handler+0x4c>
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
   13056:	4a13      	ldr	r2, [pc, #76]	; (130a4 <Reset_Handler+0x68>)
   13058:	4b13      	ldr	r3, [pc, #76]	; (130a8 <Reset_Handler+0x6c>)
   1305a:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   1305e:	609a      	str	r2, [r3, #8]
	SCB->CPACR |= (0xFu << 20);
   13060:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   13064:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
   13068:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
   1306c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   13070:	f3bf 8f6f 	isb	sy
	__libc_init_array();
   13074:	4b0d      	ldr	r3, [pc, #52]	; (130ac <Reset_Handler+0x70>)
   13076:	4798      	blx	r3
	main();
   13078:	4b0d      	ldr	r3, [pc, #52]	; (130b0 <Reset_Handler+0x74>)
   1307a:	4798      	blx	r3
	while (1)
   1307c:	e7fe      	b.n	1307c <Reset_Handler+0x40>
			*pDest++ = *pSrc++;
   1307e:	f852 0b04 	ldr.w	r0, [r2], #4
   13082:	f843 0b04 	str.w	r0, [r3], #4
   13086:	e7df      	b.n	13048 <Reset_Handler+0xc>
		*pDest++ = 0;
   13088:	f843 1b04 	str.w	r1, [r3], #4
   1308c:	e7e1      	b.n	13052 <Reset_Handler+0x16>
   1308e:	bf00      	nop
   13090:	00016970 	.word	0x00016970
   13094:	20000000 	.word	0x20000000
   13098:	200005b0 	.word	0x200005b0
   1309c:	200005b0 	.word	0x200005b0
   130a0:	2001cfe4 	.word	0x2001cfe4
   130a4:	00004000 	.word	0x00004000
   130a8:	e000ed00 	.word	0xe000ed00
   130ac:	0001427d 	.word	0x0001427d
   130b0:	0001213d 	.word	0x0001213d

000130b4 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
   130b4:	b510      	push	{r4, lr}
	system_init();
   130b6:	4b04      	ldr	r3, [pc, #16]	; (130c8 <atmel_start_init+0x14>)
   130b8:	4798      	blx	r3
	usb_init();
   130ba:	4b04      	ldr	r3, [pc, #16]	; (130cc <atmel_start_init+0x18>)
   130bc:	4798      	blx	r3
	stdio_redirect_init();
}
   130be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_redirect_init();
   130c2:	4b03      	ldr	r3, [pc, #12]	; (130d0 <atmel_start_init+0x1c>)
   130c4:	4718      	bx	r3
   130c6:	bf00      	nop
   130c8:	00010365 	.word	0x00010365
   130cc:	0000c919 	.word	0x0000c919
   130d0:	0000eccd 	.word	0x0000eccd

000130d4 <usbdc_unconfig>:
/**
 * \brief Unconfig, close all interfaces
 */
static void usbdc_unconfig(void)
{
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
   130d4:	4b05      	ldr	r3, [pc, #20]	; (130ec <usbdc_unconfig+0x18>)
{
   130d6:	b510      	push	{r4, lr}
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
   130d8:	691c      	ldr	r4, [r3, #16]
	while (NULL != func) {
   130da:	b904      	cbnz	r4, 130de <usbdc_unconfig+0xa>
		func->ctrl(func, USBDF_DISABLE, NULL);
		func = func->next;
	}
}
   130dc:	bd10      	pop	{r4, pc}
		func->ctrl(func, USBDF_DISABLE, NULL);
   130de:	6863      	ldr	r3, [r4, #4]
   130e0:	4620      	mov	r0, r4
   130e2:	2200      	movs	r2, #0
   130e4:	2101      	movs	r1, #1
   130e6:	4798      	blx	r3
		func = func->next;
   130e8:	6824      	ldr	r4, [r4, #0]
   130ea:	e7f6      	b.n	130da <usbdc_unconfig+0x6>
   130ec:	20009108 	.word	0x20009108

000130f0 <usbdc_change_notify>:
}

/** Invoke all registered Change notification callbacks. */
static void usbdc_change_notify(enum usbdc_change_type change, uint32_t value)
{
	struct usbdc_change_handler *cg = (struct usbdc_change_handler *)usbdc.handlers.change_list.head;
   130f0:	4b06      	ldr	r3, [pc, #24]	; (1310c <usbdc_change_notify+0x1c>)
{
   130f2:	b570      	push	{r4, r5, r6, lr}
	struct usbdc_change_handler *cg = (struct usbdc_change_handler *)usbdc.handlers.change_list.head;
   130f4:	68dc      	ldr	r4, [r3, #12]
{
   130f6:	4605      	mov	r5, r0
   130f8:	460e      	mov	r6, r1

	while (cg != NULL) {
   130fa:	b904      	cbnz	r4, 130fe <usbdc_change_notify+0xe>
		if (NULL != cg->cb) {
			cg->cb(change, value);
		}
		cg = cg->next;
	}
}
   130fc:	bd70      	pop	{r4, r5, r6, pc}
		if (NULL != cg->cb) {
   130fe:	6863      	ldr	r3, [r4, #4]
   13100:	b113      	cbz	r3, 13108 <usbdc_change_notify+0x18>
			cg->cb(change, value);
   13102:	4631      	mov	r1, r6
   13104:	4628      	mov	r0, r5
   13106:	4798      	blx	r3
		cg = cg->next;
   13108:	6824      	ldr	r4, [r4, #0]
   1310a:	e7f6      	b.n	130fa <usbdc_change_notify+0xa>
   1310c:	20009108 	.word	0x20009108

00013110 <usbdc_request_handler>:

/** Invoke all registered request callbacks until request handled. */
static int32_t usbdc_request_handler(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
   13110:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct usbdc_req_handler *h = (struct usbdc_req_handler *)usbdc.handlers.req_list.head;
   13112:	4b0c      	ldr	r3, [pc, #48]	; (13144 <usbdc_request_handler+0x34>)
   13114:	689c      	ldr	r4, [r3, #8]
{
   13116:	4605      	mov	r5, r0
   13118:	460e      	mov	r6, r1
   1311a:	4617      	mov	r7, r2
	int32_t                   rc;

	while (h != NULL) {
   1311c:	b90c      	cbnz	r4, 13122 <usbdc_request_handler+0x12>
				return -1;
			}
		}
		h = h->next;
	}
	return false;
   1311e:	4620      	mov	r0, r4
}
   13120:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (NULL != h->cb) {
   13122:	6863      	ldr	r3, [r4, #4]
   13124:	b90b      	cbnz	r3, 1312a <usbdc_request_handler+0x1a>
		h = h->next;
   13126:	6824      	ldr	r4, [r4, #0]
   13128:	e7f8      	b.n	1311c <usbdc_request_handler+0xc>
			rc = h->cb(ep, req, stage);
   1312a:	463a      	mov	r2, r7
   1312c:	4631      	mov	r1, r6
   1312e:	4628      	mov	r0, r5
   13130:	4798      	blx	r3
			if (0 == rc) {
   13132:	b120      	cbz	r0, 1313e <usbdc_request_handler+0x2e>
			} else if (ERR_NOT_FOUND != rc) {
   13134:	300a      	adds	r0, #10
   13136:	d0f6      	beq.n	13126 <usbdc_request_handler+0x16>
				return -1;
   13138:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1313c:	e7f0      	b.n	13120 <usbdc_request_handler+0x10>
				return true;
   1313e:	2001      	movs	r0, #1
   13140:	e7ee      	b.n	13120 <usbdc_request_handler+0x10>
   13142:	bf00      	nop
   13144:	20009108 	.word	0x20009108

00013148 <usbd_sof_cb>:
	struct usbdc_sof_handler *sof = (struct usbdc_sof_handler *)usbdc.handlers.sof_list.head;
   13148:	4b04      	ldr	r3, [pc, #16]	; (1315c <usbd_sof_cb+0x14>)

/**
 * \brief Callback invoked on USB device SOF
 */
static void usbd_sof_cb(void)
{
   1314a:	b510      	push	{r4, lr}
	struct usbdc_sof_handler *sof = (struct usbdc_sof_handler *)usbdc.handlers.sof_list.head;
   1314c:	685c      	ldr	r4, [r3, #4]
	while (sof != NULL) {
   1314e:	b904      	cbnz	r4, 13152 <usbd_sof_cb+0xa>
	usbdc_sof_notify();
}
   13150:	bd10      	pop	{r4, pc}
		if (NULL != sof->cb) {
   13152:	6863      	ldr	r3, [r4, #4]
   13154:	b103      	cbz	r3, 13158 <usbd_sof_cb+0x10>
			sof->cb();
   13156:	4798      	blx	r3
		sof = sof->next;
   13158:	6824      	ldr	r4, [r4, #0]
   1315a:	e7f8      	b.n	1314e <usbd_sof_cb+0x6>
   1315c:	20009108 	.word	0x20009108

00013160 <usbdc_cb_ctl_done>:
 * \return Data has error or not.
 * \retval true There is data error, protocol error.
 * \retval false There is no data error.
 */
static bool usbdc_cb_ctl_done(const uint8_t ep, const enum usb_xfer_code code, struct usb_req *req)
{
   13160:	b510      	push	{r4, lr}
   13162:	4614      	mov	r4, r2
	(void)ep;

	switch (code) {
   13164:	460a      	mov	r2, r1
   13166:	b119      	cbz	r1, 13170 <usbdc_cb_ctl_done+0x10>
   13168:	2901      	cmp	r1, #1
   1316a:	d021      	beq.n	131b0 <usbdc_cb_ctl_done+0x50>
		return usbdc_ctrl_data_end(req);
	default:
		break;
	}
	return false;
}
   1316c:	2000      	movs	r0, #0
   1316e:	bd10      	pop	{r4, pc}
	if (req->bmRequestType != USB_REQT_TYPE_STANDARD) {
   13170:	7823      	ldrb	r3, [r4, #0]
   13172:	2b00      	cmp	r3, #0
   13174:	d1fa      	bne.n	1316c <usbdc_cb_ctl_done+0xc>
	switch (req->bRequest) {
   13176:	7863      	ldrb	r3, [r4, #1]
   13178:	2b05      	cmp	r3, #5
   1317a:	d00d      	beq.n	13198 <usbdc_cb_ctl_done+0x38>
   1317c:	2b09      	cmp	r3, #9
   1317e:	d1f5      	bne.n	1316c <usbdc_cb_ctl_done+0xc>
		usbdc.cfg_value = req->wValue;
   13180:	8862      	ldrh	r2, [r4, #2]
   13182:	4b0e      	ldr	r3, [pc, #56]	; (131bc <usbdc_cb_ctl_done+0x5c>)
		usbdc.state     = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
   13184:	2a00      	cmp	r2, #0
		usbdc.cfg_value = req->wValue;
   13186:	76da      	strb	r2, [r3, #27]
		usbdc.state     = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
   13188:	bf14      	ite	ne
   1318a:	2104      	movne	r1, #4
   1318c:	2103      	moveq	r1, #3
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
   1318e:	7699      	strb	r1, [r3, #26]
		usbdc_change_notify(USBDC_C_STATE, usbdc.state);
   13190:	2001      	movs	r0, #1
   13192:	4b0b      	ldr	r3, [pc, #44]	; (131c0 <usbdc_cb_ctl_done+0x60>)
   13194:	4798      	blx	r3
		break;
   13196:	e7e9      	b.n	1316c <usbdc_cb_ctl_done+0xc>
		usbdc_set_address(req->wValue);
   13198:	8860      	ldrh	r0, [r4, #2]
	usb_d_set_address(addr);
   1319a:	4b0a      	ldr	r3, [pc, #40]	; (131c4 <usbdc_cb_ctl_done+0x64>)
   1319c:	b2c0      	uxtb	r0, r0
   1319e:	4798      	blx	r3
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
   131a0:	8863      	ldrh	r3, [r4, #2]
   131a2:	2b00      	cmp	r3, #0
   131a4:	bf18      	it	ne
   131a6:	2103      	movne	r1, #3
   131a8:	4b04      	ldr	r3, [pc, #16]	; (131bc <usbdc_cb_ctl_done+0x5c>)
   131aa:	bf08      	it	eq
   131ac:	2102      	moveq	r1, #2
   131ae:	e7ee      	b.n	1318e <usbdc_cb_ctl_done+0x2e>
	usbdc_request_handler(0, req, USB_DATA_STAGE);
   131b0:	4b05      	ldr	r3, [pc, #20]	; (131c8 <usbdc_cb_ctl_done+0x68>)
   131b2:	4621      	mov	r1, r4
   131b4:	2000      	movs	r0, #0
   131b6:	4798      	blx	r3
		return usbdc_ctrl_data_end(req);
   131b8:	e7d8      	b.n	1316c <usbdc_cb_ctl_done+0xc>
   131ba:	bf00      	nop
   131bc:	20009108 	.word	0x20009108
   131c0:	000130f1 	.word	0x000130f1
   131c4:	0000f519 	.word	0x0000f519
   131c8:	00013111 	.word	0x00013111

000131cc <usbdc_reset>:

/**
 * \brief USB Device Core Reset
 */
void usbdc_reset(void)
{
   131cc:	b570      	push	{r4, r5, r6, lr}
	usbdc_unconfig();

	usbdc.state       = USBD_S_DEFAULT;
   131ce:	4d0d      	ldr	r5, [pc, #52]	; (13204 <usbdc_reset+0x38>)
	usbdc_unconfig();
   131d0:	4b0d      	ldr	r3, [pc, #52]	; (13208 <usbdc_reset+0x3c>)
	usbdc.cfg_value   = 0;
	usbdc.ifc_alt_map = 0;
   131d2:	2400      	movs	r4, #0
	usbdc.state       = USBD_S_DEFAULT;
   131d4:	2602      	movs	r6, #2
	usbdc_unconfig();
   131d6:	4798      	blx	r3
	usbdc.state       = USBD_S_DEFAULT;
   131d8:	836e      	strh	r6, [r5, #26]

	// Setup EP0
	usb_d_ep_deinit(0);
   131da:	4620      	mov	r0, r4
   131dc:	4b0b      	ldr	r3, [pc, #44]	; (1320c <usbdc_reset+0x40>)
	usbdc.ifc_alt_map = 0;
   131de:	776c      	strb	r4, [r5, #29]
	usb_d_ep_deinit(0);
   131e0:	4798      	blx	r3
	usb_d_ep0_init(usbdc.ctrl_size);
   131e2:	4b0b      	ldr	r3, [pc, #44]	; (13210 <usbdc_reset+0x44>)
   131e4:	7f28      	ldrb	r0, [r5, #28]
	usb_d_ep_register_callback(0, USB_D_EP_CB_SETUP, (FUNC_PTR)usbdc_cb_ctl_req);
   131e6:	4d0b      	ldr	r5, [pc, #44]	; (13214 <usbdc_reset+0x48>)
	usb_d_ep0_init(usbdc.ctrl_size);
   131e8:	4798      	blx	r3
	usb_d_ep_register_callback(0, USB_D_EP_CB_SETUP, (FUNC_PTR)usbdc_cb_ctl_req);
   131ea:	4621      	mov	r1, r4
   131ec:	4620      	mov	r0, r4
   131ee:	4a0a      	ldr	r2, [pc, #40]	; (13218 <usbdc_reset+0x4c>)
   131f0:	47a8      	blx	r5
	usb_d_ep_register_callback(0, USB_D_EP_CB_XFER, (FUNC_PTR)usbdc_cb_ctl_done);
   131f2:	4620      	mov	r0, r4
   131f4:	4631      	mov	r1, r6
   131f6:	4a09      	ldr	r2, [pc, #36]	; (1321c <usbdc_reset+0x50>)
   131f8:	47a8      	blx	r5
	usb_d_ep_enable(0);
   131fa:	4620      	mov	r0, r4
   131fc:	4b08      	ldr	r3, [pc, #32]	; (13220 <usbdc_reset+0x54>)
}
   131fe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	usb_d_ep_enable(0);
   13202:	4718      	bx	r3
   13204:	20009108 	.word	0x20009108
   13208:	000130d5 	.word	0x000130d5
   1320c:	0000f585 	.word	0x0000f585
   13210:	0000f575 	.word	0x0000f575
   13214:	0000f799 	.word	0x0000f799
   13218:	0001325d 	.word	0x0001325d
   1321c:	00013161 	.word	0x00013161
   13220:	0000f5b1 	.word	0x0000f5b1

00013224 <usbd_event_cb>:
 */
static void usbd_event_cb(const enum usb_event ev, const uint32_t param)
{
	(void)param;

	switch (ev) {
   13224:	b110      	cbz	r0, 1322c <usbd_event_cb+0x8>
   13226:	2801      	cmp	r0, #1
   13228:	d002      	beq.n	13230 <usbd_event_cb+0xc>
   1322a:	4770      	bx	lr
	case USB_EV_VBUS:
		usbdc_change_notify(USBDC_C_CONN, param);
   1322c:	4b01      	ldr	r3, [pc, #4]	; (13234 <usbd_event_cb+0x10>)
   1322e:	4718      	bx	r3
		break;

	case USB_EV_RESET:
		usbdc_reset();
   13230:	4b01      	ldr	r3, [pc, #4]	; (13238 <usbd_event_cb+0x14>)
   13232:	4718      	bx	r3
   13234:	000130f1 	.word	0x000130f1
   13238:	000131cd 	.word	0x000131cd

0001323c <usbdc_xfer>:

/**
 * \brief Issue USB device transfer
 */
int32_t usbdc_xfer(uint8_t ep, uint8_t *buf, uint32_t size, bool zlp)
{
   1323c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct usb_d_transfer xfer = {(uint8_t *)buf, size, ep, zlp};
   1323e:	f88d 000c 	strb.w	r0, [sp, #12]
   13242:	f88d 300d 	strb.w	r3, [sp, #13]
	return usb_d_ep_transfer(&xfer);
   13246:	a801      	add	r0, sp, #4
   13248:	4b03      	ldr	r3, [pc, #12]	; (13258 <usbdc_xfer+0x1c>)
	struct usb_d_transfer xfer = {(uint8_t *)buf, size, ep, zlp};
   1324a:	e9cd 1201 	strd	r1, r2, [sp, #4]
	return usb_d_ep_transfer(&xfer);
   1324e:	4798      	blx	r3
}
   13250:	b005      	add	sp, #20
   13252:	f85d fb04 	ldr.w	pc, [sp], #4
   13256:	bf00      	nop
   13258:	0000f5f1 	.word	0x0000f5f1

0001325c <usbdc_cb_ctl_req>:
{
   1325c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	switch (usbdc_request_handler(ep, req, USB_SETUP_STAGE)) {
   13260:	4ba6      	ldr	r3, [pc, #664]	; (134fc <usbdc_cb_ctl_req+0x2a0>)
   13262:	2200      	movs	r2, #0
{
   13264:	4605      	mov	r5, r0
   13266:	460c      	mov	r4, r1
	switch (usbdc_request_handler(ep, req, USB_SETUP_STAGE)) {
   13268:	4798      	blx	r3
   1326a:	1c43      	adds	r3, r0, #1
   1326c:	d008      	beq.n	13280 <usbdc_cb_ctl_req+0x24>
   1326e:	2801      	cmp	r0, #1
   13270:	d034      	beq.n	132dc <usbdc_cb_ctl_req+0x80>
	switch (req->bmRequestType & (USB_REQT_TYPE_MASK | USB_REQT_DIR_IN)) {
   13272:	7823      	ldrb	r3, [r4, #0]
   13274:	f013 02e0 	ands.w	r2, r3, #224	; 0xe0
   13278:	d004      	beq.n	13284 <usbdc_cb_ctl_req+0x28>
   1327a:	2a80      	cmp	r2, #128	; 0x80
   1327c:	f000 80ca 	beq.w	13414 <usbdc_cb_ctl_req+0x1b8>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   13280:	2000      	movs	r0, #0
   13282:	e02b      	b.n	132dc <usbdc_cb_ctl_req+0x80>
	switch (req->bRequest) {
   13284:	7862      	ldrb	r2, [r4, #1]
   13286:	3a01      	subs	r2, #1
   13288:	2a0a      	cmp	r2, #10
   1328a:	d8f9      	bhi.n	13280 <usbdc_cb_ctl_req+0x24>
   1328c:	a101      	add	r1, pc, #4	; (adr r1, 13294 <usbdc_cb_ctl_req+0x38>)
   1328e:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
   13292:	bf00      	nop
   13294:	00013347 	.word	0x00013347
   13298:	00013281 	.word	0x00013281
   1329c:	0001336d 	.word	0x0001336d
   132a0:	00013281 	.word	0x00013281
   132a4:	000132cb 	.word	0x000132cb
   132a8:	00013281 	.word	0x00013281
   132ac:	00013281 	.word	0x00013281
   132b0:	00013281 	.word	0x00013281
   132b4:	000132c1 	.word	0x000132c1
   132b8:	00013281 	.word	0x00013281
   132bc:	00013387 	.word	0x00013387
		if (!usbdc_set_config(req->wValue)) {
   132c0:	8862      	ldrh	r2, [r4, #2]
   132c2:	b2d2      	uxtb	r2, r2
	if (cfg_value == 0) {
   132c4:	b96a      	cbnz	r2, 132e2 <usbdc_cb_ctl_req+0x86>
		usbdc_unconfig();
   132c6:	4b8e      	ldr	r3, [pc, #568]	; (13500 <usbdc_cb_ctl_req+0x2a4>)
   132c8:	4798      	blx	r3
		return (ERR_NONE == usbdc_xfer(ep, NULL, 0, true));
   132ca:	2200      	movs	r2, #0
   132cc:	2301      	movs	r3, #1
   132ce:	4611      	mov	r1, r2
	if (ERR_NONE != usbdc_xfer(ep, str_desc, length, need_zlp)) {
   132d0:	4c8c      	ldr	r4, [pc, #560]	; (13504 <usbdc_cb_ctl_req+0x2a8>)
   132d2:	4628      	mov	r0, r5
   132d4:	47a0      	blx	r4
   132d6:	fab0 f080 	clz	r0, r0
   132da:	0940      	lsrs	r0, r0, #5
}
   132dc:	b004      	add	sp, #16
   132de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, cfg_value);
   132e2:	4c89      	ldr	r4, [pc, #548]	; (13508 <usbdc_cb_ctl_req+0x2ac>)
   132e4:	6823      	ldr	r3, [r4, #0]
   132e6:	e9d3 0100 	ldrd	r0, r1, [r3]
   132ea:	4b88      	ldr	r3, [pc, #544]	; (1350c <usbdc_cb_ctl_req+0x2b0>)
   132ec:	4798      	blx	r3
	if (NULL == cfg_desc) {
   132ee:	2800      	cmp	r0, #0
   132f0:	d0c6      	beq.n	13280 <usbdc_cb_ctl_req+0x24>
   132f2:	78c2      	ldrb	r2, [r0, #3]
   132f4:	7883      	ldrb	r3, [r0, #2]
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   132f6:	4f86      	ldr	r7, [pc, #536]	; (13510 <usbdc_cb_ctl_req+0x2b4>)
   132f8:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	desc.eod  = cfg_desc + total_len;
   132fc:	fa10 f183 	uxtah	r1, r0, r3
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   13300:	2204      	movs	r2, #4
	desc.eod  = cfg_desc + total_len;
   13302:	9103      	str	r1, [sp, #12]
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   13304:	47b8      	blx	r7
	uint8_t                 last_iface = 0xFF;
   13306:	23ff      	movs	r3, #255	; 0xff
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   13308:	9002      	str	r0, [sp, #8]
	while (NULL != desc.sod) {
   1330a:	9a02      	ldr	r2, [sp, #8]
   1330c:	2a00      	cmp	r2, #0
   1330e:	d0dc      	beq.n	132ca <usbdc_cb_ctl_req+0x6e>
		if (last_iface != desc.sod[2] /* bInterfaceNumber */) {
   13310:	f892 8002 	ldrb.w	r8, [r2, #2]
   13314:	4598      	cmp	r8, r3
   13316:	d014      	beq.n	13342 <usbdc_cb_ctl_req+0xe6>
			func       = (struct usbdf_driver *)usbdc.func_list.head;
   13318:	6926      	ldr	r6, [r4, #16]
			while (NULL != func) {
   1331a:	b94e      	cbnz	r6, 13330 <usbdc_cb_ctl_req+0xd4>
		desc.sod = usb_desc_next(desc.sod);
   1331c:	9802      	ldr	r0, [sp, #8]
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   1331e:	9903      	ldr	r1, [sp, #12]
	return (desc + usb_desc_len(desc));
   13320:	7803      	ldrb	r3, [r0, #0]
   13322:	2204      	movs	r2, #4
   13324:	4418      	add	r0, r3
		desc.sod = usb_desc_next(desc.sod);
   13326:	9002      	str	r0, [sp, #8]
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   13328:	47b8      	blx	r7
   1332a:	4643      	mov	r3, r8
   1332c:	9002      	str	r0, [sp, #8]
   1332e:	e7ec      	b.n	1330a <usbdc_cb_ctl_req+0xae>
				if (func->ctrl(func, USBDF_ENABLE, &desc)) {
   13330:	6873      	ldr	r3, [r6, #4]
   13332:	aa02      	add	r2, sp, #8
   13334:	2100      	movs	r1, #0
   13336:	4630      	mov	r0, r6
   13338:	4798      	blx	r3
   1333a:	2800      	cmp	r0, #0
   1333c:	d0ee      	beq.n	1331c <usbdc_cb_ctl_req+0xc0>
					func = func->next;
   1333e:	6836      	ldr	r6, [r6, #0]
   13340:	e7eb      	b.n	1331a <usbdc_cb_ctl_req+0xbe>
   13342:	4698      	mov	r8, r3
   13344:	e7ea      	b.n	1331c <usbdc_cb_ctl_req+0xc0>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   13346:	2b02      	cmp	r3, #2
   13348:	d19a      	bne.n	13280 <usbdc_cb_ctl_req+0x24>
		if (req->wLength != 0) {
   1334a:	88e2      	ldrh	r2, [r4, #6]
   1334c:	2a00      	cmp	r2, #0
   1334e:	d197      	bne.n	13280 <usbdc_cb_ctl_req+0x24>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_CLR);
   13350:	88a0      	ldrh	r0, [r4, #4]
   13352:	4b70      	ldr	r3, [pc, #448]	; (13514 <usbdc_cb_ctl_req+0x2b8>)
   13354:	9201      	str	r2, [sp, #4]
   13356:	4611      	mov	r1, r2
   13358:	b2c0      	uxtb	r0, r0
   1335a:	4798      	blx	r3
		usbdc_xfer(ep, NULL, 0, true);
   1335c:	9a01      	ldr	r2, [sp, #4]
   1335e:	2301      	movs	r3, #1
		usbdc_xfer(ep, NULL, 0, true);
   13360:	4611      	mov	r1, r2
   13362:	4628      	mov	r0, r5
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   13364:	4c67      	ldr	r4, [pc, #412]	; (13504 <usbdc_cb_ctl_req+0x2a8>)
   13366:	47a0      	blx	r4
			return true;
   13368:	2001      	movs	r0, #1
   1336a:	e7b7      	b.n	132dc <usbdc_cb_ctl_req+0x80>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   1336c:	2b02      	cmp	r3, #2
   1336e:	d187      	bne.n	13280 <usbdc_cb_ctl_req+0x24>
		if (req->wLength != 0) {
   13370:	88e6      	ldrh	r6, [r4, #6]
   13372:	2e00      	cmp	r6, #0
   13374:	d184      	bne.n	13280 <usbdc_cb_ctl_req+0x24>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_SET);
   13376:	88a0      	ldrh	r0, [r4, #4]
   13378:	4b66      	ldr	r3, [pc, #408]	; (13514 <usbdc_cb_ctl_req+0x2b8>)
   1337a:	2101      	movs	r1, #1
   1337c:	b2c0      	uxtb	r0, r0
   1337e:	4798      	blx	r3
		usbdc_xfer(ep, NULL, 0, true);
   13380:	2301      	movs	r3, #1
   13382:	4632      	mov	r2, r6
   13384:	e7ec      	b.n	13360 <usbdc_cb_ctl_req+0x104>
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
   13386:	4d60      	ldr	r5, [pc, #384]	; (13508 <usbdc_cb_ctl_req+0x2ac>)
		return usbdc_set_interface(req->wValue, req->wIndex);
   13388:	8866      	ldrh	r6, [r4, #2]
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
   1338a:	682b      	ldr	r3, [r5, #0]
   1338c:	7eea      	ldrb	r2, [r5, #27]
		return usbdc_set_interface(req->wValue, req->wIndex);
   1338e:	88a7      	ldrh	r7, [r4, #4]
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
   13390:	e9d3 0100 	ldrd	r0, r1, [r3]
   13394:	4b5d      	ldr	r3, [pc, #372]	; (1350c <usbdc_cb_ctl_req+0x2b0>)
   13396:	4798      	blx	r3
	if (NULL == ifc) {
   13398:	2800      	cmp	r0, #0
   1339a:	f43f af71 	beq.w	13280 <usbdc_cb_ctl_req+0x24>
	desc.sod = ifc;
   1339e:	9002      	str	r0, [sp, #8]
	return (ptr[0] + (ptr[1] << 8));
   133a0:	78c2      	ldrb	r2, [r0, #3]
   133a2:	7883      	ldrb	r3, [r0, #2]
	if (NULL == (ifc = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE))) {
   133a4:	4c5a      	ldr	r4, [pc, #360]	; (13510 <usbdc_cb_ctl_req+0x2b4>)
   133a6:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	desc.eod = ifc + usb_cfg_desc_total_len(ifc);
   133aa:	fa10 f183 	uxtah	r1, r0, r3
   133ae:	9103      	str	r1, [sp, #12]
	if (NULL == (ifc = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE))) {
   133b0:	2204      	movs	r2, #4
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   133b2:	47a0      	blx	r4
		if (NULL == ifc) {
   133b4:	2800      	cmp	r0, #0
   133b6:	f43f af63 	beq.w	13280 <usbdc_cb_ctl_req+0x24>
	while (ifc[2] != ifc_id || ifc[3] != alt_set) {
   133ba:	7883      	ldrb	r3, [r0, #2]
   133bc:	42bb      	cmp	r3, r7
   133be:	d110      	bne.n	133e2 <usbdc_cb_ctl_req+0x186>
   133c0:	78c3      	ldrb	r3, [r0, #3]
   133c2:	42b3      	cmp	r3, r6
   133c4:	d10d      	bne.n	133e2 <usbdc_cb_ctl_req+0x186>
	func     = (struct usbdf_driver *)usbdc.func_list.head;
   133c6:	692c      	ldr	r4, [r5, #16]
	desc.sod = ifc;
   133c8:	9002      	str	r0, [sp, #8]
	while (NULL != func) {
   133ca:	2c00      	cmp	r4, #0
   133cc:	f43f af58 	beq.w	13280 <usbdc_cb_ctl_req+0x24>
		if (func->ctrl(func, USBDF_DISABLE, &desc)) {
   133d0:	2101      	movs	r1, #1
   133d2:	6863      	ldr	r3, [r4, #4]
   133d4:	aa02      	add	r2, sp, #8
   133d6:	4620      	mov	r0, r4
   133d8:	4798      	blx	r3
   133da:	4601      	mov	r1, r0
   133dc:	b140      	cbz	r0, 133f0 <usbdc_cb_ctl_req+0x194>
			func = func->next;
   133de:	6824      	ldr	r4, [r4, #0]
   133e0:	e7f3      	b.n	133ca <usbdc_cb_ctl_req+0x16e>
		desc.sod = usb_desc_next(desc.sod);
   133e2:	9802      	ldr	r0, [sp, #8]
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   133e4:	9903      	ldr	r1, [sp, #12]
	return (desc + usb_desc_len(desc));
   133e6:	7803      	ldrb	r3, [r0, #0]
   133e8:	4418      	add	r0, r3
		desc.sod = usb_desc_next(desc.sod);
   133ea:	9002      	str	r0, [sp, #8]
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   133ec:	2204      	movs	r2, #4
   133ee:	e7e0      	b.n	133b2 <usbdc_cb_ctl_req+0x156>
		} else if (ERR_NONE == func->ctrl(func, USBDF_ENABLE, &desc)) {
   133f0:	6863      	ldr	r3, [r4, #4]
   133f2:	aa02      	add	r2, sp, #8
   133f4:	4620      	mov	r0, r4
   133f6:	4798      	blx	r3
   133f8:	2800      	cmp	r0, #0
   133fa:	f47f af41 	bne.w	13280 <usbdc_cb_ctl_req+0x24>
			if (alt_set) {
   133fe:	b126      	cbz	r6, 1340a <usbdc_cb_ctl_req+0x1ae>
				usbdc.ifc_alt_map |= 1 << ifc_id;
   13400:	2301      	movs	r3, #1
   13402:	40bb      	lsls	r3, r7
   13404:	7f6f      	ldrb	r7, [r5, #29]
   13406:	431f      	orrs	r7, r3
   13408:	776f      	strb	r7, [r5, #29]
			usbdc_xfer(0, NULL, 0, 0);
   1340a:	2300      	movs	r3, #0
   1340c:	461a      	mov	r2, r3
   1340e:	4619      	mov	r1, r3
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   13410:	4618      	mov	r0, r3
   13412:	e7a7      	b.n	13364 <usbdc_cb_ctl_req+0x108>
	switch (req->bRequest) {
   13414:	7862      	ldrb	r2, [r4, #1]
   13416:	2a0a      	cmp	r2, #10
   13418:	f63f af32 	bhi.w	13280 <usbdc_cb_ctl_req+0x24>
   1341c:	a101      	add	r1, pc, #4	; (adr r1, 13424 <usbdc_cb_ctl_req+0x1c8>)
   1341e:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
   13422:	bf00      	nop
   13424:	0001351d 	.word	0x0001351d
   13428:	00013281 	.word	0x00013281
   1342c:	00013281 	.word	0x00013281
   13430:	00013281 	.word	0x00013281
   13434:	00013281 	.word	0x00013281
   13438:	00013281 	.word	0x00013281
   1343c:	00013451 	.word	0x00013451
   13440:	00013281 	.word	0x00013281
   13444:	000134ed 	.word	0x000134ed
   13448:	00013281 	.word	0x00013281
   1344c:	0001354b 	.word	0x0001354b
	uint8_t type = (uint8_t)(req->wValue >> 8);
   13450:	8863      	ldrh	r3, [r4, #2]
   13452:	0a19      	lsrs	r1, r3, #8
	switch (type) {
   13454:	2902      	cmp	r1, #2
	uint8_t type = (uint8_t)(req->wValue >> 8);
   13456:	460a      	mov	r2, r1
	switch (type) {
   13458:	d016      	beq.n	13488 <usbdc_cb_ctl_req+0x22c>
   1345a:	2903      	cmp	r1, #3
   1345c:	d031      	beq.n	134c2 <usbdc_cb_ctl_req+0x266>
   1345e:	2901      	cmp	r1, #1
   13460:	f47f af0e 	bne.w	13280 <usbdc_cb_ctl_req+0x24>
		dev_desc = usb_find_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, USB_DT_DEVICE);
   13464:	4b28      	ldr	r3, [pc, #160]	; (13508 <usbdc_cb_ctl_req+0x2ac>)
	uint16_t length   = req->wLength;
   13466:	88e4      	ldrh	r4, [r4, #6]
		dev_desc = usb_find_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, USB_DT_DEVICE);
   13468:	681b      	ldr	r3, [r3, #0]
   1346a:	e9d3 0100 	ldrd	r0, r1, [r3]
   1346e:	4b28      	ldr	r3, [pc, #160]	; (13510 <usbdc_cb_ctl_req+0x2b4>)
   13470:	4798      	blx	r3
	if (!dev_desc) {
   13472:	4601      	mov	r1, r0
   13474:	2800      	cmp	r0, #0
   13476:	f43f af03 	beq.w	13280 <usbdc_cb_ctl_req+0x24>
	if (ERR_NONE != usbdc_xfer(ep, dev_desc, length, false)) {
   1347a:	2c12      	cmp	r4, #18
   1347c:	4622      	mov	r2, r4
   1347e:	f04f 0300 	mov.w	r3, #0
   13482:	bf28      	it	cs
   13484:	2212      	movcs	r2, #18
   13486:	e723      	b.n	132d0 <usbdc_cb_ctl_req+0x74>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13488:	4a1f      	ldr	r2, [pc, #124]	; (13508 <usbdc_cb_ctl_req+0x2ac>)
	uint16_t length   = req->wLength;
   1348a:	88e4      	ldrh	r4, [r4, #6]
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index + 1);
   1348c:	6810      	ldr	r0, [r2, #0]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   1348e:	7f16      	ldrb	r6, [r2, #28]
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index + 1);
   13490:	1c5a      	adds	r2, r3, #1
   13492:	e9d0 0100 	ldrd	r0, r1, [r0]
   13496:	4b1d      	ldr	r3, [pc, #116]	; (1350c <usbdc_cb_ctl_req+0x2b0>)
   13498:	b2d2      	uxtb	r2, r2
   1349a:	4798      	blx	r3
	if (NULL == cfg_desc) {
   1349c:	4601      	mov	r1, r0
   1349e:	2800      	cmp	r0, #0
   134a0:	f43f aeee 	beq.w	13280 <usbdc_cb_ctl_req+0x24>
	return (ptr[0] + (ptr[1] << 8));
   134a4:	78c3      	ldrb	r3, [r0, #3]
   134a6:	7882      	ldrb	r2, [r0, #2]
   134a8:	eb02 2203 	add.w	r2, r2, r3, lsl #8
   134ac:	b292      	uxth	r2, r2
	if (length <= total_len) {
   134ae:	4294      	cmp	r4, r2
   134b0:	d91a      	bls.n	134e8 <usbdc_cb_ctl_req+0x28c>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   134b2:	3e01      	subs	r6, #1
   134b4:	4226      	tst	r6, r4
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   134b6:	bf0c      	ite	eq
   134b8:	2301      	moveq	r3, #1
   134ba:	2300      	movne	r3, #0
   134bc:	4614      	mov	r4, r2
	if (ERR_NONE != usbdc_xfer(ep, str_desc, length, need_zlp)) {
   134be:	4622      	mov	r2, r4
   134c0:	e706      	b.n	132d0 <usbdc_cb_ctl_req+0x74>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   134c2:	4a11      	ldr	r2, [pc, #68]	; (13508 <usbdc_cb_ctl_req+0x2ac>)
	uint16_t length   = req->wLength;
   134c4:	88e4      	ldrh	r4, [r4, #6]
	str_desc = usb_find_str_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index);
   134c6:	6810      	ldr	r0, [r2, #0]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   134c8:	7f16      	ldrb	r6, [r2, #28]
	str_desc = usb_find_str_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index);
   134ca:	e9d0 0100 	ldrd	r0, r1, [r0]
   134ce:	b2da      	uxtb	r2, r3
   134d0:	4b11      	ldr	r3, [pc, #68]	; (13518 <usbdc_cb_ctl_req+0x2bc>)
   134d2:	4798      	blx	r3
	if (NULL == str_desc) {
   134d4:	4601      	mov	r1, r0
   134d6:	2800      	cmp	r0, #0
   134d8:	f43f aed2 	beq.w	13280 <usbdc_cb_ctl_req+0x24>
	if (length <= str_desc[0]) {
   134dc:	7802      	ldrb	r2, [r0, #0]
   134de:	4294      	cmp	r4, r2
   134e0:	d902      	bls.n	134e8 <usbdc_cb_ctl_req+0x28c>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   134e2:	1e73      	subs	r3, r6, #1
   134e4:	4223      	tst	r3, r4
   134e6:	e7e6      	b.n	134b6 <usbdc_cb_ctl_req+0x25a>
		need_zlp = false;
   134e8:	2300      	movs	r3, #0
   134ea:	e7e8      	b.n	134be <usbdc_cb_ctl_req+0x262>
		*(uint8_t *)usbdc.ctrl_buf = usbdc.cfg_value;
   134ec:	4906      	ldr	r1, [pc, #24]	; (13508 <usbdc_cb_ctl_req+0x2ac>)
   134ee:	694b      	ldr	r3, [r1, #20]
   134f0:	7eca      	ldrb	r2, [r1, #27]
   134f2:	701a      	strb	r2, [r3, #0]
		usbdc_xfer(ep, usbdc.ctrl_buf, 1, false);
   134f4:	2300      	movs	r3, #0
   134f6:	2201      	movs	r2, #1
	usbdc_xfer(ep, usbdc.ctrl_buf, 2, false);
   134f8:	6949      	ldr	r1, [r1, #20]
   134fa:	e732      	b.n	13362 <usbdc_cb_ctl_req+0x106>
   134fc:	00013111 	.word	0x00013111
   13500:	000130d5 	.word	0x000130d5
   13504:	0001323d 	.word	0x0001323d
   13508:	20009108 	.word	0x20009108
   1350c:	0000b825 	.word	0x0000b825
   13510:	0000b7ed 	.word	0x0000b7ed
   13514:	0000f735 	.word	0x0000f735
   13518:	0000b861 	.word	0x0000b861
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   1351c:	f003 011f 	and.w	r1, r3, #31
   13520:	f013 031e 	ands.w	r3, r3, #30
   13524:	d00b      	beq.n	1353e <usbdc_cb_ctl_req+0x2e2>
   13526:	2902      	cmp	r1, #2
   13528:	f47f aeaa 	bne.w	13280 <usbdc_cb_ctl_req+0x24>
		st = usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_GET);
   1352c:	88a0      	ldrh	r0, [r4, #4]
   1352e:	4b17      	ldr	r3, [pc, #92]	; (1358c <usbdc_cb_ctl_req+0x330>)
   13530:	b2c0      	uxtb	r0, r0
   13532:	4798      	blx	r3
		if (st < 0) {
   13534:	1e03      	subs	r3, r0, #0
   13536:	f6ff aea3 	blt.w	13280 <usbdc_cb_ctl_req+0x24>
		st = st & 0x1;
   1353a:	f003 0301 	and.w	r3, r3, #1
	memcpy(usbdc.ctrl_buf, &st, 2);
   1353e:	4914      	ldr	r1, [pc, #80]	; (13590 <usbdc_cb_ctl_req+0x334>)
   13540:	694a      	ldr	r2, [r1, #20]
   13542:	8013      	strh	r3, [r2, #0]
	usbdc_xfer(ep, usbdc.ctrl_buf, 2, false);
   13544:	2300      	movs	r3, #0
   13546:	2202      	movs	r2, #2
   13548:	e7d6      	b.n	134f8 <usbdc_cb_ctl_req+0x29c>
	if (!(usbdc.ifc_alt_map & (1 << req->wIndex))) {
   1354a:	4911      	ldr	r1, [pc, #68]	; (13590 <usbdc_cb_ctl_req+0x334>)
   1354c:	88a2      	ldrh	r2, [r4, #4]
   1354e:	7f4b      	ldrb	r3, [r1, #29]
   13550:	4113      	asrs	r3, r2
   13552:	f013 0301 	ands.w	r3, r3, #1
   13556:	460e      	mov	r6, r1
   13558:	d00c      	beq.n	13574 <usbdc_cb_ctl_req+0x318>
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
   1355a:	690d      	ldr	r5, [r1, #16]
	while (NULL != func) {
   1355c:	2d00      	cmp	r5, #0
   1355e:	f43f ae8f 	beq.w	13280 <usbdc_cb_ctl_req+0x24>
		if (0 > (rc = func->ctrl(func, USBDF_GET_IFACE, req))) {
   13562:	686b      	ldr	r3, [r5, #4]
   13564:	4622      	mov	r2, r4
   13566:	2102      	movs	r1, #2
   13568:	4628      	mov	r0, r5
   1356a:	4798      	blx	r3
   1356c:	2800      	cmp	r0, #0
   1356e:	da06      	bge.n	1357e <usbdc_cb_ctl_req+0x322>
			func = func->next;
   13570:	682d      	ldr	r5, [r5, #0]
   13572:	e7f3      	b.n	1355c <usbdc_cb_ctl_req+0x300>
		usbdc.ctrl_buf[0] = 0;
   13574:	694a      	ldr	r2, [r1, #20]
   13576:	7013      	strb	r3, [r2, #0]
		usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   13578:	6949      	ldr	r1, [r1, #20]
   1357a:	2201      	movs	r2, #1
   1357c:	e748      	b.n	13410 <usbdc_cb_ctl_req+0x1b4>
			usbdc.ctrl_buf[0] = (uint8_t)rc;
   1357e:	6973      	ldr	r3, [r6, #20]
   13580:	7018      	strb	r0, [r3, #0]
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   13582:	6971      	ldr	r1, [r6, #20]
   13584:	2300      	movs	r3, #0
   13586:	2201      	movs	r2, #1
   13588:	e742      	b.n	13410 <usbdc_cb_ctl_req+0x1b4>
   1358a:	bf00      	nop
   1358c:	0000f735 	.word	0x0000f735
   13590:	20009108 	.word	0x20009108

00013594 <usbdc_register_handler>:
/**
 * \brief Register the handler
 */
void usbdc_register_handler(enum usbdc_handler_type type, const struct usbdc_handler *h)
{
	switch (type) {
   13594:	2801      	cmp	r0, #1
   13596:	d005      	beq.n	135a4 <usbdc_register_handler+0x10>
   13598:	2802      	cmp	r0, #2
   1359a:	d005      	beq.n	135a8 <usbdc_register_handler+0x14>
   1359c:	b930      	cbnz	r0, 135ac <usbdc_register_handler+0x18>
	case USBDC_HDL_SOF:
		list_insert_at_end(&usbdc.handlers.sof_list, (void *)h);
   1359e:	4804      	ldr	r0, [pc, #16]	; (135b0 <usbdc_register_handler+0x1c>)
		break;
	case USBDC_HDL_REQ:
		list_insert_at_end(&usbdc.handlers.req_list, (void *)h);
		break;
	case USBDC_HDL_CHANGE:
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
   135a0:	4b04      	ldr	r3, [pc, #16]	; (135b4 <usbdc_register_handler+0x20>)
   135a2:	4718      	bx	r3
		list_insert_at_end(&usbdc.handlers.req_list, (void *)h);
   135a4:	4804      	ldr	r0, [pc, #16]	; (135b8 <usbdc_register_handler+0x24>)
   135a6:	e7fb      	b.n	135a0 <usbdc_register_handler+0xc>
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
   135a8:	4804      	ldr	r0, [pc, #16]	; (135bc <usbdc_register_handler+0x28>)
   135aa:	e7f9      	b.n	135a0 <usbdc_register_handler+0xc>
		break;
	default:
		break;
	}
}
   135ac:	4770      	bx	lr
   135ae:	bf00      	nop
   135b0:	2000910c 	.word	0x2000910c
   135b4:	0000f829 	.word	0x0000f829
   135b8:	20009110 	.word	0x20009110
   135bc:	20009114 	.word	0x20009114

000135c0 <usbdc_init>:

/**
 * \brief Initialize the USB device core driver
 */
int32_t usbdc_init(uint8_t *ctrl_buf)
{
   135c0:	b538      	push	{r3, r4, r5, lr}
	ASSERT(ctrl_buf);
   135c2:	4604      	mov	r4, r0
   135c4:	3800      	subs	r0, #0
   135c6:	bf18      	it	ne
   135c8:	2001      	movne	r0, #1
   135ca:	490c      	ldr	r1, [pc, #48]	; (135fc <usbdc_init+0x3c>)
   135cc:	4b0c      	ldr	r3, [pc, #48]	; (13600 <usbdc_init+0x40>)
   135ce:	f240 3255 	movw	r2, #853	; 0x355
   135d2:	4798      	blx	r3

	int32_t rc;

	rc = usb_d_init();
   135d4:	4b0b      	ldr	r3, [pc, #44]	; (13604 <usbdc_init+0x44>)
   135d6:	4798      	blx	r3
	if (rc < 0) {
   135d8:	2800      	cmp	r0, #0
   135da:	db0e      	blt.n	135fa <usbdc_init+0x3a>
		return rc;
	}

	memset(&usbdc, 0, sizeof(usbdc));
   135dc:	4b0a      	ldr	r3, [pc, #40]	; (13608 <usbdc_init+0x48>)
   135de:	4d0b      	ldr	r5, [pc, #44]	; (1360c <usbdc_init+0x4c>)
   135e0:	2220      	movs	r2, #32
   135e2:	4618      	mov	r0, r3
   135e4:	2100      	movs	r1, #0
   135e6:	47a8      	blx	r5
	usbdc.ctrl_buf = ctrl_buf;
	usb_d_register_callback(USB_D_CB_SOF, (FUNC_PTR)usbd_sof_cb);
   135e8:	4909      	ldr	r1, [pc, #36]	; (13610 <usbdc_init+0x50>)
	usbdc.ctrl_buf = ctrl_buf;
   135ea:	6144      	str	r4, [r0, #20]
	usb_d_register_callback(USB_D_CB_SOF, (FUNC_PTR)usbd_sof_cb);
   135ec:	4c09      	ldr	r4, [pc, #36]	; (13614 <usbdc_init+0x54>)
   135ee:	2000      	movs	r0, #0
   135f0:	47a0      	blx	r4
	usb_d_register_callback(USB_D_CB_EVENT, (FUNC_PTR)usbd_event_cb);
   135f2:	2001      	movs	r0, #1
   135f4:	4908      	ldr	r1, [pc, #32]	; (13618 <usbdc_init+0x58>)
   135f6:	47a0      	blx	r4

	return 0;
   135f8:	2000      	movs	r0, #0
}
   135fa:	bd38      	pop	{r3, r4, r5, pc}
   135fc:	0001681c 	.word	0x0001681c
   13600:	0000e03d 	.word	0x0000e03d
   13604:	0000f491 	.word	0x0000f491
   13608:	20009108 	.word	0x20009108
   1360c:	000142f1 	.word	0x000142f1
   13610:	00013149 	.word	0x00013149
   13614:	0000f4f9 	.word	0x0000f4f9
   13618:	00013225 	.word	0x00013225

0001361c <usbdc_register_function>:
 * \brief Register/unregister function support of a USB device function
 *
 * Must be invoked when USB device is stopped.
 */
void usbdc_register_function(struct usbdf_driver *func)
{
   1361c:	4601      	mov	r1, r0
	list_insert_at_end(&usbdc.func_list, func);
   1361e:	4b01      	ldr	r3, [pc, #4]	; (13624 <usbdc_register_function+0x8>)
   13620:	4801      	ldr	r0, [pc, #4]	; (13628 <usbdc_register_function+0xc>)
   13622:	4718      	bx	r3
   13624:	0000f829 	.word	0x0000f829
   13628:	20009118 	.word	0x20009118

0001362c <usbdc_start>:

/**
 * \brief Start the USB device driver with specific descriptors set
 */
int32_t usbdc_start(struct usbd_descriptors *desces)
{
   1362c:	b510      	push	{r4, lr}
	if (usbdc.state >= USBD_S_POWER) {
   1362e:	4b0a      	ldr	r3, [pc, #40]	; (13658 <usbdc_start+0x2c>)
   13630:	7e9c      	ldrb	r4, [r3, #26]
   13632:	b954      	cbnz	r4, 1364a <usbdc_start+0x1e>
		return ERR_BUSY;
	}

	if (desces) {
   13634:	b160      	cbz	r0, 13650 <usbdc_start+0x24>
#endif
	} else {
		return ERR_BAD_DATA;
	}

	usbdc.ctrl_size = desces->sod[7];
   13636:	6802      	ldr	r2, [r0, #0]
		usbdc.desces.ls_fs = desces;
   13638:	6018      	str	r0, [r3, #0]
	usbdc.ctrl_size = desces->sod[7];
   1363a:	79d2      	ldrb	r2, [r2, #7]
   1363c:	771a      	strb	r2, [r3, #28]
	usbdc.state     = USBD_S_POWER;
   1363e:	2201      	movs	r2, #1
   13640:	769a      	strb	r2, [r3, #26]
	usb_d_enable();
   13642:	4b06      	ldr	r3, [pc, #24]	; (1365c <usbdc_start+0x30>)
   13644:	4798      	blx	r3
	return ERR_NONE;
   13646:	4620      	mov	r0, r4
}
   13648:	bd10      	pop	{r4, pc}
		return ERR_BUSY;
   1364a:	f06f 0003 	mvn.w	r0, #3
   1364e:	e7fb      	b.n	13648 <usbdc_start+0x1c>
		return ERR_BAD_DATA;
   13650:	f06f 0008 	mvn.w	r0, #8
   13654:	e7f8      	b.n	13648 <usbdc_start+0x1c>
   13656:	bf00      	nop
   13658:	20009108 	.word	0x20009108
   1365c:	0000f501 	.word	0x0000f501

00013660 <usbdc_attach>:
/**
 * \brief Attach the USB device to host
 */
void usbdc_attach(void)
{
	usb_d_attach();
   13660:	4b00      	ldr	r3, [pc, #0]	; (13664 <usbdc_attach+0x4>)
   13662:	4718      	bx	r3
   13664:	0000f509 	.word	0x0000f509

00013668 <usbdc_get_ctrl_buffer>:
 * \brief Return USB Device endpoint0 buffer
 */
uint8_t *usbdc_get_ctrl_buffer(void)
{
	return usbdc.ctrl_buf;
}
   13668:	4b01      	ldr	r3, [pc, #4]	; (13670 <usbdc_get_ctrl_buffer+0x8>)
   1366a:	6958      	ldr	r0, [r3, #20]
   1366c:	4770      	bx	lr
   1366e:	bf00      	nop
   13670:	20009108 	.word	0x20009108

00013674 <usbdc_get_state>:
/**
 * \brief Return current USB state
 */
uint8_t usbdc_get_state(void)
{
	if (usbdc.state & USBD_S_SUSPEND) {
   13674:	4b03      	ldr	r3, [pc, #12]	; (13684 <usbdc_get_state+0x10>)
   13676:	7e98      	ldrb	r0, [r3, #26]
   13678:	f010 0f10 	tst.w	r0, #16
		return USBD_S_SUSPEND;
	}
	return usbdc.state;
}
   1367c:	bf18      	it	ne
   1367e:	2010      	movne	r0, #16
   13680:	4770      	bx	lr
   13682:	bf00      	nop
   13684:	20009108 	.word	0x20009108

00013688 <hri_tc_wait_for_sync>:
typedef uint8_t  hri_tccount8_per_reg_t;
typedef uint8_t  hri_tccount8_perbuf_reg_t;

static inline void hri_tc_wait_for_sync(const void *const hw, hri_tc_syncbusy_reg_t reg)
{
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
   13688:	6903      	ldr	r3, [r0, #16]
   1368a:	420b      	tst	r3, r1
   1368c:	d1fc      	bne.n	13688 <hri_tc_wait_for_sync>
	};
}
   1368e:	4770      	bx	lr

00013690 <_tc_timer_start>:
/**
 * \brief Start hardware timer
 */
void _tc_timer_start(struct _timer_device *const device)
{
	hri_tc_set_CTRLA_ENABLE_bit(device->hw);
   13690:	68c0      	ldr	r0, [r0, #12]
}

static inline void hri_tc_set_CTRLA_ENABLE_bit(const void *const hw)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
   13692:	6803      	ldr	r3, [r0, #0]
   13694:	f043 0302 	orr.w	r3, r3, #2
   13698:	6003      	str	r3, [r0, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   1369a:	2103      	movs	r1, #3
   1369c:	4b00      	ldr	r3, [pc, #0]	; (136a0 <_tc_timer_start+0x10>)
   1369e:	4718      	bx	r3
   136a0:	00013689 	.word	0x00013689

000136a4 <_tc_timer_get_period>:
/**
 * \brief Retrieve timer period
 */
uint32_t _tc_timer_get_period(const struct _timer_device *const device)
{
	void *const hw = device->hw;
   136a4:	68c0      	ldr	r0, [r0, #12]
{
   136a6:	b508      	push	{r3, lr}
}

static inline hri_tc_ctrla_reg_t hri_tc_read_CTRLA_MODE_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   136a8:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   136aa:	f3c3 0381 	ubfx	r3, r3, #2, #2

	if (TC_CTRLA_MODE_COUNT32_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   136ae:	2b02      	cmp	r3, #2
   136b0:	d104      	bne.n	136bc <_tc_timer_get_period+0x18>
	TC_CRITICAL_SECTION_LEAVE();
}

static inline hri_tccount32_cc_reg_t hri_tccount32_read_CC_reg(const void *const hw, uint8_t index)
{
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   136b2:	4b0e      	ldr	r3, [pc, #56]	; (136ec <_tc_timer_get_period+0x48>)
   136b4:	21c0      	movs	r1, #192	; 0xc0
   136b6:	4798      	blx	r3
	return ((Tc *)hw)->COUNT32.CC[index].reg;
   136b8:	69c0      	ldr	r0, [r0, #28]
	} else if (TC_CTRLA_MODE_COUNT8_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
		return hri_tccount8_read_PER_reg(hw);
	}

	return 0;
}
   136ba:	bd08      	pop	{r3, pc}
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   136bc:	6803      	ldr	r3, [r0, #0]
	} else if (TC_CTRLA_MODE_COUNT16_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   136be:	f013 0f0c 	tst.w	r3, #12
   136c2:	d105      	bne.n	136d0 <_tc_timer_get_period+0x2c>
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   136c4:	4b09      	ldr	r3, [pc, #36]	; (136ec <_tc_timer_get_period+0x48>)
   136c6:	21c0      	movs	r1, #192	; 0xc0
   136c8:	4798      	blx	r3
	return ((Tc *)hw)->COUNT16.CC[index].reg;
   136ca:	8b80      	ldrh	r0, [r0, #28]
   136cc:	b280      	uxth	r0, r0
		return hri_tccount16_read_CC_reg(hw, 0);
   136ce:	e7f4      	b.n	136ba <_tc_timer_get_period+0x16>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   136d0:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   136d2:	f3c3 0381 	ubfx	r3, r3, #2, #2
	} else if (TC_CTRLA_MODE_COUNT8_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   136d6:	2b01      	cmp	r3, #1
   136d8:	d105      	bne.n	136e6 <_tc_timer_get_period+0x42>
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   136da:	4b04      	ldr	r3, [pc, #16]	; (136ec <_tc_timer_get_period+0x48>)
   136dc:	2120      	movs	r1, #32
   136de:	4798      	blx	r3
	return ((Tc *)hw)->COUNT8.PER.reg;
   136e0:	7ec0      	ldrb	r0, [r0, #27]
   136e2:	b2c0      	uxtb	r0, r0
		return hri_tccount8_read_PER_reg(hw);
   136e4:	e7e9      	b.n	136ba <_tc_timer_get_period+0x16>
	return 0;
   136e6:	2000      	movs	r0, #0
   136e8:	e7e7      	b.n	136ba <_tc_timer_get_period+0x16>
   136ea:	bf00      	nop
   136ec:	00013689 	.word	0x00013689

000136f0 <_tc_timer_is_started>:
/**
 * \brief Check if timer is running
 */
bool _tc_timer_is_started(const struct _timer_device *const device)
{
   136f0:	b508      	push	{r3, lr}
	return hri_tc_get_CTRLA_ENABLE_bit(device->hw);
   136f2:	68c0      	ldr	r0, [r0, #12]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   136f4:	4b03      	ldr	r3, [pc, #12]	; (13704 <_tc_timer_is_started+0x14>)
   136f6:	2103      	movs	r1, #3
   136f8:	4798      	blx	r3
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   136fa:	6800      	ldr	r0, [r0, #0]
}
   136fc:	f3c0 0040 	ubfx	r0, r0, #1, #1
   13700:	bd08      	pop	{r3, pc}
   13702:	bf00      	nop
   13704:	00013689 	.word	0x00013689

00013708 <tc_interrupt_handler>:
 *
 * \param[in] instance TC instance number
 */
static void tc_interrupt_handler(struct _timer_device *device)
{
	void *const hw = device->hw;
   13708:	68c2      	ldr	r2, [r0, #12]
	return (((Tc *)hw)->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) >> TC_INTFLAG_OVF_Pos;
   1370a:	7a91      	ldrb	r1, [r2, #10]

	if (hri_tc_get_interrupt_OVF_bit(hw)) {
   1370c:	07c9      	lsls	r1, r1, #31
   1370e:	d503      	bpl.n	13718 <tc_interrupt_handler+0x10>
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
   13710:	2101      	movs	r1, #1
		hri_tc_clear_interrupt_OVF_bit(hw);
		device->timer_cb.period_expired(device);
   13712:	6803      	ldr	r3, [r0, #0]
   13714:	7291      	strb	r1, [r2, #10]
   13716:	4718      	bx	r3
	}
}
   13718:	4770      	bx	lr
	...

0001371c <get_tc_index>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The index of TC configuration
 */
static int8_t get_tc_index(const void *const hw)
{
   1371c:	b570      	push	{r4, r5, r6, lr}
 * \param[in] hw The pointer to hardware instance
 */
static inline uint8_t _get_hardware_offset(const void *const hw)
{
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
   1371e:	4d15      	ldr	r5, [pc, #84]	; (13774 <get_tc_index+0x58>)
{
   13720:	4606      	mov	r6, r0
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
   13722:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
   13724:	b088      	sub	sp, #32
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
   13726:	466c      	mov	r4, sp
   13728:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1372a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   1372e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
   13732:	466a      	mov	r2, sp
   13734:	2300      	movs	r3, #0
		if ((uint32_t)hw == (uint32_t)tc_modules[i]) {
   13736:	f852 1b04 	ldr.w	r1, [r2], #4
   1373a:	42b1      	cmp	r1, r6
   1373c:	d104      	bne.n	13748 <get_tc_index+0x2c>
			return i;
   1373e:	b2d8      	uxtb	r0, r3
		if (_tcs[i].number == index) {
   13740:	b93b      	cbnz	r3, 13752 <get_tc_index+0x36>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
   13742:	4618      	mov	r0, r3
			return i;
   13744:	b240      	sxtb	r0, r0
   13746:	e012      	b.n	1376e <get_tc_index+0x52>
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
   13748:	3301      	adds	r3, #1
   1374a:	2b08      	cmp	r3, #8
   1374c:	d1f3      	bne.n	13736 <get_tc_index+0x1a>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
   1374e:	2000      	movs	r0, #0
   13750:	e7f8      	b.n	13744 <get_tc_index+0x28>
		if (_tcs[i].number == index) {
   13752:	2801      	cmp	r0, #1
   13754:	d0f6      	beq.n	13744 <get_tc_index+0x28>
   13756:	2802      	cmp	r0, #2
   13758:	d0f4      	beq.n	13744 <get_tc_index+0x28>
   1375a:	2803      	cmp	r0, #3
   1375c:	d0f2      	beq.n	13744 <get_tc_index+0x28>
	ASSERT(false);
   1375e:	2000      	movs	r0, #0
   13760:	4905      	ldr	r1, [pc, #20]	; (13778 <get_tc_index+0x5c>)
   13762:	4b06      	ldr	r3, [pc, #24]	; (1377c <get_tc_index+0x60>)
   13764:	f240 1267 	movw	r2, #359	; 0x167
   13768:	4798      	blx	r3
	return -1;
   1376a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   1376e:	b008      	add	sp, #32
   13770:	bd70      	pop	{r4, r5, r6, pc}
   13772:	bf00      	nop
   13774:	00016848 	.word	0x00016848
   13778:	00016832 	.word	0x00016832
   1377c:	0000e03d 	.word	0x0000e03d

00013780 <_tc_timer_set_irq>:
{
   13780:	b510      	push	{r4, lr}
	int8_t      i  = get_tc_index(hw);
   13782:	4b0a      	ldr	r3, [pc, #40]	; (137ac <_tc_timer_set_irq+0x2c>)
   13784:	68c0      	ldr	r0, [r0, #12]
   13786:	4798      	blx	r3
	ASSERT(ARRAY_SIZE(_tcs));
   13788:	4b09      	ldr	r3, [pc, #36]	; (137b0 <_tc_timer_set_irq+0x30>)
   1378a:	490a      	ldr	r1, [pc, #40]	; (137b4 <_tc_timer_set_irq+0x34>)
	int8_t      i  = get_tc_index(hw);
   1378c:	4604      	mov	r4, r0
	ASSERT(ARRAY_SIZE(_tcs));
   1378e:	f44f 7291 	mov.w	r2, #290	; 0x122
   13792:	2001      	movs	r0, #1
   13794:	4798      	blx	r3
	_irq_set(_tcs[i].irq);
   13796:	4808      	ldr	r0, [pc, #32]	; (137b8 <_tc_timer_set_irq+0x38>)
   13798:	2314      	movs	r3, #20
   1379a:	fb03 0404 	mla	r4, r3, r4, r0
   1379e:	4b07      	ldr	r3, [pc, #28]	; (137bc <_tc_timer_set_irq+0x3c>)
   137a0:	f894 0022 	ldrb.w	r0, [r4, #34]	; 0x22
}
   137a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_irq_set(_tcs[i].irq);
   137a8:	4718      	bx	r3
   137aa:	bf00      	nop
   137ac:	0001371d 	.word	0x0001371d
   137b0:	0000e03d 	.word	0x0000e03d
   137b4:	00016832 	.word	0x00016832
   137b8:	00016848 	.word	0x00016848
   137bc:	0000baa9 	.word	0x0000baa9

000137c0 <_tc_timer_stop>:
	hri_tc_clear_CTRLA_ENABLE_bit(device->hw);
   137c0:	68c0      	ldr	r0, [r0, #12]
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   137c2:	6803      	ldr	r3, [r0, #0]
   137c4:	f023 0302 	bic.w	r3, r3, #2
   137c8:	6003      	str	r3, [r0, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   137ca:	2103      	movs	r1, #3
   137cc:	4b00      	ldr	r3, [pc, #0]	; (137d0 <_tc_timer_stop+0x10>)
   137ce:	4718      	bx	r3
   137d0:	00013689 	.word	0x00013689

000137d4 <_tc_timer_deinit>:
{
   137d4:	b570      	push	{r4, r5, r6, lr}
	void *const hw = device->hw;
   137d6:	68c4      	ldr	r4, [r0, #12]
	int8_t      i  = get_tc_index(hw);
   137d8:	4b17      	ldr	r3, [pc, #92]	; (13838 <_tc_timer_deinit+0x64>)
   137da:	4620      	mov	r0, r4
   137dc:	4798      	blx	r3
	ASSERT(ARRAY_SIZE(_tcs));
   137de:	4b17      	ldr	r3, [pc, #92]	; (1383c <_tc_timer_deinit+0x68>)
   137e0:	4917      	ldr	r1, [pc, #92]	; (13840 <_tc_timer_deinit+0x6c>)
	int8_t      i  = get_tc_index(hw);
   137e2:	4605      	mov	r5, r0
	ASSERT(ARRAY_SIZE(_tcs));
   137e4:	22cd      	movs	r2, #205	; 0xcd
   137e6:	2001      	movs	r0, #1
   137e8:	4798      	blx	r3
	NVIC_DisableIRQ(_tcs[i].irq);
   137ea:	4816      	ldr	r0, [pc, #88]	; (13844 <_tc_timer_deinit+0x70>)
   137ec:	2314      	movs	r3, #20
   137ee:	fb03 0505 	mla	r5, r3, r5, r0
   137f2:	f9b5 3022 	ldrsh.w	r3, [r5, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
   137f6:	2b00      	cmp	r3, #0
   137f8:	db0d      	blt.n	13816 <_tc_timer_deinit+0x42>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   137fa:	095a      	lsrs	r2, r3, #5
   137fc:	2101      	movs	r1, #1
   137fe:	f003 031f 	and.w	r3, r3, #31
   13802:	fa01 f303 	lsl.w	r3, r1, r3
   13806:	3220      	adds	r2, #32
   13808:	490f      	ldr	r1, [pc, #60]	; (13848 <_tc_timer_deinit+0x74>)
   1380a:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   1380e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   13812:	f3bf 8f6f 	isb	sy
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   13816:	6823      	ldr	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13818:	4a0c      	ldr	r2, [pc, #48]	; (1384c <_tc_timer_deinit+0x78>)
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   1381a:	f023 0302 	bic.w	r3, r3, #2
   1381e:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13820:	2103      	movs	r1, #3
   13822:	4620      	mov	r0, r4
   13824:	4790      	blx	r2
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_SWRST;
   13826:	6823      	ldr	r3, [r4, #0]
   13828:	f043 0301 	orr.w	r3, r3, #1
   1382c:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST);
   1382e:	2101      	movs	r1, #1
}
   13830:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   13834:	4710      	bx	r2
   13836:	bf00      	nop
   13838:	0001371d 	.word	0x0001371d
   1383c:	0000e03d 	.word	0x0000e03d
   13840:	00016832 	.word	0x00016832
   13844:	00016848 	.word	0x00016848
   13848:	e000e100 	.word	0xe000e100
   1384c:	00013689 	.word	0x00013689

00013850 <_tc_timer_init>:
{
   13850:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int8_t i = get_tc_index(hw);
   13854:	4b51      	ldr	r3, [pc, #324]	; (1399c <_tc_timer_init+0x14c>)
{
   13856:	4607      	mov	r7, r0
	int8_t i = get_tc_index(hw);
   13858:	4608      	mov	r0, r1
{
   1385a:	460c      	mov	r4, r1
	int8_t i = get_tc_index(hw);
   1385c:	4798      	blx	r3
	ASSERT(ARRAY_SIZE(_tcs));
   1385e:	4b50      	ldr	r3, [pc, #320]	; (139a0 <_tc_timer_init+0x150>)
   13860:	4950      	ldr	r1, [pc, #320]	; (139a4 <_tc_timer_init+0x154>)
	device->hw = hw;
   13862:	60fc      	str	r4, [r7, #12]
	ASSERT(ARRAY_SIZE(_tcs));
   13864:	22a0      	movs	r2, #160	; 0xa0
	int8_t i = get_tc_index(hw);
   13866:	4606      	mov	r6, r0
	ASSERT(ARRAY_SIZE(_tcs));
   13868:	2001      	movs	r0, #1
   1386a:	4798      	blx	r3
	return ((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg;
   1386c:	6923      	ldr	r3, [r4, #16]
   1386e:	4a4e      	ldr	r2, [pc, #312]	; (139a8 <_tc_timer_init+0x158>)
	if (!hri_tc_is_syncing(hw, TC_SYNCBUSY_SWRST)) {
   13870:	f013 0f01 	tst.w	r3, #1
   13874:	d112      	bne.n	1389c <_tc_timer_init+0x4c>
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13876:	2103      	movs	r1, #3
   13878:	4620      	mov	r0, r4
   1387a:	4790      	blx	r2
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   1387c:	6823      	ldr	r3, [r4, #0]
		if (hri_tc_get_CTRLA_reg(hw, TC_CTRLA_ENABLE)) {
   1387e:	079b      	lsls	r3, r3, #30
   13880:	d507      	bpl.n	13892 <_tc_timer_init+0x42>
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   13882:	6823      	ldr	r3, [r4, #0]
   13884:	f023 0302 	bic.w	r3, r3, #2
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13888:	2103      	movs	r1, #3
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   1388a:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   1388c:	4790      	blx	r2
			hri_tc_wait_for_sync(hw, TC_SYNCBUSY_ENABLE);
   1388e:	2102      	movs	r1, #2
   13890:	4790      	blx	r2
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
   13892:	2301      	movs	r3, #1
   13894:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13896:	2103      	movs	r1, #3
   13898:	4620      	mov	r0, r4
   1389a:	4790      	blx	r2
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
   1389c:	f8df 9124 	ldr.w	r9, [pc, #292]	; 139c4 <_tc_timer_init+0x174>
   138a0:	2514      	movs	r5, #20
   138a2:	fb05 9506 	mla	r5, r5, r6, r9
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST);
   138a6:	2101      	movs	r1, #1
   138a8:	4620      	mov	r0, r4
   138aa:	4790      	blx	r2
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
   138ac:	f8d5 8024 	ldr.w	r8, [r5, #36]	; 0x24
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
   138b0:	f8c4 8000 	str.w	r8, [r4]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   138b4:	2103      	movs	r1, #3
   138b6:	4790      	blx	r2
	hri_tc_write_DBGCTRL_reg(hw, _tcs[i].dbg_ctrl);
   138b8:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
	((Tc *)hw)->COUNT16.DBGCTRL.reg = data;
   138bc:	73e3      	strb	r3, [r4, #15]
	hri_tc_write_EVCTRL_reg(hw, _tcs[i].event_ctrl);
   138be:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
	((Tc *)hw)->COUNT16.EVCTRL.reg = data;
   138c0:	80e3      	strh	r3, [r4, #6]
	((Tc *)hw)->COUNT16.WAVE.reg = data;
   138c2:	2301      	movs	r3, #1
   138c4:	7323      	strb	r3, [r4, #12]
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
   138c6:	f008 030c 	and.w	r3, r8, #12
   138ca:	2b08      	cmp	r3, #8
   138cc:	d13b      	bne.n	13946 <_tc_timer_init+0xf6>
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
   138ce:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
	((Tc *)hw)->COUNT32.CC[index].reg = data;
   138d0:	61e3      	str	r3, [r4, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   138d2:	21c0      	movs	r1, #192	; 0xc0
   138d4:	4790      	blx	r2
		hri_tccount32_write_CC_reg(hw, 1, _tcs[i].cc1);
   138d6:	6b2b      	ldr	r3, [r5, #48]	; 0x30
	((Tc *)hw)->COUNT32.CC[index].reg = data;
   138d8:	6223      	str	r3, [r4, #32]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   138da:	21c0      	movs	r1, #192	; 0xc0
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   138dc:	4620      	mov	r0, r4
   138de:	4790      	blx	r2
	((Tc *)hw)->COUNT16.INTENSET.reg = TC_INTENSET_OVF;
   138e0:	2301      	movs	r3, #1
   138e2:	7263      	strb	r3, [r4, #9]
	if (hw == TC0) {
   138e4:	4b31      	ldr	r3, [pc, #196]	; (139ac <_tc_timer_init+0x15c>)
   138e6:	429c      	cmp	r4, r3
   138e8:	d146      	bne.n	13978 <_tc_timer_init+0x128>
		_tc0_dev = (struct _timer_device *)dev;
   138ea:	4b31      	ldr	r3, [pc, #196]	; (139b0 <_tc_timer_init+0x160>)
   138ec:	601f      	str	r7, [r3, #0]
	NVIC_DisableIRQ(_tcs[i].irq);
   138ee:	2314      	movs	r3, #20
   138f0:	fb03 9306 	mla	r3, r3, r6, r9
   138f4:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
   138f8:	2b00      	cmp	r3, #0
   138fa:	db0d      	blt.n	13918 <_tc_timer_init+0xc8>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   138fc:	095a      	lsrs	r2, r3, #5
   138fe:	2101      	movs	r1, #1
   13900:	f003 031f 	and.w	r3, r3, #31
   13904:	fa01 f303 	lsl.w	r3, r1, r3
   13908:	3220      	adds	r2, #32
   1390a:	492a      	ldr	r1, [pc, #168]	; (139b4 <_tc_timer_init+0x164>)
   1390c:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   13910:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   13914:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(_tcs[i].irq);
   13918:	2014      	movs	r0, #20
   1391a:	fb00 9606 	mla	r6, r0, r6, r9
   1391e:	f9b6 3022 	ldrsh.w	r3, [r6, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
   13922:	2b00      	cmp	r3, #0
   13924:	db0c      	blt.n	13940 <_tc_timer_init+0xf0>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13926:	f003 011f 	and.w	r1, r3, #31
   1392a:	095b      	lsrs	r3, r3, #5
   1392c:	009b      	lsls	r3, r3, #2
   1392e:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   13932:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
   13936:	2201      	movs	r2, #1
   13938:	408a      	lsls	r2, r1
   1393a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1393e:	601a      	str	r2, [r3, #0]
}
   13940:	2000      	movs	r0, #0
   13942:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT16) {
   13946:	b933      	cbnz	r3, 13956 <_tc_timer_init+0x106>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)_tcs[i].cc0);
   13948:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
	((Tc *)hw)->COUNT16.CC[index].reg = data;
   1394a:	83a3      	strh	r3, [r4, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   1394c:	21c0      	movs	r1, #192	; 0xc0
   1394e:	4790      	blx	r2
		hri_tccount16_write_CC_reg(hw, 1, (uint16_t)_tcs[i].cc1);
   13950:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
	((Tc *)hw)->COUNT16.CC[index].reg = data;
   13952:	83e3      	strh	r3, [r4, #30]
   13954:	e7c1      	b.n	138da <_tc_timer_init+0x8a>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT8) {
   13956:	2b04      	cmp	r3, #4
   13958:	d1c2      	bne.n	138e0 <_tc_timer_init+0x90>
		hri_tccount8_write_CC_reg(hw, 0, (uint8_t)_tcs[i].cc0);
   1395a:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
	((Tc *)hw)->COUNT8.CC[index].reg = data;
   1395e:	7723      	strb	r3, [r4, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13960:	21c0      	movs	r1, #192	; 0xc0
   13962:	4790      	blx	r2
		hri_tccount8_write_CC_reg(hw, 1, (uint8_t)_tcs[i].cc1);
   13964:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
	((Tc *)hw)->COUNT8.CC[index].reg = data;
   13968:	7763      	strb	r3, [r4, #29]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   1396a:	21c0      	movs	r1, #192	; 0xc0
   1396c:	4790      	blx	r2
		hri_tccount8_write_PER_reg(hw, _tcs[i].per);
   1396e:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
	((Tc *)hw)->COUNT8.PER.reg = data;
   13972:	76e3      	strb	r3, [r4, #27]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   13974:	2120      	movs	r1, #32
   13976:	e7b1      	b.n	138dc <_tc_timer_init+0x8c>
	if (hw == TC1) {
   13978:	4b0f      	ldr	r3, [pc, #60]	; (139b8 <_tc_timer_init+0x168>)
   1397a:	429c      	cmp	r4, r3
   1397c:	d008      	beq.n	13990 <_tc_timer_init+0x140>
	if (hw == TC2) {
   1397e:	4b0f      	ldr	r3, [pc, #60]	; (139bc <_tc_timer_init+0x16c>)
   13980:	429c      	cmp	r4, r3
   13982:	d008      	beq.n	13996 <_tc_timer_init+0x146>
	if (hw == TC3) {
   13984:	4b0e      	ldr	r3, [pc, #56]	; (139c0 <_tc_timer_init+0x170>)
   13986:	429c      	cmp	r4, r3
   13988:	d1b1      	bne.n	138ee <_tc_timer_init+0x9e>
		_tc3_dev = (struct _timer_device *)dev;
   1398a:	4b09      	ldr	r3, [pc, #36]	; (139b0 <_tc_timer_init+0x160>)
   1398c:	60df      	str	r7, [r3, #12]
   1398e:	e7ae      	b.n	138ee <_tc_timer_init+0x9e>
		_tc1_dev = (struct _timer_device *)dev;
   13990:	4b07      	ldr	r3, [pc, #28]	; (139b0 <_tc_timer_init+0x160>)
   13992:	605f      	str	r7, [r3, #4]
	if (hw == TC3) {
   13994:	e7ab      	b.n	138ee <_tc_timer_init+0x9e>
		_tc2_dev = (struct _timer_device *)dev;
   13996:	4b06      	ldr	r3, [pc, #24]	; (139b0 <_tc_timer_init+0x160>)
   13998:	609f      	str	r7, [r3, #8]
	if (hw == TC3) {
   1399a:	e7a8      	b.n	138ee <_tc_timer_init+0x9e>
   1399c:	0001371d 	.word	0x0001371d
   139a0:	0000e03d 	.word	0x0000e03d
   139a4:	00016832 	.word	0x00016832
   139a8:	00013689 	.word	0x00013689
   139ac:	40003800 	.word	0x40003800
   139b0:	20009128 	.word	0x20009128
   139b4:	e000e100 	.word	0xe000e100
   139b8:	40003c00 	.word	0x40003c00
   139bc:	4101a000 	.word	0x4101a000
   139c0:	4101c000 	.word	0x4101c000
   139c4:	00016848 	.word	0x00016848

000139c8 <_tc_timer_set_period>:
	void *const hw = device->hw;
   139c8:	68c0      	ldr	r0, [r0, #12]
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   139ca:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   139cc:	f3c3 0381 	ubfx	r3, r3, #2, #2
	if (TC_CTRLA_MODE_COUNT32_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   139d0:	2b02      	cmp	r3, #2
   139d2:	d103      	bne.n	139dc <_tc_timer_set_period+0x14>
	((Tc *)hw)->COUNT32.CC[index].reg = data;
   139d4:	61c1      	str	r1, [r0, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   139d6:	21c0      	movs	r1, #192	; 0xc0
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   139d8:	4b09      	ldr	r3, [pc, #36]	; (13a00 <_tc_timer_set_period+0x38>)
   139da:	4718      	bx	r3
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   139dc:	6803      	ldr	r3, [r0, #0]
	} else if (TC_CTRLA_MODE_COUNT16_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   139de:	f013 0f0c 	tst.w	r3, #12
   139e2:	d102      	bne.n	139ea <_tc_timer_set_period+0x22>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)clock_cycles);
   139e4:	b289      	uxth	r1, r1
	((Tc *)hw)->COUNT16.CC[index].reg = data;
   139e6:	8381      	strh	r1, [r0, #28]
   139e8:	e7f5      	b.n	139d6 <_tc_timer_set_period+0xe>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   139ea:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   139ec:	f3c3 0381 	ubfx	r3, r3, #2, #2
	} else if (TC_CTRLA_MODE_COUNT8_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   139f0:	2b01      	cmp	r3, #1
   139f2:	d103      	bne.n	139fc <_tc_timer_set_period+0x34>
		hri_tccount8_write_PER_reg(hw, clock_cycles);
   139f4:	b2c9      	uxtb	r1, r1
	((Tc *)hw)->COUNT8.PER.reg = data;
   139f6:	76c1      	strb	r1, [r0, #27]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   139f8:	2120      	movs	r1, #32
   139fa:	e7ed      	b.n	139d8 <_tc_timer_set_period+0x10>
}
   139fc:	4770      	bx	lr
   139fe:	bf00      	nop
   13a00:	00013689 	.word	0x00013689

00013a04 <_tc_get_timer>:
}
   13a04:	4800      	ldr	r0, [pc, #0]	; (13a08 <_tc_get_timer+0x4>)
   13a06:	4770      	bx	lr
   13a08:	2000052c 	.word	0x2000052c

00013a0c <TC0_Handler>:
	tc_interrupt_handler(_tc0_dev);
   13a0c:	4b01      	ldr	r3, [pc, #4]	; (13a14 <TC0_Handler+0x8>)
   13a0e:	6818      	ldr	r0, [r3, #0]
   13a10:	4b01      	ldr	r3, [pc, #4]	; (13a18 <TC0_Handler+0xc>)
   13a12:	4718      	bx	r3
   13a14:	20009128 	.word	0x20009128
   13a18:	00013709 	.word	0x00013709

00013a1c <TC1_Handler>:
	tc_interrupt_handler(_tc1_dev);
   13a1c:	4b01      	ldr	r3, [pc, #4]	; (13a24 <TC1_Handler+0x8>)
   13a1e:	6858      	ldr	r0, [r3, #4]
   13a20:	4b01      	ldr	r3, [pc, #4]	; (13a28 <TC1_Handler+0xc>)
   13a22:	4718      	bx	r3
   13a24:	20009128 	.word	0x20009128
   13a28:	00013709 	.word	0x00013709

00013a2c <TC2_Handler>:
	tc_interrupt_handler(_tc2_dev);
   13a2c:	4b01      	ldr	r3, [pc, #4]	; (13a34 <TC2_Handler+0x8>)
   13a2e:	6898      	ldr	r0, [r3, #8]
   13a30:	4b01      	ldr	r3, [pc, #4]	; (13a38 <TC2_Handler+0xc>)
   13a32:	4718      	bx	r3
   13a34:	20009128 	.word	0x20009128
   13a38:	00013709 	.word	0x00013709

00013a3c <TC3_Handler>:
	tc_interrupt_handler(_tc3_dev);
   13a3c:	4b01      	ldr	r3, [pc, #4]	; (13a44 <TC3_Handler+0x8>)
   13a3e:	68d8      	ldr	r0, [r3, #12]
   13a40:	4b01      	ldr	r3, [pc, #4]	; (13a48 <TC3_Handler+0xc>)
   13a42:	4718      	bx	r3
   13a44:	20009128 	.word	0x20009128
   13a48:	00013709 	.word	0x00013709

00013a4c <_delay_init>:
   13a4c:	4b03      	ldr	r3, [pc, #12]	; (13a5c <_delay_init+0x10>)
   13a4e:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
   13a52:	605a      	str	r2, [r3, #4]
   13a54:	2205      	movs	r2, #5
   13a56:	601a      	str	r2, [r3, #0]
   13a58:	4770      	bx	lr
   13a5a:	bf00      	nop
   13a5c:	e000e010 	.word	0xe000e010

00013a60 <_delay_cycles>:
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
	(void)hw;
	uint8_t  n   = cycles >> 24;
   13a60:	0e0b      	lsrs	r3, r1, #24
   13a62:	4a0c      	ldr	r2, [pc, #48]	; (13a94 <_delay_cycles+0x34>)
{
   13a64:	b530      	push	{r4, r5, lr}
	uint8_t  n   = cycles >> 24;
   13a66:	4618      	mov	r0, r3
	uint32_t buf = cycles;

	while (n--) {
		SysTick->LOAD = 0xFFFFFF;
   13a68:	f06f 447f 	mvn.w	r4, #4278190080	; 0xff000000
	while (n--) {
   13a6c:	3801      	subs	r0, #1
   13a6e:	b2c0      	uxtb	r0, r0
   13a70:	28ff      	cmp	r0, #255	; 0xff
   13a72:	d108      	bne.n	13a86 <_delay_cycles+0x26>
   13a74:	eba3 6303 	sub.w	r3, r3, r3, lsl #24
   13a78:	4419      	add	r1, r3
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
			;
		buf -= 0xFFFFFF;
	}

	SysTick->LOAD = buf;
   13a7a:	6051      	str	r1, [r2, #4]
	SysTick->VAL  = buf;
   13a7c:	6091      	str	r1, [r2, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
   13a7e:	6813      	ldr	r3, [r2, #0]
   13a80:	03db      	lsls	r3, r3, #15
   13a82:	d5fc      	bpl.n	13a7e <_delay_cycles+0x1e>
		;
}
   13a84:	bd30      	pop	{r4, r5, pc}
		SysTick->LOAD = 0xFFFFFF;
   13a86:	6054      	str	r4, [r2, #4]
		SysTick->VAL  = 0xFFFFFF;
   13a88:	6094      	str	r4, [r2, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
   13a8a:	6815      	ldr	r5, [r2, #0]
   13a8c:	03ed      	lsls	r5, r5, #15
   13a8e:	d5fc      	bpl.n	13a8a <_delay_cycles+0x2a>
   13a90:	e7ec      	b.n	13a6c <_delay_cycles+0xc>
   13a92:	bf00      	nop
   13a94:	e000e010 	.word	0xe000e010

00013a98 <_crc_sync_init>:
/**
 * \brief Initialize CRC.
 */
int32_t _crc_sync_init(struct _crc_sync_device *const device, void *const hw)
{
	device->hw = hw;
   13a98:	6001      	str	r1, [r0, #0]

	return ERR_NONE;
}
   13a9a:	2000      	movs	r0, #0
   13a9c:	4770      	bx	lr
	...

00013aa0 <__aeabi_drsub>:
   13aa0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   13aa4:	e002      	b.n	13aac <__adddf3>
   13aa6:	bf00      	nop

00013aa8 <__aeabi_dsub>:
   13aa8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00013aac <__adddf3>:
   13aac:	b530      	push	{r4, r5, lr}
   13aae:	ea4f 0441 	mov.w	r4, r1, lsl #1
   13ab2:	ea4f 0543 	mov.w	r5, r3, lsl #1
   13ab6:	ea94 0f05 	teq	r4, r5
   13aba:	bf08      	it	eq
   13abc:	ea90 0f02 	teqeq	r0, r2
   13ac0:	bf1f      	itttt	ne
   13ac2:	ea54 0c00 	orrsne.w	ip, r4, r0
   13ac6:	ea55 0c02 	orrsne.w	ip, r5, r2
   13aca:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   13ace:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   13ad2:	f000 80e2 	beq.w	13c9a <__adddf3+0x1ee>
   13ad6:	ea4f 5454 	mov.w	r4, r4, lsr #21
   13ada:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   13ade:	bfb8      	it	lt
   13ae0:	426d      	neglt	r5, r5
   13ae2:	dd0c      	ble.n	13afe <__adddf3+0x52>
   13ae4:	442c      	add	r4, r5
   13ae6:	ea80 0202 	eor.w	r2, r0, r2
   13aea:	ea81 0303 	eor.w	r3, r1, r3
   13aee:	ea82 0000 	eor.w	r0, r2, r0
   13af2:	ea83 0101 	eor.w	r1, r3, r1
   13af6:	ea80 0202 	eor.w	r2, r0, r2
   13afa:	ea81 0303 	eor.w	r3, r1, r3
   13afe:	2d36      	cmp	r5, #54	; 0x36
   13b00:	bf88      	it	hi
   13b02:	bd30      	pophi	{r4, r5, pc}
   13b04:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   13b08:	ea4f 3101 	mov.w	r1, r1, lsl #12
   13b0c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   13b10:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   13b14:	d002      	beq.n	13b1c <__adddf3+0x70>
   13b16:	4240      	negs	r0, r0
   13b18:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   13b1c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   13b20:	ea4f 3303 	mov.w	r3, r3, lsl #12
   13b24:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   13b28:	d002      	beq.n	13b30 <__adddf3+0x84>
   13b2a:	4252      	negs	r2, r2
   13b2c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   13b30:	ea94 0f05 	teq	r4, r5
   13b34:	f000 80a7 	beq.w	13c86 <__adddf3+0x1da>
   13b38:	f1a4 0401 	sub.w	r4, r4, #1
   13b3c:	f1d5 0e20 	rsbs	lr, r5, #32
   13b40:	db0d      	blt.n	13b5e <__adddf3+0xb2>
   13b42:	fa02 fc0e 	lsl.w	ip, r2, lr
   13b46:	fa22 f205 	lsr.w	r2, r2, r5
   13b4a:	1880      	adds	r0, r0, r2
   13b4c:	f141 0100 	adc.w	r1, r1, #0
   13b50:	fa03 f20e 	lsl.w	r2, r3, lr
   13b54:	1880      	adds	r0, r0, r2
   13b56:	fa43 f305 	asr.w	r3, r3, r5
   13b5a:	4159      	adcs	r1, r3
   13b5c:	e00e      	b.n	13b7c <__adddf3+0xd0>
   13b5e:	f1a5 0520 	sub.w	r5, r5, #32
   13b62:	f10e 0e20 	add.w	lr, lr, #32
   13b66:	2a01      	cmp	r2, #1
   13b68:	fa03 fc0e 	lsl.w	ip, r3, lr
   13b6c:	bf28      	it	cs
   13b6e:	f04c 0c02 	orrcs.w	ip, ip, #2
   13b72:	fa43 f305 	asr.w	r3, r3, r5
   13b76:	18c0      	adds	r0, r0, r3
   13b78:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   13b7c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   13b80:	d507      	bpl.n	13b92 <__adddf3+0xe6>
   13b82:	f04f 0e00 	mov.w	lr, #0
   13b86:	f1dc 0c00 	rsbs	ip, ip, #0
   13b8a:	eb7e 0000 	sbcs.w	r0, lr, r0
   13b8e:	eb6e 0101 	sbc.w	r1, lr, r1
   13b92:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   13b96:	d31b      	bcc.n	13bd0 <__adddf3+0x124>
   13b98:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   13b9c:	d30c      	bcc.n	13bb8 <__adddf3+0x10c>
   13b9e:	0849      	lsrs	r1, r1, #1
   13ba0:	ea5f 0030 	movs.w	r0, r0, rrx
   13ba4:	ea4f 0c3c 	mov.w	ip, ip, rrx
   13ba8:	f104 0401 	add.w	r4, r4, #1
   13bac:	ea4f 5244 	mov.w	r2, r4, lsl #21
   13bb0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   13bb4:	f080 809a 	bcs.w	13cec <__adddf3+0x240>
   13bb8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   13bbc:	bf08      	it	eq
   13bbe:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   13bc2:	f150 0000 	adcs.w	r0, r0, #0
   13bc6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   13bca:	ea41 0105 	orr.w	r1, r1, r5
   13bce:	bd30      	pop	{r4, r5, pc}
   13bd0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   13bd4:	4140      	adcs	r0, r0
   13bd6:	eb41 0101 	adc.w	r1, r1, r1
   13bda:	3c01      	subs	r4, #1
   13bdc:	bf28      	it	cs
   13bde:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
   13be2:	d2e9      	bcs.n	13bb8 <__adddf3+0x10c>
   13be4:	f091 0f00 	teq	r1, #0
   13be8:	bf04      	itt	eq
   13bea:	4601      	moveq	r1, r0
   13bec:	2000      	moveq	r0, #0
   13bee:	fab1 f381 	clz	r3, r1
   13bf2:	bf08      	it	eq
   13bf4:	3320      	addeq	r3, #32
   13bf6:	f1a3 030b 	sub.w	r3, r3, #11
   13bfa:	f1b3 0220 	subs.w	r2, r3, #32
   13bfe:	da0c      	bge.n	13c1a <__adddf3+0x16e>
   13c00:	320c      	adds	r2, #12
   13c02:	dd08      	ble.n	13c16 <__adddf3+0x16a>
   13c04:	f102 0c14 	add.w	ip, r2, #20
   13c08:	f1c2 020c 	rsb	r2, r2, #12
   13c0c:	fa01 f00c 	lsl.w	r0, r1, ip
   13c10:	fa21 f102 	lsr.w	r1, r1, r2
   13c14:	e00c      	b.n	13c30 <__adddf3+0x184>
   13c16:	f102 0214 	add.w	r2, r2, #20
   13c1a:	bfd8      	it	le
   13c1c:	f1c2 0c20 	rsble	ip, r2, #32
   13c20:	fa01 f102 	lsl.w	r1, r1, r2
   13c24:	fa20 fc0c 	lsr.w	ip, r0, ip
   13c28:	bfdc      	itt	le
   13c2a:	ea41 010c 	orrle.w	r1, r1, ip
   13c2e:	4090      	lslle	r0, r2
   13c30:	1ae4      	subs	r4, r4, r3
   13c32:	bfa2      	ittt	ge
   13c34:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   13c38:	4329      	orrge	r1, r5
   13c3a:	bd30      	popge	{r4, r5, pc}
   13c3c:	ea6f 0404 	mvn.w	r4, r4
   13c40:	3c1f      	subs	r4, #31
   13c42:	da1c      	bge.n	13c7e <__adddf3+0x1d2>
   13c44:	340c      	adds	r4, #12
   13c46:	dc0e      	bgt.n	13c66 <__adddf3+0x1ba>
   13c48:	f104 0414 	add.w	r4, r4, #20
   13c4c:	f1c4 0220 	rsb	r2, r4, #32
   13c50:	fa20 f004 	lsr.w	r0, r0, r4
   13c54:	fa01 f302 	lsl.w	r3, r1, r2
   13c58:	ea40 0003 	orr.w	r0, r0, r3
   13c5c:	fa21 f304 	lsr.w	r3, r1, r4
   13c60:	ea45 0103 	orr.w	r1, r5, r3
   13c64:	bd30      	pop	{r4, r5, pc}
   13c66:	f1c4 040c 	rsb	r4, r4, #12
   13c6a:	f1c4 0220 	rsb	r2, r4, #32
   13c6e:	fa20 f002 	lsr.w	r0, r0, r2
   13c72:	fa01 f304 	lsl.w	r3, r1, r4
   13c76:	ea40 0003 	orr.w	r0, r0, r3
   13c7a:	4629      	mov	r1, r5
   13c7c:	bd30      	pop	{r4, r5, pc}
   13c7e:	fa21 f004 	lsr.w	r0, r1, r4
   13c82:	4629      	mov	r1, r5
   13c84:	bd30      	pop	{r4, r5, pc}
   13c86:	f094 0f00 	teq	r4, #0
   13c8a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   13c8e:	bf06      	itte	eq
   13c90:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   13c94:	3401      	addeq	r4, #1
   13c96:	3d01      	subne	r5, #1
   13c98:	e74e      	b.n	13b38 <__adddf3+0x8c>
   13c9a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   13c9e:	bf18      	it	ne
   13ca0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   13ca4:	d029      	beq.n	13cfa <__adddf3+0x24e>
   13ca6:	ea94 0f05 	teq	r4, r5
   13caa:	bf08      	it	eq
   13cac:	ea90 0f02 	teqeq	r0, r2
   13cb0:	d005      	beq.n	13cbe <__adddf3+0x212>
   13cb2:	ea54 0c00 	orrs.w	ip, r4, r0
   13cb6:	bf04      	itt	eq
   13cb8:	4619      	moveq	r1, r3
   13cba:	4610      	moveq	r0, r2
   13cbc:	bd30      	pop	{r4, r5, pc}
   13cbe:	ea91 0f03 	teq	r1, r3
   13cc2:	bf1e      	ittt	ne
   13cc4:	2100      	movne	r1, #0
   13cc6:	2000      	movne	r0, #0
   13cc8:	bd30      	popne	{r4, r5, pc}
   13cca:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   13cce:	d105      	bne.n	13cdc <__adddf3+0x230>
   13cd0:	0040      	lsls	r0, r0, #1
   13cd2:	4149      	adcs	r1, r1
   13cd4:	bf28      	it	cs
   13cd6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   13cda:	bd30      	pop	{r4, r5, pc}
   13cdc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   13ce0:	bf3c      	itt	cc
   13ce2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   13ce6:	bd30      	popcc	{r4, r5, pc}
   13ce8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   13cec:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   13cf0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   13cf4:	f04f 0000 	mov.w	r0, #0
   13cf8:	bd30      	pop	{r4, r5, pc}
   13cfa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   13cfe:	bf1a      	itte	ne
   13d00:	4619      	movne	r1, r3
   13d02:	4610      	movne	r0, r2
   13d04:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   13d08:	bf1c      	itt	ne
   13d0a:	460b      	movne	r3, r1
   13d0c:	4602      	movne	r2, r0
   13d0e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   13d12:	bf06      	itte	eq
   13d14:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   13d18:	ea91 0f03 	teqeq	r1, r3
   13d1c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   13d20:	bd30      	pop	{r4, r5, pc}
   13d22:	bf00      	nop

00013d24 <__aeabi_ui2d>:
   13d24:	f090 0f00 	teq	r0, #0
   13d28:	bf04      	itt	eq
   13d2a:	2100      	moveq	r1, #0
   13d2c:	4770      	bxeq	lr
   13d2e:	b530      	push	{r4, r5, lr}
   13d30:	f44f 6480 	mov.w	r4, #1024	; 0x400
   13d34:	f104 0432 	add.w	r4, r4, #50	; 0x32
   13d38:	f04f 0500 	mov.w	r5, #0
   13d3c:	f04f 0100 	mov.w	r1, #0
   13d40:	e750      	b.n	13be4 <__adddf3+0x138>
   13d42:	bf00      	nop

00013d44 <__aeabi_i2d>:
   13d44:	f090 0f00 	teq	r0, #0
   13d48:	bf04      	itt	eq
   13d4a:	2100      	moveq	r1, #0
   13d4c:	4770      	bxeq	lr
   13d4e:	b530      	push	{r4, r5, lr}
   13d50:	f44f 6480 	mov.w	r4, #1024	; 0x400
   13d54:	f104 0432 	add.w	r4, r4, #50	; 0x32
   13d58:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   13d5c:	bf48      	it	mi
   13d5e:	4240      	negmi	r0, r0
   13d60:	f04f 0100 	mov.w	r1, #0
   13d64:	e73e      	b.n	13be4 <__adddf3+0x138>
   13d66:	bf00      	nop

00013d68 <__aeabi_f2d>:
   13d68:	0042      	lsls	r2, r0, #1
   13d6a:	ea4f 01e2 	mov.w	r1, r2, asr #3
   13d6e:	ea4f 0131 	mov.w	r1, r1, rrx
   13d72:	ea4f 7002 	mov.w	r0, r2, lsl #28
   13d76:	bf1f      	itttt	ne
   13d78:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   13d7c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   13d80:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   13d84:	4770      	bxne	lr
   13d86:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   13d8a:	bf08      	it	eq
   13d8c:	4770      	bxeq	lr
   13d8e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
   13d92:	bf04      	itt	eq
   13d94:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
   13d98:	4770      	bxeq	lr
   13d9a:	b530      	push	{r4, r5, lr}
   13d9c:	f44f 7460 	mov.w	r4, #896	; 0x380
   13da0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   13da4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   13da8:	e71c      	b.n	13be4 <__adddf3+0x138>
   13daa:	bf00      	nop

00013dac <__aeabi_ul2d>:
   13dac:	ea50 0201 	orrs.w	r2, r0, r1
   13db0:	bf08      	it	eq
   13db2:	4770      	bxeq	lr
   13db4:	b530      	push	{r4, r5, lr}
   13db6:	f04f 0500 	mov.w	r5, #0
   13dba:	e00a      	b.n	13dd2 <__aeabi_l2d+0x16>

00013dbc <__aeabi_l2d>:
   13dbc:	ea50 0201 	orrs.w	r2, r0, r1
   13dc0:	bf08      	it	eq
   13dc2:	4770      	bxeq	lr
   13dc4:	b530      	push	{r4, r5, lr}
   13dc6:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   13dca:	d502      	bpl.n	13dd2 <__aeabi_l2d+0x16>
   13dcc:	4240      	negs	r0, r0
   13dce:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   13dd2:	f44f 6480 	mov.w	r4, #1024	; 0x400
   13dd6:	f104 0432 	add.w	r4, r4, #50	; 0x32
   13dda:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   13dde:	f43f aed8 	beq.w	13b92 <__adddf3+0xe6>
   13de2:	f04f 0203 	mov.w	r2, #3
   13de6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   13dea:	bf18      	it	ne
   13dec:	3203      	addne	r2, #3
   13dee:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   13df2:	bf18      	it	ne
   13df4:	3203      	addne	r2, #3
   13df6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   13dfa:	f1c2 0320 	rsb	r3, r2, #32
   13dfe:	fa00 fc03 	lsl.w	ip, r0, r3
   13e02:	fa20 f002 	lsr.w	r0, r0, r2
   13e06:	fa01 fe03 	lsl.w	lr, r1, r3
   13e0a:	ea40 000e 	orr.w	r0, r0, lr
   13e0e:	fa21 f102 	lsr.w	r1, r1, r2
   13e12:	4414      	add	r4, r2
   13e14:	e6bd      	b.n	13b92 <__adddf3+0xe6>
   13e16:	bf00      	nop

00013e18 <__aeabi_dmul>:
   13e18:	b570      	push	{r4, r5, r6, lr}
   13e1a:	f04f 0cff 	mov.w	ip, #255	; 0xff
   13e1e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   13e22:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   13e26:	bf1d      	ittte	ne
   13e28:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   13e2c:	ea94 0f0c 	teqne	r4, ip
   13e30:	ea95 0f0c 	teqne	r5, ip
   13e34:	f000 f8de 	bleq	13ff4 <__aeabi_dmul+0x1dc>
   13e38:	442c      	add	r4, r5
   13e3a:	ea81 0603 	eor.w	r6, r1, r3
   13e3e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   13e42:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   13e46:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   13e4a:	bf18      	it	ne
   13e4c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   13e50:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   13e54:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   13e58:	d038      	beq.n	13ecc <__aeabi_dmul+0xb4>
   13e5a:	fba0 ce02 	umull	ip, lr, r0, r2
   13e5e:	f04f 0500 	mov.w	r5, #0
   13e62:	fbe1 e502 	umlal	lr, r5, r1, r2
   13e66:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   13e6a:	fbe0 e503 	umlal	lr, r5, r0, r3
   13e6e:	f04f 0600 	mov.w	r6, #0
   13e72:	fbe1 5603 	umlal	r5, r6, r1, r3
   13e76:	f09c 0f00 	teq	ip, #0
   13e7a:	bf18      	it	ne
   13e7c:	f04e 0e01 	orrne.w	lr, lr, #1
   13e80:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   13e84:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   13e88:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   13e8c:	d204      	bcs.n	13e98 <__aeabi_dmul+0x80>
   13e8e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   13e92:	416d      	adcs	r5, r5
   13e94:	eb46 0606 	adc.w	r6, r6, r6
   13e98:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   13e9c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   13ea0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   13ea4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   13ea8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   13eac:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   13eb0:	bf88      	it	hi
   13eb2:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   13eb6:	d81e      	bhi.n	13ef6 <__aeabi_dmul+0xde>
   13eb8:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   13ebc:	bf08      	it	eq
   13ebe:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   13ec2:	f150 0000 	adcs.w	r0, r0, #0
   13ec6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   13eca:	bd70      	pop	{r4, r5, r6, pc}
   13ecc:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   13ed0:	ea46 0101 	orr.w	r1, r6, r1
   13ed4:	ea40 0002 	orr.w	r0, r0, r2
   13ed8:	ea81 0103 	eor.w	r1, r1, r3
   13edc:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   13ee0:	bfc2      	ittt	gt
   13ee2:	ebd4 050c 	rsbsgt	r5, r4, ip
   13ee6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   13eea:	bd70      	popgt	{r4, r5, r6, pc}
   13eec:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   13ef0:	f04f 0e00 	mov.w	lr, #0
   13ef4:	3c01      	subs	r4, #1
   13ef6:	f300 80ab 	bgt.w	14050 <__aeabi_dmul+0x238>
   13efa:	f114 0f36 	cmn.w	r4, #54	; 0x36
   13efe:	bfde      	ittt	le
   13f00:	2000      	movle	r0, #0
   13f02:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   13f06:	bd70      	pople	{r4, r5, r6, pc}
   13f08:	f1c4 0400 	rsb	r4, r4, #0
   13f0c:	3c20      	subs	r4, #32
   13f0e:	da35      	bge.n	13f7c <__aeabi_dmul+0x164>
   13f10:	340c      	adds	r4, #12
   13f12:	dc1b      	bgt.n	13f4c <__aeabi_dmul+0x134>
   13f14:	f104 0414 	add.w	r4, r4, #20
   13f18:	f1c4 0520 	rsb	r5, r4, #32
   13f1c:	fa00 f305 	lsl.w	r3, r0, r5
   13f20:	fa20 f004 	lsr.w	r0, r0, r4
   13f24:	fa01 f205 	lsl.w	r2, r1, r5
   13f28:	ea40 0002 	orr.w	r0, r0, r2
   13f2c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   13f30:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   13f34:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   13f38:	fa21 f604 	lsr.w	r6, r1, r4
   13f3c:	eb42 0106 	adc.w	r1, r2, r6
   13f40:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   13f44:	bf08      	it	eq
   13f46:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   13f4a:	bd70      	pop	{r4, r5, r6, pc}
   13f4c:	f1c4 040c 	rsb	r4, r4, #12
   13f50:	f1c4 0520 	rsb	r5, r4, #32
   13f54:	fa00 f304 	lsl.w	r3, r0, r4
   13f58:	fa20 f005 	lsr.w	r0, r0, r5
   13f5c:	fa01 f204 	lsl.w	r2, r1, r4
   13f60:	ea40 0002 	orr.w	r0, r0, r2
   13f64:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   13f68:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   13f6c:	f141 0100 	adc.w	r1, r1, #0
   13f70:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   13f74:	bf08      	it	eq
   13f76:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   13f7a:	bd70      	pop	{r4, r5, r6, pc}
   13f7c:	f1c4 0520 	rsb	r5, r4, #32
   13f80:	fa00 f205 	lsl.w	r2, r0, r5
   13f84:	ea4e 0e02 	orr.w	lr, lr, r2
   13f88:	fa20 f304 	lsr.w	r3, r0, r4
   13f8c:	fa01 f205 	lsl.w	r2, r1, r5
   13f90:	ea43 0302 	orr.w	r3, r3, r2
   13f94:	fa21 f004 	lsr.w	r0, r1, r4
   13f98:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   13f9c:	fa21 f204 	lsr.w	r2, r1, r4
   13fa0:	ea20 0002 	bic.w	r0, r0, r2
   13fa4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   13fa8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   13fac:	bf08      	it	eq
   13fae:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   13fb2:	bd70      	pop	{r4, r5, r6, pc}
   13fb4:	f094 0f00 	teq	r4, #0
   13fb8:	d10f      	bne.n	13fda <__aeabi_dmul+0x1c2>
   13fba:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   13fbe:	0040      	lsls	r0, r0, #1
   13fc0:	eb41 0101 	adc.w	r1, r1, r1
   13fc4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   13fc8:	bf08      	it	eq
   13fca:	3c01      	subeq	r4, #1
   13fcc:	d0f7      	beq.n	13fbe <__aeabi_dmul+0x1a6>
   13fce:	ea41 0106 	orr.w	r1, r1, r6
   13fd2:	f095 0f00 	teq	r5, #0
   13fd6:	bf18      	it	ne
   13fd8:	4770      	bxne	lr
   13fda:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   13fde:	0052      	lsls	r2, r2, #1
   13fe0:	eb43 0303 	adc.w	r3, r3, r3
   13fe4:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   13fe8:	bf08      	it	eq
   13fea:	3d01      	subeq	r5, #1
   13fec:	d0f7      	beq.n	13fde <__aeabi_dmul+0x1c6>
   13fee:	ea43 0306 	orr.w	r3, r3, r6
   13ff2:	4770      	bx	lr
   13ff4:	ea94 0f0c 	teq	r4, ip
   13ff8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   13ffc:	bf18      	it	ne
   13ffe:	ea95 0f0c 	teqne	r5, ip
   14002:	d00c      	beq.n	1401e <__aeabi_dmul+0x206>
   14004:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   14008:	bf18      	it	ne
   1400a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   1400e:	d1d1      	bne.n	13fb4 <__aeabi_dmul+0x19c>
   14010:	ea81 0103 	eor.w	r1, r1, r3
   14014:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   14018:	f04f 0000 	mov.w	r0, #0
   1401c:	bd70      	pop	{r4, r5, r6, pc}
   1401e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   14022:	bf06      	itte	eq
   14024:	4610      	moveq	r0, r2
   14026:	4619      	moveq	r1, r3
   14028:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   1402c:	d019      	beq.n	14062 <__aeabi_dmul+0x24a>
   1402e:	ea94 0f0c 	teq	r4, ip
   14032:	d102      	bne.n	1403a <__aeabi_dmul+0x222>
   14034:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   14038:	d113      	bne.n	14062 <__aeabi_dmul+0x24a>
   1403a:	ea95 0f0c 	teq	r5, ip
   1403e:	d105      	bne.n	1404c <__aeabi_dmul+0x234>
   14040:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   14044:	bf1c      	itt	ne
   14046:	4610      	movne	r0, r2
   14048:	4619      	movne	r1, r3
   1404a:	d10a      	bne.n	14062 <__aeabi_dmul+0x24a>
   1404c:	ea81 0103 	eor.w	r1, r1, r3
   14050:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   14054:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   14058:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   1405c:	f04f 0000 	mov.w	r0, #0
   14060:	bd70      	pop	{r4, r5, r6, pc}
   14062:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   14066:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   1406a:	bd70      	pop	{r4, r5, r6, pc}

0001406c <__aeabi_ddiv>:
   1406c:	b570      	push	{r4, r5, r6, lr}
   1406e:	f04f 0cff 	mov.w	ip, #255	; 0xff
   14072:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   14076:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   1407a:	bf1d      	ittte	ne
   1407c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   14080:	ea94 0f0c 	teqne	r4, ip
   14084:	ea95 0f0c 	teqne	r5, ip
   14088:	f000 f8a7 	bleq	141da <__aeabi_ddiv+0x16e>
   1408c:	eba4 0405 	sub.w	r4, r4, r5
   14090:	ea81 0e03 	eor.w	lr, r1, r3
   14094:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   14098:	ea4f 3101 	mov.w	r1, r1, lsl #12
   1409c:	f000 8088 	beq.w	141b0 <__aeabi_ddiv+0x144>
   140a0:	ea4f 3303 	mov.w	r3, r3, lsl #12
   140a4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   140a8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   140ac:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   140b0:	ea4f 2202 	mov.w	r2, r2, lsl #8
   140b4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   140b8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   140bc:	ea4f 2600 	mov.w	r6, r0, lsl #8
   140c0:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   140c4:	429d      	cmp	r5, r3
   140c6:	bf08      	it	eq
   140c8:	4296      	cmpeq	r6, r2
   140ca:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   140ce:	f504 7440 	add.w	r4, r4, #768	; 0x300
   140d2:	d202      	bcs.n	140da <__aeabi_ddiv+0x6e>
   140d4:	085b      	lsrs	r3, r3, #1
   140d6:	ea4f 0232 	mov.w	r2, r2, rrx
   140da:	1ab6      	subs	r6, r6, r2
   140dc:	eb65 0503 	sbc.w	r5, r5, r3
   140e0:	085b      	lsrs	r3, r3, #1
   140e2:	ea4f 0232 	mov.w	r2, r2, rrx
   140e6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   140ea:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   140ee:	ebb6 0e02 	subs.w	lr, r6, r2
   140f2:	eb75 0e03 	sbcs.w	lr, r5, r3
   140f6:	bf22      	ittt	cs
   140f8:	1ab6      	subcs	r6, r6, r2
   140fa:	4675      	movcs	r5, lr
   140fc:	ea40 000c 	orrcs.w	r0, r0, ip
   14100:	085b      	lsrs	r3, r3, #1
   14102:	ea4f 0232 	mov.w	r2, r2, rrx
   14106:	ebb6 0e02 	subs.w	lr, r6, r2
   1410a:	eb75 0e03 	sbcs.w	lr, r5, r3
   1410e:	bf22      	ittt	cs
   14110:	1ab6      	subcs	r6, r6, r2
   14112:	4675      	movcs	r5, lr
   14114:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   14118:	085b      	lsrs	r3, r3, #1
   1411a:	ea4f 0232 	mov.w	r2, r2, rrx
   1411e:	ebb6 0e02 	subs.w	lr, r6, r2
   14122:	eb75 0e03 	sbcs.w	lr, r5, r3
   14126:	bf22      	ittt	cs
   14128:	1ab6      	subcs	r6, r6, r2
   1412a:	4675      	movcs	r5, lr
   1412c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   14130:	085b      	lsrs	r3, r3, #1
   14132:	ea4f 0232 	mov.w	r2, r2, rrx
   14136:	ebb6 0e02 	subs.w	lr, r6, r2
   1413a:	eb75 0e03 	sbcs.w	lr, r5, r3
   1413e:	bf22      	ittt	cs
   14140:	1ab6      	subcs	r6, r6, r2
   14142:	4675      	movcs	r5, lr
   14144:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   14148:	ea55 0e06 	orrs.w	lr, r5, r6
   1414c:	d018      	beq.n	14180 <__aeabi_ddiv+0x114>
   1414e:	ea4f 1505 	mov.w	r5, r5, lsl #4
   14152:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   14156:	ea4f 1606 	mov.w	r6, r6, lsl #4
   1415a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   1415e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   14162:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   14166:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   1416a:	d1c0      	bne.n	140ee <__aeabi_ddiv+0x82>
   1416c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   14170:	d10b      	bne.n	1418a <__aeabi_ddiv+0x11e>
   14172:	ea41 0100 	orr.w	r1, r1, r0
   14176:	f04f 0000 	mov.w	r0, #0
   1417a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   1417e:	e7b6      	b.n	140ee <__aeabi_ddiv+0x82>
   14180:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   14184:	bf04      	itt	eq
   14186:	4301      	orreq	r1, r0
   14188:	2000      	moveq	r0, #0
   1418a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   1418e:	bf88      	it	hi
   14190:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   14194:	f63f aeaf 	bhi.w	13ef6 <__aeabi_dmul+0xde>
   14198:	ebb5 0c03 	subs.w	ip, r5, r3
   1419c:	bf04      	itt	eq
   1419e:	ebb6 0c02 	subseq.w	ip, r6, r2
   141a2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   141a6:	f150 0000 	adcs.w	r0, r0, #0
   141aa:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   141ae:	bd70      	pop	{r4, r5, r6, pc}
   141b0:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   141b4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   141b8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   141bc:	bfc2      	ittt	gt
   141be:	ebd4 050c 	rsbsgt	r5, r4, ip
   141c2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   141c6:	bd70      	popgt	{r4, r5, r6, pc}
   141c8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   141cc:	f04f 0e00 	mov.w	lr, #0
   141d0:	3c01      	subs	r4, #1
   141d2:	e690      	b.n	13ef6 <__aeabi_dmul+0xde>
   141d4:	ea45 0e06 	orr.w	lr, r5, r6
   141d8:	e68d      	b.n	13ef6 <__aeabi_dmul+0xde>
   141da:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   141de:	ea94 0f0c 	teq	r4, ip
   141e2:	bf08      	it	eq
   141e4:	ea95 0f0c 	teqeq	r5, ip
   141e8:	f43f af3b 	beq.w	14062 <__aeabi_dmul+0x24a>
   141ec:	ea94 0f0c 	teq	r4, ip
   141f0:	d10a      	bne.n	14208 <__aeabi_ddiv+0x19c>
   141f2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   141f6:	f47f af34 	bne.w	14062 <__aeabi_dmul+0x24a>
   141fa:	ea95 0f0c 	teq	r5, ip
   141fe:	f47f af25 	bne.w	1404c <__aeabi_dmul+0x234>
   14202:	4610      	mov	r0, r2
   14204:	4619      	mov	r1, r3
   14206:	e72c      	b.n	14062 <__aeabi_dmul+0x24a>
   14208:	ea95 0f0c 	teq	r5, ip
   1420c:	d106      	bne.n	1421c <__aeabi_ddiv+0x1b0>
   1420e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   14212:	f43f aefd 	beq.w	14010 <__aeabi_dmul+0x1f8>
   14216:	4610      	mov	r0, r2
   14218:	4619      	mov	r1, r3
   1421a:	e722      	b.n	14062 <__aeabi_dmul+0x24a>
   1421c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   14220:	bf18      	it	ne
   14222:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   14226:	f47f aec5 	bne.w	13fb4 <__aeabi_dmul+0x19c>
   1422a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   1422e:	f47f af0d 	bne.w	1404c <__aeabi_dmul+0x234>
   14232:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   14236:	f47f aeeb 	bne.w	14010 <__aeabi_dmul+0x1f8>
   1423a:	e712      	b.n	14062 <__aeabi_dmul+0x24a>

0001423c <__aeabi_d2uiz>:
   1423c:	004a      	lsls	r2, r1, #1
   1423e:	d211      	bcs.n	14264 <__aeabi_d2uiz+0x28>
   14240:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   14244:	d211      	bcs.n	1426a <__aeabi_d2uiz+0x2e>
   14246:	d50d      	bpl.n	14264 <__aeabi_d2uiz+0x28>
   14248:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   1424c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   14250:	d40e      	bmi.n	14270 <__aeabi_d2uiz+0x34>
   14252:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   14256:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1425a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   1425e:	fa23 f002 	lsr.w	r0, r3, r2
   14262:	4770      	bx	lr
   14264:	f04f 0000 	mov.w	r0, #0
   14268:	4770      	bx	lr
   1426a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   1426e:	d102      	bne.n	14276 <__aeabi_d2uiz+0x3a>
   14270:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14274:	4770      	bx	lr
   14276:	f04f 0000 	mov.w	r0, #0
   1427a:	4770      	bx	lr

0001427c <__libc_init_array>:
   1427c:	b570      	push	{r4, r5, r6, lr}
   1427e:	4d0d      	ldr	r5, [pc, #52]	; (142b4 <__libc_init_array+0x38>)
   14280:	4c0d      	ldr	r4, [pc, #52]	; (142b8 <__libc_init_array+0x3c>)
   14282:	1b64      	subs	r4, r4, r5
   14284:	10a4      	asrs	r4, r4, #2
   14286:	2600      	movs	r6, #0
   14288:	42a6      	cmp	r6, r4
   1428a:	d109      	bne.n	142a0 <__libc_init_array+0x24>
   1428c:	4d0b      	ldr	r5, [pc, #44]	; (142bc <__libc_init_array+0x40>)
   1428e:	4c0c      	ldr	r4, [pc, #48]	; (142c0 <__libc_init_array+0x44>)
   14290:	f002 fb5e 	bl	16950 <_init>
   14294:	1b64      	subs	r4, r4, r5
   14296:	10a4      	asrs	r4, r4, #2
   14298:	2600      	movs	r6, #0
   1429a:	42a6      	cmp	r6, r4
   1429c:	d105      	bne.n	142aa <__libc_init_array+0x2e>
   1429e:	bd70      	pop	{r4, r5, r6, pc}
   142a0:	f855 3b04 	ldr.w	r3, [r5], #4
   142a4:	4798      	blx	r3
   142a6:	3601      	adds	r6, #1
   142a8:	e7ee      	b.n	14288 <__libc_init_array+0xc>
   142aa:	f855 3b04 	ldr.w	r3, [r5], #4
   142ae:	4798      	blx	r3
   142b0:	3601      	adds	r6, #1
   142b2:	e7f2      	b.n	1429a <__libc_init_array+0x1e>
   142b4:	0001695c 	.word	0x0001695c
   142b8:	0001695c 	.word	0x0001695c
   142bc:	0001695c 	.word	0x0001695c
   142c0:	00016960 	.word	0x00016960

000142c4 <malloc>:
   142c4:	4b02      	ldr	r3, [pc, #8]	; (142d0 <malloc+0xc>)
   142c6:	4601      	mov	r1, r0
   142c8:	6818      	ldr	r0, [r3, #0]
   142ca:	f000 b867 	b.w	1439c <_malloc_r>
   142ce:	bf00      	nop
   142d0:	2000054c 	.word	0x2000054c

000142d4 <memcpy>:
   142d4:	440a      	add	r2, r1
   142d6:	4291      	cmp	r1, r2
   142d8:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   142dc:	d100      	bne.n	142e0 <memcpy+0xc>
   142de:	4770      	bx	lr
   142e0:	b510      	push	{r4, lr}
   142e2:	f811 4b01 	ldrb.w	r4, [r1], #1
   142e6:	f803 4f01 	strb.w	r4, [r3, #1]!
   142ea:	4291      	cmp	r1, r2
   142ec:	d1f9      	bne.n	142e2 <memcpy+0xe>
   142ee:	bd10      	pop	{r4, pc}

000142f0 <memset>:
   142f0:	4402      	add	r2, r0
   142f2:	4603      	mov	r3, r0
   142f4:	4293      	cmp	r3, r2
   142f6:	d100      	bne.n	142fa <memset+0xa>
   142f8:	4770      	bx	lr
   142fa:	f803 1b01 	strb.w	r1, [r3], #1
   142fe:	e7f9      	b.n	142f4 <memset+0x4>

00014300 <_free_r>:
   14300:	b538      	push	{r3, r4, r5, lr}
   14302:	4605      	mov	r5, r0
   14304:	2900      	cmp	r1, #0
   14306:	d045      	beq.n	14394 <_free_r+0x94>
   14308:	f851 3c04 	ldr.w	r3, [r1, #-4]
   1430c:	1f0c      	subs	r4, r1, #4
   1430e:	2b00      	cmp	r3, #0
   14310:	bfb8      	it	lt
   14312:	18e4      	addlt	r4, r4, r3
   14314:	f000 fd62 	bl	14ddc <__malloc_lock>
   14318:	4a1f      	ldr	r2, [pc, #124]	; (14398 <_free_r+0x98>)
   1431a:	6813      	ldr	r3, [r2, #0]
   1431c:	4610      	mov	r0, r2
   1431e:	b933      	cbnz	r3, 1432e <_free_r+0x2e>
   14320:	6063      	str	r3, [r4, #4]
   14322:	6014      	str	r4, [r2, #0]
   14324:	4628      	mov	r0, r5
   14326:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1432a:	f000 bd5d 	b.w	14de8 <__malloc_unlock>
   1432e:	42a3      	cmp	r3, r4
   14330:	d90b      	bls.n	1434a <_free_r+0x4a>
   14332:	6821      	ldr	r1, [r4, #0]
   14334:	1862      	adds	r2, r4, r1
   14336:	4293      	cmp	r3, r2
   14338:	bf04      	itt	eq
   1433a:	681a      	ldreq	r2, [r3, #0]
   1433c:	685b      	ldreq	r3, [r3, #4]
   1433e:	6063      	str	r3, [r4, #4]
   14340:	bf04      	itt	eq
   14342:	1852      	addeq	r2, r2, r1
   14344:	6022      	streq	r2, [r4, #0]
   14346:	6004      	str	r4, [r0, #0]
   14348:	e7ec      	b.n	14324 <_free_r+0x24>
   1434a:	461a      	mov	r2, r3
   1434c:	685b      	ldr	r3, [r3, #4]
   1434e:	b10b      	cbz	r3, 14354 <_free_r+0x54>
   14350:	42a3      	cmp	r3, r4
   14352:	d9fa      	bls.n	1434a <_free_r+0x4a>
   14354:	6811      	ldr	r1, [r2, #0]
   14356:	1850      	adds	r0, r2, r1
   14358:	42a0      	cmp	r0, r4
   1435a:	d10b      	bne.n	14374 <_free_r+0x74>
   1435c:	6820      	ldr	r0, [r4, #0]
   1435e:	4401      	add	r1, r0
   14360:	1850      	adds	r0, r2, r1
   14362:	4283      	cmp	r3, r0
   14364:	6011      	str	r1, [r2, #0]
   14366:	d1dd      	bne.n	14324 <_free_r+0x24>
   14368:	6818      	ldr	r0, [r3, #0]
   1436a:	685b      	ldr	r3, [r3, #4]
   1436c:	6053      	str	r3, [r2, #4]
   1436e:	4401      	add	r1, r0
   14370:	6011      	str	r1, [r2, #0]
   14372:	e7d7      	b.n	14324 <_free_r+0x24>
   14374:	d902      	bls.n	1437c <_free_r+0x7c>
   14376:	230c      	movs	r3, #12
   14378:	602b      	str	r3, [r5, #0]
   1437a:	e7d3      	b.n	14324 <_free_r+0x24>
   1437c:	6820      	ldr	r0, [r4, #0]
   1437e:	1821      	adds	r1, r4, r0
   14380:	428b      	cmp	r3, r1
   14382:	bf04      	itt	eq
   14384:	6819      	ldreq	r1, [r3, #0]
   14386:	685b      	ldreq	r3, [r3, #4]
   14388:	6063      	str	r3, [r4, #4]
   1438a:	bf04      	itt	eq
   1438c:	1809      	addeq	r1, r1, r0
   1438e:	6021      	streq	r1, [r4, #0]
   14390:	6054      	str	r4, [r2, #4]
   14392:	e7c7      	b.n	14324 <_free_r+0x24>
   14394:	bd38      	pop	{r3, r4, r5, pc}
   14396:	bf00      	nop
   14398:	20009138 	.word	0x20009138

0001439c <_malloc_r>:
   1439c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1439e:	1ccd      	adds	r5, r1, #3
   143a0:	f025 0503 	bic.w	r5, r5, #3
   143a4:	3508      	adds	r5, #8
   143a6:	2d0c      	cmp	r5, #12
   143a8:	bf38      	it	cc
   143aa:	250c      	movcc	r5, #12
   143ac:	2d00      	cmp	r5, #0
   143ae:	4606      	mov	r6, r0
   143b0:	db01      	blt.n	143b6 <_malloc_r+0x1a>
   143b2:	42a9      	cmp	r1, r5
   143b4:	d903      	bls.n	143be <_malloc_r+0x22>
   143b6:	230c      	movs	r3, #12
   143b8:	6033      	str	r3, [r6, #0]
   143ba:	2000      	movs	r0, #0
   143bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   143be:	f000 fd0d 	bl	14ddc <__malloc_lock>
   143c2:	4921      	ldr	r1, [pc, #132]	; (14448 <_malloc_r+0xac>)
   143c4:	680a      	ldr	r2, [r1, #0]
   143c6:	4614      	mov	r4, r2
   143c8:	b99c      	cbnz	r4, 143f2 <_malloc_r+0x56>
   143ca:	4f20      	ldr	r7, [pc, #128]	; (1444c <_malloc_r+0xb0>)
   143cc:	683b      	ldr	r3, [r7, #0]
   143ce:	b923      	cbnz	r3, 143da <_malloc_r+0x3e>
   143d0:	4621      	mov	r1, r4
   143d2:	4630      	mov	r0, r6
   143d4:	f000 f8ca 	bl	1456c <_sbrk_r>
   143d8:	6038      	str	r0, [r7, #0]
   143da:	4629      	mov	r1, r5
   143dc:	4630      	mov	r0, r6
   143de:	f000 f8c5 	bl	1456c <_sbrk_r>
   143e2:	1c43      	adds	r3, r0, #1
   143e4:	d123      	bne.n	1442e <_malloc_r+0x92>
   143e6:	230c      	movs	r3, #12
   143e8:	6033      	str	r3, [r6, #0]
   143ea:	4630      	mov	r0, r6
   143ec:	f000 fcfc 	bl	14de8 <__malloc_unlock>
   143f0:	e7e3      	b.n	143ba <_malloc_r+0x1e>
   143f2:	6823      	ldr	r3, [r4, #0]
   143f4:	1b5b      	subs	r3, r3, r5
   143f6:	d417      	bmi.n	14428 <_malloc_r+0x8c>
   143f8:	2b0b      	cmp	r3, #11
   143fa:	d903      	bls.n	14404 <_malloc_r+0x68>
   143fc:	6023      	str	r3, [r4, #0]
   143fe:	441c      	add	r4, r3
   14400:	6025      	str	r5, [r4, #0]
   14402:	e004      	b.n	1440e <_malloc_r+0x72>
   14404:	6863      	ldr	r3, [r4, #4]
   14406:	42a2      	cmp	r2, r4
   14408:	bf0c      	ite	eq
   1440a:	600b      	streq	r3, [r1, #0]
   1440c:	6053      	strne	r3, [r2, #4]
   1440e:	4630      	mov	r0, r6
   14410:	f000 fcea 	bl	14de8 <__malloc_unlock>
   14414:	f104 000b 	add.w	r0, r4, #11
   14418:	1d23      	adds	r3, r4, #4
   1441a:	f020 0007 	bic.w	r0, r0, #7
   1441e:	1ac2      	subs	r2, r0, r3
   14420:	d0cc      	beq.n	143bc <_malloc_r+0x20>
   14422:	1a1b      	subs	r3, r3, r0
   14424:	50a3      	str	r3, [r4, r2]
   14426:	e7c9      	b.n	143bc <_malloc_r+0x20>
   14428:	4622      	mov	r2, r4
   1442a:	6864      	ldr	r4, [r4, #4]
   1442c:	e7cc      	b.n	143c8 <_malloc_r+0x2c>
   1442e:	1cc4      	adds	r4, r0, #3
   14430:	f024 0403 	bic.w	r4, r4, #3
   14434:	42a0      	cmp	r0, r4
   14436:	d0e3      	beq.n	14400 <_malloc_r+0x64>
   14438:	1a21      	subs	r1, r4, r0
   1443a:	4630      	mov	r0, r6
   1443c:	f000 f896 	bl	1456c <_sbrk_r>
   14440:	3001      	adds	r0, #1
   14442:	d1dd      	bne.n	14400 <_malloc_r+0x64>
   14444:	e7cf      	b.n	143e6 <_malloc_r+0x4a>
   14446:	bf00      	nop
   14448:	20009138 	.word	0x20009138
   1444c:	2000913c 	.word	0x2000913c

00014450 <iprintf>:
   14450:	b40f      	push	{r0, r1, r2, r3}
   14452:	4b0a      	ldr	r3, [pc, #40]	; (1447c <iprintf+0x2c>)
   14454:	b513      	push	{r0, r1, r4, lr}
   14456:	681c      	ldr	r4, [r3, #0]
   14458:	b124      	cbz	r4, 14464 <iprintf+0x14>
   1445a:	69a3      	ldr	r3, [r4, #24]
   1445c:	b913      	cbnz	r3, 14464 <iprintf+0x14>
   1445e:	4620      	mov	r0, r4
   14460:	f000 fbb8 	bl	14bd4 <__sinit>
   14464:	ab05      	add	r3, sp, #20
   14466:	9a04      	ldr	r2, [sp, #16]
   14468:	68a1      	ldr	r1, [r4, #8]
   1446a:	9301      	str	r3, [sp, #4]
   1446c:	4620      	mov	r0, r4
   1446e:	f000 fe45 	bl	150fc <_vfiprintf_r>
   14472:	b002      	add	sp, #8
   14474:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   14478:	b004      	add	sp, #16
   1447a:	4770      	bx	lr
   1447c:	2000054c 	.word	0x2000054c

00014480 <_puts_r>:
   14480:	b570      	push	{r4, r5, r6, lr}
   14482:	460e      	mov	r6, r1
   14484:	4605      	mov	r5, r0
   14486:	b118      	cbz	r0, 14490 <_puts_r+0x10>
   14488:	6983      	ldr	r3, [r0, #24]
   1448a:	b90b      	cbnz	r3, 14490 <_puts_r+0x10>
   1448c:	f000 fba2 	bl	14bd4 <__sinit>
   14490:	69ab      	ldr	r3, [r5, #24]
   14492:	68ac      	ldr	r4, [r5, #8]
   14494:	b913      	cbnz	r3, 1449c <_puts_r+0x1c>
   14496:	4628      	mov	r0, r5
   14498:	f000 fb9c 	bl	14bd4 <__sinit>
   1449c:	4b2c      	ldr	r3, [pc, #176]	; (14550 <_puts_r+0xd0>)
   1449e:	429c      	cmp	r4, r3
   144a0:	d120      	bne.n	144e4 <_puts_r+0x64>
   144a2:	686c      	ldr	r4, [r5, #4]
   144a4:	6e63      	ldr	r3, [r4, #100]	; 0x64
   144a6:	07db      	lsls	r3, r3, #31
   144a8:	d405      	bmi.n	144b6 <_puts_r+0x36>
   144aa:	89a3      	ldrh	r3, [r4, #12]
   144ac:	0598      	lsls	r0, r3, #22
   144ae:	d402      	bmi.n	144b6 <_puts_r+0x36>
   144b0:	6da0      	ldr	r0, [r4, #88]	; 0x58
   144b2:	f000 fc2d 	bl	14d10 <__retarget_lock_acquire_recursive>
   144b6:	89a3      	ldrh	r3, [r4, #12]
   144b8:	0719      	lsls	r1, r3, #28
   144ba:	d51d      	bpl.n	144f8 <_puts_r+0x78>
   144bc:	6923      	ldr	r3, [r4, #16]
   144be:	b1db      	cbz	r3, 144f8 <_puts_r+0x78>
   144c0:	3e01      	subs	r6, #1
   144c2:	68a3      	ldr	r3, [r4, #8]
   144c4:	f816 1f01 	ldrb.w	r1, [r6, #1]!
   144c8:	3b01      	subs	r3, #1
   144ca:	60a3      	str	r3, [r4, #8]
   144cc:	bb39      	cbnz	r1, 1451e <_puts_r+0x9e>
   144ce:	2b00      	cmp	r3, #0
   144d0:	da38      	bge.n	14544 <_puts_r+0xc4>
   144d2:	4622      	mov	r2, r4
   144d4:	210a      	movs	r1, #10
   144d6:	4628      	mov	r0, r5
   144d8:	f000 f9a2 	bl	14820 <__swbuf_r>
   144dc:	3001      	adds	r0, #1
   144de:	d011      	beq.n	14504 <_puts_r+0x84>
   144e0:	250a      	movs	r5, #10
   144e2:	e011      	b.n	14508 <_puts_r+0x88>
   144e4:	4b1b      	ldr	r3, [pc, #108]	; (14554 <_puts_r+0xd4>)
   144e6:	429c      	cmp	r4, r3
   144e8:	d101      	bne.n	144ee <_puts_r+0x6e>
   144ea:	68ac      	ldr	r4, [r5, #8]
   144ec:	e7da      	b.n	144a4 <_puts_r+0x24>
   144ee:	4b1a      	ldr	r3, [pc, #104]	; (14558 <_puts_r+0xd8>)
   144f0:	429c      	cmp	r4, r3
   144f2:	bf08      	it	eq
   144f4:	68ec      	ldreq	r4, [r5, #12]
   144f6:	e7d5      	b.n	144a4 <_puts_r+0x24>
   144f8:	4621      	mov	r1, r4
   144fa:	4628      	mov	r0, r5
   144fc:	f000 f9e2 	bl	148c4 <__swsetup_r>
   14500:	2800      	cmp	r0, #0
   14502:	d0dd      	beq.n	144c0 <_puts_r+0x40>
   14504:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   14508:	6e63      	ldr	r3, [r4, #100]	; 0x64
   1450a:	07da      	lsls	r2, r3, #31
   1450c:	d405      	bmi.n	1451a <_puts_r+0x9a>
   1450e:	89a3      	ldrh	r3, [r4, #12]
   14510:	059b      	lsls	r3, r3, #22
   14512:	d402      	bmi.n	1451a <_puts_r+0x9a>
   14514:	6da0      	ldr	r0, [r4, #88]	; 0x58
   14516:	f000 fbfc 	bl	14d12 <__retarget_lock_release_recursive>
   1451a:	4628      	mov	r0, r5
   1451c:	bd70      	pop	{r4, r5, r6, pc}
   1451e:	2b00      	cmp	r3, #0
   14520:	da04      	bge.n	1452c <_puts_r+0xac>
   14522:	69a2      	ldr	r2, [r4, #24]
   14524:	429a      	cmp	r2, r3
   14526:	dc06      	bgt.n	14536 <_puts_r+0xb6>
   14528:	290a      	cmp	r1, #10
   1452a:	d004      	beq.n	14536 <_puts_r+0xb6>
   1452c:	6823      	ldr	r3, [r4, #0]
   1452e:	1c5a      	adds	r2, r3, #1
   14530:	6022      	str	r2, [r4, #0]
   14532:	7019      	strb	r1, [r3, #0]
   14534:	e7c5      	b.n	144c2 <_puts_r+0x42>
   14536:	4622      	mov	r2, r4
   14538:	4628      	mov	r0, r5
   1453a:	f000 f971 	bl	14820 <__swbuf_r>
   1453e:	3001      	adds	r0, #1
   14540:	d1bf      	bne.n	144c2 <_puts_r+0x42>
   14542:	e7df      	b.n	14504 <_puts_r+0x84>
   14544:	6823      	ldr	r3, [r4, #0]
   14546:	250a      	movs	r5, #10
   14548:	1c5a      	adds	r2, r3, #1
   1454a:	6022      	str	r2, [r4, #0]
   1454c:	701d      	strb	r5, [r3, #0]
   1454e:	e7db      	b.n	14508 <_puts_r+0x88>
   14550:	000168dc 	.word	0x000168dc
   14554:	000168fc 	.word	0x000168fc
   14558:	000168bc 	.word	0x000168bc

0001455c <puts>:
   1455c:	4b02      	ldr	r3, [pc, #8]	; (14568 <puts+0xc>)
   1455e:	4601      	mov	r1, r0
   14560:	6818      	ldr	r0, [r3, #0]
   14562:	f7ff bf8d 	b.w	14480 <_puts_r>
   14566:	bf00      	nop
   14568:	2000054c 	.word	0x2000054c

0001456c <_sbrk_r>:
   1456c:	b538      	push	{r3, r4, r5, lr}
   1456e:	4d06      	ldr	r5, [pc, #24]	; (14588 <_sbrk_r+0x1c>)
   14570:	2300      	movs	r3, #0
   14572:	4604      	mov	r4, r0
   14574:	4608      	mov	r0, r1
   14576:	602b      	str	r3, [r5, #0]
   14578:	f7f7 fc20 	bl	bdbc <_sbrk>
   1457c:	1c43      	adds	r3, r0, #1
   1457e:	d102      	bne.n	14586 <_sbrk_r+0x1a>
   14580:	682b      	ldr	r3, [r5, #0]
   14582:	b103      	cbz	r3, 14586 <_sbrk_r+0x1a>
   14584:	6023      	str	r3, [r4, #0]
   14586:	bd38      	pop	{r3, r4, r5, pc}
   14588:	2001cfe0 	.word	0x2001cfe0

0001458c <setbuf>:
   1458c:	2900      	cmp	r1, #0
   1458e:	f44f 6380 	mov.w	r3, #1024	; 0x400
   14592:	bf0c      	ite	eq
   14594:	2202      	moveq	r2, #2
   14596:	2200      	movne	r2, #0
   14598:	f000 b800 	b.w	1459c <setvbuf>

0001459c <setvbuf>:
   1459c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   145a0:	461d      	mov	r5, r3
   145a2:	4b5d      	ldr	r3, [pc, #372]	; (14718 <setvbuf+0x17c>)
   145a4:	681f      	ldr	r7, [r3, #0]
   145a6:	4604      	mov	r4, r0
   145a8:	460e      	mov	r6, r1
   145aa:	4690      	mov	r8, r2
   145ac:	b127      	cbz	r7, 145b8 <setvbuf+0x1c>
   145ae:	69bb      	ldr	r3, [r7, #24]
   145b0:	b913      	cbnz	r3, 145b8 <setvbuf+0x1c>
   145b2:	4638      	mov	r0, r7
   145b4:	f000 fb0e 	bl	14bd4 <__sinit>
   145b8:	4b58      	ldr	r3, [pc, #352]	; (1471c <setvbuf+0x180>)
   145ba:	429c      	cmp	r4, r3
   145bc:	d167      	bne.n	1468e <setvbuf+0xf2>
   145be:	687c      	ldr	r4, [r7, #4]
   145c0:	f1b8 0f02 	cmp.w	r8, #2
   145c4:	d006      	beq.n	145d4 <setvbuf+0x38>
   145c6:	f1b8 0f01 	cmp.w	r8, #1
   145ca:	f200 809f 	bhi.w	1470c <setvbuf+0x170>
   145ce:	2d00      	cmp	r5, #0
   145d0:	f2c0 809c 	blt.w	1470c <setvbuf+0x170>
   145d4:	6e63      	ldr	r3, [r4, #100]	; 0x64
   145d6:	07db      	lsls	r3, r3, #31
   145d8:	d405      	bmi.n	145e6 <setvbuf+0x4a>
   145da:	89a3      	ldrh	r3, [r4, #12]
   145dc:	0598      	lsls	r0, r3, #22
   145de:	d402      	bmi.n	145e6 <setvbuf+0x4a>
   145e0:	6da0      	ldr	r0, [r4, #88]	; 0x58
   145e2:	f000 fb95 	bl	14d10 <__retarget_lock_acquire_recursive>
   145e6:	4621      	mov	r1, r4
   145e8:	4638      	mov	r0, r7
   145ea:	f000 fa5f 	bl	14aac <_fflush_r>
   145ee:	6b61      	ldr	r1, [r4, #52]	; 0x34
   145f0:	b141      	cbz	r1, 14604 <setvbuf+0x68>
   145f2:	f104 0344 	add.w	r3, r4, #68	; 0x44
   145f6:	4299      	cmp	r1, r3
   145f8:	d002      	beq.n	14600 <setvbuf+0x64>
   145fa:	4638      	mov	r0, r7
   145fc:	f7ff fe80 	bl	14300 <_free_r>
   14600:	2300      	movs	r3, #0
   14602:	6363      	str	r3, [r4, #52]	; 0x34
   14604:	2300      	movs	r3, #0
   14606:	61a3      	str	r3, [r4, #24]
   14608:	6063      	str	r3, [r4, #4]
   1460a:	89a3      	ldrh	r3, [r4, #12]
   1460c:	0619      	lsls	r1, r3, #24
   1460e:	d503      	bpl.n	14618 <setvbuf+0x7c>
   14610:	6921      	ldr	r1, [r4, #16]
   14612:	4638      	mov	r0, r7
   14614:	f7ff fe74 	bl	14300 <_free_r>
   14618:	89a3      	ldrh	r3, [r4, #12]
   1461a:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
   1461e:	f023 0303 	bic.w	r3, r3, #3
   14622:	f1b8 0f02 	cmp.w	r8, #2
   14626:	81a3      	strh	r3, [r4, #12]
   14628:	d06c      	beq.n	14704 <setvbuf+0x168>
   1462a:	ab01      	add	r3, sp, #4
   1462c:	466a      	mov	r2, sp
   1462e:	4621      	mov	r1, r4
   14630:	4638      	mov	r0, r7
   14632:	f000 fb6f 	bl	14d14 <__swhatbuf_r>
   14636:	89a3      	ldrh	r3, [r4, #12]
   14638:	4318      	orrs	r0, r3
   1463a:	81a0      	strh	r0, [r4, #12]
   1463c:	2d00      	cmp	r5, #0
   1463e:	d130      	bne.n	146a2 <setvbuf+0x106>
   14640:	9d00      	ldr	r5, [sp, #0]
   14642:	4628      	mov	r0, r5
   14644:	f7ff fe3e 	bl	142c4 <malloc>
   14648:	4606      	mov	r6, r0
   1464a:	2800      	cmp	r0, #0
   1464c:	d155      	bne.n	146fa <setvbuf+0x15e>
   1464e:	f8dd 9000 	ldr.w	r9, [sp]
   14652:	45a9      	cmp	r9, r5
   14654:	d14a      	bne.n	146ec <setvbuf+0x150>
   14656:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   1465a:	2200      	movs	r2, #0
   1465c:	60a2      	str	r2, [r4, #8]
   1465e:	f104 0247 	add.w	r2, r4, #71	; 0x47
   14662:	6022      	str	r2, [r4, #0]
   14664:	6122      	str	r2, [r4, #16]
   14666:	2201      	movs	r2, #1
   14668:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   1466c:	6162      	str	r2, [r4, #20]
   1466e:	6e62      	ldr	r2, [r4, #100]	; 0x64
   14670:	f043 0302 	orr.w	r3, r3, #2
   14674:	07d2      	lsls	r2, r2, #31
   14676:	81a3      	strh	r3, [r4, #12]
   14678:	d405      	bmi.n	14686 <setvbuf+0xea>
   1467a:	f413 7f00 	tst.w	r3, #512	; 0x200
   1467e:	d102      	bne.n	14686 <setvbuf+0xea>
   14680:	6da0      	ldr	r0, [r4, #88]	; 0x58
   14682:	f000 fb46 	bl	14d12 <__retarget_lock_release_recursive>
   14686:	4628      	mov	r0, r5
   14688:	b003      	add	sp, #12
   1468a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1468e:	4b24      	ldr	r3, [pc, #144]	; (14720 <setvbuf+0x184>)
   14690:	429c      	cmp	r4, r3
   14692:	d101      	bne.n	14698 <setvbuf+0xfc>
   14694:	68bc      	ldr	r4, [r7, #8]
   14696:	e793      	b.n	145c0 <setvbuf+0x24>
   14698:	4b22      	ldr	r3, [pc, #136]	; (14724 <setvbuf+0x188>)
   1469a:	429c      	cmp	r4, r3
   1469c:	bf08      	it	eq
   1469e:	68fc      	ldreq	r4, [r7, #12]
   146a0:	e78e      	b.n	145c0 <setvbuf+0x24>
   146a2:	2e00      	cmp	r6, #0
   146a4:	d0cd      	beq.n	14642 <setvbuf+0xa6>
   146a6:	69bb      	ldr	r3, [r7, #24]
   146a8:	b913      	cbnz	r3, 146b0 <setvbuf+0x114>
   146aa:	4638      	mov	r0, r7
   146ac:	f000 fa92 	bl	14bd4 <__sinit>
   146b0:	f1b8 0f01 	cmp.w	r8, #1
   146b4:	bf08      	it	eq
   146b6:	89a3      	ldrheq	r3, [r4, #12]
   146b8:	6026      	str	r6, [r4, #0]
   146ba:	bf04      	itt	eq
   146bc:	f043 0301 	orreq.w	r3, r3, #1
   146c0:	81a3      	strheq	r3, [r4, #12]
   146c2:	89a2      	ldrh	r2, [r4, #12]
   146c4:	f012 0308 	ands.w	r3, r2, #8
   146c8:	e9c4 6504 	strd	r6, r5, [r4, #16]
   146cc:	d01c      	beq.n	14708 <setvbuf+0x16c>
   146ce:	07d3      	lsls	r3, r2, #31
   146d0:	bf41      	itttt	mi
   146d2:	2300      	movmi	r3, #0
   146d4:	426d      	negmi	r5, r5
   146d6:	60a3      	strmi	r3, [r4, #8]
   146d8:	61a5      	strmi	r5, [r4, #24]
   146da:	bf58      	it	pl
   146dc:	60a5      	strpl	r5, [r4, #8]
   146de:	6e65      	ldr	r5, [r4, #100]	; 0x64
   146e0:	f015 0501 	ands.w	r5, r5, #1
   146e4:	d115      	bne.n	14712 <setvbuf+0x176>
   146e6:	f412 7f00 	tst.w	r2, #512	; 0x200
   146ea:	e7c8      	b.n	1467e <setvbuf+0xe2>
   146ec:	4648      	mov	r0, r9
   146ee:	f7ff fde9 	bl	142c4 <malloc>
   146f2:	4606      	mov	r6, r0
   146f4:	2800      	cmp	r0, #0
   146f6:	d0ae      	beq.n	14656 <setvbuf+0xba>
   146f8:	464d      	mov	r5, r9
   146fa:	89a3      	ldrh	r3, [r4, #12]
   146fc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   14700:	81a3      	strh	r3, [r4, #12]
   14702:	e7d0      	b.n	146a6 <setvbuf+0x10a>
   14704:	2500      	movs	r5, #0
   14706:	e7a8      	b.n	1465a <setvbuf+0xbe>
   14708:	60a3      	str	r3, [r4, #8]
   1470a:	e7e8      	b.n	146de <setvbuf+0x142>
   1470c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   14710:	e7b9      	b.n	14686 <setvbuf+0xea>
   14712:	2500      	movs	r5, #0
   14714:	e7b7      	b.n	14686 <setvbuf+0xea>
   14716:	bf00      	nop
   14718:	2000054c 	.word	0x2000054c
   1471c:	000168dc 	.word	0x000168dc
   14720:	000168fc 	.word	0x000168fc
   14724:	000168bc 	.word	0x000168bc

00014728 <sniprintf>:
   14728:	b40c      	push	{r2, r3}
   1472a:	b530      	push	{r4, r5, lr}
   1472c:	4b17      	ldr	r3, [pc, #92]	; (1478c <sniprintf+0x64>)
   1472e:	1e0c      	subs	r4, r1, #0
   14730:	681d      	ldr	r5, [r3, #0]
   14732:	b09d      	sub	sp, #116	; 0x74
   14734:	da08      	bge.n	14748 <sniprintf+0x20>
   14736:	238b      	movs	r3, #139	; 0x8b
   14738:	602b      	str	r3, [r5, #0]
   1473a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1473e:	b01d      	add	sp, #116	; 0x74
   14740:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   14744:	b002      	add	sp, #8
   14746:	4770      	bx	lr
   14748:	f44f 7302 	mov.w	r3, #520	; 0x208
   1474c:	f8ad 3014 	strh.w	r3, [sp, #20]
   14750:	bf14      	ite	ne
   14752:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
   14756:	4623      	moveq	r3, r4
   14758:	9304      	str	r3, [sp, #16]
   1475a:	9307      	str	r3, [sp, #28]
   1475c:	f64f 73ff 	movw	r3, #65535	; 0xffff
   14760:	9002      	str	r0, [sp, #8]
   14762:	9006      	str	r0, [sp, #24]
   14764:	f8ad 3016 	strh.w	r3, [sp, #22]
   14768:	9a20      	ldr	r2, [sp, #128]	; 0x80
   1476a:	ab21      	add	r3, sp, #132	; 0x84
   1476c:	a902      	add	r1, sp, #8
   1476e:	4628      	mov	r0, r5
   14770:	9301      	str	r3, [sp, #4]
   14772:	f000 fb9b 	bl	14eac <_svfiprintf_r>
   14776:	1c43      	adds	r3, r0, #1
   14778:	bfbc      	itt	lt
   1477a:	238b      	movlt	r3, #139	; 0x8b
   1477c:	602b      	strlt	r3, [r5, #0]
   1477e:	2c00      	cmp	r4, #0
   14780:	d0dd      	beq.n	1473e <sniprintf+0x16>
   14782:	9b02      	ldr	r3, [sp, #8]
   14784:	2200      	movs	r2, #0
   14786:	701a      	strb	r2, [r3, #0]
   14788:	e7d9      	b.n	1473e <sniprintf+0x16>
   1478a:	bf00      	nop
   1478c:	2000054c 	.word	0x2000054c

00014790 <siprintf>:
   14790:	b40e      	push	{r1, r2, r3}
   14792:	b500      	push	{lr}
   14794:	b09c      	sub	sp, #112	; 0x70
   14796:	ab1d      	add	r3, sp, #116	; 0x74
   14798:	9002      	str	r0, [sp, #8]
   1479a:	9006      	str	r0, [sp, #24]
   1479c:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   147a0:	4809      	ldr	r0, [pc, #36]	; (147c8 <siprintf+0x38>)
   147a2:	9107      	str	r1, [sp, #28]
   147a4:	9104      	str	r1, [sp, #16]
   147a6:	4909      	ldr	r1, [pc, #36]	; (147cc <siprintf+0x3c>)
   147a8:	f853 2b04 	ldr.w	r2, [r3], #4
   147ac:	9105      	str	r1, [sp, #20]
   147ae:	6800      	ldr	r0, [r0, #0]
   147b0:	9301      	str	r3, [sp, #4]
   147b2:	a902      	add	r1, sp, #8
   147b4:	f000 fb7a 	bl	14eac <_svfiprintf_r>
   147b8:	9b02      	ldr	r3, [sp, #8]
   147ba:	2200      	movs	r2, #0
   147bc:	701a      	strb	r2, [r3, #0]
   147be:	b01c      	add	sp, #112	; 0x70
   147c0:	f85d eb04 	ldr.w	lr, [sp], #4
   147c4:	b003      	add	sp, #12
   147c6:	4770      	bx	lr
   147c8:	2000054c 	.word	0x2000054c
   147cc:	ffff0208 	.word	0xffff0208

000147d0 <strchr>:
   147d0:	b2c9      	uxtb	r1, r1
   147d2:	4603      	mov	r3, r0
   147d4:	4618      	mov	r0, r3
   147d6:	f813 2b01 	ldrb.w	r2, [r3], #1
   147da:	b112      	cbz	r2, 147e2 <strchr+0x12>
   147dc:	428a      	cmp	r2, r1
   147de:	d1f9      	bne.n	147d4 <strchr+0x4>
   147e0:	4770      	bx	lr
   147e2:	2900      	cmp	r1, #0
   147e4:	bf18      	it	ne
   147e6:	2000      	movne	r0, #0
   147e8:	4770      	bx	lr

000147ea <strcmp>:
   147ea:	f810 2b01 	ldrb.w	r2, [r0], #1
   147ee:	f811 3b01 	ldrb.w	r3, [r1], #1
   147f2:	2a01      	cmp	r2, #1
   147f4:	bf28      	it	cs
   147f6:	429a      	cmpcs	r2, r3
   147f8:	d0f7      	beq.n	147ea <strcmp>
   147fa:	1ad0      	subs	r0, r2, r3
   147fc:	4770      	bx	lr

000147fe <strcpy>:
   147fe:	4603      	mov	r3, r0
   14800:	f811 2b01 	ldrb.w	r2, [r1], #1
   14804:	f803 2b01 	strb.w	r2, [r3], #1
   14808:	2a00      	cmp	r2, #0
   1480a:	d1f9      	bne.n	14800 <strcpy+0x2>
   1480c:	4770      	bx	lr

0001480e <strlen>:
   1480e:	4603      	mov	r3, r0
   14810:	f813 2b01 	ldrb.w	r2, [r3], #1
   14814:	2a00      	cmp	r2, #0
   14816:	d1fb      	bne.n	14810 <strlen+0x2>
   14818:	1a18      	subs	r0, r3, r0
   1481a:	3801      	subs	r0, #1
   1481c:	4770      	bx	lr
	...

00014820 <__swbuf_r>:
   14820:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   14822:	460e      	mov	r6, r1
   14824:	4614      	mov	r4, r2
   14826:	4605      	mov	r5, r0
   14828:	b118      	cbz	r0, 14832 <__swbuf_r+0x12>
   1482a:	6983      	ldr	r3, [r0, #24]
   1482c:	b90b      	cbnz	r3, 14832 <__swbuf_r+0x12>
   1482e:	f000 f9d1 	bl	14bd4 <__sinit>
   14832:	4b21      	ldr	r3, [pc, #132]	; (148b8 <__swbuf_r+0x98>)
   14834:	429c      	cmp	r4, r3
   14836:	d12b      	bne.n	14890 <__swbuf_r+0x70>
   14838:	686c      	ldr	r4, [r5, #4]
   1483a:	69a3      	ldr	r3, [r4, #24]
   1483c:	60a3      	str	r3, [r4, #8]
   1483e:	89a3      	ldrh	r3, [r4, #12]
   14840:	071a      	lsls	r2, r3, #28
   14842:	d52f      	bpl.n	148a4 <__swbuf_r+0x84>
   14844:	6923      	ldr	r3, [r4, #16]
   14846:	b36b      	cbz	r3, 148a4 <__swbuf_r+0x84>
   14848:	6923      	ldr	r3, [r4, #16]
   1484a:	6820      	ldr	r0, [r4, #0]
   1484c:	1ac0      	subs	r0, r0, r3
   1484e:	6963      	ldr	r3, [r4, #20]
   14850:	b2f6      	uxtb	r6, r6
   14852:	4283      	cmp	r3, r0
   14854:	4637      	mov	r7, r6
   14856:	dc04      	bgt.n	14862 <__swbuf_r+0x42>
   14858:	4621      	mov	r1, r4
   1485a:	4628      	mov	r0, r5
   1485c:	f000 f926 	bl	14aac <_fflush_r>
   14860:	bb30      	cbnz	r0, 148b0 <__swbuf_r+0x90>
   14862:	68a3      	ldr	r3, [r4, #8]
   14864:	3b01      	subs	r3, #1
   14866:	60a3      	str	r3, [r4, #8]
   14868:	6823      	ldr	r3, [r4, #0]
   1486a:	1c5a      	adds	r2, r3, #1
   1486c:	6022      	str	r2, [r4, #0]
   1486e:	701e      	strb	r6, [r3, #0]
   14870:	6963      	ldr	r3, [r4, #20]
   14872:	3001      	adds	r0, #1
   14874:	4283      	cmp	r3, r0
   14876:	d004      	beq.n	14882 <__swbuf_r+0x62>
   14878:	89a3      	ldrh	r3, [r4, #12]
   1487a:	07db      	lsls	r3, r3, #31
   1487c:	d506      	bpl.n	1488c <__swbuf_r+0x6c>
   1487e:	2e0a      	cmp	r6, #10
   14880:	d104      	bne.n	1488c <__swbuf_r+0x6c>
   14882:	4621      	mov	r1, r4
   14884:	4628      	mov	r0, r5
   14886:	f000 f911 	bl	14aac <_fflush_r>
   1488a:	b988      	cbnz	r0, 148b0 <__swbuf_r+0x90>
   1488c:	4638      	mov	r0, r7
   1488e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14890:	4b0a      	ldr	r3, [pc, #40]	; (148bc <__swbuf_r+0x9c>)
   14892:	429c      	cmp	r4, r3
   14894:	d101      	bne.n	1489a <__swbuf_r+0x7a>
   14896:	68ac      	ldr	r4, [r5, #8]
   14898:	e7cf      	b.n	1483a <__swbuf_r+0x1a>
   1489a:	4b09      	ldr	r3, [pc, #36]	; (148c0 <__swbuf_r+0xa0>)
   1489c:	429c      	cmp	r4, r3
   1489e:	bf08      	it	eq
   148a0:	68ec      	ldreq	r4, [r5, #12]
   148a2:	e7ca      	b.n	1483a <__swbuf_r+0x1a>
   148a4:	4621      	mov	r1, r4
   148a6:	4628      	mov	r0, r5
   148a8:	f000 f80c 	bl	148c4 <__swsetup_r>
   148ac:	2800      	cmp	r0, #0
   148ae:	d0cb      	beq.n	14848 <__swbuf_r+0x28>
   148b0:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   148b4:	e7ea      	b.n	1488c <__swbuf_r+0x6c>
   148b6:	bf00      	nop
   148b8:	000168dc 	.word	0x000168dc
   148bc:	000168fc 	.word	0x000168fc
   148c0:	000168bc 	.word	0x000168bc

000148c4 <__swsetup_r>:
   148c4:	4b32      	ldr	r3, [pc, #200]	; (14990 <__swsetup_r+0xcc>)
   148c6:	b570      	push	{r4, r5, r6, lr}
   148c8:	681d      	ldr	r5, [r3, #0]
   148ca:	4606      	mov	r6, r0
   148cc:	460c      	mov	r4, r1
   148ce:	b125      	cbz	r5, 148da <__swsetup_r+0x16>
   148d0:	69ab      	ldr	r3, [r5, #24]
   148d2:	b913      	cbnz	r3, 148da <__swsetup_r+0x16>
   148d4:	4628      	mov	r0, r5
   148d6:	f000 f97d 	bl	14bd4 <__sinit>
   148da:	4b2e      	ldr	r3, [pc, #184]	; (14994 <__swsetup_r+0xd0>)
   148dc:	429c      	cmp	r4, r3
   148de:	d10f      	bne.n	14900 <__swsetup_r+0x3c>
   148e0:	686c      	ldr	r4, [r5, #4]
   148e2:	89a3      	ldrh	r3, [r4, #12]
   148e4:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   148e8:	0719      	lsls	r1, r3, #28
   148ea:	d42c      	bmi.n	14946 <__swsetup_r+0x82>
   148ec:	06dd      	lsls	r5, r3, #27
   148ee:	d411      	bmi.n	14914 <__swsetup_r+0x50>
   148f0:	2309      	movs	r3, #9
   148f2:	6033      	str	r3, [r6, #0]
   148f4:	f042 0340 	orr.w	r3, r2, #64	; 0x40
   148f8:	81a3      	strh	r3, [r4, #12]
   148fa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   148fe:	e03e      	b.n	1497e <__swsetup_r+0xba>
   14900:	4b25      	ldr	r3, [pc, #148]	; (14998 <__swsetup_r+0xd4>)
   14902:	429c      	cmp	r4, r3
   14904:	d101      	bne.n	1490a <__swsetup_r+0x46>
   14906:	68ac      	ldr	r4, [r5, #8]
   14908:	e7eb      	b.n	148e2 <__swsetup_r+0x1e>
   1490a:	4b24      	ldr	r3, [pc, #144]	; (1499c <__swsetup_r+0xd8>)
   1490c:	429c      	cmp	r4, r3
   1490e:	bf08      	it	eq
   14910:	68ec      	ldreq	r4, [r5, #12]
   14912:	e7e6      	b.n	148e2 <__swsetup_r+0x1e>
   14914:	0758      	lsls	r0, r3, #29
   14916:	d512      	bpl.n	1493e <__swsetup_r+0x7a>
   14918:	6b61      	ldr	r1, [r4, #52]	; 0x34
   1491a:	b141      	cbz	r1, 1492e <__swsetup_r+0x6a>
   1491c:	f104 0344 	add.w	r3, r4, #68	; 0x44
   14920:	4299      	cmp	r1, r3
   14922:	d002      	beq.n	1492a <__swsetup_r+0x66>
   14924:	4630      	mov	r0, r6
   14926:	f7ff fceb 	bl	14300 <_free_r>
   1492a:	2300      	movs	r3, #0
   1492c:	6363      	str	r3, [r4, #52]	; 0x34
   1492e:	89a3      	ldrh	r3, [r4, #12]
   14930:	f023 0324 	bic.w	r3, r3, #36	; 0x24
   14934:	81a3      	strh	r3, [r4, #12]
   14936:	2300      	movs	r3, #0
   14938:	6063      	str	r3, [r4, #4]
   1493a:	6923      	ldr	r3, [r4, #16]
   1493c:	6023      	str	r3, [r4, #0]
   1493e:	89a3      	ldrh	r3, [r4, #12]
   14940:	f043 0308 	orr.w	r3, r3, #8
   14944:	81a3      	strh	r3, [r4, #12]
   14946:	6923      	ldr	r3, [r4, #16]
   14948:	b94b      	cbnz	r3, 1495e <__swsetup_r+0x9a>
   1494a:	89a3      	ldrh	r3, [r4, #12]
   1494c:	f403 7320 	and.w	r3, r3, #640	; 0x280
   14950:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   14954:	d003      	beq.n	1495e <__swsetup_r+0x9a>
   14956:	4621      	mov	r1, r4
   14958:	4630      	mov	r0, r6
   1495a:	f000 f9ff 	bl	14d5c <__smakebuf_r>
   1495e:	89a0      	ldrh	r0, [r4, #12]
   14960:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   14964:	f010 0301 	ands.w	r3, r0, #1
   14968:	d00a      	beq.n	14980 <__swsetup_r+0xbc>
   1496a:	2300      	movs	r3, #0
   1496c:	60a3      	str	r3, [r4, #8]
   1496e:	6963      	ldr	r3, [r4, #20]
   14970:	425b      	negs	r3, r3
   14972:	61a3      	str	r3, [r4, #24]
   14974:	6923      	ldr	r3, [r4, #16]
   14976:	b943      	cbnz	r3, 1498a <__swsetup_r+0xc6>
   14978:	f010 0080 	ands.w	r0, r0, #128	; 0x80
   1497c:	d1ba      	bne.n	148f4 <__swsetup_r+0x30>
   1497e:	bd70      	pop	{r4, r5, r6, pc}
   14980:	0781      	lsls	r1, r0, #30
   14982:	bf58      	it	pl
   14984:	6963      	ldrpl	r3, [r4, #20]
   14986:	60a3      	str	r3, [r4, #8]
   14988:	e7f4      	b.n	14974 <__swsetup_r+0xb0>
   1498a:	2000      	movs	r0, #0
   1498c:	e7f7      	b.n	1497e <__swsetup_r+0xba>
   1498e:	bf00      	nop
   14990:	2000054c 	.word	0x2000054c
   14994:	000168dc 	.word	0x000168dc
   14998:	000168fc 	.word	0x000168fc
   1499c:	000168bc 	.word	0x000168bc

000149a0 <__sflush_r>:
   149a0:	898a      	ldrh	r2, [r1, #12]
   149a2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   149a6:	4605      	mov	r5, r0
   149a8:	0710      	lsls	r0, r2, #28
   149aa:	460c      	mov	r4, r1
   149ac:	d458      	bmi.n	14a60 <__sflush_r+0xc0>
   149ae:	684b      	ldr	r3, [r1, #4]
   149b0:	2b00      	cmp	r3, #0
   149b2:	dc05      	bgt.n	149c0 <__sflush_r+0x20>
   149b4:	6c0b      	ldr	r3, [r1, #64]	; 0x40
   149b6:	2b00      	cmp	r3, #0
   149b8:	dc02      	bgt.n	149c0 <__sflush_r+0x20>
   149ba:	2000      	movs	r0, #0
   149bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   149c0:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   149c2:	2e00      	cmp	r6, #0
   149c4:	d0f9      	beq.n	149ba <__sflush_r+0x1a>
   149c6:	2300      	movs	r3, #0
   149c8:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
   149cc:	682f      	ldr	r7, [r5, #0]
   149ce:	602b      	str	r3, [r5, #0]
   149d0:	d032      	beq.n	14a38 <__sflush_r+0x98>
   149d2:	6d60      	ldr	r0, [r4, #84]	; 0x54
   149d4:	89a3      	ldrh	r3, [r4, #12]
   149d6:	075a      	lsls	r2, r3, #29
   149d8:	d505      	bpl.n	149e6 <__sflush_r+0x46>
   149da:	6863      	ldr	r3, [r4, #4]
   149dc:	1ac0      	subs	r0, r0, r3
   149de:	6b63      	ldr	r3, [r4, #52]	; 0x34
   149e0:	b10b      	cbz	r3, 149e6 <__sflush_r+0x46>
   149e2:	6c23      	ldr	r3, [r4, #64]	; 0x40
   149e4:	1ac0      	subs	r0, r0, r3
   149e6:	2300      	movs	r3, #0
   149e8:	4602      	mov	r2, r0
   149ea:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   149ec:	6a21      	ldr	r1, [r4, #32]
   149ee:	4628      	mov	r0, r5
   149f0:	47b0      	blx	r6
   149f2:	1c43      	adds	r3, r0, #1
   149f4:	89a3      	ldrh	r3, [r4, #12]
   149f6:	d106      	bne.n	14a06 <__sflush_r+0x66>
   149f8:	6829      	ldr	r1, [r5, #0]
   149fa:	291d      	cmp	r1, #29
   149fc:	d82c      	bhi.n	14a58 <__sflush_r+0xb8>
   149fe:	4a2a      	ldr	r2, [pc, #168]	; (14aa8 <__sflush_r+0x108>)
   14a00:	40ca      	lsrs	r2, r1
   14a02:	07d6      	lsls	r6, r2, #31
   14a04:	d528      	bpl.n	14a58 <__sflush_r+0xb8>
   14a06:	2200      	movs	r2, #0
   14a08:	6062      	str	r2, [r4, #4]
   14a0a:	04d9      	lsls	r1, r3, #19
   14a0c:	6922      	ldr	r2, [r4, #16]
   14a0e:	6022      	str	r2, [r4, #0]
   14a10:	d504      	bpl.n	14a1c <__sflush_r+0x7c>
   14a12:	1c42      	adds	r2, r0, #1
   14a14:	d101      	bne.n	14a1a <__sflush_r+0x7a>
   14a16:	682b      	ldr	r3, [r5, #0]
   14a18:	b903      	cbnz	r3, 14a1c <__sflush_r+0x7c>
   14a1a:	6560      	str	r0, [r4, #84]	; 0x54
   14a1c:	6b61      	ldr	r1, [r4, #52]	; 0x34
   14a1e:	602f      	str	r7, [r5, #0]
   14a20:	2900      	cmp	r1, #0
   14a22:	d0ca      	beq.n	149ba <__sflush_r+0x1a>
   14a24:	f104 0344 	add.w	r3, r4, #68	; 0x44
   14a28:	4299      	cmp	r1, r3
   14a2a:	d002      	beq.n	14a32 <__sflush_r+0x92>
   14a2c:	4628      	mov	r0, r5
   14a2e:	f7ff fc67 	bl	14300 <_free_r>
   14a32:	2000      	movs	r0, #0
   14a34:	6360      	str	r0, [r4, #52]	; 0x34
   14a36:	e7c1      	b.n	149bc <__sflush_r+0x1c>
   14a38:	6a21      	ldr	r1, [r4, #32]
   14a3a:	2301      	movs	r3, #1
   14a3c:	4628      	mov	r0, r5
   14a3e:	47b0      	blx	r6
   14a40:	1c41      	adds	r1, r0, #1
   14a42:	d1c7      	bne.n	149d4 <__sflush_r+0x34>
   14a44:	682b      	ldr	r3, [r5, #0]
   14a46:	2b00      	cmp	r3, #0
   14a48:	d0c4      	beq.n	149d4 <__sflush_r+0x34>
   14a4a:	2b1d      	cmp	r3, #29
   14a4c:	d001      	beq.n	14a52 <__sflush_r+0xb2>
   14a4e:	2b16      	cmp	r3, #22
   14a50:	d101      	bne.n	14a56 <__sflush_r+0xb6>
   14a52:	602f      	str	r7, [r5, #0]
   14a54:	e7b1      	b.n	149ba <__sflush_r+0x1a>
   14a56:	89a3      	ldrh	r3, [r4, #12]
   14a58:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   14a5c:	81a3      	strh	r3, [r4, #12]
   14a5e:	e7ad      	b.n	149bc <__sflush_r+0x1c>
   14a60:	690f      	ldr	r7, [r1, #16]
   14a62:	2f00      	cmp	r7, #0
   14a64:	d0a9      	beq.n	149ba <__sflush_r+0x1a>
   14a66:	0793      	lsls	r3, r2, #30
   14a68:	680e      	ldr	r6, [r1, #0]
   14a6a:	bf08      	it	eq
   14a6c:	694b      	ldreq	r3, [r1, #20]
   14a6e:	600f      	str	r7, [r1, #0]
   14a70:	bf18      	it	ne
   14a72:	2300      	movne	r3, #0
   14a74:	eba6 0807 	sub.w	r8, r6, r7
   14a78:	608b      	str	r3, [r1, #8]
   14a7a:	f1b8 0f00 	cmp.w	r8, #0
   14a7e:	dd9c      	ble.n	149ba <__sflush_r+0x1a>
   14a80:	6a21      	ldr	r1, [r4, #32]
   14a82:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   14a84:	4643      	mov	r3, r8
   14a86:	463a      	mov	r2, r7
   14a88:	4628      	mov	r0, r5
   14a8a:	47b0      	blx	r6
   14a8c:	2800      	cmp	r0, #0
   14a8e:	dc06      	bgt.n	14a9e <__sflush_r+0xfe>
   14a90:	89a3      	ldrh	r3, [r4, #12]
   14a92:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   14a96:	81a3      	strh	r3, [r4, #12]
   14a98:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14a9c:	e78e      	b.n	149bc <__sflush_r+0x1c>
   14a9e:	4407      	add	r7, r0
   14aa0:	eba8 0800 	sub.w	r8, r8, r0
   14aa4:	e7e9      	b.n	14a7a <__sflush_r+0xda>
   14aa6:	bf00      	nop
   14aa8:	20400001 	.word	0x20400001

00014aac <_fflush_r>:
   14aac:	b538      	push	{r3, r4, r5, lr}
   14aae:	690b      	ldr	r3, [r1, #16]
   14ab0:	4605      	mov	r5, r0
   14ab2:	460c      	mov	r4, r1
   14ab4:	b913      	cbnz	r3, 14abc <_fflush_r+0x10>
   14ab6:	2500      	movs	r5, #0
   14ab8:	4628      	mov	r0, r5
   14aba:	bd38      	pop	{r3, r4, r5, pc}
   14abc:	b118      	cbz	r0, 14ac6 <_fflush_r+0x1a>
   14abe:	6983      	ldr	r3, [r0, #24]
   14ac0:	b90b      	cbnz	r3, 14ac6 <_fflush_r+0x1a>
   14ac2:	f000 f887 	bl	14bd4 <__sinit>
   14ac6:	4b14      	ldr	r3, [pc, #80]	; (14b18 <_fflush_r+0x6c>)
   14ac8:	429c      	cmp	r4, r3
   14aca:	d11b      	bne.n	14b04 <_fflush_r+0x58>
   14acc:	686c      	ldr	r4, [r5, #4]
   14ace:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   14ad2:	2b00      	cmp	r3, #0
   14ad4:	d0ef      	beq.n	14ab6 <_fflush_r+0xa>
   14ad6:	6e62      	ldr	r2, [r4, #100]	; 0x64
   14ad8:	07d0      	lsls	r0, r2, #31
   14ada:	d404      	bmi.n	14ae6 <_fflush_r+0x3a>
   14adc:	0599      	lsls	r1, r3, #22
   14ade:	d402      	bmi.n	14ae6 <_fflush_r+0x3a>
   14ae0:	6da0      	ldr	r0, [r4, #88]	; 0x58
   14ae2:	f000 f915 	bl	14d10 <__retarget_lock_acquire_recursive>
   14ae6:	4628      	mov	r0, r5
   14ae8:	4621      	mov	r1, r4
   14aea:	f7ff ff59 	bl	149a0 <__sflush_r>
   14aee:	6e63      	ldr	r3, [r4, #100]	; 0x64
   14af0:	07da      	lsls	r2, r3, #31
   14af2:	4605      	mov	r5, r0
   14af4:	d4e0      	bmi.n	14ab8 <_fflush_r+0xc>
   14af6:	89a3      	ldrh	r3, [r4, #12]
   14af8:	059b      	lsls	r3, r3, #22
   14afa:	d4dd      	bmi.n	14ab8 <_fflush_r+0xc>
   14afc:	6da0      	ldr	r0, [r4, #88]	; 0x58
   14afe:	f000 f908 	bl	14d12 <__retarget_lock_release_recursive>
   14b02:	e7d9      	b.n	14ab8 <_fflush_r+0xc>
   14b04:	4b05      	ldr	r3, [pc, #20]	; (14b1c <_fflush_r+0x70>)
   14b06:	429c      	cmp	r4, r3
   14b08:	d101      	bne.n	14b0e <_fflush_r+0x62>
   14b0a:	68ac      	ldr	r4, [r5, #8]
   14b0c:	e7df      	b.n	14ace <_fflush_r+0x22>
   14b0e:	4b04      	ldr	r3, [pc, #16]	; (14b20 <_fflush_r+0x74>)
   14b10:	429c      	cmp	r4, r3
   14b12:	bf08      	it	eq
   14b14:	68ec      	ldreq	r4, [r5, #12]
   14b16:	e7da      	b.n	14ace <_fflush_r+0x22>
   14b18:	000168dc 	.word	0x000168dc
   14b1c:	000168fc 	.word	0x000168fc
   14b20:	000168bc 	.word	0x000168bc

00014b24 <std>:
   14b24:	2300      	movs	r3, #0
   14b26:	b510      	push	{r4, lr}
   14b28:	4604      	mov	r4, r0
   14b2a:	e9c0 3300 	strd	r3, r3, [r0]
   14b2e:	e9c0 3304 	strd	r3, r3, [r0, #16]
   14b32:	6083      	str	r3, [r0, #8]
   14b34:	8181      	strh	r1, [r0, #12]
   14b36:	6643      	str	r3, [r0, #100]	; 0x64
   14b38:	81c2      	strh	r2, [r0, #14]
   14b3a:	6183      	str	r3, [r0, #24]
   14b3c:	4619      	mov	r1, r3
   14b3e:	2208      	movs	r2, #8
   14b40:	305c      	adds	r0, #92	; 0x5c
   14b42:	f7ff fbd5 	bl	142f0 <memset>
   14b46:	4b05      	ldr	r3, [pc, #20]	; (14b5c <std+0x38>)
   14b48:	6263      	str	r3, [r4, #36]	; 0x24
   14b4a:	4b05      	ldr	r3, [pc, #20]	; (14b60 <std+0x3c>)
   14b4c:	62a3      	str	r3, [r4, #40]	; 0x28
   14b4e:	4b05      	ldr	r3, [pc, #20]	; (14b64 <std+0x40>)
   14b50:	62e3      	str	r3, [r4, #44]	; 0x2c
   14b52:	4b05      	ldr	r3, [pc, #20]	; (14b68 <std+0x44>)
   14b54:	6224      	str	r4, [r4, #32]
   14b56:	6323      	str	r3, [r4, #48]	; 0x30
   14b58:	bd10      	pop	{r4, pc}
   14b5a:	bf00      	nop
   14b5c:	00015685 	.word	0x00015685
   14b60:	000156a7 	.word	0x000156a7
   14b64:	000156df 	.word	0x000156df
   14b68:	00015703 	.word	0x00015703

00014b6c <_cleanup_r>:
   14b6c:	4901      	ldr	r1, [pc, #4]	; (14b74 <_cleanup_r+0x8>)
   14b6e:	f000 b8af 	b.w	14cd0 <_fwalk_reent>
   14b72:	bf00      	nop
   14b74:	00014aad 	.word	0x00014aad

00014b78 <__sfmoreglue>:
   14b78:	b570      	push	{r4, r5, r6, lr}
   14b7a:	1e4a      	subs	r2, r1, #1
   14b7c:	2568      	movs	r5, #104	; 0x68
   14b7e:	4355      	muls	r5, r2
   14b80:	460e      	mov	r6, r1
   14b82:	f105 0174 	add.w	r1, r5, #116	; 0x74
   14b86:	f7ff fc09 	bl	1439c <_malloc_r>
   14b8a:	4604      	mov	r4, r0
   14b8c:	b140      	cbz	r0, 14ba0 <__sfmoreglue+0x28>
   14b8e:	2100      	movs	r1, #0
   14b90:	e9c0 1600 	strd	r1, r6, [r0]
   14b94:	300c      	adds	r0, #12
   14b96:	60a0      	str	r0, [r4, #8]
   14b98:	f105 0268 	add.w	r2, r5, #104	; 0x68
   14b9c:	f7ff fba8 	bl	142f0 <memset>
   14ba0:	4620      	mov	r0, r4
   14ba2:	bd70      	pop	{r4, r5, r6, pc}

00014ba4 <__sfp_lock_acquire>:
   14ba4:	4801      	ldr	r0, [pc, #4]	; (14bac <__sfp_lock_acquire+0x8>)
   14ba6:	f000 b8b3 	b.w	14d10 <__retarget_lock_acquire_recursive>
   14baa:	bf00      	nop
   14bac:	2001cfdc 	.word	0x2001cfdc

00014bb0 <__sfp_lock_release>:
   14bb0:	4801      	ldr	r0, [pc, #4]	; (14bb8 <__sfp_lock_release+0x8>)
   14bb2:	f000 b8ae 	b.w	14d12 <__retarget_lock_release_recursive>
   14bb6:	bf00      	nop
   14bb8:	2001cfdc 	.word	0x2001cfdc

00014bbc <__sinit_lock_acquire>:
   14bbc:	4801      	ldr	r0, [pc, #4]	; (14bc4 <__sinit_lock_acquire+0x8>)
   14bbe:	f000 b8a7 	b.w	14d10 <__retarget_lock_acquire_recursive>
   14bc2:	bf00      	nop
   14bc4:	2001cfd7 	.word	0x2001cfd7

00014bc8 <__sinit_lock_release>:
   14bc8:	4801      	ldr	r0, [pc, #4]	; (14bd0 <__sinit_lock_release+0x8>)
   14bca:	f000 b8a2 	b.w	14d12 <__retarget_lock_release_recursive>
   14bce:	bf00      	nop
   14bd0:	2001cfd7 	.word	0x2001cfd7

00014bd4 <__sinit>:
   14bd4:	b510      	push	{r4, lr}
   14bd6:	4604      	mov	r4, r0
   14bd8:	f7ff fff0 	bl	14bbc <__sinit_lock_acquire>
   14bdc:	69a3      	ldr	r3, [r4, #24]
   14bde:	b11b      	cbz	r3, 14be8 <__sinit+0x14>
   14be0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   14be4:	f7ff bff0 	b.w	14bc8 <__sinit_lock_release>
   14be8:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
   14bec:	6523      	str	r3, [r4, #80]	; 0x50
   14bee:	4b13      	ldr	r3, [pc, #76]	; (14c3c <__sinit+0x68>)
   14bf0:	4a13      	ldr	r2, [pc, #76]	; (14c40 <__sinit+0x6c>)
   14bf2:	681b      	ldr	r3, [r3, #0]
   14bf4:	62a2      	str	r2, [r4, #40]	; 0x28
   14bf6:	42a3      	cmp	r3, r4
   14bf8:	bf04      	itt	eq
   14bfa:	2301      	moveq	r3, #1
   14bfc:	61a3      	streq	r3, [r4, #24]
   14bfe:	4620      	mov	r0, r4
   14c00:	f000 f820 	bl	14c44 <__sfp>
   14c04:	6060      	str	r0, [r4, #4]
   14c06:	4620      	mov	r0, r4
   14c08:	f000 f81c 	bl	14c44 <__sfp>
   14c0c:	60a0      	str	r0, [r4, #8]
   14c0e:	4620      	mov	r0, r4
   14c10:	f000 f818 	bl	14c44 <__sfp>
   14c14:	2200      	movs	r2, #0
   14c16:	60e0      	str	r0, [r4, #12]
   14c18:	2104      	movs	r1, #4
   14c1a:	6860      	ldr	r0, [r4, #4]
   14c1c:	f7ff ff82 	bl	14b24 <std>
   14c20:	68a0      	ldr	r0, [r4, #8]
   14c22:	2201      	movs	r2, #1
   14c24:	2109      	movs	r1, #9
   14c26:	f7ff ff7d 	bl	14b24 <std>
   14c2a:	68e0      	ldr	r0, [r4, #12]
   14c2c:	2202      	movs	r2, #2
   14c2e:	2112      	movs	r1, #18
   14c30:	f7ff ff78 	bl	14b24 <std>
   14c34:	2301      	movs	r3, #1
   14c36:	61a3      	str	r3, [r4, #24]
   14c38:	e7d2      	b.n	14be0 <__sinit+0xc>
   14c3a:	bf00      	nop
   14c3c:	000168b8 	.word	0x000168b8
   14c40:	00014b6d 	.word	0x00014b6d

00014c44 <__sfp>:
   14c44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   14c46:	4607      	mov	r7, r0
   14c48:	f7ff ffac 	bl	14ba4 <__sfp_lock_acquire>
   14c4c:	4b1e      	ldr	r3, [pc, #120]	; (14cc8 <__sfp+0x84>)
   14c4e:	681e      	ldr	r6, [r3, #0]
   14c50:	69b3      	ldr	r3, [r6, #24]
   14c52:	b913      	cbnz	r3, 14c5a <__sfp+0x16>
   14c54:	4630      	mov	r0, r6
   14c56:	f7ff ffbd 	bl	14bd4 <__sinit>
   14c5a:	3648      	adds	r6, #72	; 0x48
   14c5c:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
   14c60:	3b01      	subs	r3, #1
   14c62:	d503      	bpl.n	14c6c <__sfp+0x28>
   14c64:	6833      	ldr	r3, [r6, #0]
   14c66:	b30b      	cbz	r3, 14cac <__sfp+0x68>
   14c68:	6836      	ldr	r6, [r6, #0]
   14c6a:	e7f7      	b.n	14c5c <__sfp+0x18>
   14c6c:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
   14c70:	b9d5      	cbnz	r5, 14ca8 <__sfp+0x64>
   14c72:	4b16      	ldr	r3, [pc, #88]	; (14ccc <__sfp+0x88>)
   14c74:	60e3      	str	r3, [r4, #12]
   14c76:	f104 0058 	add.w	r0, r4, #88	; 0x58
   14c7a:	6665      	str	r5, [r4, #100]	; 0x64
   14c7c:	f000 f847 	bl	14d0e <__retarget_lock_init_recursive>
   14c80:	f7ff ff96 	bl	14bb0 <__sfp_lock_release>
   14c84:	e9c4 5501 	strd	r5, r5, [r4, #4]
   14c88:	e9c4 5504 	strd	r5, r5, [r4, #16]
   14c8c:	6025      	str	r5, [r4, #0]
   14c8e:	61a5      	str	r5, [r4, #24]
   14c90:	2208      	movs	r2, #8
   14c92:	4629      	mov	r1, r5
   14c94:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   14c98:	f7ff fb2a 	bl	142f0 <memset>
   14c9c:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
   14ca0:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
   14ca4:	4620      	mov	r0, r4
   14ca6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14ca8:	3468      	adds	r4, #104	; 0x68
   14caa:	e7d9      	b.n	14c60 <__sfp+0x1c>
   14cac:	2104      	movs	r1, #4
   14cae:	4638      	mov	r0, r7
   14cb0:	f7ff ff62 	bl	14b78 <__sfmoreglue>
   14cb4:	4604      	mov	r4, r0
   14cb6:	6030      	str	r0, [r6, #0]
   14cb8:	2800      	cmp	r0, #0
   14cba:	d1d5      	bne.n	14c68 <__sfp+0x24>
   14cbc:	f7ff ff78 	bl	14bb0 <__sfp_lock_release>
   14cc0:	230c      	movs	r3, #12
   14cc2:	603b      	str	r3, [r7, #0]
   14cc4:	e7ee      	b.n	14ca4 <__sfp+0x60>
   14cc6:	bf00      	nop
   14cc8:	000168b8 	.word	0x000168b8
   14ccc:	ffff0001 	.word	0xffff0001

00014cd0 <_fwalk_reent>:
   14cd0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   14cd4:	4606      	mov	r6, r0
   14cd6:	4688      	mov	r8, r1
   14cd8:	f100 0448 	add.w	r4, r0, #72	; 0x48
   14cdc:	2700      	movs	r7, #0
   14cde:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
   14ce2:	f1b9 0901 	subs.w	r9, r9, #1
   14ce6:	d505      	bpl.n	14cf4 <_fwalk_reent+0x24>
   14ce8:	6824      	ldr	r4, [r4, #0]
   14cea:	2c00      	cmp	r4, #0
   14cec:	d1f7      	bne.n	14cde <_fwalk_reent+0xe>
   14cee:	4638      	mov	r0, r7
   14cf0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   14cf4:	89ab      	ldrh	r3, [r5, #12]
   14cf6:	2b01      	cmp	r3, #1
   14cf8:	d907      	bls.n	14d0a <_fwalk_reent+0x3a>
   14cfa:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
   14cfe:	3301      	adds	r3, #1
   14d00:	d003      	beq.n	14d0a <_fwalk_reent+0x3a>
   14d02:	4629      	mov	r1, r5
   14d04:	4630      	mov	r0, r6
   14d06:	47c0      	blx	r8
   14d08:	4307      	orrs	r7, r0
   14d0a:	3568      	adds	r5, #104	; 0x68
   14d0c:	e7e9      	b.n	14ce2 <_fwalk_reent+0x12>

00014d0e <__retarget_lock_init_recursive>:
   14d0e:	4770      	bx	lr

00014d10 <__retarget_lock_acquire_recursive>:
   14d10:	4770      	bx	lr

00014d12 <__retarget_lock_release_recursive>:
   14d12:	4770      	bx	lr

00014d14 <__swhatbuf_r>:
   14d14:	b570      	push	{r4, r5, r6, lr}
   14d16:	460e      	mov	r6, r1
   14d18:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   14d1c:	2900      	cmp	r1, #0
   14d1e:	b096      	sub	sp, #88	; 0x58
   14d20:	4614      	mov	r4, r2
   14d22:	461d      	mov	r5, r3
   14d24:	da07      	bge.n	14d36 <__swhatbuf_r+0x22>
   14d26:	2300      	movs	r3, #0
   14d28:	602b      	str	r3, [r5, #0]
   14d2a:	89b3      	ldrh	r3, [r6, #12]
   14d2c:	061a      	lsls	r2, r3, #24
   14d2e:	d410      	bmi.n	14d52 <__swhatbuf_r+0x3e>
   14d30:	f44f 6380 	mov.w	r3, #1024	; 0x400
   14d34:	e00e      	b.n	14d54 <__swhatbuf_r+0x40>
   14d36:	466a      	mov	r2, sp
   14d38:	f000 fd0a 	bl	15750 <_fstat_r>
   14d3c:	2800      	cmp	r0, #0
   14d3e:	dbf2      	blt.n	14d26 <__swhatbuf_r+0x12>
   14d40:	9a01      	ldr	r2, [sp, #4]
   14d42:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
   14d46:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
   14d4a:	425a      	negs	r2, r3
   14d4c:	415a      	adcs	r2, r3
   14d4e:	602a      	str	r2, [r5, #0]
   14d50:	e7ee      	b.n	14d30 <__swhatbuf_r+0x1c>
   14d52:	2340      	movs	r3, #64	; 0x40
   14d54:	2000      	movs	r0, #0
   14d56:	6023      	str	r3, [r4, #0]
   14d58:	b016      	add	sp, #88	; 0x58
   14d5a:	bd70      	pop	{r4, r5, r6, pc}

00014d5c <__smakebuf_r>:
   14d5c:	898b      	ldrh	r3, [r1, #12]
   14d5e:	b573      	push	{r0, r1, r4, r5, r6, lr}
   14d60:	079d      	lsls	r5, r3, #30
   14d62:	4606      	mov	r6, r0
   14d64:	460c      	mov	r4, r1
   14d66:	d507      	bpl.n	14d78 <__smakebuf_r+0x1c>
   14d68:	f104 0347 	add.w	r3, r4, #71	; 0x47
   14d6c:	6023      	str	r3, [r4, #0]
   14d6e:	6123      	str	r3, [r4, #16]
   14d70:	2301      	movs	r3, #1
   14d72:	6163      	str	r3, [r4, #20]
   14d74:	b002      	add	sp, #8
   14d76:	bd70      	pop	{r4, r5, r6, pc}
   14d78:	ab01      	add	r3, sp, #4
   14d7a:	466a      	mov	r2, sp
   14d7c:	f7ff ffca 	bl	14d14 <__swhatbuf_r>
   14d80:	9900      	ldr	r1, [sp, #0]
   14d82:	4605      	mov	r5, r0
   14d84:	4630      	mov	r0, r6
   14d86:	f7ff fb09 	bl	1439c <_malloc_r>
   14d8a:	b948      	cbnz	r0, 14da0 <__smakebuf_r+0x44>
   14d8c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   14d90:	059a      	lsls	r2, r3, #22
   14d92:	d4ef      	bmi.n	14d74 <__smakebuf_r+0x18>
   14d94:	f023 0303 	bic.w	r3, r3, #3
   14d98:	f043 0302 	orr.w	r3, r3, #2
   14d9c:	81a3      	strh	r3, [r4, #12]
   14d9e:	e7e3      	b.n	14d68 <__smakebuf_r+0xc>
   14da0:	4b0d      	ldr	r3, [pc, #52]	; (14dd8 <__smakebuf_r+0x7c>)
   14da2:	62b3      	str	r3, [r6, #40]	; 0x28
   14da4:	89a3      	ldrh	r3, [r4, #12]
   14da6:	6020      	str	r0, [r4, #0]
   14da8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   14dac:	81a3      	strh	r3, [r4, #12]
   14dae:	9b00      	ldr	r3, [sp, #0]
   14db0:	6163      	str	r3, [r4, #20]
   14db2:	9b01      	ldr	r3, [sp, #4]
   14db4:	6120      	str	r0, [r4, #16]
   14db6:	b15b      	cbz	r3, 14dd0 <__smakebuf_r+0x74>
   14db8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   14dbc:	4630      	mov	r0, r6
   14dbe:	f000 fcd9 	bl	15774 <_isatty_r>
   14dc2:	b128      	cbz	r0, 14dd0 <__smakebuf_r+0x74>
   14dc4:	89a3      	ldrh	r3, [r4, #12]
   14dc6:	f023 0303 	bic.w	r3, r3, #3
   14dca:	f043 0301 	orr.w	r3, r3, #1
   14dce:	81a3      	strh	r3, [r4, #12]
   14dd0:	89a0      	ldrh	r0, [r4, #12]
   14dd2:	4305      	orrs	r5, r0
   14dd4:	81a5      	strh	r5, [r4, #12]
   14dd6:	e7cd      	b.n	14d74 <__smakebuf_r+0x18>
   14dd8:	00014b6d 	.word	0x00014b6d

00014ddc <__malloc_lock>:
   14ddc:	4801      	ldr	r0, [pc, #4]	; (14de4 <__malloc_lock+0x8>)
   14dde:	f7ff bf97 	b.w	14d10 <__retarget_lock_acquire_recursive>
   14de2:	bf00      	nop
   14de4:	2001cfd8 	.word	0x2001cfd8

00014de8 <__malloc_unlock>:
   14de8:	4801      	ldr	r0, [pc, #4]	; (14df0 <__malloc_unlock+0x8>)
   14dea:	f7ff bf92 	b.w	14d12 <__retarget_lock_release_recursive>
   14dee:	bf00      	nop
   14df0:	2001cfd8 	.word	0x2001cfd8

00014df4 <__ssputs_r>:
   14df4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14df8:	688e      	ldr	r6, [r1, #8]
   14dfa:	429e      	cmp	r6, r3
   14dfc:	4682      	mov	sl, r0
   14dfe:	460c      	mov	r4, r1
   14e00:	4690      	mov	r8, r2
   14e02:	461f      	mov	r7, r3
   14e04:	d838      	bhi.n	14e78 <__ssputs_r+0x84>
   14e06:	898a      	ldrh	r2, [r1, #12]
   14e08:	f412 6f90 	tst.w	r2, #1152	; 0x480
   14e0c:	d032      	beq.n	14e74 <__ssputs_r+0x80>
   14e0e:	6825      	ldr	r5, [r4, #0]
   14e10:	6909      	ldr	r1, [r1, #16]
   14e12:	eba5 0901 	sub.w	r9, r5, r1
   14e16:	6965      	ldr	r5, [r4, #20]
   14e18:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   14e1c:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   14e20:	3301      	adds	r3, #1
   14e22:	444b      	add	r3, r9
   14e24:	106d      	asrs	r5, r5, #1
   14e26:	429d      	cmp	r5, r3
   14e28:	bf38      	it	cc
   14e2a:	461d      	movcc	r5, r3
   14e2c:	0553      	lsls	r3, r2, #21
   14e2e:	d531      	bpl.n	14e94 <__ssputs_r+0xa0>
   14e30:	4629      	mov	r1, r5
   14e32:	f7ff fab3 	bl	1439c <_malloc_r>
   14e36:	4606      	mov	r6, r0
   14e38:	b950      	cbnz	r0, 14e50 <__ssputs_r+0x5c>
   14e3a:	230c      	movs	r3, #12
   14e3c:	f8ca 3000 	str.w	r3, [sl]
   14e40:	89a3      	ldrh	r3, [r4, #12]
   14e42:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   14e46:	81a3      	strh	r3, [r4, #12]
   14e48:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14e4c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   14e50:	6921      	ldr	r1, [r4, #16]
   14e52:	464a      	mov	r2, r9
   14e54:	f7ff fa3e 	bl	142d4 <memcpy>
   14e58:	89a3      	ldrh	r3, [r4, #12]
   14e5a:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   14e5e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   14e62:	81a3      	strh	r3, [r4, #12]
   14e64:	6126      	str	r6, [r4, #16]
   14e66:	6165      	str	r5, [r4, #20]
   14e68:	444e      	add	r6, r9
   14e6a:	eba5 0509 	sub.w	r5, r5, r9
   14e6e:	6026      	str	r6, [r4, #0]
   14e70:	60a5      	str	r5, [r4, #8]
   14e72:	463e      	mov	r6, r7
   14e74:	42be      	cmp	r6, r7
   14e76:	d900      	bls.n	14e7a <__ssputs_r+0x86>
   14e78:	463e      	mov	r6, r7
   14e7a:	4632      	mov	r2, r6
   14e7c:	6820      	ldr	r0, [r4, #0]
   14e7e:	4641      	mov	r1, r8
   14e80:	f000 fcee 	bl	15860 <memmove>
   14e84:	68a3      	ldr	r3, [r4, #8]
   14e86:	6822      	ldr	r2, [r4, #0]
   14e88:	1b9b      	subs	r3, r3, r6
   14e8a:	4432      	add	r2, r6
   14e8c:	60a3      	str	r3, [r4, #8]
   14e8e:	6022      	str	r2, [r4, #0]
   14e90:	2000      	movs	r0, #0
   14e92:	e7db      	b.n	14e4c <__ssputs_r+0x58>
   14e94:	462a      	mov	r2, r5
   14e96:	f000 fcfd 	bl	15894 <_realloc_r>
   14e9a:	4606      	mov	r6, r0
   14e9c:	2800      	cmp	r0, #0
   14e9e:	d1e1      	bne.n	14e64 <__ssputs_r+0x70>
   14ea0:	6921      	ldr	r1, [r4, #16]
   14ea2:	4650      	mov	r0, sl
   14ea4:	f7ff fa2c 	bl	14300 <_free_r>
   14ea8:	e7c7      	b.n	14e3a <__ssputs_r+0x46>
	...

00014eac <_svfiprintf_r>:
   14eac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14eb0:	4698      	mov	r8, r3
   14eb2:	898b      	ldrh	r3, [r1, #12]
   14eb4:	061b      	lsls	r3, r3, #24
   14eb6:	b09d      	sub	sp, #116	; 0x74
   14eb8:	4607      	mov	r7, r0
   14eba:	460d      	mov	r5, r1
   14ebc:	4614      	mov	r4, r2
   14ebe:	d50e      	bpl.n	14ede <_svfiprintf_r+0x32>
   14ec0:	690b      	ldr	r3, [r1, #16]
   14ec2:	b963      	cbnz	r3, 14ede <_svfiprintf_r+0x32>
   14ec4:	2140      	movs	r1, #64	; 0x40
   14ec6:	f7ff fa69 	bl	1439c <_malloc_r>
   14eca:	6028      	str	r0, [r5, #0]
   14ecc:	6128      	str	r0, [r5, #16]
   14ece:	b920      	cbnz	r0, 14eda <_svfiprintf_r+0x2e>
   14ed0:	230c      	movs	r3, #12
   14ed2:	603b      	str	r3, [r7, #0]
   14ed4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14ed8:	e0d1      	b.n	1507e <_svfiprintf_r+0x1d2>
   14eda:	2340      	movs	r3, #64	; 0x40
   14edc:	616b      	str	r3, [r5, #20]
   14ede:	2300      	movs	r3, #0
   14ee0:	9309      	str	r3, [sp, #36]	; 0x24
   14ee2:	2320      	movs	r3, #32
   14ee4:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   14ee8:	f8cd 800c 	str.w	r8, [sp, #12]
   14eec:	2330      	movs	r3, #48	; 0x30
   14eee:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 15098 <_svfiprintf_r+0x1ec>
   14ef2:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   14ef6:	f04f 0901 	mov.w	r9, #1
   14efa:	4623      	mov	r3, r4
   14efc:	469a      	mov	sl, r3
   14efe:	f813 2b01 	ldrb.w	r2, [r3], #1
   14f02:	b10a      	cbz	r2, 14f08 <_svfiprintf_r+0x5c>
   14f04:	2a25      	cmp	r2, #37	; 0x25
   14f06:	d1f9      	bne.n	14efc <_svfiprintf_r+0x50>
   14f08:	ebba 0b04 	subs.w	fp, sl, r4
   14f0c:	d00b      	beq.n	14f26 <_svfiprintf_r+0x7a>
   14f0e:	465b      	mov	r3, fp
   14f10:	4622      	mov	r2, r4
   14f12:	4629      	mov	r1, r5
   14f14:	4638      	mov	r0, r7
   14f16:	f7ff ff6d 	bl	14df4 <__ssputs_r>
   14f1a:	3001      	adds	r0, #1
   14f1c:	f000 80aa 	beq.w	15074 <_svfiprintf_r+0x1c8>
   14f20:	9a09      	ldr	r2, [sp, #36]	; 0x24
   14f22:	445a      	add	r2, fp
   14f24:	9209      	str	r2, [sp, #36]	; 0x24
   14f26:	f89a 3000 	ldrb.w	r3, [sl]
   14f2a:	2b00      	cmp	r3, #0
   14f2c:	f000 80a2 	beq.w	15074 <_svfiprintf_r+0x1c8>
   14f30:	2300      	movs	r3, #0
   14f32:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   14f36:	e9cd 2305 	strd	r2, r3, [sp, #20]
   14f3a:	f10a 0a01 	add.w	sl, sl, #1
   14f3e:	9304      	str	r3, [sp, #16]
   14f40:	9307      	str	r3, [sp, #28]
   14f42:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   14f46:	931a      	str	r3, [sp, #104]	; 0x68
   14f48:	4654      	mov	r4, sl
   14f4a:	2205      	movs	r2, #5
   14f4c:	f814 1b01 	ldrb.w	r1, [r4], #1
   14f50:	4851      	ldr	r0, [pc, #324]	; (15098 <_svfiprintf_r+0x1ec>)
   14f52:	f000 fc35 	bl	157c0 <memchr>
   14f56:	9a04      	ldr	r2, [sp, #16]
   14f58:	b9d8      	cbnz	r0, 14f92 <_svfiprintf_r+0xe6>
   14f5a:	06d0      	lsls	r0, r2, #27
   14f5c:	bf44      	itt	mi
   14f5e:	2320      	movmi	r3, #32
   14f60:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   14f64:	0711      	lsls	r1, r2, #28
   14f66:	bf44      	itt	mi
   14f68:	232b      	movmi	r3, #43	; 0x2b
   14f6a:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   14f6e:	f89a 3000 	ldrb.w	r3, [sl]
   14f72:	2b2a      	cmp	r3, #42	; 0x2a
   14f74:	d015      	beq.n	14fa2 <_svfiprintf_r+0xf6>
   14f76:	9a07      	ldr	r2, [sp, #28]
   14f78:	4654      	mov	r4, sl
   14f7a:	2000      	movs	r0, #0
   14f7c:	f04f 0c0a 	mov.w	ip, #10
   14f80:	4621      	mov	r1, r4
   14f82:	f811 3b01 	ldrb.w	r3, [r1], #1
   14f86:	3b30      	subs	r3, #48	; 0x30
   14f88:	2b09      	cmp	r3, #9
   14f8a:	d94e      	bls.n	1502a <_svfiprintf_r+0x17e>
   14f8c:	b1b0      	cbz	r0, 14fbc <_svfiprintf_r+0x110>
   14f8e:	9207      	str	r2, [sp, #28]
   14f90:	e014      	b.n	14fbc <_svfiprintf_r+0x110>
   14f92:	eba0 0308 	sub.w	r3, r0, r8
   14f96:	fa09 f303 	lsl.w	r3, r9, r3
   14f9a:	4313      	orrs	r3, r2
   14f9c:	9304      	str	r3, [sp, #16]
   14f9e:	46a2      	mov	sl, r4
   14fa0:	e7d2      	b.n	14f48 <_svfiprintf_r+0x9c>
   14fa2:	9b03      	ldr	r3, [sp, #12]
   14fa4:	1d19      	adds	r1, r3, #4
   14fa6:	681b      	ldr	r3, [r3, #0]
   14fa8:	9103      	str	r1, [sp, #12]
   14faa:	2b00      	cmp	r3, #0
   14fac:	bfbb      	ittet	lt
   14fae:	425b      	neglt	r3, r3
   14fb0:	f042 0202 	orrlt.w	r2, r2, #2
   14fb4:	9307      	strge	r3, [sp, #28]
   14fb6:	9307      	strlt	r3, [sp, #28]
   14fb8:	bfb8      	it	lt
   14fba:	9204      	strlt	r2, [sp, #16]
   14fbc:	7823      	ldrb	r3, [r4, #0]
   14fbe:	2b2e      	cmp	r3, #46	; 0x2e
   14fc0:	d10c      	bne.n	14fdc <_svfiprintf_r+0x130>
   14fc2:	7863      	ldrb	r3, [r4, #1]
   14fc4:	2b2a      	cmp	r3, #42	; 0x2a
   14fc6:	d135      	bne.n	15034 <_svfiprintf_r+0x188>
   14fc8:	9b03      	ldr	r3, [sp, #12]
   14fca:	1d1a      	adds	r2, r3, #4
   14fcc:	681b      	ldr	r3, [r3, #0]
   14fce:	9203      	str	r2, [sp, #12]
   14fd0:	2b00      	cmp	r3, #0
   14fd2:	bfb8      	it	lt
   14fd4:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   14fd8:	3402      	adds	r4, #2
   14fda:	9305      	str	r3, [sp, #20]
   14fdc:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 150a8 <_svfiprintf_r+0x1fc>
   14fe0:	7821      	ldrb	r1, [r4, #0]
   14fe2:	2203      	movs	r2, #3
   14fe4:	4650      	mov	r0, sl
   14fe6:	f000 fbeb 	bl	157c0 <memchr>
   14fea:	b140      	cbz	r0, 14ffe <_svfiprintf_r+0x152>
   14fec:	2340      	movs	r3, #64	; 0x40
   14fee:	eba0 000a 	sub.w	r0, r0, sl
   14ff2:	fa03 f000 	lsl.w	r0, r3, r0
   14ff6:	9b04      	ldr	r3, [sp, #16]
   14ff8:	4303      	orrs	r3, r0
   14ffa:	3401      	adds	r4, #1
   14ffc:	9304      	str	r3, [sp, #16]
   14ffe:	f814 1b01 	ldrb.w	r1, [r4], #1
   15002:	4826      	ldr	r0, [pc, #152]	; (1509c <_svfiprintf_r+0x1f0>)
   15004:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   15008:	2206      	movs	r2, #6
   1500a:	f000 fbd9 	bl	157c0 <memchr>
   1500e:	2800      	cmp	r0, #0
   15010:	d038      	beq.n	15084 <_svfiprintf_r+0x1d8>
   15012:	4b23      	ldr	r3, [pc, #140]	; (150a0 <_svfiprintf_r+0x1f4>)
   15014:	bb1b      	cbnz	r3, 1505e <_svfiprintf_r+0x1b2>
   15016:	9b03      	ldr	r3, [sp, #12]
   15018:	3307      	adds	r3, #7
   1501a:	f023 0307 	bic.w	r3, r3, #7
   1501e:	3308      	adds	r3, #8
   15020:	9303      	str	r3, [sp, #12]
   15022:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15024:	4433      	add	r3, r6
   15026:	9309      	str	r3, [sp, #36]	; 0x24
   15028:	e767      	b.n	14efa <_svfiprintf_r+0x4e>
   1502a:	fb0c 3202 	mla	r2, ip, r2, r3
   1502e:	460c      	mov	r4, r1
   15030:	2001      	movs	r0, #1
   15032:	e7a5      	b.n	14f80 <_svfiprintf_r+0xd4>
   15034:	2300      	movs	r3, #0
   15036:	3401      	adds	r4, #1
   15038:	9305      	str	r3, [sp, #20]
   1503a:	4619      	mov	r1, r3
   1503c:	f04f 0c0a 	mov.w	ip, #10
   15040:	4620      	mov	r0, r4
   15042:	f810 2b01 	ldrb.w	r2, [r0], #1
   15046:	3a30      	subs	r2, #48	; 0x30
   15048:	2a09      	cmp	r2, #9
   1504a:	d903      	bls.n	15054 <_svfiprintf_r+0x1a8>
   1504c:	2b00      	cmp	r3, #0
   1504e:	d0c5      	beq.n	14fdc <_svfiprintf_r+0x130>
   15050:	9105      	str	r1, [sp, #20]
   15052:	e7c3      	b.n	14fdc <_svfiprintf_r+0x130>
   15054:	fb0c 2101 	mla	r1, ip, r1, r2
   15058:	4604      	mov	r4, r0
   1505a:	2301      	movs	r3, #1
   1505c:	e7f0      	b.n	15040 <_svfiprintf_r+0x194>
   1505e:	ab03      	add	r3, sp, #12
   15060:	9300      	str	r3, [sp, #0]
   15062:	462a      	mov	r2, r5
   15064:	4b0f      	ldr	r3, [pc, #60]	; (150a4 <_svfiprintf_r+0x1f8>)
   15066:	a904      	add	r1, sp, #16
   15068:	4638      	mov	r0, r7
   1506a:	f3af 8000 	nop.w
   1506e:	1c42      	adds	r2, r0, #1
   15070:	4606      	mov	r6, r0
   15072:	d1d6      	bne.n	15022 <_svfiprintf_r+0x176>
   15074:	89ab      	ldrh	r3, [r5, #12]
   15076:	065b      	lsls	r3, r3, #25
   15078:	f53f af2c 	bmi.w	14ed4 <_svfiprintf_r+0x28>
   1507c:	9809      	ldr	r0, [sp, #36]	; 0x24
   1507e:	b01d      	add	sp, #116	; 0x74
   15080:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15084:	ab03      	add	r3, sp, #12
   15086:	9300      	str	r3, [sp, #0]
   15088:	462a      	mov	r2, r5
   1508a:	4b06      	ldr	r3, [pc, #24]	; (150a4 <_svfiprintf_r+0x1f8>)
   1508c:	a904      	add	r1, sp, #16
   1508e:	4638      	mov	r0, r7
   15090:	f000 f9d2 	bl	15438 <_printf_i>
   15094:	e7eb      	b.n	1506e <_svfiprintf_r+0x1c2>
   15096:	bf00      	nop
   15098:	0001691c 	.word	0x0001691c
   1509c:	00016926 	.word	0x00016926
   150a0:	00000000 	.word	0x00000000
   150a4:	00014df5 	.word	0x00014df5
   150a8:	00016922 	.word	0x00016922

000150ac <__sfputc_r>:
   150ac:	6893      	ldr	r3, [r2, #8]
   150ae:	3b01      	subs	r3, #1
   150b0:	2b00      	cmp	r3, #0
   150b2:	b410      	push	{r4}
   150b4:	6093      	str	r3, [r2, #8]
   150b6:	da07      	bge.n	150c8 <__sfputc_r+0x1c>
   150b8:	6994      	ldr	r4, [r2, #24]
   150ba:	42a3      	cmp	r3, r4
   150bc:	db01      	blt.n	150c2 <__sfputc_r+0x16>
   150be:	290a      	cmp	r1, #10
   150c0:	d102      	bne.n	150c8 <__sfputc_r+0x1c>
   150c2:	bc10      	pop	{r4}
   150c4:	f7ff bbac 	b.w	14820 <__swbuf_r>
   150c8:	6813      	ldr	r3, [r2, #0]
   150ca:	1c58      	adds	r0, r3, #1
   150cc:	6010      	str	r0, [r2, #0]
   150ce:	7019      	strb	r1, [r3, #0]
   150d0:	4608      	mov	r0, r1
   150d2:	bc10      	pop	{r4}
   150d4:	4770      	bx	lr

000150d6 <__sfputs_r>:
   150d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   150d8:	4606      	mov	r6, r0
   150da:	460f      	mov	r7, r1
   150dc:	4614      	mov	r4, r2
   150de:	18d5      	adds	r5, r2, r3
   150e0:	42ac      	cmp	r4, r5
   150e2:	d101      	bne.n	150e8 <__sfputs_r+0x12>
   150e4:	2000      	movs	r0, #0
   150e6:	e007      	b.n	150f8 <__sfputs_r+0x22>
   150e8:	f814 1b01 	ldrb.w	r1, [r4], #1
   150ec:	463a      	mov	r2, r7
   150ee:	4630      	mov	r0, r6
   150f0:	f7ff ffdc 	bl	150ac <__sfputc_r>
   150f4:	1c43      	adds	r3, r0, #1
   150f6:	d1f3      	bne.n	150e0 <__sfputs_r+0xa>
   150f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

000150fc <_vfiprintf_r>:
   150fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15100:	460d      	mov	r5, r1
   15102:	b09d      	sub	sp, #116	; 0x74
   15104:	4614      	mov	r4, r2
   15106:	4698      	mov	r8, r3
   15108:	4606      	mov	r6, r0
   1510a:	b118      	cbz	r0, 15114 <_vfiprintf_r+0x18>
   1510c:	6983      	ldr	r3, [r0, #24]
   1510e:	b90b      	cbnz	r3, 15114 <_vfiprintf_r+0x18>
   15110:	f7ff fd60 	bl	14bd4 <__sinit>
   15114:	4b89      	ldr	r3, [pc, #548]	; (1533c <_vfiprintf_r+0x240>)
   15116:	429d      	cmp	r5, r3
   15118:	d11b      	bne.n	15152 <_vfiprintf_r+0x56>
   1511a:	6875      	ldr	r5, [r6, #4]
   1511c:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   1511e:	07d9      	lsls	r1, r3, #31
   15120:	d405      	bmi.n	1512e <_vfiprintf_r+0x32>
   15122:	89ab      	ldrh	r3, [r5, #12]
   15124:	059a      	lsls	r2, r3, #22
   15126:	d402      	bmi.n	1512e <_vfiprintf_r+0x32>
   15128:	6da8      	ldr	r0, [r5, #88]	; 0x58
   1512a:	f7ff fdf1 	bl	14d10 <__retarget_lock_acquire_recursive>
   1512e:	89ab      	ldrh	r3, [r5, #12]
   15130:	071b      	lsls	r3, r3, #28
   15132:	d501      	bpl.n	15138 <_vfiprintf_r+0x3c>
   15134:	692b      	ldr	r3, [r5, #16]
   15136:	b9eb      	cbnz	r3, 15174 <_vfiprintf_r+0x78>
   15138:	4629      	mov	r1, r5
   1513a:	4630      	mov	r0, r6
   1513c:	f7ff fbc2 	bl	148c4 <__swsetup_r>
   15140:	b1c0      	cbz	r0, 15174 <_vfiprintf_r+0x78>
   15142:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   15144:	07dc      	lsls	r4, r3, #31
   15146:	d50e      	bpl.n	15166 <_vfiprintf_r+0x6a>
   15148:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1514c:	b01d      	add	sp, #116	; 0x74
   1514e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15152:	4b7b      	ldr	r3, [pc, #492]	; (15340 <_vfiprintf_r+0x244>)
   15154:	429d      	cmp	r5, r3
   15156:	d101      	bne.n	1515c <_vfiprintf_r+0x60>
   15158:	68b5      	ldr	r5, [r6, #8]
   1515a:	e7df      	b.n	1511c <_vfiprintf_r+0x20>
   1515c:	4b79      	ldr	r3, [pc, #484]	; (15344 <_vfiprintf_r+0x248>)
   1515e:	429d      	cmp	r5, r3
   15160:	bf08      	it	eq
   15162:	68f5      	ldreq	r5, [r6, #12]
   15164:	e7da      	b.n	1511c <_vfiprintf_r+0x20>
   15166:	89ab      	ldrh	r3, [r5, #12]
   15168:	0598      	lsls	r0, r3, #22
   1516a:	d4ed      	bmi.n	15148 <_vfiprintf_r+0x4c>
   1516c:	6da8      	ldr	r0, [r5, #88]	; 0x58
   1516e:	f7ff fdd0 	bl	14d12 <__retarget_lock_release_recursive>
   15172:	e7e9      	b.n	15148 <_vfiprintf_r+0x4c>
   15174:	2300      	movs	r3, #0
   15176:	9309      	str	r3, [sp, #36]	; 0x24
   15178:	2320      	movs	r3, #32
   1517a:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   1517e:	f8cd 800c 	str.w	r8, [sp, #12]
   15182:	2330      	movs	r3, #48	; 0x30
   15184:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 15348 <_vfiprintf_r+0x24c>
   15188:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   1518c:	f04f 0901 	mov.w	r9, #1
   15190:	4623      	mov	r3, r4
   15192:	469a      	mov	sl, r3
   15194:	f813 2b01 	ldrb.w	r2, [r3], #1
   15198:	b10a      	cbz	r2, 1519e <_vfiprintf_r+0xa2>
   1519a:	2a25      	cmp	r2, #37	; 0x25
   1519c:	d1f9      	bne.n	15192 <_vfiprintf_r+0x96>
   1519e:	ebba 0b04 	subs.w	fp, sl, r4
   151a2:	d00b      	beq.n	151bc <_vfiprintf_r+0xc0>
   151a4:	465b      	mov	r3, fp
   151a6:	4622      	mov	r2, r4
   151a8:	4629      	mov	r1, r5
   151aa:	4630      	mov	r0, r6
   151ac:	f7ff ff93 	bl	150d6 <__sfputs_r>
   151b0:	3001      	adds	r0, #1
   151b2:	f000 80aa 	beq.w	1530a <_vfiprintf_r+0x20e>
   151b6:	9a09      	ldr	r2, [sp, #36]	; 0x24
   151b8:	445a      	add	r2, fp
   151ba:	9209      	str	r2, [sp, #36]	; 0x24
   151bc:	f89a 3000 	ldrb.w	r3, [sl]
   151c0:	2b00      	cmp	r3, #0
   151c2:	f000 80a2 	beq.w	1530a <_vfiprintf_r+0x20e>
   151c6:	2300      	movs	r3, #0
   151c8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   151cc:	e9cd 2305 	strd	r2, r3, [sp, #20]
   151d0:	f10a 0a01 	add.w	sl, sl, #1
   151d4:	9304      	str	r3, [sp, #16]
   151d6:	9307      	str	r3, [sp, #28]
   151d8:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   151dc:	931a      	str	r3, [sp, #104]	; 0x68
   151de:	4654      	mov	r4, sl
   151e0:	2205      	movs	r2, #5
   151e2:	f814 1b01 	ldrb.w	r1, [r4], #1
   151e6:	4858      	ldr	r0, [pc, #352]	; (15348 <_vfiprintf_r+0x24c>)
   151e8:	f000 faea 	bl	157c0 <memchr>
   151ec:	9a04      	ldr	r2, [sp, #16]
   151ee:	b9d8      	cbnz	r0, 15228 <_vfiprintf_r+0x12c>
   151f0:	06d1      	lsls	r1, r2, #27
   151f2:	bf44      	itt	mi
   151f4:	2320      	movmi	r3, #32
   151f6:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   151fa:	0713      	lsls	r3, r2, #28
   151fc:	bf44      	itt	mi
   151fe:	232b      	movmi	r3, #43	; 0x2b
   15200:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   15204:	f89a 3000 	ldrb.w	r3, [sl]
   15208:	2b2a      	cmp	r3, #42	; 0x2a
   1520a:	d015      	beq.n	15238 <_vfiprintf_r+0x13c>
   1520c:	9a07      	ldr	r2, [sp, #28]
   1520e:	4654      	mov	r4, sl
   15210:	2000      	movs	r0, #0
   15212:	f04f 0c0a 	mov.w	ip, #10
   15216:	4621      	mov	r1, r4
   15218:	f811 3b01 	ldrb.w	r3, [r1], #1
   1521c:	3b30      	subs	r3, #48	; 0x30
   1521e:	2b09      	cmp	r3, #9
   15220:	d94e      	bls.n	152c0 <_vfiprintf_r+0x1c4>
   15222:	b1b0      	cbz	r0, 15252 <_vfiprintf_r+0x156>
   15224:	9207      	str	r2, [sp, #28]
   15226:	e014      	b.n	15252 <_vfiprintf_r+0x156>
   15228:	eba0 0308 	sub.w	r3, r0, r8
   1522c:	fa09 f303 	lsl.w	r3, r9, r3
   15230:	4313      	orrs	r3, r2
   15232:	9304      	str	r3, [sp, #16]
   15234:	46a2      	mov	sl, r4
   15236:	e7d2      	b.n	151de <_vfiprintf_r+0xe2>
   15238:	9b03      	ldr	r3, [sp, #12]
   1523a:	1d19      	adds	r1, r3, #4
   1523c:	681b      	ldr	r3, [r3, #0]
   1523e:	9103      	str	r1, [sp, #12]
   15240:	2b00      	cmp	r3, #0
   15242:	bfbb      	ittet	lt
   15244:	425b      	neglt	r3, r3
   15246:	f042 0202 	orrlt.w	r2, r2, #2
   1524a:	9307      	strge	r3, [sp, #28]
   1524c:	9307      	strlt	r3, [sp, #28]
   1524e:	bfb8      	it	lt
   15250:	9204      	strlt	r2, [sp, #16]
   15252:	7823      	ldrb	r3, [r4, #0]
   15254:	2b2e      	cmp	r3, #46	; 0x2e
   15256:	d10c      	bne.n	15272 <_vfiprintf_r+0x176>
   15258:	7863      	ldrb	r3, [r4, #1]
   1525a:	2b2a      	cmp	r3, #42	; 0x2a
   1525c:	d135      	bne.n	152ca <_vfiprintf_r+0x1ce>
   1525e:	9b03      	ldr	r3, [sp, #12]
   15260:	1d1a      	adds	r2, r3, #4
   15262:	681b      	ldr	r3, [r3, #0]
   15264:	9203      	str	r2, [sp, #12]
   15266:	2b00      	cmp	r3, #0
   15268:	bfb8      	it	lt
   1526a:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   1526e:	3402      	adds	r4, #2
   15270:	9305      	str	r3, [sp, #20]
   15272:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 15358 <_vfiprintf_r+0x25c>
   15276:	7821      	ldrb	r1, [r4, #0]
   15278:	2203      	movs	r2, #3
   1527a:	4650      	mov	r0, sl
   1527c:	f000 faa0 	bl	157c0 <memchr>
   15280:	b140      	cbz	r0, 15294 <_vfiprintf_r+0x198>
   15282:	2340      	movs	r3, #64	; 0x40
   15284:	eba0 000a 	sub.w	r0, r0, sl
   15288:	fa03 f000 	lsl.w	r0, r3, r0
   1528c:	9b04      	ldr	r3, [sp, #16]
   1528e:	4303      	orrs	r3, r0
   15290:	3401      	adds	r4, #1
   15292:	9304      	str	r3, [sp, #16]
   15294:	f814 1b01 	ldrb.w	r1, [r4], #1
   15298:	482c      	ldr	r0, [pc, #176]	; (1534c <_vfiprintf_r+0x250>)
   1529a:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   1529e:	2206      	movs	r2, #6
   152a0:	f000 fa8e 	bl	157c0 <memchr>
   152a4:	2800      	cmp	r0, #0
   152a6:	d03f      	beq.n	15328 <_vfiprintf_r+0x22c>
   152a8:	4b29      	ldr	r3, [pc, #164]	; (15350 <_vfiprintf_r+0x254>)
   152aa:	bb1b      	cbnz	r3, 152f4 <_vfiprintf_r+0x1f8>
   152ac:	9b03      	ldr	r3, [sp, #12]
   152ae:	3307      	adds	r3, #7
   152b0:	f023 0307 	bic.w	r3, r3, #7
   152b4:	3308      	adds	r3, #8
   152b6:	9303      	str	r3, [sp, #12]
   152b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   152ba:	443b      	add	r3, r7
   152bc:	9309      	str	r3, [sp, #36]	; 0x24
   152be:	e767      	b.n	15190 <_vfiprintf_r+0x94>
   152c0:	fb0c 3202 	mla	r2, ip, r2, r3
   152c4:	460c      	mov	r4, r1
   152c6:	2001      	movs	r0, #1
   152c8:	e7a5      	b.n	15216 <_vfiprintf_r+0x11a>
   152ca:	2300      	movs	r3, #0
   152cc:	3401      	adds	r4, #1
   152ce:	9305      	str	r3, [sp, #20]
   152d0:	4619      	mov	r1, r3
   152d2:	f04f 0c0a 	mov.w	ip, #10
   152d6:	4620      	mov	r0, r4
   152d8:	f810 2b01 	ldrb.w	r2, [r0], #1
   152dc:	3a30      	subs	r2, #48	; 0x30
   152de:	2a09      	cmp	r2, #9
   152e0:	d903      	bls.n	152ea <_vfiprintf_r+0x1ee>
   152e2:	2b00      	cmp	r3, #0
   152e4:	d0c5      	beq.n	15272 <_vfiprintf_r+0x176>
   152e6:	9105      	str	r1, [sp, #20]
   152e8:	e7c3      	b.n	15272 <_vfiprintf_r+0x176>
   152ea:	fb0c 2101 	mla	r1, ip, r1, r2
   152ee:	4604      	mov	r4, r0
   152f0:	2301      	movs	r3, #1
   152f2:	e7f0      	b.n	152d6 <_vfiprintf_r+0x1da>
   152f4:	ab03      	add	r3, sp, #12
   152f6:	9300      	str	r3, [sp, #0]
   152f8:	462a      	mov	r2, r5
   152fa:	4b16      	ldr	r3, [pc, #88]	; (15354 <_vfiprintf_r+0x258>)
   152fc:	a904      	add	r1, sp, #16
   152fe:	4630      	mov	r0, r6
   15300:	f3af 8000 	nop.w
   15304:	4607      	mov	r7, r0
   15306:	1c78      	adds	r0, r7, #1
   15308:	d1d6      	bne.n	152b8 <_vfiprintf_r+0x1bc>
   1530a:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   1530c:	07d9      	lsls	r1, r3, #31
   1530e:	d405      	bmi.n	1531c <_vfiprintf_r+0x220>
   15310:	89ab      	ldrh	r3, [r5, #12]
   15312:	059a      	lsls	r2, r3, #22
   15314:	d402      	bmi.n	1531c <_vfiprintf_r+0x220>
   15316:	6da8      	ldr	r0, [r5, #88]	; 0x58
   15318:	f7ff fcfb 	bl	14d12 <__retarget_lock_release_recursive>
   1531c:	89ab      	ldrh	r3, [r5, #12]
   1531e:	065b      	lsls	r3, r3, #25
   15320:	f53f af12 	bmi.w	15148 <_vfiprintf_r+0x4c>
   15324:	9809      	ldr	r0, [sp, #36]	; 0x24
   15326:	e711      	b.n	1514c <_vfiprintf_r+0x50>
   15328:	ab03      	add	r3, sp, #12
   1532a:	9300      	str	r3, [sp, #0]
   1532c:	462a      	mov	r2, r5
   1532e:	4b09      	ldr	r3, [pc, #36]	; (15354 <_vfiprintf_r+0x258>)
   15330:	a904      	add	r1, sp, #16
   15332:	4630      	mov	r0, r6
   15334:	f000 f880 	bl	15438 <_printf_i>
   15338:	e7e4      	b.n	15304 <_vfiprintf_r+0x208>
   1533a:	bf00      	nop
   1533c:	000168dc 	.word	0x000168dc
   15340:	000168fc 	.word	0x000168fc
   15344:	000168bc 	.word	0x000168bc
   15348:	0001691c 	.word	0x0001691c
   1534c:	00016926 	.word	0x00016926
   15350:	00000000 	.word	0x00000000
   15354:	000150d7 	.word	0x000150d7
   15358:	00016922 	.word	0x00016922

0001535c <_printf_common>:
   1535c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   15360:	4616      	mov	r6, r2
   15362:	4699      	mov	r9, r3
   15364:	688a      	ldr	r2, [r1, #8]
   15366:	690b      	ldr	r3, [r1, #16]
   15368:	f8dd 8020 	ldr.w	r8, [sp, #32]
   1536c:	4293      	cmp	r3, r2
   1536e:	bfb8      	it	lt
   15370:	4613      	movlt	r3, r2
   15372:	6033      	str	r3, [r6, #0]
   15374:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
   15378:	4607      	mov	r7, r0
   1537a:	460c      	mov	r4, r1
   1537c:	b10a      	cbz	r2, 15382 <_printf_common+0x26>
   1537e:	3301      	adds	r3, #1
   15380:	6033      	str	r3, [r6, #0]
   15382:	6823      	ldr	r3, [r4, #0]
   15384:	0699      	lsls	r1, r3, #26
   15386:	bf42      	ittt	mi
   15388:	6833      	ldrmi	r3, [r6, #0]
   1538a:	3302      	addmi	r3, #2
   1538c:	6033      	strmi	r3, [r6, #0]
   1538e:	6825      	ldr	r5, [r4, #0]
   15390:	f015 0506 	ands.w	r5, r5, #6
   15394:	d106      	bne.n	153a4 <_printf_common+0x48>
   15396:	f104 0a19 	add.w	sl, r4, #25
   1539a:	68e3      	ldr	r3, [r4, #12]
   1539c:	6832      	ldr	r2, [r6, #0]
   1539e:	1a9b      	subs	r3, r3, r2
   153a0:	42ab      	cmp	r3, r5
   153a2:	dc26      	bgt.n	153f2 <_printf_common+0x96>
   153a4:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
   153a8:	1e13      	subs	r3, r2, #0
   153aa:	6822      	ldr	r2, [r4, #0]
   153ac:	bf18      	it	ne
   153ae:	2301      	movne	r3, #1
   153b0:	0692      	lsls	r2, r2, #26
   153b2:	d42b      	bmi.n	1540c <_printf_common+0xb0>
   153b4:	f104 0243 	add.w	r2, r4, #67	; 0x43
   153b8:	4649      	mov	r1, r9
   153ba:	4638      	mov	r0, r7
   153bc:	47c0      	blx	r8
   153be:	3001      	adds	r0, #1
   153c0:	d01e      	beq.n	15400 <_printf_common+0xa4>
   153c2:	6823      	ldr	r3, [r4, #0]
   153c4:	68e5      	ldr	r5, [r4, #12]
   153c6:	6832      	ldr	r2, [r6, #0]
   153c8:	f003 0306 	and.w	r3, r3, #6
   153cc:	2b04      	cmp	r3, #4
   153ce:	bf08      	it	eq
   153d0:	1aad      	subeq	r5, r5, r2
   153d2:	68a3      	ldr	r3, [r4, #8]
   153d4:	6922      	ldr	r2, [r4, #16]
   153d6:	bf0c      	ite	eq
   153d8:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
   153dc:	2500      	movne	r5, #0
   153de:	4293      	cmp	r3, r2
   153e0:	bfc4      	itt	gt
   153e2:	1a9b      	subgt	r3, r3, r2
   153e4:	18ed      	addgt	r5, r5, r3
   153e6:	2600      	movs	r6, #0
   153e8:	341a      	adds	r4, #26
   153ea:	42b5      	cmp	r5, r6
   153ec:	d11a      	bne.n	15424 <_printf_common+0xc8>
   153ee:	2000      	movs	r0, #0
   153f0:	e008      	b.n	15404 <_printf_common+0xa8>
   153f2:	2301      	movs	r3, #1
   153f4:	4652      	mov	r2, sl
   153f6:	4649      	mov	r1, r9
   153f8:	4638      	mov	r0, r7
   153fa:	47c0      	blx	r8
   153fc:	3001      	adds	r0, #1
   153fe:	d103      	bne.n	15408 <_printf_common+0xac>
   15400:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15404:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   15408:	3501      	adds	r5, #1
   1540a:	e7c6      	b.n	1539a <_printf_common+0x3e>
   1540c:	18e1      	adds	r1, r4, r3
   1540e:	1c5a      	adds	r2, r3, #1
   15410:	2030      	movs	r0, #48	; 0x30
   15412:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
   15416:	4422      	add	r2, r4
   15418:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
   1541c:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
   15420:	3302      	adds	r3, #2
   15422:	e7c7      	b.n	153b4 <_printf_common+0x58>
   15424:	2301      	movs	r3, #1
   15426:	4622      	mov	r2, r4
   15428:	4649      	mov	r1, r9
   1542a:	4638      	mov	r0, r7
   1542c:	47c0      	blx	r8
   1542e:	3001      	adds	r0, #1
   15430:	d0e6      	beq.n	15400 <_printf_common+0xa4>
   15432:	3601      	adds	r6, #1
   15434:	e7d9      	b.n	153ea <_printf_common+0x8e>
	...

00015438 <_printf_i>:
   15438:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   1543c:	460c      	mov	r4, r1
   1543e:	4691      	mov	r9, r2
   15440:	7e27      	ldrb	r7, [r4, #24]
   15442:	990c      	ldr	r1, [sp, #48]	; 0x30
   15444:	2f78      	cmp	r7, #120	; 0x78
   15446:	4680      	mov	r8, r0
   15448:	469a      	mov	sl, r3
   1544a:	f104 0243 	add.w	r2, r4, #67	; 0x43
   1544e:	d807      	bhi.n	15460 <_printf_i+0x28>
   15450:	2f62      	cmp	r7, #98	; 0x62
   15452:	d80a      	bhi.n	1546a <_printf_i+0x32>
   15454:	2f00      	cmp	r7, #0
   15456:	f000 80d8 	beq.w	1560a <_printf_i+0x1d2>
   1545a:	2f58      	cmp	r7, #88	; 0x58
   1545c:	f000 80a3 	beq.w	155a6 <_printf_i+0x16e>
   15460:	f104 0642 	add.w	r6, r4, #66	; 0x42
   15464:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
   15468:	e03a      	b.n	154e0 <_printf_i+0xa8>
   1546a:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
   1546e:	2b15      	cmp	r3, #21
   15470:	d8f6      	bhi.n	15460 <_printf_i+0x28>
   15472:	a001      	add	r0, pc, #4	; (adr r0, 15478 <_printf_i+0x40>)
   15474:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
   15478:	000154d1 	.word	0x000154d1
   1547c:	000154e5 	.word	0x000154e5
   15480:	00015461 	.word	0x00015461
   15484:	00015461 	.word	0x00015461
   15488:	00015461 	.word	0x00015461
   1548c:	00015461 	.word	0x00015461
   15490:	000154e5 	.word	0x000154e5
   15494:	00015461 	.word	0x00015461
   15498:	00015461 	.word	0x00015461
   1549c:	00015461 	.word	0x00015461
   154a0:	00015461 	.word	0x00015461
   154a4:	000155f1 	.word	0x000155f1
   154a8:	00015515 	.word	0x00015515
   154ac:	000155d3 	.word	0x000155d3
   154b0:	00015461 	.word	0x00015461
   154b4:	00015461 	.word	0x00015461
   154b8:	00015613 	.word	0x00015613
   154bc:	00015461 	.word	0x00015461
   154c0:	00015515 	.word	0x00015515
   154c4:	00015461 	.word	0x00015461
   154c8:	00015461 	.word	0x00015461
   154cc:	000155db 	.word	0x000155db
   154d0:	680b      	ldr	r3, [r1, #0]
   154d2:	1d1a      	adds	r2, r3, #4
   154d4:	681b      	ldr	r3, [r3, #0]
   154d6:	600a      	str	r2, [r1, #0]
   154d8:	f104 0642 	add.w	r6, r4, #66	; 0x42
   154dc:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
   154e0:	2301      	movs	r3, #1
   154e2:	e0a3      	b.n	1562c <_printf_i+0x1f4>
   154e4:	6825      	ldr	r5, [r4, #0]
   154e6:	6808      	ldr	r0, [r1, #0]
   154e8:	062e      	lsls	r6, r5, #24
   154ea:	f100 0304 	add.w	r3, r0, #4
   154ee:	d50a      	bpl.n	15506 <_printf_i+0xce>
   154f0:	6805      	ldr	r5, [r0, #0]
   154f2:	600b      	str	r3, [r1, #0]
   154f4:	2d00      	cmp	r5, #0
   154f6:	da03      	bge.n	15500 <_printf_i+0xc8>
   154f8:	232d      	movs	r3, #45	; 0x2d
   154fa:	426d      	negs	r5, r5
   154fc:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   15500:	485e      	ldr	r0, [pc, #376]	; (1567c <_printf_i+0x244>)
   15502:	230a      	movs	r3, #10
   15504:	e019      	b.n	1553a <_printf_i+0x102>
   15506:	f015 0f40 	tst.w	r5, #64	; 0x40
   1550a:	6805      	ldr	r5, [r0, #0]
   1550c:	600b      	str	r3, [r1, #0]
   1550e:	bf18      	it	ne
   15510:	b22d      	sxthne	r5, r5
   15512:	e7ef      	b.n	154f4 <_printf_i+0xbc>
   15514:	680b      	ldr	r3, [r1, #0]
   15516:	6825      	ldr	r5, [r4, #0]
   15518:	1d18      	adds	r0, r3, #4
   1551a:	6008      	str	r0, [r1, #0]
   1551c:	0628      	lsls	r0, r5, #24
   1551e:	d501      	bpl.n	15524 <_printf_i+0xec>
   15520:	681d      	ldr	r5, [r3, #0]
   15522:	e002      	b.n	1552a <_printf_i+0xf2>
   15524:	0669      	lsls	r1, r5, #25
   15526:	d5fb      	bpl.n	15520 <_printf_i+0xe8>
   15528:	881d      	ldrh	r5, [r3, #0]
   1552a:	4854      	ldr	r0, [pc, #336]	; (1567c <_printf_i+0x244>)
   1552c:	2f6f      	cmp	r7, #111	; 0x6f
   1552e:	bf0c      	ite	eq
   15530:	2308      	moveq	r3, #8
   15532:	230a      	movne	r3, #10
   15534:	2100      	movs	r1, #0
   15536:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
   1553a:	6866      	ldr	r6, [r4, #4]
   1553c:	60a6      	str	r6, [r4, #8]
   1553e:	2e00      	cmp	r6, #0
   15540:	bfa2      	ittt	ge
   15542:	6821      	ldrge	r1, [r4, #0]
   15544:	f021 0104 	bicge.w	r1, r1, #4
   15548:	6021      	strge	r1, [r4, #0]
   1554a:	b90d      	cbnz	r5, 15550 <_printf_i+0x118>
   1554c:	2e00      	cmp	r6, #0
   1554e:	d04d      	beq.n	155ec <_printf_i+0x1b4>
   15550:	4616      	mov	r6, r2
   15552:	fbb5 f1f3 	udiv	r1, r5, r3
   15556:	fb03 5711 	mls	r7, r3, r1, r5
   1555a:	5dc7      	ldrb	r7, [r0, r7]
   1555c:	f806 7d01 	strb.w	r7, [r6, #-1]!
   15560:	462f      	mov	r7, r5
   15562:	42bb      	cmp	r3, r7
   15564:	460d      	mov	r5, r1
   15566:	d9f4      	bls.n	15552 <_printf_i+0x11a>
   15568:	2b08      	cmp	r3, #8
   1556a:	d10b      	bne.n	15584 <_printf_i+0x14c>
   1556c:	6823      	ldr	r3, [r4, #0]
   1556e:	07df      	lsls	r7, r3, #31
   15570:	d508      	bpl.n	15584 <_printf_i+0x14c>
   15572:	6923      	ldr	r3, [r4, #16]
   15574:	6861      	ldr	r1, [r4, #4]
   15576:	4299      	cmp	r1, r3
   15578:	bfde      	ittt	le
   1557a:	2330      	movle	r3, #48	; 0x30
   1557c:	f806 3c01 	strble.w	r3, [r6, #-1]
   15580:	f106 36ff 	addle.w	r6, r6, #4294967295	; 0xffffffff
   15584:	1b92      	subs	r2, r2, r6
   15586:	6122      	str	r2, [r4, #16]
   15588:	f8cd a000 	str.w	sl, [sp]
   1558c:	464b      	mov	r3, r9
   1558e:	aa03      	add	r2, sp, #12
   15590:	4621      	mov	r1, r4
   15592:	4640      	mov	r0, r8
   15594:	f7ff fee2 	bl	1535c <_printf_common>
   15598:	3001      	adds	r0, #1
   1559a:	d14c      	bne.n	15636 <_printf_i+0x1fe>
   1559c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   155a0:	b004      	add	sp, #16
   155a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   155a6:	4835      	ldr	r0, [pc, #212]	; (1567c <_printf_i+0x244>)
   155a8:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
   155ac:	6823      	ldr	r3, [r4, #0]
   155ae:	680e      	ldr	r6, [r1, #0]
   155b0:	061f      	lsls	r7, r3, #24
   155b2:	f856 5b04 	ldr.w	r5, [r6], #4
   155b6:	600e      	str	r6, [r1, #0]
   155b8:	d514      	bpl.n	155e4 <_printf_i+0x1ac>
   155ba:	07d9      	lsls	r1, r3, #31
   155bc:	bf44      	itt	mi
   155be:	f043 0320 	orrmi.w	r3, r3, #32
   155c2:	6023      	strmi	r3, [r4, #0]
   155c4:	b91d      	cbnz	r5, 155ce <_printf_i+0x196>
   155c6:	6823      	ldr	r3, [r4, #0]
   155c8:	f023 0320 	bic.w	r3, r3, #32
   155cc:	6023      	str	r3, [r4, #0]
   155ce:	2310      	movs	r3, #16
   155d0:	e7b0      	b.n	15534 <_printf_i+0xfc>
   155d2:	6823      	ldr	r3, [r4, #0]
   155d4:	f043 0320 	orr.w	r3, r3, #32
   155d8:	6023      	str	r3, [r4, #0]
   155da:	2378      	movs	r3, #120	; 0x78
   155dc:	4828      	ldr	r0, [pc, #160]	; (15680 <_printf_i+0x248>)
   155de:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
   155e2:	e7e3      	b.n	155ac <_printf_i+0x174>
   155e4:	065e      	lsls	r6, r3, #25
   155e6:	bf48      	it	mi
   155e8:	b2ad      	uxthmi	r5, r5
   155ea:	e7e6      	b.n	155ba <_printf_i+0x182>
   155ec:	4616      	mov	r6, r2
   155ee:	e7bb      	b.n	15568 <_printf_i+0x130>
   155f0:	680b      	ldr	r3, [r1, #0]
   155f2:	6826      	ldr	r6, [r4, #0]
   155f4:	6960      	ldr	r0, [r4, #20]
   155f6:	1d1d      	adds	r5, r3, #4
   155f8:	600d      	str	r5, [r1, #0]
   155fa:	0635      	lsls	r5, r6, #24
   155fc:	681b      	ldr	r3, [r3, #0]
   155fe:	d501      	bpl.n	15604 <_printf_i+0x1cc>
   15600:	6018      	str	r0, [r3, #0]
   15602:	e002      	b.n	1560a <_printf_i+0x1d2>
   15604:	0671      	lsls	r1, r6, #25
   15606:	d5fb      	bpl.n	15600 <_printf_i+0x1c8>
   15608:	8018      	strh	r0, [r3, #0]
   1560a:	2300      	movs	r3, #0
   1560c:	6123      	str	r3, [r4, #16]
   1560e:	4616      	mov	r6, r2
   15610:	e7ba      	b.n	15588 <_printf_i+0x150>
   15612:	680b      	ldr	r3, [r1, #0]
   15614:	1d1a      	adds	r2, r3, #4
   15616:	600a      	str	r2, [r1, #0]
   15618:	681e      	ldr	r6, [r3, #0]
   1561a:	6862      	ldr	r2, [r4, #4]
   1561c:	2100      	movs	r1, #0
   1561e:	4630      	mov	r0, r6
   15620:	f000 f8ce 	bl	157c0 <memchr>
   15624:	b108      	cbz	r0, 1562a <_printf_i+0x1f2>
   15626:	1b80      	subs	r0, r0, r6
   15628:	6060      	str	r0, [r4, #4]
   1562a:	6863      	ldr	r3, [r4, #4]
   1562c:	6123      	str	r3, [r4, #16]
   1562e:	2300      	movs	r3, #0
   15630:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   15634:	e7a8      	b.n	15588 <_printf_i+0x150>
   15636:	6923      	ldr	r3, [r4, #16]
   15638:	4632      	mov	r2, r6
   1563a:	4649      	mov	r1, r9
   1563c:	4640      	mov	r0, r8
   1563e:	47d0      	blx	sl
   15640:	3001      	adds	r0, #1
   15642:	d0ab      	beq.n	1559c <_printf_i+0x164>
   15644:	6823      	ldr	r3, [r4, #0]
   15646:	079b      	lsls	r3, r3, #30
   15648:	d413      	bmi.n	15672 <_printf_i+0x23a>
   1564a:	68e0      	ldr	r0, [r4, #12]
   1564c:	9b03      	ldr	r3, [sp, #12]
   1564e:	4298      	cmp	r0, r3
   15650:	bfb8      	it	lt
   15652:	4618      	movlt	r0, r3
   15654:	e7a4      	b.n	155a0 <_printf_i+0x168>
   15656:	2301      	movs	r3, #1
   15658:	4632      	mov	r2, r6
   1565a:	4649      	mov	r1, r9
   1565c:	4640      	mov	r0, r8
   1565e:	47d0      	blx	sl
   15660:	3001      	adds	r0, #1
   15662:	d09b      	beq.n	1559c <_printf_i+0x164>
   15664:	3501      	adds	r5, #1
   15666:	68e3      	ldr	r3, [r4, #12]
   15668:	9903      	ldr	r1, [sp, #12]
   1566a:	1a5b      	subs	r3, r3, r1
   1566c:	42ab      	cmp	r3, r5
   1566e:	dcf2      	bgt.n	15656 <_printf_i+0x21e>
   15670:	e7eb      	b.n	1564a <_printf_i+0x212>
   15672:	2500      	movs	r5, #0
   15674:	f104 0619 	add.w	r6, r4, #25
   15678:	e7f5      	b.n	15666 <_printf_i+0x22e>
   1567a:	bf00      	nop
   1567c:	0001692d 	.word	0x0001692d
   15680:	0001693e 	.word	0x0001693e

00015684 <__sread>:
   15684:	b510      	push	{r4, lr}
   15686:	460c      	mov	r4, r1
   15688:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   1568c:	f000 f928 	bl	158e0 <_read_r>
   15690:	2800      	cmp	r0, #0
   15692:	bfab      	itete	ge
   15694:	6d63      	ldrge	r3, [r4, #84]	; 0x54
   15696:	89a3      	ldrhlt	r3, [r4, #12]
   15698:	181b      	addge	r3, r3, r0
   1569a:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
   1569e:	bfac      	ite	ge
   156a0:	6563      	strge	r3, [r4, #84]	; 0x54
   156a2:	81a3      	strhlt	r3, [r4, #12]
   156a4:	bd10      	pop	{r4, pc}

000156a6 <__swrite>:
   156a6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   156aa:	461f      	mov	r7, r3
   156ac:	898b      	ldrh	r3, [r1, #12]
   156ae:	05db      	lsls	r3, r3, #23
   156b0:	4605      	mov	r5, r0
   156b2:	460c      	mov	r4, r1
   156b4:	4616      	mov	r6, r2
   156b6:	d505      	bpl.n	156c4 <__swrite+0x1e>
   156b8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   156bc:	2302      	movs	r3, #2
   156be:	2200      	movs	r2, #0
   156c0:	f000 f868 	bl	15794 <_lseek_r>
   156c4:	89a3      	ldrh	r3, [r4, #12]
   156c6:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   156ca:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   156ce:	81a3      	strh	r3, [r4, #12]
   156d0:	4632      	mov	r2, r6
   156d2:	463b      	mov	r3, r7
   156d4:	4628      	mov	r0, r5
   156d6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   156da:	f000 b817 	b.w	1570c <_write_r>

000156de <__sseek>:
   156de:	b510      	push	{r4, lr}
   156e0:	460c      	mov	r4, r1
   156e2:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   156e6:	f000 f855 	bl	15794 <_lseek_r>
   156ea:	1c43      	adds	r3, r0, #1
   156ec:	89a3      	ldrh	r3, [r4, #12]
   156ee:	bf15      	itete	ne
   156f0:	6560      	strne	r0, [r4, #84]	; 0x54
   156f2:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   156f6:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
   156fa:	81a3      	strheq	r3, [r4, #12]
   156fc:	bf18      	it	ne
   156fe:	81a3      	strhne	r3, [r4, #12]
   15700:	bd10      	pop	{r4, pc}

00015702 <__sclose>:
   15702:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   15706:	f000 b813 	b.w	15730 <_close_r>
	...

0001570c <_write_r>:
   1570c:	b538      	push	{r3, r4, r5, lr}
   1570e:	4d07      	ldr	r5, [pc, #28]	; (1572c <_write_r+0x20>)
   15710:	4604      	mov	r4, r0
   15712:	4608      	mov	r0, r1
   15714:	4611      	mov	r1, r2
   15716:	2200      	movs	r2, #0
   15718:	602a      	str	r2, [r5, #0]
   1571a:	461a      	mov	r2, r3
   1571c:	f7f6 f984 	bl	ba28 <_write>
   15720:	1c43      	adds	r3, r0, #1
   15722:	d102      	bne.n	1572a <_write_r+0x1e>
   15724:	682b      	ldr	r3, [r5, #0]
   15726:	b103      	cbz	r3, 1572a <_write_r+0x1e>
   15728:	6023      	str	r3, [r4, #0]
   1572a:	bd38      	pop	{r3, r4, r5, pc}
   1572c:	2001cfe0 	.word	0x2001cfe0

00015730 <_close_r>:
   15730:	b538      	push	{r3, r4, r5, lr}
   15732:	4d06      	ldr	r5, [pc, #24]	; (1574c <_close_r+0x1c>)
   15734:	2300      	movs	r3, #0
   15736:	4604      	mov	r4, r0
   15738:	4608      	mov	r0, r1
   1573a:	602b      	str	r3, [r5, #0]
   1573c:	f7f6 fb4c 	bl	bdd8 <_close>
   15740:	1c43      	adds	r3, r0, #1
   15742:	d102      	bne.n	1574a <_close_r+0x1a>
   15744:	682b      	ldr	r3, [r5, #0]
   15746:	b103      	cbz	r3, 1574a <_close_r+0x1a>
   15748:	6023      	str	r3, [r4, #0]
   1574a:	bd38      	pop	{r3, r4, r5, pc}
   1574c:	2001cfe0 	.word	0x2001cfe0

00015750 <_fstat_r>:
   15750:	b538      	push	{r3, r4, r5, lr}
   15752:	4d07      	ldr	r5, [pc, #28]	; (15770 <_fstat_r+0x20>)
   15754:	2300      	movs	r3, #0
   15756:	4604      	mov	r4, r0
   15758:	4608      	mov	r0, r1
   1575a:	4611      	mov	r1, r2
   1575c:	602b      	str	r3, [r5, #0]
   1575e:	f7f6 fb3e 	bl	bdde <_fstat>
   15762:	1c43      	adds	r3, r0, #1
   15764:	d102      	bne.n	1576c <_fstat_r+0x1c>
   15766:	682b      	ldr	r3, [r5, #0]
   15768:	b103      	cbz	r3, 1576c <_fstat_r+0x1c>
   1576a:	6023      	str	r3, [r4, #0]
   1576c:	bd38      	pop	{r3, r4, r5, pc}
   1576e:	bf00      	nop
   15770:	2001cfe0 	.word	0x2001cfe0

00015774 <_isatty_r>:
   15774:	b538      	push	{r3, r4, r5, lr}
   15776:	4d06      	ldr	r5, [pc, #24]	; (15790 <_isatty_r+0x1c>)
   15778:	2300      	movs	r3, #0
   1577a:	4604      	mov	r4, r0
   1577c:	4608      	mov	r0, r1
   1577e:	602b      	str	r3, [r5, #0]
   15780:	f7f6 fb32 	bl	bde8 <_isatty>
   15784:	1c43      	adds	r3, r0, #1
   15786:	d102      	bne.n	1578e <_isatty_r+0x1a>
   15788:	682b      	ldr	r3, [r5, #0]
   1578a:	b103      	cbz	r3, 1578e <_isatty_r+0x1a>
   1578c:	6023      	str	r3, [r4, #0]
   1578e:	bd38      	pop	{r3, r4, r5, pc}
   15790:	2001cfe0 	.word	0x2001cfe0

00015794 <_lseek_r>:
   15794:	b538      	push	{r3, r4, r5, lr}
   15796:	4d07      	ldr	r5, [pc, #28]	; (157b4 <_lseek_r+0x20>)
   15798:	4604      	mov	r4, r0
   1579a:	4608      	mov	r0, r1
   1579c:	4611      	mov	r1, r2
   1579e:	2200      	movs	r2, #0
   157a0:	602a      	str	r2, [r5, #0]
   157a2:	461a      	mov	r2, r3
   157a4:	f7f6 fb22 	bl	bdec <_lseek>
   157a8:	1c43      	adds	r3, r0, #1
   157aa:	d102      	bne.n	157b2 <_lseek_r+0x1e>
   157ac:	682b      	ldr	r3, [r5, #0]
   157ae:	b103      	cbz	r3, 157b2 <_lseek_r+0x1e>
   157b0:	6023      	str	r3, [r4, #0]
   157b2:	bd38      	pop	{r3, r4, r5, pc}
   157b4:	2001cfe0 	.word	0x2001cfe0
	...

000157c0 <memchr>:
   157c0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   157c4:	2a10      	cmp	r2, #16
   157c6:	db2b      	blt.n	15820 <memchr+0x60>
   157c8:	f010 0f07 	tst.w	r0, #7
   157cc:	d008      	beq.n	157e0 <memchr+0x20>
   157ce:	f810 3b01 	ldrb.w	r3, [r0], #1
   157d2:	3a01      	subs	r2, #1
   157d4:	428b      	cmp	r3, r1
   157d6:	d02d      	beq.n	15834 <memchr+0x74>
   157d8:	f010 0f07 	tst.w	r0, #7
   157dc:	b342      	cbz	r2, 15830 <memchr+0x70>
   157de:	d1f6      	bne.n	157ce <memchr+0xe>
   157e0:	b4f0      	push	{r4, r5, r6, r7}
   157e2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
   157e6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
   157ea:	f022 0407 	bic.w	r4, r2, #7
   157ee:	f07f 0700 	mvns.w	r7, #0
   157f2:	2300      	movs	r3, #0
   157f4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
   157f8:	3c08      	subs	r4, #8
   157fa:	ea85 0501 	eor.w	r5, r5, r1
   157fe:	ea86 0601 	eor.w	r6, r6, r1
   15802:	fa85 f547 	uadd8	r5, r5, r7
   15806:	faa3 f587 	sel	r5, r3, r7
   1580a:	fa86 f647 	uadd8	r6, r6, r7
   1580e:	faa5 f687 	sel	r6, r5, r7
   15812:	b98e      	cbnz	r6, 15838 <memchr+0x78>
   15814:	d1ee      	bne.n	157f4 <memchr+0x34>
   15816:	bcf0      	pop	{r4, r5, r6, r7}
   15818:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   1581c:	f002 0207 	and.w	r2, r2, #7
   15820:	b132      	cbz	r2, 15830 <memchr+0x70>
   15822:	f810 3b01 	ldrb.w	r3, [r0], #1
   15826:	3a01      	subs	r2, #1
   15828:	ea83 0301 	eor.w	r3, r3, r1
   1582c:	b113      	cbz	r3, 15834 <memchr+0x74>
   1582e:	d1f8      	bne.n	15822 <memchr+0x62>
   15830:	2000      	movs	r0, #0
   15832:	4770      	bx	lr
   15834:	3801      	subs	r0, #1
   15836:	4770      	bx	lr
   15838:	2d00      	cmp	r5, #0
   1583a:	bf06      	itte	eq
   1583c:	4635      	moveq	r5, r6
   1583e:	3803      	subeq	r0, #3
   15840:	3807      	subne	r0, #7
   15842:	f015 0f01 	tst.w	r5, #1
   15846:	d107      	bne.n	15858 <memchr+0x98>
   15848:	3001      	adds	r0, #1
   1584a:	f415 7f80 	tst.w	r5, #256	; 0x100
   1584e:	bf02      	ittt	eq
   15850:	3001      	addeq	r0, #1
   15852:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
   15856:	3001      	addeq	r0, #1
   15858:	bcf0      	pop	{r4, r5, r6, r7}
   1585a:	3801      	subs	r0, #1
   1585c:	4770      	bx	lr
   1585e:	bf00      	nop

00015860 <memmove>:
   15860:	4288      	cmp	r0, r1
   15862:	b510      	push	{r4, lr}
   15864:	eb01 0402 	add.w	r4, r1, r2
   15868:	d902      	bls.n	15870 <memmove+0x10>
   1586a:	4284      	cmp	r4, r0
   1586c:	4623      	mov	r3, r4
   1586e:	d807      	bhi.n	15880 <memmove+0x20>
   15870:	1e43      	subs	r3, r0, #1
   15872:	42a1      	cmp	r1, r4
   15874:	d008      	beq.n	15888 <memmove+0x28>
   15876:	f811 2b01 	ldrb.w	r2, [r1], #1
   1587a:	f803 2f01 	strb.w	r2, [r3, #1]!
   1587e:	e7f8      	b.n	15872 <memmove+0x12>
   15880:	4402      	add	r2, r0
   15882:	4601      	mov	r1, r0
   15884:	428a      	cmp	r2, r1
   15886:	d100      	bne.n	1588a <memmove+0x2a>
   15888:	bd10      	pop	{r4, pc}
   1588a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
   1588e:	f802 4d01 	strb.w	r4, [r2, #-1]!
   15892:	e7f7      	b.n	15884 <memmove+0x24>

00015894 <_realloc_r>:
   15894:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15896:	4607      	mov	r7, r0
   15898:	4614      	mov	r4, r2
   1589a:	460e      	mov	r6, r1
   1589c:	b921      	cbnz	r1, 158a8 <_realloc_r+0x14>
   1589e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   158a2:	4611      	mov	r1, r2
   158a4:	f7fe bd7a 	b.w	1439c <_malloc_r>
   158a8:	b922      	cbnz	r2, 158b4 <_realloc_r+0x20>
   158aa:	f7fe fd29 	bl	14300 <_free_r>
   158ae:	4625      	mov	r5, r4
   158b0:	4628      	mov	r0, r5
   158b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   158b4:	f000 f826 	bl	15904 <_malloc_usable_size_r>
   158b8:	42a0      	cmp	r0, r4
   158ba:	d20f      	bcs.n	158dc <_realloc_r+0x48>
   158bc:	4621      	mov	r1, r4
   158be:	4638      	mov	r0, r7
   158c0:	f7fe fd6c 	bl	1439c <_malloc_r>
   158c4:	4605      	mov	r5, r0
   158c6:	2800      	cmp	r0, #0
   158c8:	d0f2      	beq.n	158b0 <_realloc_r+0x1c>
   158ca:	4631      	mov	r1, r6
   158cc:	4622      	mov	r2, r4
   158ce:	f7fe fd01 	bl	142d4 <memcpy>
   158d2:	4631      	mov	r1, r6
   158d4:	4638      	mov	r0, r7
   158d6:	f7fe fd13 	bl	14300 <_free_r>
   158da:	e7e9      	b.n	158b0 <_realloc_r+0x1c>
   158dc:	4635      	mov	r5, r6
   158de:	e7e7      	b.n	158b0 <_realloc_r+0x1c>

000158e0 <_read_r>:
   158e0:	b538      	push	{r3, r4, r5, lr}
   158e2:	4d07      	ldr	r5, [pc, #28]	; (15900 <_read_r+0x20>)
   158e4:	4604      	mov	r4, r0
   158e6:	4608      	mov	r0, r1
   158e8:	4611      	mov	r1, r2
   158ea:	2200      	movs	r2, #0
   158ec:	602a      	str	r2, [r5, #0]
   158ee:	461a      	mov	r2, r3
   158f0:	f7f8 f86a 	bl	d9c8 <_read>
   158f4:	1c43      	adds	r3, r0, #1
   158f6:	d102      	bne.n	158fe <_read_r+0x1e>
   158f8:	682b      	ldr	r3, [r5, #0]
   158fa:	b103      	cbz	r3, 158fe <_read_r+0x1e>
   158fc:	6023      	str	r3, [r4, #0]
   158fe:	bd38      	pop	{r3, r4, r5, pc}
   15900:	2001cfe0 	.word	0x2001cfe0

00015904 <_malloc_usable_size_r>:
   15904:	f851 3c04 	ldr.w	r3, [r1, #-4]
   15908:	1f18      	subs	r0, r3, #4
   1590a:	2b00      	cmp	r3, #0
   1590c:	bfbc      	itt	lt
   1590e:	580b      	ldrlt	r3, [r1, r0]
   15910:	18c0      	addlt	r0, r0, r3
   15912:	4770      	bx	lr
   15914:	6d617246 	.word	0x6d617246
   15918:	74532065 	.word	0x74532065
   1591c:	20747261 	.word	0x20747261
   15920:	7366664f 	.word	0x7366664f
   15924:	7b007465 	.word	0x7b007465
   15928:	70797422 	.word	0x70797422
   1592c:	223a2265 	.word	0x223a2265
   15930:	4e524157 	.word	0x4e524157
   15934:	22474e49 	.word	0x22474e49
   15938:	6422202c 	.word	0x6422202c
   1593c:	22617461 	.word	0x22617461
   15940:	225b203a 	.word	0x225b203a
   15944:	5d227325 	.word	0x5d227325
   15948:	000a0d7d 	.word	0x000a0d7d
   1594c:	6e6e6f43 	.word	0x6e6e6f43
   15950:	00746365 	.word	0x00746365
   15954:	7974227b 	.word	0x7974227b
   15958:	3a226570 	.word	0x3a226570
   1595c:	41572220 	.word	0x41572220
   15960:	4e494e52 	.word	0x4e494e52
   15964:	202c2247 	.word	0x202c2247
   15968:	74616422 	.word	0x74616422
   1596c:	203a2261 	.word	0x203a2261
   15970:	6e55225b 	.word	0x6e55225b
   15974:	776f6e6b 	.word	0x776f6e6b
   15978:	73654d20 	.word	0x73654d20
   1597c:	65676173 	.word	0x65676173
   15980:	70795420 	.word	0x70795420
   15984:	7d5d2265 	.word	0x7d5d2265
   15988:	227b000d 	.word	0x227b000d
   1598c:	65707974 	.word	0x65707974
   15990:	22203a22 	.word	0x22203a22
   15994:	4e524157 	.word	0x4e524157
   15998:	22474e49 	.word	0x22474e49
   1599c:	6422202c 	.word	0x6422202c
   159a0:	22617461 	.word	0x22617461
   159a4:	225b203a 	.word	0x225b203a
   159a8:	61766e49 	.word	0x61766e49
   159ac:	2064696c 	.word	0x2064696c
   159b0:	63656843 	.word	0x63656843
   159b4:	6d75736b 	.word	0x6d75736b
   159b8:	0d7d5d22 	.word	0x0d7d5d22
   159bc:	6d695400 	.word	0x6d695400
   159c0:	74756f65 	.word	0x74756f65
   159c4:	73694420 	.word	0x73694420
   159c8:	6e6e6f63 	.word	0x6e6e6f63
   159cc:	20746365 	.word	0x20746365
   159d0:	65522026 	.word	0x65522026
   159d4:	20746573 	.word	0x20746573
   159d8:	65636552 	.word	0x65636552
   159dc:	72657669 	.word	0x72657669
   159e0:	6d695400 	.word	0x6d695400
   159e4:	74756f65 	.word	0x74756f65
   159e8:	52202620 	.word	0x52202620
   159ec:	74657365 	.word	0x74657365
   159f0:	63655220 	.word	0x63655220
   159f4:	65766965 	.word	0x65766965
   159f8:	63250072 	.word	0x63250072
   159fc:	63256325 	.word	0x63256325
   15a00:	30256325 	.word	0x30256325
   15a04:	30257832 	.word	0x30257832
   15a08:	30257832 	.word	0x30257832
   15a0c:	63257832 	.word	0x63257832
   15a10:	000a3030 	.word	0x000a3030
   15a14:	30256325 	.word	0x30256325
   15a18:	2e5f7833 	.word	0x2e5f7833
   15a1c:	2e2e2e2e 	.word	0x2e2e2e2e
   15a20:	2e2e2e2e 	.word	0x2e2e2e2e
   15a24:	2e2e2e2e 	.word	0x2e2e2e2e
   15a28:	2e2e2e2e 	.word	0x2e2e2e2e
   15a2c:	2e2e2e2e 	.word	0x2e2e2e2e
   15a30:	2e2e2e2e 	.word	0x2e2e2e2e
   15a34:	2e2e2e2e 	.word	0x2e2e2e2e
   15a38:	252e2e2e 	.word	0x252e2e2e
   15a3c:	63250063 	.word	0x63250063
   15a40:	78333025 	.word	0x78333025
   15a44:	2e2e2e5f 	.word	0x2e2e2e5f
   15a48:	2e2e2e2e 	.word	0x2e2e2e2e
   15a4c:	0063252e 	.word	0x0063252e
   15a50:	30256325 	.word	0x30256325
   15a54:	2e5f7833 	.word	0x2e5f7833
   15a58:	0063252e 	.word	0x0063252e
   15a5c:	30256325 	.word	0x30256325
   15a60:	2e5f7833 	.word	0x2e5f7833
   15a64:	2e2e2e2e 	.word	0x2e2e2e2e
   15a68:	0063252e 	.word	0x0063252e
   15a6c:	7974227b 	.word	0x7974227b
   15a70:	3a226570 	.word	0x3a226570
   15a74:	43574822 	.word	0x43574822
   15a78:	2c224746 	.word	0x2c224746
   15a7c:	61642220 	.word	0x61642220
   15a80:	3a226174 	.word	0x3a226174
   15a84:	64252220 	.word	0x64252220
   15a88:	0a0d7d22 	.word	0x0a0d7d22
   15a8c:	204f4e00 	.word	0x204f4e00
   15a90:	52455355 	.word	0x52455355
   15a94:	574f5220 	.word	0x574f5220
   15a98:	45484320 	.word	0x45484320
   15a9c:	00214b43 	.word	0x00214b43
   15aa0:	55206f4e 	.word	0x55206f4e
   15aa4:	2074696e 	.word	0x2074696e
   15aa8:	74736554 	.word	0x74736554
   15aac:	206f4e00 	.word	0x206f4e00
   15ab0:	64726148 	.word	0x64726148
   15ab4:	65726177 	.word	0x65726177
   15ab8:	73655420 	.word	0x73655420
   15abc:	65520074 	.word	0x65520074
   15ac0:	6e696461 	.word	0x6e696461
   15ac4:	73552067 	.word	0x73552067
   15ac8:	52207265 	.word	0x52207265
   15acc:	7b00776f 	.word	0x7b00776f
   15ad0:	70797422 	.word	0x70797422
   15ad4:	223a2265 	.word	0x223a2265
   15ad8:	22474f4c 	.word	0x22474f4c
   15adc:	6422202c 	.word	0x6422202c
   15ae0:	22617461 	.word	0x22617461
   15ae4:	225b203a 	.word	0x225b203a
   15ae8:	5d227325 	.word	0x5d227325
   15aec:	000a0d7d 	.word	0x000a0d7d
   15af0:	69726556 	.word	0x69726556
   15af4:	6e697966 	.word	0x6e697966
   15af8:	73552067 	.word	0x73552067
   15afc:	52207265 	.word	0x52207265
   15b00:	5500776f 	.word	0x5500776f
   15b04:	74616470 	.word	0x74616470
   15b08:	20676e69 	.word	0x20676e69
   15b0c:	72657355 	.word	0x72657355
   15b10:	776f5220 	.word	0x776f5220
   15b14:	73795300 	.word	0x73795300
   15b18:	206d6574 	.word	0x206d6574
   15b1c:	65736552 	.word	0x65736552
   15b20:	6e550074 	.word	0x6e550074
   15b24:	6e616863 	.word	0x6e616863
   15b28:	20646567 	.word	0x20646567
   15b2c:	72657355 	.word	0x72657355
   15b30:	776f5220 	.word	0x776f5220
   15b34:	00          	.byte	0x00
   15b35:	45          	.byte	0x45
   15b36:	5252      	.short	0x5252
   15b38:	6920524f 	.word	0x6920524f
   15b3c:	7865206e 	.word	0x7865206e
   15b40:	6c5f7270 	.word	0x6c5f7270
   15b44:	6c657665 	.word	0x6c657665
   15b48:	2928335f 	.word	0x2928335f
   15b4c:	73626100 	.word	0x73626100
   15b50:	78697300 	.word	0x78697300
   15b54:	64646100 	.word	0x64646100
   15b58:	69727000 	.word	0x69727000
   15b5c:	6900746e 	.word	0x6900746e
   15b60:	75460066 	.word	0x75460066
   15b64:	6974636e 	.word	0x6974636e
   15b68:	22206e6f 	.word	0x22206e6f
   15b6c:	20227325 	.word	0x20227325
   15b70:	20746f6e 	.word	0x20746f6e
   15b74:	6e756f66 	.word	0x6e756f66
   15b78:	000a2164 	.word	0x000a2164
   15b7c:	29642528 	.word	0x29642528
   15b80:	32302500 	.word	0x32302500
   15b84:	0078      	.short	0x0078
   15b86:	3002      	.short	0x3002
   15b88:	7b653035 	.word	0x7b653035
   15b8c:	305a2870 	.word	0x305a2870
   15b90:	30307d29 	.word	0x30307d29
   15b94:	30306330 	.word	0x30306330
   15b98:	30020003 	.word	0x30020003
   15b9c:	7b653035 	.word	0x7b653035
   15ba0:	305a2870 	.word	0x305a2870
   15ba4:	30307d29 	.word	0x30307d29
   15ba8:	707b3830 	.word	0x707b3830
   15bac:	29345a28 	.word	0x29345a28
   15bb0:	3002037d 	.word	0x3002037d
   15bb4:	7b653033 	.word	0x7b653033
   15bb8:	355a2870 	.word	0x355a2870
   15bbc:	00037d29 	.word	0x00037d29
   15bc0:	30353002 	.word	0x30353002
   15bc4:	28707b65 	.word	0x28707b65
   15bc8:	7d29305a 	.word	0x7d29305a
   15bcc:	39303030 	.word	0x39303030
   15bd0:	5a28707b 	.word	0x5a28707b
   15bd4:	037d2934 	.word	0x037d2934
   15bd8:	35300200 	.word	0x35300200
   15bdc:	707b6530 	.word	0x707b6530
   15be0:	29305a28 	.word	0x29305a28
   15be4:	3030307d 	.word	0x3030307d
   15be8:	28707b61 	.word	0x28707b61
   15bec:	7d29345a 	.word	0x7d29345a
   15bf0:	33300203 	.word	0x33300203
   15bf4:	707b6530 	.word	0x707b6530
   15bf8:	29305a28 	.word	0x29305a28
   15bfc:	0200037d 	.word	0x0200037d
   15c00:	65303530 	.word	0x65303530
   15c04:	5a28707b 	.word	0x5a28707b
   15c08:	307d2930 	.word	0x307d2930
   15c0c:	7b623030 	.word	0x7b623030
   15c10:	345a2870 	.word	0x345a2870
   15c14:	02037d29 	.word	0x02037d29
   15c18:	66303330 	.word	0x66303330
   15c1c:	5a28707b 	.word	0x5a28707b
   15c20:	037d2930 	.word	0x037d2930
   15c24:	20495500 	.word	0x20495500
   15c28:	65776f50 	.word	0x65776f50
   15c2c:	6e452072 	.word	0x6e452072
   15c30:	656c6261 	.word	0x656c6261
   15c34:	696e4900 	.word	0x696e4900
   15c38:	6f4d2074 	.word	0x6f4d2074
   15c3c:	656c7564 	.word	0x656c7564
   15c40:	4f50203a 	.word	0x4f50203a
   15c44:	49003631 	.word	0x49003631
   15c48:	2074696e 	.word	0x2074696e
   15c4c:	75646f4d 	.word	0x75646f4d
   15c50:	203a656c 	.word	0x203a656c
   15c54:	36315542 	.word	0x36315542
   15c58:	696e4900 	.word	0x696e4900
   15c5c:	6f4d2074 	.word	0x6f4d2074
   15c60:	656c7564 	.word	0x656c7564
   15c64:	4250203a 	.word	0x4250203a
   15c68:	49003446 	.word	0x49003446
   15c6c:	2074696e 	.word	0x2074696e
   15c70:	75646f4d 	.word	0x75646f4d
   15c74:	203a656c 	.word	0x203a656c
   15c78:	36314e45 	.word	0x36314e45
   15c7c:	696e4900 	.word	0x696e4900
   15c80:	6f4d2074 	.word	0x6f4d2074
   15c84:	656c7564 	.word	0x656c7564
   15c88:	6e55203a 	.word	0x6e55203a
   15c8c:	776f6e6b 	.word	0x776f6e6b
   15c90:	6f4d206e 	.word	0x6f4d206e
   15c94:	656c7564 	.word	0x656c7564
   15c98:	43574800 	.word	0x43574800
   15c9c:	4d204746 	.word	0x4d204746
   15ca0:	616d7369 	.word	0x616d7369
   15ca4:	00686374 	.word	0x00686374
   15ca8:	0f0e0d0c 	.word	0x0f0e0d0c
   15cac:	0b0a0908 	.word	0x0b0a0908
   15cb0:	07060504 	.word	0x07060504
   15cb4:	03020100 	.word	0x03020100
   15cb8:	0f0e0d0c 	.word	0x0f0e0d0c
   15cbc:	0b0a0908 	.word	0x0b0a0908
   15cc0:	07060504 	.word	0x07060504
   15cc4:	03020100 	.word	0x03020100
   15cc8:	0f0e0d0c 	.word	0x0f0e0d0c
   15ccc:	0b0a0908 	.word	0x0b0a0908
   15cd0:	07060504 	.word	0x07060504
   15cd4:	03020100 	.word	0x03020100
   15cd8:	0f0e0d0c 	.word	0x0f0e0d0c
   15cdc:	0b0a0908 	.word	0x0b0a0908
   15ce0:	07060504 	.word	0x07060504
   15ce4:	03020100 	.word	0x03020100
   15ce8:	63256325 	.word	0x63256325
   15cec:	2e2e2e2e 	.word	0x2e2e2e2e
   15cf0:	2e2e2e2e 	.word	0x2e2e2e2e
   15cf4:	2e2e2e2e 	.word	0x2e2e2e2e
   15cf8:	6325      	.short	0x6325
   15cfa:	00          	.byte	0x00
   15cfb:	25          	.byte	0x25
   15cfc:	33302563 	.word	0x33302563
   15d00:	63256578 	.word	0x63256578
   15d04:	00          	.byte	0x00
   15d05:	25          	.byte	0x25
   15d06:	2563      	.short	0x2563
   15d08:	5f783330 	.word	0x5f783330
   15d0c:	2e2e2e2e 	.word	0x2e2e2e2e
   15d10:	25006325 	.word	0x25006325
   15d14:	33302563 	.word	0x33302563
   15d18:	23006578 	.word	0x23006578
   15d1c:	23200020 	.word	0x23200020
   15d20:	38302500 	.word	0x38302500
   15d24:	72670078 	.word	0x72670078
   15d28:	735f6469 	.word	0x735f6469
   15d2c:	3a3a7379 	.word	0x3a3a7379
   15d30:	63656863 	.word	0x63656863
   15d34:	6d75736b 	.word	0x6d75736b
   15d38:	65684300 	.word	0x65684300
   15d3c:	75736b63 	.word	0x75736b63
   15d40:	6552206d 	.word	0x6552206d
   15d44:	432f6461 	.word	0x432f6461
   15d48:	75636c61 	.word	0x75636c61
   15d4c:	6574616c 	.word	0x6574616c
   15d50:	63617000 	.word	0x63617000
   15d54:	7b74656b 	.word	0x7b74656b
   15d58:	202c6425 	.word	0x202c6425
   15d5c:	202c6425 	.word	0x202c6425
   15d60:	202c6425 	.word	0x202c6425
   15d64:	202c6425 	.word	0x202c6425
   15d68:	202c6425 	.word	0x202c6425
   15d6c:	202c6425 	.word	0x202c6425
   15d70:	202c6425 	.word	0x202c6425
   15d74:	207d6425 	.word	0x207d6425
   15d78:	64616552 	.word	0x64616552
   15d7c:	6425203a 	.word	0x6425203a
   15d80:	6143202c 	.word	0x6143202c
   15d84:	6c75636c 	.word	0x6c75636c
   15d88:	3a657461 	.word	0x3a657461
   15d8c:	00642520 	.word	0x00642520
   15d90:	63656843 	.word	0x63656843
   15d94:	6d75736b 	.word	0x6d75736b
   15d98:	69725720 	.word	0x69725720
   15d9c:	432f6574 	.word	0x432f6574
   15da0:	75636c61 	.word	0x75636c61
   15da4:	6574616c 	.word	0x6574616c
   15da8:	65684300 	.word	0x65684300
   15dac:	75736b63 	.word	0x75736b63
   15db0:	764f206d 	.word	0x764f206d
   15db4:	72777265 	.word	0x72777265
   15db8:	00657469 	.word	0x00657469
   15dbc:	61726150 	.word	0x61726150
   15dc0:	72706170 	.word	0x72706170
   15dc4:	73616b69 	.word	0x73616b69
   15dc8:	00          	.byte	0x00
   15dc9:	25          	.byte	0x25
   15dca:	2563      	.short	0x2563
   15dcc:	5f783330 	.word	0x5f783330
   15dd0:	2e2e2e2e 	.word	0x2e2e2e2e
   15dd4:	02002e2e 	.word	0x02002e2e
   15dd8:	65313430 	.word	0x65313430
   15ddc:	5428707b 	.word	0x5428707b
   15de0:	307d2930 	.word	0x307d2930
   15de4:	28707b31 	.word	0x28707b31
   15de8:	7d29315a 	.word	0x7d29315a
   15dec:	5a28707b 	.word	0x5a28707b
   15df0:	7b7d2932 	.word	0x7b7d2932
   15df4:	335a2870 	.word	0x335a2870
   15df8:	00037d29 	.word	0x00037d29
   15dfc:	30303002 	.word	0x30303002
   15e00:	39303065 	.word	0x39303065
   15e04:	28707b30 	.word	0x28707b30
   15e08:	7d293054 	.word	0x7d293054
   15e0c:	5428707b 	.word	0x5428707b
   15e10:	037d2932 	.word	0x037d2932
   15e14:	30343002 	.word	0x30343002
   15e18:	28707b65 	.word	0x28707b65
   15e1c:	7d293054 	.word	0x7d293054
   15e20:	707b3130 	.word	0x707b3130
   15e24:	29325428 	.word	0x29325428
   15e28:	0200037d 	.word	0x0200037d
   15e2c:	65303030 	.word	0x65303030
   15e30:	30383030 	.word	0x30383030
   15e34:	5428707b 	.word	0x5428707b
   15e38:	7b7d2930 	.word	0x7b7d2930
   15e3c:	32542870 	.word	0x32542870
   15e40:	02037d29 	.word	0x02037d29
   15e44:	65303430 	.word	0x65303430
   15e48:	5428707b 	.word	0x5428707b
   15e4c:	307d2930 	.word	0x307d2930
   15e50:	28707b31 	.word	0x28707b31
   15e54:	7d293254 	.word	0x7d293254
   15e58:	30020003 	.word	0x30020003
   15e5c:	30653030 	.word	0x30653030
   15e60:	7b306230 	.word	0x7b306230
   15e64:	30542870 	.word	0x30542870
   15e68:	707b7d29 	.word	0x707b7d29
   15e6c:	29325428 	.word	0x29325428
   15e70:	3002037d 	.word	0x3002037d
   15e74:	7b653034 	.word	0x7b653034
   15e78:	30542870 	.word	0x30542870
   15e7c:	31307d29 	.word	0x31307d29
   15e80:	5428707b 	.word	0x5428707b
   15e84:	037d2932 	.word	0x037d2932
   15e88:	34300200 	.word	0x34300200
   15e8c:	707b6531 	.word	0x707b6531
   15e90:	29305428 	.word	0x29305428
   15e94:	7b31307d 	.word	0x7b31307d
   15e98:	315a2870 	.word	0x315a2870
   15e9c:	707b7d29 	.word	0x707b7d29
   15ea0:	29325a28 	.word	0x29325a28
   15ea4:	28707b7d 	.word	0x28707b7d
   15ea8:	7d29335a 	.word	0x7d29335a
   15eac:	34300203 	.word	0x34300203
   15eb0:	707b6531 	.word	0x707b6531
   15eb4:	29305428 	.word	0x29305428
   15eb8:	7b32307d 	.word	0x7b32307d
   15ebc:	315a2870 	.word	0x315a2870
   15ec0:	707b7d29 	.word	0x707b7d29
   15ec4:	29325a28 	.word	0x29325a28
   15ec8:	28707b7d 	.word	0x28707b7d
   15ecc:	7d29335a 	.word	0x7d29335a
   15ed0:	30020003 	.word	0x30020003
   15ed4:	30653030 	.word	0x30653030
   15ed8:	7b306230 	.word	0x7b306230
   15edc:	30542870 	.word	0x30542870
   15ee0:	707b7d29 	.word	0x707b7d29
   15ee4:	29385428 	.word	0x29385428
   15ee8:	4923037d 	.word	0x4923037d
   15eec:	305a7b46 	.word	0x305a7b46
   15ef0:	7d333d3d 	.word	0x7d333d3d
   15ef4:	02485423 	.word	0x02485423
   15ef8:	65313430 	.word	0x65313430
   15efc:	5428707b 	.word	0x5428707b
   15f00:	307d2930 	.word	0x307d2930
   15f04:	28707b31 	.word	0x28707b31
   15f08:	7d293854 	.word	0x7d293854
   15f0c:	5a28707b 	.word	0x5a28707b
   15f10:	7b7d2932 	.word	0x7b7d2932
   15f14:	32312870 	.word	0x32312870
   15f18:	38542d38 	.word	0x38542d38
   15f1c:	23037d29 	.word	0x23037d29
   15f20:	45234c45 	.word	0x45234c45
   15f24:	3430024e 	.word	0x3430024e
   15f28:	707b6530 	.word	0x707b6530
   15f2c:	29305428 	.word	0x29305428
   15f30:	7b31307d 	.word	0x7b31307d
   15f34:	38542870 	.word	0x38542870
   15f38:	00037d29 	.word	0x00037d29
   15f3c:	30303002 	.word	0x30303002
   15f40:	62303065 	.word	0x62303065
   15f44:	28707b30 	.word	0x28707b30
   15f48:	7d293054 	.word	0x7d293054
   15f4c:	5428707b 	.word	0x5428707b
   15f50:	037d2938 	.word	0x037d2938
   15f54:	30343002 	.word	0x30343002
   15f58:	28707b65 	.word	0x28707b65
   15f5c:	7d293054 	.word	0x7d293054
   15f60:	707b3130 	.word	0x707b3130
   15f64:	29385428 	.word	0x29385428
   15f68:	0200037d 	.word	0x0200037d
   15f6c:	65303030 	.word	0x65303030
   15f70:	30393030 	.word	0x30393030
   15f74:	5428707b 	.word	0x5428707b
   15f78:	7b7d2930 	.word	0x7b7d2930
   15f7c:	32542870 	.word	0x32542870
   15f80:	02037d29 	.word	0x02037d29
   15f84:	65303430 	.word	0x65303430
   15f88:	5428707b 	.word	0x5428707b
   15f8c:	307d2930 	.word	0x307d2930
   15f90:	28707b32 	.word	0x28707b32
   15f94:	7d293254 	.word	0x7d293254
   15f98:	30020003 	.word	0x30020003
   15f9c:	30653030 	.word	0x30653030
   15fa0:	7b303830 	.word	0x7b303830
   15fa4:	30542870 	.word	0x30542870
   15fa8:	707b7d29 	.word	0x707b7d29
   15fac:	29325428 	.word	0x29325428
   15fb0:	3002037d 	.word	0x3002037d
   15fb4:	7b653034 	.word	0x7b653034
   15fb8:	30542870 	.word	0x30542870
   15fbc:	32307d29 	.word	0x32307d29
   15fc0:	5428707b 	.word	0x5428707b
   15fc4:	037d2932 	.word	0x037d2932
   15fc8:	67655200 	.word	0x67655200
   15fcc:	65747369 	.word	0x65747369
   15fd0:	63412072 	.word	0x63412072
   15fd4:	6e6f6974 	.word	0x6e6f6974
   15fd8:	65764500 	.word	0x65764500
   15fdc:	4e20746e 	.word	0x4e20746e
   15fe0:	4620746f 	.word	0x4620746f
   15fe4:	646e756f 	.word	0x646e756f
   15fe8:	73452000 	.word	0x73452000
   15fec:	65706163 	.word	0x65706163
   15ff0:	68432064 	.word	0x68432064
   15ff4:	46207261 	.word	0x46207261
   15ff8:	646e756f 	.word	0x646e756f
   15ffc:	30020020 	.word	0x30020020
   16000:	7b653035 	.word	0x7b653035
   16004:	305a2870 	.word	0x305a2870
   16008:	707b7d29 	.word	0x707b7d29
   1600c:	29305428 	.word	0x29305428
   16010:	3030307d 	.word	0x3030307d
   16014:	02000330 	.word	0x02000330
   16018:	65303530 	.word	0x65303530
   1601c:	5a28707b 	.word	0x5a28707b
   16020:	7b7d2930 	.word	0x7b7d2930
   16024:	30542870 	.word	0x30542870
   16028:	34307d29 	.word	0x34307d29
   1602c:	5428707b 	.word	0x5428707b
   16030:	037d2932 	.word	0x037d2932
   16034:	35300200 	.word	0x35300200
   16038:	707b6530 	.word	0x707b6530
   1603c:	29305a28 	.word	0x29305a28
   16040:	28707b7d 	.word	0x28707b7d
   16044:	7d293054 	.word	0x7d293054
   16048:	707b3530 	.word	0x707b3530
   1604c:	29325428 	.word	0x29325428
   16050:	0200037d 	.word	0x0200037d
   16054:	65303530 	.word	0x65303530
   16058:	5a28707b 	.word	0x5a28707b
   1605c:	7b7d2930 	.word	0x7b7d2930
   16060:	30542870 	.word	0x30542870
   16064:	31307d29 	.word	0x31307d29
   16068:	5428707b 	.word	0x5428707b
   1606c:	037d2932 	.word	0x037d2932
   16070:	35300200 	.word	0x35300200
   16074:	707b6530 	.word	0x707b6530
   16078:	29305a28 	.word	0x29305a28
   1607c:	28707b7d 	.word	0x28707b7d
   16080:	7d293054 	.word	0x7d293054
   16084:	707b3130 	.word	0x707b3130
   16088:	29355428 	.word	0x29355428
   1608c:	0200037d 	.word	0x0200037d
   16090:	65303530 	.word	0x65303530
   16094:	5a28707b 	.word	0x5a28707b
   16098:	7b7d2930 	.word	0x7b7d2930
   1609c:	30542870 	.word	0x30542870
   160a0:	64307d29 	.word	0x64307d29
   160a4:	5428707b 	.word	0x5428707b
   160a8:	037d2935 	.word	0x037d2935
   160ac:	6e795300 	.word	0x6e795300
   160b0:	20786174 	.word	0x20786174
   160b4:	6f727245 	.word	0x6f727245
   160b8:	000d2172 	.word	0x000d2172
   160bc:	20009150 	.word	0x20009150
   160c0:	20019870 	.word	0x20019870
   160c4:	200138d4 	.word	0x200138d4
   160c8:	200102d4 	.word	0x200102d4
   160cc:	682f2e2e 	.word	0x682f2e2e
   160d0:	732f6c61 	.word	0x732f6c61
   160d4:	682f6372 	.word	0x682f6372
   160d8:	695f6c61 	.word	0x695f6c61
   160dc:	00632e6f 	.word	0x00632e6f
   160e0:	682f2e2e 	.word	0x682f2e2e
   160e4:	732f6c61 	.word	0x732f6c61
   160e8:	682f6372 	.word	0x682f6372
   160ec:	695f6c61 	.word	0x695f6c61
   160f0:	6d5f6332 	.word	0x6d5f6332
   160f4:	7973615f 	.word	0x7973615f
   160f8:	632e636e 	.word	0x632e636e
   160fc:	00          	.byte	0x00
   160fd:	2e          	.byte	0x2e
   160fe:	2f2e      	.short	0x2f2e
   16100:	2f6c7068 	.word	0x2f6c7068
   16104:	2f746477 	.word	0x2f746477
   16108:	5f6c7068 	.word	0x5f6c7068
   1610c:	2e746477 	.word	0x2e746477
   16110:	0063      	.short	0x0063
   16112:	2e2e      	.short	0x2e2e
   16114:	6c61682f 	.word	0x6c61682f
   16118:	6372732f 	.word	0x6372732f
   1611c:	6c61682f 	.word	0x6c61682f
   16120:	6970735f 	.word	0x6970735f
   16124:	645f6d5f 	.word	0x645f6d5f
   16128:	632e616d 	.word	0x632e616d
   1612c:	00000000 	.word	0x00000000

00016130 <user_mux_confs>:
	...
   1615c:	04030201 04030201 00000000 00000000     ................
	...

00016174 <channel_confs>:
   16174:	05230522 05250524 00000000 00000000     ".#.$.%.........
	...

000161b4 <interrupt_cfg>:
   161b4:	00000002 00000002 00000002 00000002     ................
	...
   16234:	682f2e2e 712f6c70 2f697073 5f6c7068     ../hpl/qspi/hpl_
   16244:	69707371 2e00632e 70682f2e 766e2f6c     qspi.c.../hpl/nv
   16254:	7274636d 70682f6c 766e5f6c 7274636d     mctrl/hpl_nvmctr
   16264:	00632e6c 682f2e2e 732f6c61 682f6372     l.c.../hal/src/h
   16274:	745f6c61 72656d69 0000632e              al_timer.c..

00016280 <_usb_ep_cfgs>:
   16280:	20008928 00000000 00000040 00000000     (.. ....@.......
	...
   16298:	20008920 00000000 00000008 200088e0      .. ........... 
   162a8:	200088d8 00080040 00000000 00000000     ... @...........
	...
   162c0:	20008898 00400000 20726d54 00637653     ... ..@.Tmr Svc.

000162d0 <mouse_report_desc>:
   162d0:	02090105 010901a1 090500a1 03290119     ..............).
   162e0:	01250015 03950175 05750281 01810195     ..%.u.....u.....
   162f0:	30090105 38093109 7f258115 03950875     ...0.1.8..%.u...
   16300:	c0c00681                                ....

00016304 <_cfgs>:
   16304:	00200600 08068000 00200400 08068000     .. ....... .....
   16314:	00201000 08068000 00200c00 08068000     .. ....... .....
	...
   16334:	00200b00 14000003 00200a00 08000002     .. ....... .....
   16344:	00201300 14000003 00000000 00000000     .. .............
	...
   163f4:	00005400 1c000000 00005300 0c000000     .T.......S......
   16404:	682f2e2e 732f6c61 682f6372 615f6c61     ../hal/src/hal_a
   16414:	615f6364 636e7973 2e00632e 61682f2e     dc_async.c.../ha
   16424:	72732f6c 61682f63 61725f6c 735f646e     l/src/hal_rand_s
   16434:	2e636e79 2e2e0063 6c70682f 6e72742f     ync.c.../hpl/trn
   16444:	70682f67 72745f6c 632e676e               g/hpl_trng.c.

00016451 <keyboard_report_desc>:
   16451:	06090105 070501a1 e729e019 01250015     ..........)...%.
   16461:	08950175 01810281 65290019 65250015     u.........)e..%e
   16471:	06950875 08050081 05290119 01250015     u.........)...%.
   16481:	05950175 03950291 2ec00191 61682f2e     u............/ha
   16491:	72732f6c 61682f63 73755f6c 5f747261     l/src/hal_usart_
   164a1:	636e7973 2e00632e 61682f2e 72732f6c     sync.c.../hal/sr
   164b1:	61682f63 6c665f6c 2e687361 2e2e0063     c/hal_flash.c...
   164c1:	6c61682f 6372732f 6c61682f 6970735f     /hal/src/hal_spi
   164d1:	615f6d5f 636e7973 2e00632e 61682f2e     _m_async.c.../ha
   164e1:	72732f6c 61682f63 72635f6c 79735f63     l/src/hal_crc_sy
   164f1:	632e636e                                 nc.c.

000164f6 <CSWTCH.37>:
   164f6:	010101ed                                 .......

000164fd <CSWTCH.40>:
   164fd:	010100ed 2ef00201 61682f2e 74752f6c     ........./hal/ut
   1650d:	2f736c69 2f637273 6c697475 696c5f73     ils/src/utils_li
   1651d:	632e7473 2f2e2e00 2f6c7068 2f637472     st.c.../hpl/rtc/
   1652d:	5f6c7068 2e637472 2e2e0063 6c61682f     hpl_rtc.c.../hal
   1653d:	636e692f 6564756c 6c61682f 7464775f     /include/hal_wdt
   1654d:	2e00682e 61682f2e 72732f6c 61682f63     .h.../hal/src/ha
   1655d:	73755f6c 5f747261 6e797361 00632e63     l_usart_async.c.
   1656d:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
   1657d:	65735f6c 6d6f6372 0000632e 00400030     l_sercom.c..0.@.
   1658d:	00400034 00410120 00410140 00430000     4.@. .A.@.A...C.
   1659d:	00430004 00430008                        ..C...C...C

000165a8 <sercomspi_regs>:
   165a8:	3020000c 00020000 00000000 01ff0005     .. 0............
   165b8:	20000c03 00000000 00000000 ff000600     ... ............
   165c8:	00000701                                ....

000165cc <_i2cms>:
   165cc:	00000005 00200014 00000100 0000e6e5     ...... .........
   165dc:	00d70000 02dc6c00                       .....l..

000165e4 <_usarts>:
   165e4:	00000000 40100004 00030000 00700002     .......@......p.
   165f4:	0000aaaa 00000000 00000001 40100004     ...............@
   16604:	00030000 00700002 0000aaaa 00000000     ......p.........
   16614:	00000002 40100004 00030000 00700002     .......@......p.
   16624:	00005555 00000000 00000004 40100004     UU.............@
   16634:	00030000 00700002 0000aaaa 00000000     ......p.........
   16644:	00000006 40100004 00030000 00700002     .......@......p.
   16654:	0000aaaa 00000000 682f2e2e 752f6c61     ........../hal/u
   16664:	736c6974 6372732f 6974752f 725f736c     tils/src/utils_r
   16674:	62676e69 65666675 00632e72 6d617845     ingbuffer.c.Exam
   16684:	54656c70 206b7361 3f3f3f3f 202e2e2e     pleTask ????... 
   16694:	0d206425 494d000a 203a4944 78323025     %d ...MIDI: %02x
   166a4:	32302520 30252078 25207832 0a783230      %02x %02x %02x.
   166b4:	61745300 6f206b63 66726576 20776f6c     .Stack overflow 
   166c4:	74206e69 206b7361 0a0d7325 61745300     in task %s...Sta
   166d4:	49207472 6974696e 7a696c61 44006465     rt Initialized.D
   166e4:	49203135 0074696e 706d6f43 7469736f     51 Init.Composit
   166f4:	65442065 65636976 696e4920 6c616974     e Device Initial
   16704:	64657a69 69724700 6f4d2064 656c7564     ized.Grid Module
   16714:	696e4920 6c616974 64657a69 746e4500      Initialized.Ent
   16724:	6e697265 614d2067 4c206e69 00706f6f     ering Main Loop.
   16734:	20627355 6b736154 6d764e00 73615420     Usb Task.Nvm Tas
   16744:	6955006b 73615420 6552006b 76696563     k.Ui Task.Receiv
   16754:	61542065 49006b73 756f626e 5420646e     e Task.Inbound T
   16764:	006b7361 6274754f 646e756f 73615420     ask.Outbound Tas
   16774:	654c006b 61542064 45006b73 706d6178     k.Led Task.Examp
   16784:	4300656c 6f706d6f 65746973 76654420     le.Composite Dev
   16794:	20656369 6e6e6f43 65746365 6f460064     ice Connected.Fo
   167a4:	65766572 0d202172 2f2e2e00 2f6c6168     rever! ..../hal/
   167b4:	2f637273 5f6c6168 69707371 616d645f     src/hal_qspi_dma
   167c4:	4900632e 00454c44 09632509 25097525     .c.IDLE..%c.%u.%
   167d4:	75250975 2e000a0d 70682f2e 64612f6c     u.%u...../hpl/ad
   167e4:	70682f63 64615f6c 00632e63              c/hpl_adc.c.

000167f0 <_adcs>:
   167f0:	01000000 0003000c 00041807 00000000     ................
   16800:	0014080b 00010000 000c0100 18040003     ................
   16810:	00000004 080b0000 00000014 752f2e2e     ............../u
   16820:	642f6273 63697665 73752f65 2e636462     sb/device/usbdc.
   16830:	2e2e0063 6c70682f 2f63742f 5f6c7068     c.../hpl/tc/hpl_
   16840:	632e6374 00000000 40003800 40003c00     tc.c.....8.@.<.@
   16850:	4101a000 4101c000 42001400 42001800     ...A...A...B...B
   16860:	43001400 43001800                       ...C...C

00016868 <_tcs>:
   16868:	006b0000 00000308 00000021 00003a98     ..k.....!....:..
   16878:	00000000 006c0001 00000308 00000021     ......l.....!...
   16888:	00003a98 00000000 006d0002 00000308     .:........m.....
   16898:	00000021 00003a98 00000000 006e0003     !....:........n.
   168a8:	00000308 00000021 00003a98 00000000     ....!....:......

000168b8 <_global_impure_ptr>:
   168b8:	20000550                                P.. 

000168bc <__sf_fake_stderr>:
	...

000168dc <__sf_fake_stdin>:
	...

000168fc <__sf_fake_stdout>:
	...
   1691c:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
   1692c:	32313000 36353433 41393837 45444342     .0123456789ABCDE
   1693c:	31300046 35343332 39383736 64636261     F.0123456789abcd
   1694c:	00006665                                ef..

00016950 <_init>:
   16950:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16952:	bf00      	nop
   16954:	bcf8      	pop	{r3, r4, r5, r6, r7}
   16956:	bc08      	pop	{r3}
   16958:	469e      	mov	lr, r3
   1695a:	4770      	bx	lr

0001695c <__frame_dummy_init_array_entry>:
   1695c:	4289 0000                                   .B..

00016960 <_fini>:
   16960:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16962:	bf00      	nop
   16964:	bcf8      	pop	{r3, r4, r5, r6, r7}
   16966:	bc08      	pop	{r3}
   16968:	469e      	mov	lr, r3
   1696a:	4770      	bx	lr

0001696c <__do_global_dtors_aux_fini_array_entry>:
   1696c:	4265 0000                                   eB..
