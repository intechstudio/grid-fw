/*
 * SPDX-FileCopyrightText: 2021-2022 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Unlicense OR CC0-1.0
 */

#include "grid_esp32_codec.h"

#include "driver/gpio.h"

struct grid_esp32_codec_model grid_esp32_codec_state;
uint8_t* w_buf = NULL;

#include "driver/i2s_tdm.h"
#define EXAMPLE_TDM_BCLK_IO1 GPIO_NUM_41 // I2S bit clock io number
#define EXAMPLE_TDM_WS_IO1 GPIO_NUM_40   // I2S word select io number
#define EXAMPLE_TDM_DOUT_IO1 GPIO_NUM_42 // I2S data out io number
#define EXAMPLE_TDM_DIN_IO1 I2S_GPIO_UNUSED

#define EXAMPLE_BUFF_SIZE 2048

static i2s_chan_handle_t tx_chan; // I2S tx channel handler

static void i2s_example_init_tdm_simplex(void) {
  /* Setp 1: Determine the I2S channel configuration and allocate two channels one by one
   * The default configuration can be generated by the helper macro,
   * it only requires the I2S controller id and I2S role */
  i2s_chan_config_t tx_chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
  ESP_ERROR_CHECK(i2s_new_channel(&tx_chan_cfg, &tx_chan, NULL));

  /* Step 2: Setting the configurations of TDM mode and initialize each channels one by one
   * The slot configuration and clock configuration can be generated by the macros
   * These two helper macros is defined in 'i2s_tdm.h' which can only be used in TDM mode.
   * They can help to specify the slot and clock configurations for initialization or re-configuring */
  i2s_tdm_config_t tx_tdm_cfg = {
      .clk_cfg = I2S_TDM_CLK_DEFAULT_CONFIG(16000),
      .slot_cfg = I2S_TDM_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_32BIT, I2S_SLOT_MODE_MONO, I2S_TDM_SLOT0 | I2S_TDM_SLOT1 | I2S_TDM_SLOT2 | I2S_TDM_SLOT3),
      .gpio_cfg =
          {
              .mclk = I2S_GPIO_UNUSED, // some codecs may require mclk signal, this example doesn't need it
              .bclk = EXAMPLE_TDM_BCLK_IO1,
              .ws = EXAMPLE_TDM_WS_IO1,
              .dout = EXAMPLE_TDM_DOUT_IO1,
              .din = EXAMPLE_TDM_DIN_IO1,
              .invert_flags =
                  {
                      .mclk_inv = false,
                      .bclk_inv = false,
                      .ws_inv = false,
                  },
          },
  };
  tx_tdm_cfg.clk_cfg.mclk_multiple = I2S_MCLK_MULTIPLE_512;
  ESP_ERROR_CHECK(i2s_channel_init_tdm_mode(tx_chan, &tx_tdm_cfg));
}

void grid_esp32_codec_deinit(void) { free(w_buf); }

void grid_esp32_codec_init(void) {
  i2s_example_init_tdm_simplex();

  w_buf = (uint8_t*)calloc(1, EXAMPLE_BUFF_SIZE);
  assert(w_buf); // Check if w_buf allocation success

  /* Assign w_buf */
  for (int i = 0; i < EXAMPLE_BUFF_SIZE; i += 16) {
    w_buf[i] = 0x12 / 4;
    w_buf[i + 1] = 0x34 / 4;
    w_buf[i + 2] = 0x56 / 4;
    w_buf[i + 3] = 0x78 / 4;
    w_buf[i + 4] = 0x9A / 4;
    w_buf[i + 5] = 0xBC / 4;
    w_buf[i + 6] = 0xDE / 4;
    w_buf[i + 7] = 0xF0 / 4;
    w_buf[i + 8] = 0xF0 / 4;
    w_buf[i + 9] = 0xF0 / 4;
    w_buf[i + 10] = 0xF0 / 4;
    w_buf[i + 11] = 0xF0 / 4;
    w_buf[i + 12] = 0xF0 / 4;
    w_buf[i + 13] = 0xF0 / 4;
    w_buf[i + 14] = 0xF0 / 4;
    w_buf[i + 15] = 0xF0 / 4;
  }

  size_t w_bytes = EXAMPLE_BUFF_SIZE;

  /* (Optional) Preload the data before enabling the TX channel, so that the valid data can be transmitted immediately */
  while (w_bytes == EXAMPLE_BUFF_SIZE) {
    /* Here we load the target buffer repeatedly, until all the DMA buffers are preloaded */
    ESP_ERROR_CHECK(i2s_channel_preload_data(tx_chan, w_buf, EXAMPLE_BUFF_SIZE, &w_bytes));
  }

  /* Enable the TX channel */
}

void grid_esp32_codec_write(void) {

  size_t w_bytes = EXAMPLE_BUFF_SIZE;

  /* Write i2s data */
  if (i2s_channel_write(tx_chan, w_buf, EXAMPLE_BUFF_SIZE, &w_bytes, 1000) == ESP_OK) {
    printf("Write Task: i2s write %zu bytes\n", w_bytes);
  } else {
    printf("Write Task: i2s write failed\n");
  }
}

uint8_t enabled = false;

void grid_esp32_codec_enable(void) {
  if (enabled == true) {
    return;
  }
  enabled = true;
  ESP_ERROR_CHECK(i2s_channel_enable(tx_chan));
}

void grid_esp32_codec_disable(void) {
  if (enabled == false) {
    return;
  }
  enabled = false;
  i2s_channel_disable(tx_chan);
}
